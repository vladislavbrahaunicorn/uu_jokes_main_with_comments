import * as UU5 from "uu5g04";
import "uu5g04-bricks";

import "./image.less";
import Lightbox from "./lightbox.js";
import Cfg from "../config/config.js";

export const Image = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "Image",
    classNames: {
      main: Cfg.CSS + "image",
      effectCaption: Cfg.CSS + "image-effect-caption",
      img: Cfg.CSS + "image-img",
      landscape: Cfg.CSS + "image-landscape",
      portrait: Cfg.CSS + "image-portrait",
      effect: Cfg.CSS + "image-effect-",
      shape: Cfg.CSS + "image-shape-",
      fit: Cfg.CSS + "image-fit-",
      fitCoverNoScaleUpCenter: Cfg.CSS + "image-fit-covernoscaleup-center",
      crop: Cfg.CSS + "image-crop",
      loading: Cfg.CSS + "image-loading",
      loadingAnimation: Cfg.CSS + "image-loading-animation",
      fitWidth: Cfg.CSS + "image-fit-width",
      autoWidth: Cfg.CSS + "image-auto-width",
      autoHeight: Cfg.CSS + "image-auto-height",
      focusWrapper: Cfg.CSS + "image-focus-wrapper"
    },
    opt: {
      pureRender: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    src: UU5.PropTypes.string,
    loadingSrc: UU5.PropTypes.string,
    thumb: UU5.PropTypes.string,
    caption: UU5.PropTypes.string,
    fit: UU5.PropTypes.oneOf(["default", "coverNoScaleUp"]),
    effect: UU5.PropTypes.oneOf(["none", "zoom", "grayscale", "blur", "sepia", "invert", "tilt", "morph"]),
    shape: UU5.PropTypes.oneOf([
      "default",
      "rounded",
      "square",
      "roundedSquare",
      "circle",
      "rect",
      "rect4x3",
      "rect3x2",
      "rect5x4",
      "rect2x1",
      "rect3x1",
      "rect4x1",
      "rect45x10",
      "rect16x9",
      "rect16x10",
      "rect3x4",
      "rect4x5",
      "rect2x3",
      "rect1x2",
      "roundedRect",
      "roundedRect4x3",
      "roundedRect3x2",
      "roundedRect5x4",
      "roundedRect2x1",
      "roundedRect3x1",
      "roundedRect4x1",
      "roundedRect45x10",
      "roundedRect16x9",
      "roundedRect16x10",
      "roundedRect3x4",
      "roundedRect4x5",
      "roundedRect2x3",
      "roundedRect1x2"
    ]),
    width: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    height: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    onClick: UU5.PropTypes.func,
    lightbox: UU5.PropTypes.oneOfType([UU5.PropTypes.bool, UU5.PropTypes.string]),
    authenticate: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      src: "",
      loadingSrc: "",
      thumb: "",
      caption: "",
      fit: "default",
      effect: "none",
      shape: "default",
      width: null,
      height: null,
      onClick: null,
      lightbox: null,
      authenticate: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      orientation: "default",
      loading: !!this.props.loadingSrc,
      imageWidth: 0,
      imageHeight: 0
    };
  },

  componentWillMount() {
    this._setOrientation(this.props);
  },

  componentWillUnmount() {
    UU5.Environment.EventListener.removeWindowEvent("keyup", this.getId());
    this._lb && this._lb.removeImage(this.getId());
  },

  componentDidMount() {
    this._lb && this._lb.addImage(this.props.src, this.getId(), this.props.authenticate, this);
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.loadingSrc && this._getSrc(nextProps) !== this._getSrc(this.props)) {
      this.setState({ loading: true });
    }

    if (nextProps.controlled) {
      this._setOrientation(nextProps);
    }

    if ((nextProps.id !== this.props.id || nextProps.src !== this.props.src) && this._lb) {
      this._lb.replaceImage(nextProps.src, this.getId());
    }
  },

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.shape !== prevProps.shape ||
      (this.props.fit !== prevProps.fit ||
        (this.props.fit === "coverNoScaleUp" &&
          (this.props.width !== prevProps.width || this.props.height !== prevProps.height)))
    ) {
      this._onLoad();
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getDimension(shape = "default") {
    let x = 1;
    let y = 1;

    let matcher = shape.match(/[Rr]ect(?:(\d+)x(\d+))?$/);
    if (matcher) {
      x = matcher[1] ? +matcher[1] : 4;
      y = matcher[2] ? +matcher[2] : 3;
    }

    return { x, y };
  },

  _getOrientation(props = this.props) {
    let orientation;

    let shape = props.shape || "default";
    if (/[Rr]ect/.test(shape)) {
      shape = "rect";
    }
    switch (shape) {
      case "square":
      case "roundedSquare":
      case "circle": {
        orientation = "landscape";
        break;
      }
      case "rect": {
        let s = this._getDimension(props.shape);

        if (this._img) {
          let image = this._img.findDOMNode();
          let img = { height: image.naturalHeight, width: image.naturalWidth };
          if (img.width === undefined || img.height === undefined) img = image.getBoundingClientRect();

          if (img.height / img.width >= s.y / s.x) {
            orientation = "portrait";
          } else {
            orientation = "landscape";
          }
        } else {
          orientation = s.x > s.y ? "landscape" : "portrait";
        }
        break;
      }
      default: {
        orientation = "default";
      }
    }

    return orientation;
  },

  _setOrientation(props) {
    this.setState({ orientation: this._getOrientation(props) });
  },

  _getShape(shape = "default") {
    let className = this.getClassName("shape") + shape.toLowerCase();

    if (["default", "rounded"].indexOf(shape) === -1) {
      className += " " + this.getClassName("crop");

      if (/^rounded/.test(shape)) {
        className += " " + this.getClassName("shape") + "rounded";
      }

      let matcher = shape.match(/Rect(\d+x\d+)?$/);
      if (matcher) {
        className += " " + this.getClassName("shape") + "rect" + (matcher[1] ? matcher[1] : "");
      }
    }

    return className;
  },

  _getEffect(effect = "default") {
    return this.getClassName("effect") + effect;
  },

  _getFit(fit = "default") {
    let className = "";
    // fitting is available only when both sizes are known (or 1 size and shape)
    if (this.state.orientation !== "default" || (this.props.width && this.props.height)) {
      className = this.getClassName("fit") + fit.toLowerCase();
      if (fit === "coverNoScaleUp" && this.state.fitCoverNoScaleUpCenter !== false)
        className += " " + this.getClassName("fitCoverNoScaleUpCenter");
    }
    return className;
  },

  _getFrameDiv(children) {
    let mainProps = this.getMainPropsToPass();
    if (this.props.width || this.props.height) {
      mainProps.style = mainProps.style || {};
      if (this.props.width) {
        mainProps.style.width = /\d+$/.test(this.props.width) ? this.props.width + "px" : this.props.width;
      }

      if (this.props.height) {
        mainProps.style.height = /\d+$/.test(this.props.height) ? this.props.height + "px" : this.props.height;
      }
    }

    mainProps.className += " " + this._getShape(this.props.shape) + " " + this._getEffect(this.props.effect);

    if (this.props.height && !this.props.width) {
      mainProps.className += " " + this.getClassName("fitWidth");

      if (this.props.shape !== "default" && this.props.shape !== "rounded") {
        let ratio = this._getDimension(this.props.shape);
        let height = parseFloat(this.props.height);
        mainProps.style.width = height * (ratio.x / ratio.y) + "px";
      } else if (!this.state.loading && this.state.imageWidth && this.state.imageHeight) {
        let height = parseFloat(this.props.height);
        mainProps.style.width = height * (this.state.imageWidth / this.state.imageHeight) + "px";
      }
    }

    let loading = this.props.loadingSrc && this.state.loading && (
      <div className={this.getClassName("loadingAnimation")} />
    );

    if (!this.state.loading) {
      let mainAttrs = { ...mainProps.mainAttrs };
      mainAttrs.tabIndex = "0";
      mainAttrs.onFocus = this._onFocus;
      mainAttrs.onBlur = this._onBlur;
      mainProps.mainAttrs = mainAttrs;
    }

    return (
      <UU5.Bricks.Div {...mainProps}>
        {loading}
        {this.state.loading && this.props.loadingSrc && (
          <UU5.Bricks.Image
            authenticate={this.props.authenticate}
            key="loading"
            src={this.props.loadingSrc}
            className={this._getImageClassName()}
          />
        )}
        {children}

        {this.props.effect === "blur" && (
          <UU5.Bricks.Div className={this.getClassName("effectCaption")} content={this.props.caption} />
        )}

        <div className={this.getClassName("focusWrapper")} />
      </UU5.Bricks.Div>
    );
  },

  _getSrc(props = this.props) {
    return props.thumb || props.src;
  },

  _getImageClassName() {
    let className = this.getClassName("img");
    switch (this.state.orientation) {
      case "portrait":
        className += " " + this.getClassName("portrait");
        break;
      case "landscape":
        className += " " + this.getClassName("landscape");
        break;
    }
    className += " " + this._getFit(this.props.fit);
    if (this.props.height && !this.props.width) {
      className += " " + this.getClassName("autoWidth");
    } else {
      className += " " + this.getClassName("autoHeight");
    }
    return className;
  },

  _getImage() {
    let src = this._getSrc();
    let className =
      this.state.loading && this.props.loadingSrc ? this.getClassName("loading") : this._getImageClassName();

    return (
      <UU5.Bricks.Image
        name={this.getName()}
        src={src}
        ref_={img => (this._img = img)}
        className={className}
        responsive={false}
        mainAttrs={{ onLoad: this._onLoad, onError: this._onError }}
        authenticate={this.props.authenticate}
      />
    );
  },

  _getThumbnail() {
    return [
      <UU5.Bricks.Link key="1" onClick={this.props.onClick || this._showLightbox}>
        {this._getImage()}
      </UU5.Bricks.Link>,
      <Lightbox key="2" ref_={lb => (this._lb = lb)} name={this.props.lightbox === true ? "" : this.props.lightbox} />
    ];
  },

  _showLightbox() {
    this._lb.open(this.getId());
  },

  _onFocus() {
    UU5.Environment.EventListener.addWindowEvent("keyup", this.getId(), e => {
      const isEnter = e.which === 13;
      isEnter && !this.isDisabled() && this._showLightbox();
    });
  },

  _onBlur() {
    UU5.Environment.EventListener.removeWindowEvent("keyup", this.getId());
  },

  _onLoad(e) {
    let newState = { loading: false };
    if (e) {
      newState.imageWidth = e.target.naturalWidth;
      newState.imageHeight = e.target.naturalHeight;
    }
    let imageWidth = newState.imageWidth || this.state.imageWidth;
    let imageHeight = newState.imageHeight || this.state.imageHeight;

    if (this.state.orientation !== "default") {
      newState.orientation = this._getOrientation();
    }

    if (this.props.fit === "coverNoScaleUp") {
      let compEl = this.findDOMNode();
      let compWidth = compEl ? compEl.getBoundingClientRect().width : parseFloat(this.props.width);
      let compHeight = compEl ? compEl.getBoundingClientRect().height : parseFloat(this.props.height);
      newState.fitCoverNoScaleUpCenter = imageWidth < compWidth || imageHeight < compHeight;
    }

    this.setState(newState);
  },

  _onError(e) {
    this.setState({ loading: false });
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this._getFrameDiv(
      this.props.lightbox !== false ? this._getThumbnail() : <UU5.Bricks.Span>{this._getImage()}</UU5.Bricks.Span>
    );
  }
  //@@viewOn:render
});

export default Image;
