import * as UU5 from "uu5g04";
import "uu5g04-bricks";
import "uu5g04-forms";
import Adjustment from "./adjustment.js";

import "./upload-input.less";

import ImageInputAdjustment from "./internal/image-input-adjustment.js";
import { ImagePasteHandlerMixin } from "./internal/image-paste-handler.js";
import Cfg from "../config/config.js";

const ITEM_PROP_TYPE = UU5.PropTypes.shape({
  id: UU5.PropTypes.string,
  name: UU5.PropTypes.string,
  value: UU5.PropTypes.object, // Blob
  uri: UU5.PropTypes.string,
  progress: UU5.PropTypes.number,
  src: UU5.PropTypes.string, // for displaying via <img src="..." /> (image does not have to be uploaded)
  originalValue: UU5.PropTypes.object, // Blob - in case image adjustment settings gets changed (we need original file)
  error: UU5.PropTypes.any
});

export const UploadInput = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [
    UU5.Common.BaseMixin,
    UU5.Common.ElementaryMixin,
    UU5.Common.PureRenderMixin,
    UU5.Common.CallsMixin,
    UU5.Common.ColorSchemaMixin,
    UU5.Forms.InputMixin,
    ImagePasteHandlerMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "UploadInput",
    classNames: {
      main: Cfg.CSS + "upload-input"
    },
    lsi: {
      requiredMessage: UU5.Environment.Lsi.Forms.message.requiredMessage,
      placeholder: {
        cs: "Nahrát obrázek",
        en: "Load image",
        sk: "Nahrať obrázok"
      },
      placeholderMulti: {
        cs: "Nahrát obrázky",
        en: "Load images",
        sk: "Nahrať obrázky"
      },
      placeholderReadOnly: {
        cs: "Nelze nahrát obrázek",
        en: "Cannot load image",
        sk: "Nie je možné nahrať obrázok"
      },
      placeholderReadOnlyMulti: {
        cs: "Nelze nahrát obrázky",
        en: "Cannot load images",
        sk: "Nie je možné nahrať obrázky"
      },
      uploadFailed: {
        cs: "Nepodařilo se nahrát obrázek {0}.",
        en: "Upload of the image  {0} failed.",
        sk: "Nepodarilo se nahrať obrázok {0}."
      }
    },
    opt: {
      pureRender: true
    },
    calls: {
      createImage: "createImage",
      updateImage: "updateImage",
      deleteImage: "deleteImage"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: UU5.PropTypes.oneOfType([ITEM_PROP_TYPE, UU5.PropTypes.arrayOf(ITEM_PROP_TYPE)]),
    placeholder: UU5.PropTypes.oneOfType([UU5.PropTypes.object, UU5.PropTypes.string]),
    multiple: UU5.PropTypes.bool,
    outputWidth: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    outputHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    outputType: UU5.PropTypes.oneOf(Adjustment.OUTPUT_TYPES.concat(["jpg", "image/jpeg", "image/png"])),
    outputRotation: UU5.PropTypes.oneOfType([UU5.PropTypes.oneOf(["auto"]), UU5.PropTypes.number]),
    outputQuality: UU5.PropTypes.number,
    ignorePaste: UU5.PropTypes.bool,
    borderRadius: UU5.PropTypes.string,
    bgStyle: UU5.PropTypes.oneOf(["filled", "outline", "transparent", "underline"]),
    elevation: UU5.PropTypes.oneOf(["-1", "0", "1", "2", "3", "4", "5", -1, 0, 1, 2, 3, 4, 5]),
    previewWidth: UU5.PropTypes.number,
    previewHeight: UU5.PropTypes.number,
    previewShape: UU5.PropTypes.string
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      placeholder: undefined,
      multiple: false,
      outputWidth: null,
      outputHeight: null,
      outputType: null,
      outputRotation: "auto",
      outputQuality: null,
      ignorePaste: undefined,
      borderRadius: null,
      bgStyle: null,
      elevation: null,
      previewWidth: 100,
      previewHeight: null,
      previewShape: "square"
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentWillMount() {
    if (!this.props.calls) this.setCalls({}); // TODO Remove after fix in CallMixin (throws if null and calling getCall("xyz")).
    if (typeof this.props.onValidate === "function" && this._isItemsDone(this.state.value)) {
      this._validateOnChange({ value: this.state.value, event: null, component: this });
    }
  },

  componentWillReceiveProps(nextProps) {
    if (!nextProps.multiple && this.props.multiple) {
      let needsChangeEvent = false;
      this.setState(
        ({ value }) => {
          let result;
          if (Array.isArray(value) && value.length > 1) {
            needsChangeEvent = true;
            value.slice(0, value.length - 1).forEach(item => {
              if (item.src) URL.revokeObjectURL(item.src);
              this._handleDeleteImage(item);
            });
            result = { value: value[value.length - 1] };
          }
          return result;
        },
        () => (needsChangeEvent ? this._triggerChangeEvent() : null)
      );
    }

    if (nextProps.controlled) {
      // FIXME Make diff against this.props and remove images from remote (pass diff to this._onChange()).
      this.setState({ value: nextProps.value, feedback: nextProps.feedback, message: nextProps.message });
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  onChange() {
    let opt = { value: this.getValue(), component: this, feedback: this.state.feedback, message: this.state.message };

    if (!this.isComputedDisabled() && !this.isReadOnly()) {
      if (typeof this.props.onChange === "function") {
        this.props.onChange(opt);
      } else {
        this.onChangeDefault(opt);
      }
    }
    return this;
  },

  onChangeDefault(opt) {
    if (typeof this.props.onValidate === "function") {
      this._validateOnChange({ value: opt.value, event: opt.event, component: this });
    }
    return this;
  },

  isValid() {
    var feedback = this.getFeedback();
    var value = this.getValue();
    var result = true;

    if (this.props.required && (value == null || value.length === 0)) {
      this.setError(this.props.requiredMessage || this.getLsiValue("requiredMessage")); // TODO Why modify state?
      result = false;
    } else if (feedback === "error" || feedback === "loading-internal" || feedback === "loading") {
      result = false;
    }

    if (result && this.props.onValidate) {
      var validation = this.props.onValidate({ value: value, component: this });
      if (validation && typeof validation === "object") {
        if (validation.feedback === "error") {
          result = false;
        }
      }
    }

    return result;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  setValue_(value, setStateCallback) {
    if (this._checkRequired({ value: value })) {
      if (typeof this.props.onValidate === "function") {
        this._validateOnChange({ value: value, event: null, component: this });
      } else {
        this.setInitial(null, value, setStateCallback);
      }
    }

    return this;
  },

  getValue_() {
    let value = this.state.value;
    if (this.props.multiple && value && !Array.isArray(value)) value = [value];
    else if (!this.props.multiple && Array.isArray(value)) value = value[0];
    return value;
  },

  pasteImages_(imageBlobs) {
    let blobs = this.props.multiple ? imageBlobs : imageBlobs.slice(-1);
    if (blobs.length > 0) {
      this.setState(({ value }) => {
        if (!this.props.multiple) value = [];
        else value = value && !Array.isArray(value) ? [value] : value || [];
        value = value.concat(
          blobs.map(blob => ({ id: UU5.Common.Tools.generateUUID(), originalValue: blob, name: blob.name }))
        );
        if (!this.props.multiple) value = value[value.length - 1];
        return { value };
      });
    }
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _triggerChangeEvent() {
    this._updateFeedbackFromValue(() => {
      // trigger props.onChange only after all items are finished (uploaded / failed)
      if (this._isItemsDone(this.state.value)) this.onChange();
    });
  },

  _validateOnChange(opt) {
    let result = typeof this.props.onValidate === "function" ? this.props.onValidate(opt) : null;
    if (result) {
      if (typeof result === "object") {
        if (result.feedback) {
          this._setFeedback(result.feedback, result.message, result.value);
        } else {
          this.setState({ value: opt.value });
        }
      } else {
        this.showError("validateError", null, { context: { func: this.props.onValidate, result: result } });
      }
    }
    return this;
  },

  _checkRequired(opt) {
    let result = true;
    if (this.props.required && (!opt.value || opt.value.length === 0) && this.shouldValidateRequired()) {
      result = false;
      this.setError(this.props.requiredMessage || this.getLsiComponent("requiredMessage"), opt.value);
    }

    return result;
  },

  _isItemsDone(value) {
    let valueArr = value && !Array.isArray(value) ? [value] : value;
    return !valueArr || !this.getCall("createImage") || valueArr.every(item => item.uri || item.error);
  },

  _onChange(opt) {
    let { data } = opt;
    if (data) {
      this.setState(
        ({ value }) => {
          for (let k in data) {
            let modifiedItem = data[k];
            value = this._replaceStateItem(value, k, existingItem => {
              let result = existingItem;
              if (!existingItem) {
                // new image
                result = Object.assign({}, modifiedItem, modifiedItem.uri ? null : { progress: 0 });
                if (!result.uri) this._handleCreateImage(result);
              } else if (modifiedItem) {
                result = modifiedItem;
                if (existingItem.value !== modifiedItem.value) {
                  // existing image got changed
                  if (modifiedItem.value && existingItem.uri) {
                    result = Object.assign({}, modifiedItem, { uri: existingItem.uri, progress: 0 });
                    this._handleUpdateImage(result);
                  } else if (modifiedItem.value) {
                    result = Object.assign({}, modifiedItem, modifiedItem.uri ? null : { progress: 0 });
                    if (!result.uri) this._handleCreateImage(result);
                  } else {
                    this._handleDeleteImage(existingItem);
                  }
                }
              } else {
                // image removed
                this._handleDeleteImage(existingItem);
                result = null;
              }
              return result;
            });
          }
          return { value };
        },
        () => {
          this._updateFeedbackFromValue();
        }
      );
    }
  },

  _handleCreateImage(imageItem) {
    let { value, id } = imageItem;
    return new Promise((resolve, reject) => {
      let call = this.getCall("createImage");
      if (call) {
        let dtoIn = {
          data: {
            value: value
          },
          progress: progressData => this._handleCreateImageProgress({ id: id, data: progressData }),
          done: resolveData => resolve({ id: id, data: resolveData }),
          fail: reject
        };
        call(dtoIn);
      } else {
        resolve({ id: id, data: null });
      }
    }).then(this._handleCreateImageDone, e => this._handleCreateImageFail({ id, data: e }));
  },

  _handleCreateImageDone({ id, data }) {
    this.setState(({ value }) => {
      let uri = data ? data.uri : null;
      let newValue = this._replaceStateItem(value, id, existingItem => {
        let result = existingItem;
        if (existingItem) result = Object.assign({}, existingItem, { uri: uri, error: false, progress: 100 });
        else this._handleDeleteImage({ id, uri });
        return result;
      });
      return newValue === value ? undefined : { value: newValue };
    }, this._triggerChangeEvent);
  },

  _handleCreateImageFail({ id, data }) {
    UU5.Common.Tools.error(data);
    this.setState(({ value }) => {
      let newValue = this._replaceStateItem(value, id, existingItem => {
        return existingItem
          ? Object.assign({}, existingItem, { uri: null, error: this.getLsi("uploadFailed"), progress: 100 })
          : existingItem;
      });
      return newValue === value ? undefined : { value: newValue };
    }, this._triggerChangeEvent);
  },

  _handleCreateImageProgress({ id, data }) {
    let { progress } = data;
    this.setState(({ value }) => {
      let newValue = this._replaceStateItem(value, id, existingItem => {
        return existingItem ? Object.assign({}, existingItem, { progress }) : existingItem;
      });
      return newValue === value ? undefined : { value: newValue };
    });
  },

  _handleDeleteImage(imageItem) {
    let { uri, value, originalValue, id } = imageItem;
    return new Promise((resolve, reject) => {
      // remove only those with Blob, i.e. not the ones that were defined as initial value from outside (without Blob-s)
      if (uri && (value instanceof Blob || originalValue instanceof Blob)) {
        let call = this.getCall("deleteImage");
        if (call) {
          let dtoIn = {
            data: {
              uri: uri
            },
            done: resolveData => resolve({ id: id, data: resolveData }),
            fail: reject
          };
          call(dtoIn);
        } else {
          resolve({ id: id, data: null });
        }
      } else {
        resolve({ id: id, data: null });
      }
    }).then(this._handleDeleteImageDone, e => this._handleDeleteImageFail({ id, data: e }));
  },

  _handleDeleteImageDone({ id, data }) {
    // no-op
  },

  _handleDeleteImageFail({ id, data }) {
    UU5.Common.Tools.error(data);
  },

  _handleUpdateImage(imageItem) {
    let result;
    let call = this.getCall("updateImage");
    if (call) {
      let { uri, value, id } = imageItem;
      result = new Promise((resolve, reject) => {
        let dtoIn = {
          data: {
            uri: uri,
            value: value
          },
          progress: progressData => this._handleUpdateImageProgress({ id: id, data: progressData }),
          done: resolveData => resolve({ id: id, data: resolveData }),
          fail: reject
        };
        call(dtoIn);
      }).then(this._handleUpdateImageDone, e => this._handleUpdateImageFail({ id, data: e }));
    } else {
      this._handleDeleteImage(imageItem).catch(() => null); // remove in parallel
      result = this._handleCreateImage(imageItem);
    }
    return result;
  },

  _handleUpdateImageDone({ id, data }) {
    return this._handleCreateImageDone({ id, data });
  },

  _handleUpdateImageFail({ id, data }) {
    return this._handleCreateImageFail({ id, data });
  },

  _handleUpdateImageProgress({ id, data }) {
    return this._handleCreateImageProgress({ id, data });
  },

  _replaceStateItem(list, itemId, replacerFn) {
    let result;
    let listArr = list && !Array.isArray(list) ? [list] : list;
    let idx = listArr ? listArr.findIndex(item => item.id === itemId) : -1;
    if (idx === -1) {
      let newItem = replacerFn(null);
      if (newItem) result = (listArr || []).concat([newItem]);
      else result = list;
    } else {
      let existingItem = listArr ? listArr[idx] : undefined;
      let newItem = replacerFn(existingItem);
      if (newItem === existingItem) result = list;
      else {
        result = listArr ? [...listArr] : [];
        if (!newItem) result.splice(idx, 1);
        else result.splice(idx, 1, newItem);
        if (result.length === 0 && !list) result = list; // keep null / undefined if that's what it was before
      }
      let { src } = existingItem || {};
      if (src && (!newItem || src !== newItem.src)) {
        setTimeout(() => URL.revokeObjectURL(src)); // NOTE Passing normal URLs is safe too (no-op).
      }
    }
    if (!this.props.multiple && Array.isArray(result)) result = result[result.length - 1];
    return result;
  },

  _updateFeedbackFromValue(setStateCallback) {
    let errors = [];
    let uploads = [];
    let value = this.state.value && !Array.isArray(this.state.value) ? [this.state.value] : this.state.value;
    (value || []).forEach(item => {
      if (item.error) errors.push(item);
      else if (!item.uri && this.getCall("createImage")) uploads.push(item);
    });
    let feedback, message;
    if (errors.length > 0) {
      feedback = "error";
      message = (
        <div>
          {errors.map(it => (
            <div key={it.id}>
              <UU5.Bricks.Lsi lsi={it.error} params={[(it.value || it.originalValue || {}).name || ""]} />
            </div>
          ))}
        </div>
      );
    } else if (uploads.length > 0) {
      // NOTE We can't use "loading" because we want our component be enabled (interactive) while items
      // are being uploaded and "loading" feedback would disable us (due to InputMixin).
      // => we'll use different constant
      feedback = "loading-internal";
    }

    this._setFeedback(feedback, message, this.state.value, setStateCallback);
  },

  _onRemove(id) {
    this.setState(({ value }) => {
      let newValue = this._replaceStateItem(value, id, existingItem => {
        if (existingItem) this._handleDeleteImage(existingItem);
        return null;
      });
      return newValue === value ? undefined : { value: newValue };
    }, this._triggerChangeEvent);
  },

  _getInputProps() {
    return Object.assign(
      {
        display: !this.state.value || this.state.value.length === 0 || this.props.multiple,
        id: this.getId() + "-input",
        multiple: this.props.multiple,
        readOnly: this.isReadOnly(),
        disabled: this.isComputedDisabled(),
        loading: this.isLoading(),
        placeholder:
          this.props.placeholder !== undefined
            ? this.props.placeholder
            : this.getLsiComponent(
                "placeholder" +
                  (this.isReadOnly() && !this.isDisabled() ? "ReadOnly" : "") +
                  (this.props.multiple ? "Multi" : "")
              ),
        borderRadius: this.props.borderRadius,
        bgStyle: this.props.bgStyle,
        elevation: this.props.elevation,
        inputWidth: this.props.inputWidth
      },
      this.props.inputAttrs
    );
  },

  _getLineProps() {
    return {
      display: !!this.state.message,
      feedback: this.state.feedback
    };
  },

  _getAdjustmentProps() {
    return {
      value: this.state.value && !Array.isArray(this.state.value) ? [this.state.value] : this.state.value,
      onChange: this._onChange,
      inputProps: this._getInputProps(),
      lineProps: this._getLineProps(),
      onRemove: this._onRemove,
      onLoad: this._onLoad,
      width: this.props.outputWidth,
      height: this.props.outputHeight,
      type: this.props.outputType,
      rotation: this.props.outputRotation,
      quality: this.props.outputQuality,
      previewWidth: this.props.previewWidth,
      previewHeight: this.props.previewHeight,
      previewShape: this.props.previewShape
    };
  },

  _getMainAttrs() {
    let attrs = this._getInputAttrs();
    attrs.id = this.getId();
    return attrs;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return (
      <div {...this._getMainAttrs()}>
        {this.getLabel(this.getId() + "-input-hidden-input")}
        {this.getInputWrapper(<ImageInputAdjustment {...this._getAdjustmentProps()} />)}
        {this.getDisabledCoverTransparent()}
      </div>
    );
  }
  //@@viewOn:render
});

export default UploadInput;
