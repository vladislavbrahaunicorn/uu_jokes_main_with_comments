import * as UU5 from "uu5g04";
import "uu5g04-bricks";
import "uu5g04-forms";
import Adjustment from "./adjustment.js";

import "./input.less";

import ImageInputAdjustment from "./internal/image-input-adjustment.js";
import { ImagePasteHandlerMixin } from "./internal/image-paste-handler.js";
import Cfg from "../config/config.js";

const ITEM_PROP_TYPE = UU5.PropTypes.shape({
  id: UU5.PropTypes.string,
  name: UU5.PropTypes.string,
  value: UU5.PropTypes.object, // Blob
  // uri: UU5.PropTypes.string,
  // progress: UU5.PropTypes.number,
  src: UU5.PropTypes.string, // for displaying via <img src="..." /> (image does not have to be uploaded)
  originalValue: UU5.PropTypes.object, // Blob - in case image adjustment settings gets changed (we need original file)
  error: UU5.PropTypes.any
});

export const Input = UU5.Forms.Context.withContext(
  UU5.Common.VisualComponent.create({
    //@@viewOn:mixins
    mixins: [
      UU5.Common.BaseMixin,
      UU5.Common.ElementaryMixin,
      UU5.Common.PureRenderMixin,
      UU5.Common.ColorSchemaMixin,
      UU5.Forms.InputMixin,
      ImagePasteHandlerMixin
    ],
    //@@viewOff:mixins

    //@@viewOn:statics
    statics: {
      tagName: Cfg.TAG + "Input",
      classNames: {
        main: Cfg.CSS + "input"
      },
      lsi: {
        requiredMessage: UU5.Environment.Lsi.Forms.message.requiredMessage,
        placeholder: {
          cs: "Nahrát obrázek",
          en: "Load image",
          sk: "Nahrať obrázok"
        },
        placeholderMulti: {
          cs: "Nahrát obrázky",
          en: "Load images",
          sk: "Nahrať obrázky"
        },
        placeholderReadOnly: {
          cs: "Nelze nahrát obrázek",
          en: "Cannot load image",
          sk: "Nie je možné nahrať obrázok"
        },
        placeholderReadOnlyMulti: {
          cs: "Nelze nahrát obrázky",
          en: "Cannot load images",
          sk: "Nie je možné nahrať obrázky"
        }
      },
      opt: {
        pureRender: true
      }
    },
    //@@viewOff:statics

    //@@viewOn:propTypes
    propTypes: {
      value: UU5.PropTypes.oneOfType([ITEM_PROP_TYPE, UU5.PropTypes.arrayOf(ITEM_PROP_TYPE)]),
      placeholder: UU5.PropTypes.oneOfType([UU5.PropTypes.object, UU5.PropTypes.string]),
      multiple: UU5.PropTypes.bool,
      outputWidth: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
      outputHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
      outputType: UU5.PropTypes.oneOf(Adjustment.OUTPUT_TYPES.concat(["jpg", "image/jpeg", "image/png"])),
      outputRotation: UU5.PropTypes.oneOfType([UU5.PropTypes.oneOf(["auto"]), UU5.PropTypes.number]),
      outputQuality: UU5.PropTypes.number,
      ignorePaste: UU5.PropTypes.bool,
      borderRadius: UU5.PropTypes.string,
      bgStyle: UU5.PropTypes.oneOf(["filled", "outline", "transparent", "underline"]),
      elevation: UU5.PropTypes.oneOf(["-1", "0", "1", "2", "3", "4", "5", -1, 0, 1, 2, 3, 4, 5]),
      previewWidth: UU5.PropTypes.number,
      previewHeight: UU5.PropTypes.number,
      previewShape: UU5.PropTypes.string
    },
    //@@viewOff:propTypes

    //@@viewOn:getDefaultProps
    getDefaultProps() {
      return {
        placeholder: undefined,
        multiple: false,
        outputWidth: null,
        outputHeight: null,
        outputType: null,
        outputRotation: "auto",
        outputQuality: null,
        ignorePaste: undefined,
        borderRadius: null,
        bgStyle: null,
        elevation: null,
        previewWidth: 100,
        previewHeight: null,
        previewShape: "square"
      };
    },
    //@@viewOff:getDefaultProps

    //@@viewOn:standardComponentLifeCycle
    componentWillMount() {
      if (typeof this.props.onValidate === "function" && this._isItemsDone(this.state.value)) {
        this._validateOnChange({ value: this.state.value, event: null, component: this });
      }
    },

    componentWillReceiveProps(nextProps) {
      if (!nextProps.multiple && this.props.multiple) {
        let needsChangeEvent = false;
        this.setState(
          ({ value }) => {
            let result;
            if (Array.isArray(value) && value.length > 1) {
              needsChangeEvent = true;
              value.slice(0, value.length - 1).forEach(item => {
                if (item.src) URL.revokeObjectURL(item.src);
              });
              result = { value: value[value.length - 1] };
            }
            return result;
          },
          () => (needsChangeEvent ? this._triggerChangeEvent() : null)
        );
      }

      if (nextProps.controlled) {
        this.setState({ value: nextProps.value, feedback: nextProps.feedback, message: nextProps.message });
      }
    },
    //@@viewOff:standardComponentLifeCycle

    //@@viewOn:interface
    onChange() {
      let opt = { value: this.state.value, component: this };

      if (!this.isComputedDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === "function") {
          this.props.onChange(opt);
        } else {
          this.onChangeDefault(opt);
        }
      }
      return this;
    },

    onChangeDefault(opt) {
      if (typeof this.props.onValidate === "function") {
        this._validateOnChange({ value: opt.value, event: opt.event, component: this });
      }
      return this;
    },

    isValid() {
      var feedback = this.getFeedback();
      var value = this.getValue();
      var result = true;

      if (this.props.required && (value == null || value.length === 0)) {
        this.setError(this.props.requiredMessage || this.getLsiValue("requiredMessage")); // TODO Why modify state?
        result = false;
      } else if (feedback === "error" || feedback === "loading-internal" || feedback === "loading") {
        result = false;
      }

      if (result && this.props.onValidate) {
        var validation = this.props.onValidate({ value: value, component: this });
        if (validation && typeof validation === "object") {
          if (validation.feedback === "error") {
            result = false;
          }
        }
      }

      return result;
    },
    //@@viewOff:interface

    //@@viewOn:overridingMethods
    setValue_(value, setStateCallback) {
      if (this._checkRequired({ value: value })) {
        if (typeof this.props.onValidate === "function") {
          this._validateOnChange({ value: value, event: null, component: this });
        } else {
          this.setInitial(null, value, setStateCallback);
        }
      }

      return this;
    },

    getValue_() {
      let value = this.state.value;
      if (this.props.multiple && value && !Array.isArray(value)) value = [value];
      else if (!this.props.multiple && Array.isArray(value)) value = value[0];
      return value;
    },

    pasteImages_(imageBlobs) {
      let blobs = this.props.multiple ? imageBlobs : imageBlobs.slice(-1);
      if (blobs.length > 0) {
        this.setState(({ value }) => {
          if (!this.props.multiple) value = [];
          else value = value && !Array.isArray(value) ? [value] : value || [];
          value = value.concat(
            blobs.map(blob => ({ id: UU5.Common.Tools.generateUUID(), originalValue: blob, name: blob.name }))
          );
          if (!this.props.multiple) value = value[value.length - 1];
          return { value };
        });
      }
    },
    //@@viewOff:overridingMethods

    //@@viewOn:componentSpecificHelpers
    _triggerChangeEvent() {
      this._updateFeedbackFromValue(() => {
        // trigger props.onChange only after all items are finished (uploaded / failed)
        if (this._isItemsDone(this.state.value)) this.onChange();
      });
    },

    _validateOnChange(opt) {
      let result = typeof this.props.onValidate === "function" ? this.props.onValidate(opt) : null;
      if (result) {
        if (typeof result === "object") {
          if (result.feedback) {
            this._setFeedback(result.feedback, result.message, result.value);
          } else {
            this.setState({ value: opt.value });
          }
        } else {
          this.showError("validateError", null, { context: { func: this.props.onValidate, result: result } });
        }
      }
      return this;
    },

    _checkRequired(opt) {
      let result = true;
      if (this.props.required && (!opt.value || opt.value.length === 0) && this.shouldValidateRequired()) {
        result = false;
        this.setError(this.props.requiredMessage || this.getLsiComponent("requiredMessage"), opt.value);
      }

      return result;
    },

    _isItemsDone(value) {
      let valueArr = value && !Array.isArray(value) ? [value] : value;
      return !valueArr || valueArr.every(item => item.uri || item.error || (item.value && item.originalValue));
    },

    _onChange(opt) {
      let { data } = opt;
      if (data) {
        this.setState(({ value }) => {
          for (let k in data) {
            let modifiedItem = data[k];
            value = this._replaceStateItem(value, k, existingItem => modifiedItem);
          }
          return { value };
        }, this._triggerChangeEvent);
      }
    },

    _replaceStateItem(list, itemId, replacerFn) {
      let result;
      let listArr = list && !Array.isArray(list) ? [list] : list;
      let idx = listArr ? listArr.findIndex(item => item.id === itemId) : -1;
      if (idx === -1) {
        let newItem = replacerFn(null);
        if (newItem) result = (listArr || []).concat([newItem]);
        else result = list;
      } else {
        let existingItem = listArr ? listArr[idx] : undefined;
        let newItem = replacerFn(existingItem);
        if (newItem === existingItem) result = list;
        else {
          result = listArr ? [...listArr] : [];
          if (!newItem) result.splice(idx, 1);
          else result.splice(idx, 1, newItem);
          if (result.length === 0 && !list) result = list; // keep null / undefined if that's what it was before
        }
        let { src } = existingItem || {};
        if (src && (!newItem || src !== newItem.src)) {
          setTimeout(() => URL.revokeObjectURL(src)); // NOTE Passing normal URLs is safe too (no-op).
        }
      }
      if (!this.props.multiple && Array.isArray(result)) result = result[result.length - 1];
      return result;
    },

    _updateFeedbackFromValue(setStateCallback) {
      let errors = [];
      let value = this.state.value && !Array.isArray(this.state.value) ? [this.state.value] : this.state.value;
      (value || []).forEach(item => {
        if (item.error) errors.push(item);
      });
      let feedback, message;
      if (errors.length > 0) {
        feedback = "error";
        message = (
          <div>
            {errors.map(it => (
              <div key={it.id}>
                <UU5.Bricks.Lsi lsi={it.error} params={[(it.value || it.originalValue || {}).name || ""]} />
              </div>
            ))}
          </div>
        );
      }

      this._setFeedback(feedback, message, this.state.value, setStateCallback);
    },

    _onRemove(id) {
      this.setState(({ value }) => {
        let newValue = this._replaceStateItem(value, id, existingItem => null);
        return newValue === value ? undefined : { value: newValue };
      }, this._triggerChangeEvent);
    },

    _getInputProps() {
      return Object.assign(
        {
          display: !this.state.value || this.state.value.length === 0 || this.props.multiple,
          id: this.getId() + "-input",
          multiple: this.props.multiple,
          readOnly: this.isReadOnly(),
          disabled: this.isComputedDisabled(),
          loading: this.isLoading(),
          placeholder:
            this.props.placeholder !== undefined
              ? this.props.placeholder
              : this.getLsiComponent(
                  "placeholder" +
                    (this.isReadOnly() && !this.isDisabled() ? "ReadOnly" : "") +
                    (this.props.multiple ? "Multi" : "")
                ),
          borderRadius: this.props.borderRadius,
          bgStyle: this.props.bgStyle,
          elevation: this.props.elevation,
          inputWidth: this.props.inputWidth
        },
        this.props.inputAttrs
      );
    },

    _getLineProps() {
      return {
        display: !!this.state.message,
        feedback: this.state.feedback
      };
    },

    _getAdjustmentProps() {
      return {
        value: this.state.value && !Array.isArray(this.state.value) ? [this.state.value] : this.state.value,
        onChange: this._onChange,
        inputProps: this._getInputProps(),
        lineProps: this._getLineProps(),
        onRemove: this._onRemove,
        onLoad: this._onLoad,
        width: this.props.outputWidth,
        height: this.props.outputHeight,
        type: this.props.outputType,
        rotation: this.props.outputRotation,
        quality: this.props.outputQuality,
        previewWidth: this.props.previewWidth,
        previewHeight: this.props.previewHeight,
        previewShape: this.props.previewShape,
        cumulativeOnChange: true
      };
    },

    _getMainAttrs() {
      let attrs = this._getInputAttrs();
      attrs.id = this.getId();
      return attrs;
    },
    //@@viewOff:componentSpecificHelpers

    //@@viewOn:render
    render() {
      return (
        <div {...this._getMainAttrs()}>
          {this.getLabel(this.getId() + "-input-hidden-input")}
          {this.getInputWrapper(<ImageInputAdjustment {...this._getAdjustmentProps()} />)}
          {this.getDisabledCoverTransparent()}
        </div>
      );
    }
    //@@viewOff:render
  })
);

export default Input;
