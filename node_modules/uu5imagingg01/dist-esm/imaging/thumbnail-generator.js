import UU5 from "uu5g04";
import "uu5g04-forms";

import ReactCrop from "react-image-crop";
import "react-image-crop/dist/ReactCrop.css";

import "./thumbnail-generator.less";
import Cfg from "../config/config.js";

const RATIO_SEPARATOR = ":";
const ONE_BY_ONE = "1:1";
const AVATAR = "avatar";
const TWO_BY_THREE = "2:3";
const THREE_BY_TWO = "3:2";
const THREE_BY_FOUR = "3:4";
const FOUR_BY_THREE = "4:3";
const DEFAULT_TYPES = [ONE_BY_ONE, AVATAR, TWO_BY_THREE, THREE_BY_TWO, THREE_BY_FOUR, FOUR_BY_THREE];

export const ThumbnailGenerator = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.NestingLevelMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ThumbnailGenerator",
    classNames: {
      main: Cfg.CSS + "thumbnail-generator",
      aside: Cfg.CSS + "thumbnail-generator-aside",
      imageArea: Cfg.CSS + "thumbnail-generator-image-area",
      imageAreaSet: Cfg.CSS + "thumbnail-generator-image-area set",
      maskItems: Cfg.CSS + "thumbnail-generator-mask-items",
      maskItem: Cfg.CSS + "thumbnail-generator-mask-item",
      uploadText: Cfg.CSS + "thumbnail-generator-upload-text",
      areaItem: Cfg.CSS + "thumbnail-generator-area-item",
      controlButtons: Cfg.CSS + "thumbnail-generator-button-control",
      imgAlign: Cfg.CSS + "thumbnail-generator-img-align"
    },
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "box"),
    lsi: {
      clearSource: {
        en: "Clear source",
        cs: "Odstranit zdroj"
      },
      clearSelected: {
        en: "Clear selected",
        cs: "Vymazat vybrané"
      },
      uploadPlaceholder: {
        en: `<uu5string/><UU5.Bricks.Header level="4">Drag image here</UU5.Bricks.Header><UU5.Bricks.P>or click to upload</UU5.Bricks.P>`,
        cs: `<uu5string/><UU5.Bricks.Header level="4">Přetáhněte obrázek sem</UU5.Bricks.Header><UU5.Bricks.P>nebo klikněte pro vložení</UU5.Bricks.P>`
      }
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    onChange: UU5.PropTypes.func,
    thumbnailTypes: UU5.PropTypes.arrayOf(UU5.PropTypes.oneOf(DEFAULT_TYPES)),
    outputType: UU5.PropTypes.oneOf(["png", "jpeg"])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      thumbnailTypes: DEFAULT_TYPES,
      outputType: "jpeg"
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    const resultList = this.props.thumbnailTypes.map(type => ({ type, uri: null }));

    return {
      src: null,
      crops: {}, // type => {x,y,width,height}
      selectedType: null,
      resultList
    };
  },

  componentWillUnmount() {
    this._unmounted = true;
    UU5.Environment.EventListener.removeWindowEvent("keyup", this.getId());
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private
  _evalExpression(exp) {
    if (exp === AVATAR) {
      return 1;
    }

    const [width, height] = exp.split(RATIO_SEPARATOR);

    return parseInt(width) / parseInt(height);
  },

  _calcHeight(width, type) {
    return width / this._evalExpression(type);
  },

  _calcWidth(height, type) {
    return height * this._evalExpression(type);
  },

  _makeAspectCrop(crop, imageAspect) {
    let completeCrop = crop;

    if (crop.width) {
      completeCrop.height = (crop.width / crop.aspect) * imageAspect;
    }
    if (crop.height) {
      completeCrop.width = ((completeCrop.height || crop.height) * crop.aspect) / imageAspect;
    }

    if (crop.y + (completeCrop.height || crop.height) > 100) {
      completeCrop.height = 100 - crop.y;
      completeCrop.width = (completeCrop.height * crop.aspect) / imageAspect;
    }

    if (crop.x + (completeCrop.width || crop.width) > 100) {
      completeCrop.width = 100 - crop.x;
      completeCrop.height = (completeCrop.width / crop.aspect) * imageAspect;
    }

    return completeCrop;
  },

  _handleOnFileChange({ value }) {
    const reader = new FileReader();

    reader.onload = ({ target: { result: src } }) => {
      this._fileComp = null;
      this.setState({ src });
    };

    reader.readAsDataURL(value);
  },

  _onFocus() {
    UU5.Environment.EventListener.addWindowEvent("keyup", this.getId(), e => {
      const isEnter = e.which === 13;
      let fileComp = isEnter && !this.isDisabled() && this._fileComp && this._fileComp.findDOMNode();
      if (fileComp) {
        let input = fileComp.querySelector("input");
        input && input.click();
      }
    });
  },

  _onBlur() {
    UU5.Environment.EventListener.removeWindowEvent("keyup", this.getId());
  },

  _onImageLoaded(image, pixelCrop) {
    this._imageRef = image;
  },

  _onCropComplete(crop, pixelCrop) {
    if (this.state.selectedType) {
      this._makeClientCrop(crop, pixelCrop);
    }
  },

  _onCropChange(crop) {
    this.setState(state =>
      state.selectedType ? { crops: { ...state.crops, [state.selectedType]: crop } } : undefined
    );
  },

  _cropResolver(data) {
    if (!this._unmounted) {
      const { onChange } = this.props;
      this.setState(
        prevState => {
          const type = prevState.selectedType;
          let resultList = prevState.resultList.map(element =>
            element.type === type ? { ...element, uri: data } : element
          );
          return {
            resultList: resultList
          };
        },
        () => {
          if (typeof onChange === "function") {
            onChange(this.state.resultList.filter(x => !!x.uri));
          }
        }
      );
    }
  },

  _makeClientCrop(crop, pixelCrop) {
    if (this._imageRef && crop.width && crop.height) {
      const { outputType } = this.props;
      const croppedImageUrl = this._getCroppedImg(this._imageRef, pixelCrop, `newFile.${outputType}`);
      croppedImageUrl.then(this._cropResolver, null);
    }
  },

  _getCroppedImg(image, pixelCrop, fileName) {
    const canvas = document.createElement("canvas");
    canvas.width = pixelCrop.width;
    canvas.height = pixelCrop.height;
    const ctx = canvas.getContext("2d");

    ctx.drawImage(
      image,
      pixelCrop.x,
      pixelCrop.y,
      pixelCrop.width,
      pixelCrop.height,
      0,
      0,
      pixelCrop.width,
      pixelCrop.height
    );

    return new Promise((resolve, reject) => {
      canvas.toBlob(blob => {
        if (!blob) {
          //reject(new Error('Canvas is empty'));
          console.error("Canvas is empty");
          return;
        }
        let fileUrl;
        blob.name = fileName;
        window.URL.revokeObjectURL(fileUrl);
        fileUrl = window.URL.createObjectURL(blob);
        resolve(fileUrl);
      }, "image/" + this.props.outputType);
    });
  },

  _getPixelCrop(image, percentCrop) {
    if (!image || !percentCrop) {
      return null;
    }

    let imageWidth = image.naturalWidth;
    let imageHeight = image.naturalHeight;

    let x = Math.round(imageWidth * (percentCrop.x / 100));
    let y = Math.round(imageHeight * (percentCrop.y / 100));
    let width = Math.round(imageWidth * (percentCrop.width / 100));
    let height = Math.round(imageHeight * (percentCrop.height / 100));

    return {
      x: x,
      y: y,
      // Clamp width and height so rounding doesn't cause the crop to exceed bounds.
      width: Math.min(Math.max(width, 0), imageWidth - x),
      height: Math.min(Math.max(height, 0), imageHeight - y)
    };
  },

  _addOrSelectArea(type) {
    this.setState(state => {
      let crop = state.crops[type];
      let newCrop;
      // NOTE !crop.width is for case when there's no selection yet but we need to pass aspectRatio
      // to ReactCrop so that shape that user drags is using that ratio (e.g. circle instead of ellipsis).
      if (!crop || !crop.width) {
        newCrop = this._makeAspectCrop(
          {
            ...state.crops[state.selectedType],
            aspect: this._evalExpression(type)
          },
          this._imageRef.naturalWidth / this._imageRef.naturalHeight
        ); //real image size
      }

      let newState = {
        selectedType: type
      };
      if (newCrop) {
        newState.crops = { ...state.crops, [type]: newCrop };
        if (newCrop.width) {
          this._getCroppedImg(this._imageRef, this._getPixelCrop(this._imageRef, newCrop), "tmpFile.jpeg").then(
            this._cropResolver,
            null
          );
        }
      }

      return newState;
    });
  },

  _getImageArea() {
    const { crops, src, selectedType } = this.state;
    const crop = crops[selectedType] || {};
    const isImageSet = !!src;
    const croppedData = isImageSet ? (
      <UU5.Bricks.Div key="is" className={this.getClassName("imgAlign")}>
        <ReactCrop
          src={src}
          crop={crop}
          disabled={selectedType === null}
          className={selectedType}
          keepSelection
          onImageLoaded={this._onImageLoaded}
          onComplete={this._onCropComplete}
          onChange={this._onCropChange}
        />
      </UU5.Bricks.Div>
    ) : (
      <UU5.Common.Fragment key="up">
        <UU5.Bricks.Div
          className={this.getClassName("uploadText")}
          content={this.getLsiComponent("uploadPlaceholder")}
        />
        <UU5.Forms.File onChange={this._handleOnFileChange} ref_={ref => (this._fileComp = ref)} />
      </UU5.Common.Fragment>
    );

    return (
      <UU5.Bricks.Div
        key="ia"
        className={isImageSet ? this.getClassName("imageAreaSet") : this.getClassName("imageArea")}
        mainAttrs={{
          tabIndex: this.state.src === null ? "0" : "-1",
          onFocus: this._onFocus,
          onBlur: this._onBlur
        }}
      >
        {croppedData}
      </UU5.Bricks.Div>
    );
  },

  _handleOnClick(type) {
    if (this._imageRef && this.state.src) {
      this._addOrSelectArea(type);
    }
  },

  _clearSelected(cleanSrc) {
    const { onChange } = this.props;
    if (cleanSrc === true) this._fileComp = null;
    this.setState(
      prev => {
        let cleaned = prev.resultList.map(element => ({ ...element, uri: null }));

        return {
          resultList: cleaned,
          selectedType: null,
          src: cleanSrc === true ? null : prev.src,
          crops: {}
        };
      },
      () => {
        if (typeof onChange === "function") {
          onChange(this.state.resultList.filter(x => !!x.uri));
        }
      }
    );
  },

  _cleanSource() {
    this._clearSelected(true);
  },

  _getMasks() {
    return (
      <UU5.Bricks.Div key="masks" className={this.getClassName("maskItems")}>
        {this.state.resultList.map((element, index) => {
          const type = element.type;
          let minWidth = 45;
          let minHeight = 45;
          let borderRadius = 0;

          if (type === AVATAR) {
            borderRadius = 100;
          } else {
            const [widthR, heightR] = type.split(RATIO_SEPARATOR).map(x => parseInt(x));

            if (widthR > heightR) {
              minHeight = this._calcHeight(minWidth, type);
            } else {
              minWidth = this._calcWidth(minHeight, type);
            }
          }

          const key = "thumbnail-generator-area-item-" + index;
          const isSelected = this.state.selectedType === type && this.state.src;
          let cssClassName = this.getClassName("maskItem");
          if (isSelected) {
            cssClassName = cssClassName + " selected";
          }
          const link = element.uri ? element.uri : "";

          return (
            <UU5.Bricks.Div key={key} className={cssClassName}>
              <div
                onClick={() => this._handleOnClick(type)}
                className={this.getClassName("areaItem")}
                style={{
                  width: minWidth,
                  height: minHeight,
                  borderRadius: borderRadius,
                  backgroundImage: "url(" + link + ")"
                }}
              />
              <p>{type}</p>
            </UU5.Bricks.Div>
          );
        })}
        <UU5.Bricks.Div className={this.getClassName("controlButtons")}>
          {this._getCleanButton()}
          {this._getReloadButton()}
        </UU5.Bricks.Div>
      </UU5.Bricks.Div>
    );
  },

  _getReloadButton() {
    return (
      this.state.src && (
        <UU5.Bricks.Link onClick={this._cleanSource}>{this.getLsiComponent("clearSource")}</UU5.Bricks.Link>
      )
    );
  },

  _getCleanButton() {
    return (
      this.state.selectedType &&
      this.state.src !== null && (
        <UU5.Bricks.Link onClick={this._clearSelected}>{this.getLsiComponent("clearSelected")}</UU5.Bricks.Link>
      )
    );
  },

  _getChild() {
    return (
      <UU5.Bricks.Resize>
        {({ width, height }) => {
          let mainProps = this.getMainPropsToPass();
          if (width > 768) mainProps.className += " " + this.getClassName("aside");
          return (
            <UU5.Bricks.Div {...mainProps}>
              {this._getImageArea(width)}
              {this._getMasks(width)}
            </UU5.Bricks.Div>
          );
        }}
      </UU5.Bricks.Resize>
    );
  },

  //@@viewOff:private

  //@@viewOn:render
  render() {
    return this.getNestingLevel() ? this._getChild() : null;
  }
  //@@viewOff:render
});

export default ThumbnailGenerator;
