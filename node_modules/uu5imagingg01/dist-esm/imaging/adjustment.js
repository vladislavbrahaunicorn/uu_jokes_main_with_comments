export const Adjustment = {
  OUTPUT_TYPES: ["png", "jpeg"]
};

let canvas, context;

if (!HTMLCanvasElement.prototype.toBlob) {
  Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
    value: function(callback, type, quality) {
      let dataURL = this.toDataURL(type, quality).split(",")[1];
      setTimeout(() => {
        let binStr = atob(dataURL),
          len = binStr.length,
          arr = new Uint8Array(len);

        for (let i = 0; i < len; i++) {
          arr[i] = binStr.charCodeAt(i);
        }

        callback(new Blob([arr], { type: type || "image/png" }));
      });
    }
  });
}

//@@viewOn:interface
Adjustment.resize = (imageFile, width, height) => {
  return _modifyImage(imageFile, imageElement => {
    _initCanvas();
    let imgHeight = imageElement.naturalHeight || imageElement.height;
    let imgWidth = imageElement.naturalWidth || imageElement.width;
    if (typeof width === "string" && width.match(/^\d+(\.\d+)?%$/)) width = (parseFloat(width) * imgWidth) / 100;
    else if (typeof width === "string") width = Number(width);
    if (typeof height === "string" && height.match(/^\d+(\.\d+)?%$/)) height = (parseFloat(height) * imgHeight) / 100;
    else if (typeof height === "string") height = Number(height);
    let canvasWidth = width;
    let canvasHeight = height;
    if (!width) {
      canvasWidth = (height / imgHeight) * imgWidth;
    } else if (!height) {
      canvasHeight = (width / imgWidth) * imgHeight;
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    context.drawImage(imageElement, 0, 0, canvasWidth, canvasHeight);
    return { quality: 1 };
  });
};

Adjustment.resizeMax = (imageFile, maxWidth, maxHeight) => {
  return _modifyImage(imageFile, imageElement => {
    _initCanvas();
    let imgHeight = imageElement.naturalHeight || imageElement.height;
    let imgWidth = imageElement.naturalWidth || imageElement.width;
    if (typeof maxWidth === "string" && maxWidth.match(/^\d+(\.\d+)?%$/))
      maxWidth = (parseFloat(maxWidth) * imgWidth) / 100;
    else if (typeof maxWidth === "string") maxWidth = Number(maxWidth);
    if (typeof maxHeight === "string" && maxHeight.match(/^\d+(\.\d+)?%$/))
      maxHeight = (parseFloat(maxHeight) * imgHeight) / 100;
    else if (typeof maxHeight === "string") maxHeight = Number(maxHeight);
    let canvasWidth = maxWidth;
    let canvasHeight = maxHeight;
    if (!maxWidth) {
      canvasWidth = (maxHeight / imgHeight) * imgWidth;
    } else if (!maxHeight) {
      canvasHeight = (maxWidth / imgWidth) * imgHeight;
    } else {
      // contain (preserve aspect ratio, i.e. width & height are max width & max height)
      // and don't scale up
      if (imgWidth / imgHeight < maxWidth / maxHeight) {
        canvasHeight = Math.min(imgHeight, maxHeight);
        canvasWidth = Math.min(imgWidth, (canvasHeight / imgHeight) * imgWidth);
      } else {
        canvasWidth = Math.min(imgWidth, maxWidth);
        canvasHeight = Math.min(imgHeight, (canvasWidth / imgWidth) * imgHeight);
      }
    }

    if (canvasWidth > imgWidth || canvasHeight > imgHeight) {
      canvasWidth = imgWidth;
      canvasHeight = imgHeight;
    }

    canvas.width = Math.floor(canvasWidth) > 0 ? canvasWidth : 1;
    canvas.height = Math.floor(canvasHeight) > 0 ? canvasHeight : 1;
    context.drawImage(imageElement, 0, 0, canvasWidth, canvasHeight);
    return { quality: 1 };
  });
};

Adjustment.changeType = (imageFile, requiredType, quality) => {
  let result;
  if (!isTypeSupported(requiredType)) {
    result = Promise.reject(
      new Error(`Output type '${requiredType}' is not supported. Must be one of: ${Adjustment.OUTPUT_TYPES}.`)
    );
  } else {
    result = _modifyImage(imageFile, imageElement => {
      _initCanvas();
      let width = imageElement.naturalWidth || imageElement.width;
      let height = imageElement.naturalHeight || imageElement.height;
      canvas.width = width;
      canvas.height = height;
      context.drawImage(imageElement, 0, 0, width, height);
      return { type: requiredType, quality };
    });
  }
  return result;
};

Adjustment.rotate = (imageFile, method, originalFile = imageFile) => {
  return _getImageArrayBuffer(originalFile).then(imageArrayBuffer =>
    _modifyImage(imageFile, imageElement => {
      _initCanvas();
      let result = { quality: 1 };
      let orientation = _getOrientation(imageArrayBuffer);
      if (typeof method === "number") {
        _flipImage(imageElement, orientation, method);
      } else if (method === "auto" && orientation > 0) {
        _flipImageAutomatically(imageElement, orientation);
      } else {
        result.imageFile = imageFile;
      }
      return result;
    })
  );
};

Adjustment.crop = (imageFile, x, y, width, height) => {
  return _modifyImage(imageFile, imageElement => {
    _initCanvas();
    let imgHeight = imageElement.naturalHeight || imageElement.height;
    let imgWidth = imageElement.naturalWidth || imageElement.width;
    let srcWidth = Math.min(width, imgWidth - x);
    let srcHeight = Math.min(height, imgHeight - y);
    canvas.width = srcWidth;
    canvas.height = srcHeight;
    context.drawImage(imageElement, x, y, srcWidth, srcHeight, 0, 0, canvas.width, canvas.height);
    return { quality: 1 };
  });
};

Adjustment.cropRatio = (imageFile, dxWidth, dxHeight) => {
  return _modifyImage(imageFile, imageElement => {
    _initCanvas();
    let imgHeight = imageElement.naturalHeight || imageElement.height;
    let imgWidth = imageElement.naturalWidth || imageElement.width;
    let canvasWidth, canvasHeight;
    if (dxWidth / dxHeight < imgWidth / imgHeight) {
      canvasHeight = imgHeight;
      canvasWidth = (canvasHeight * dxWidth) / dxHeight;
    } else {
      canvasWidth = imgWidth;
      canvasHeight = (canvasWidth * dxHeight) / dxWidth;
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    context.drawImage(
      imageElement,
      (imgWidth - canvasWidth) / 2,
      (imgHeight - canvasHeight) / 2,
      canvasWidth,
      canvasHeight,
      0,
      0,
      canvasWidth,
      canvasHeight
    );
    return { quality: 1 };
  });
};
//@@viewOff:interface

// https://stackoverflow.com/questions/7584794/accessing-jpeg-exif-rotation-data-in-javascript-on-the-client-side
function _getOrientation(imageSrc) {
  let view = new DataView(imageSrc);
  if (view.getUint16(0, false) != 0xffd8) {
    return -2;
  }
  let length = view.byteLength,
    offset = 2;
  while (offset < length) {
    if (view.getUint16(offset + 2, false) <= 8) return -1;
    let marker = view.getUint16(offset, false);
    offset += 2;
    if (marker == 0xffe1) {
      if (view.getUint32((offset += 2), false) != 0x45786966) {
        return -1;
      }

      let little = view.getUint16((offset += 6), false) == 0x4949;
      offset += view.getUint32(offset + 4, little);
      let tags = view.getUint16(offset, little);
      offset += 2;
      for (let i = 0; i < tags; i++) {
        if (view.getUint16(offset + i * 12, little) == 0x0112) {
          return view.getUint16(offset + i * 12 + 8, little);
        }
      }
    } else if ((marker & 0xff00) != 0xff00) {
      break;
    } else {
      offset += view.getUint16(offset, false);
    }
  }
  return -1;
}

function _flipImage(imageElement, orientation, requiredRotation) {
  return _rotate(imageElement, orientation, requiredRotation);
}

function _flipImageAutomatically(imageElement, orientation) {
  return _rotate(imageElement, orientation);
}

function _rotate(imageElement, orientation, requiredRotation) {
  let width = imageElement.naturalWidth || imageElement.width;
  let height = imageElement.naturalHeight || imageElement.height;

  if (typeof requiredRotation === "number") {
    let angle = requiredRotation * (Math.PI / 180);
    let rotateX = (x, y) => -y * Math.sin(angle) + x * Math.cos(angle);
    let rotateY = (x, y) => y * Math.cos(angle) + x * Math.sin(angle);
    let leftTopX = Math.round(Math.min(0, rotateX(width, 0), rotateX(width, height), rotateX(0, height)));
    let leftTopY = Math.round(Math.min(0, rotateY(width, 0), rotateY(width, height), rotateY(0, height)));
    let rightBottomX = Math.round(Math.max(0, rotateX(width, 0), rotateX(width, height), rotateX(0, height)));
    let rightBottomY = Math.round(Math.max(0, rotateY(width, 0), rotateY(width, height), rotateY(0, height)));
    canvas.width = rightBottomX - leftTopX;
    canvas.height = rightBottomY - leftTopY;
    context.translate(-leftTopX, -leftTopY);
    context.rotate(angle);
  } else {
    switch (orientation) {
      case 2:
        // horizontal flip
        canvas.width = width;
        canvas.height = height;
        context.translate(width, 0);
        context.scale(-1, 1);
        break;
      case 3:
        // 180° left
        canvas.width = width;
        canvas.height = height;
        context.translate(width, height);
        context.rotate(Math.PI);
        break;
      case 4:
        // vertical flip
        canvas.width = width;
        canvas.height = height;
        context.translate(0, height);
        context.scale(1, -1);
        break;
      case 5:
        // vertical flip + 90 right
        canvas.width = height;
        canvas.height = width;
        context.rotate(0.5 * Math.PI);
        context.scale(1, -1);
        break;
      case 6:
        // 90° right
        canvas.width = height;
        canvas.height = width;
        context.rotate(0.5 * Math.PI);
        context.translate(0, -height);
        break;
      case 7:
        // horizontal flip + 90 right
        canvas.width = height;
        canvas.height = width;
        context.rotate(0.5 * Math.PI);
        context.translate(width, -height);
        context.scale(-1, 1);
        break;
      case 8:
        // 90° left
        canvas.width = height;
        canvas.height = width;
        context.rotate(-0.5 * Math.PI);
        context.translate(-width, 0);
        break;
      default:
        canvas.width = width;
        canvas.height = height;
    }
  }

  context.drawImage(imageElement, 0, 0);
}

function _initCanvas() {
  if (!canvas && !context) {
    canvas = document.createElement("canvas");
    canvas.style.display = "none";
    document.body.appendChild(canvas);
    context = canvas.getContext("2d");
  }

  context.clearRect(0, 0, canvas.width, canvas.height);
  context.restore();
  context.save();
}

function _modifyImage(imageFile, fn) {
  return new Promise((resolve, reject) => {
    _getImageElement(URL.createObjectURL(imageFile)).then(imageElement => {
      let { type, imageFile: resultFile, quality } = fn(imageElement) || {};
      if (resultFile) {
        resolve({ imageSrc: URL.createObjectURL(resultFile), imageFile: resultFile });
      } else {
        if (!type && imageFile.name) {
          // preserve image type, e.g. photo.jpg => image/jpg
          type = imageFile.name
            .split(".")
            .pop()
            .toLowerCase();
          if (!isTypeSupported(type)) type = null;
        }
        if (!type) type = Adjustment.OUTPUT_TYPES[0];
        type = normalizeType(type);
        let { width, height } = canvas;
        canvas.toBlob(
          blob => {
            if (!blob) {
              reject(
                new Error(
                  `Image adjustment failed (unable to get result blob data). Result canvas size: ${width}x${height}`
                )
              );
            } else if (type && blob.type !== type) {
              reject(new Error(`This browser doesn't support generating images of type '${type}'.`));
            } else {
              blob.name = imageFile.name;
              if (type) {
                blob.name = blob.name.replace(
                  /\.[^.]*$/,
                  m => "." + type.replace(/^image\//, "").replace(/^jpeg$/, "jpg")
                );
              }
              resolve({ imageSrc: URL.createObjectURL(blob), imageFile: blob });
            }
          },
          type,
          quality
        );
      }
    }, reject);
  });
}

function _getImageElement(imageSrc) {
  return new Promise((resolve, reject) => {
    let image = new Image();
    image.src = imageSrc;
    image.onload = () => {
      resolve(image);
    };
    image.onerror = () => {
      reject(new Error("Image failed to load in <img> element."));
    };
  });
}

function _getImageArrayBuffer(imageFile) {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = e => {
      resolve(e.target.result);
    };
    reader.onerror = () => {
      reject(new Error("Reading image data failed."));
    };
    reader.readAsArrayBuffer(imageFile);
  });
}

function normalizeType(type) {
  if (type && !type.startsWith("image/")) type = "image/" + type;
  if (type === "image/jpg") type = "image/jpeg";
  return type || null;
}

const isTypeSupported = (function() {
  let normalizedTypes;
  return type => {
    if (!normalizedTypes) {
      normalizedTypes = {};
      for (let type of Adjustment.OUTPUT_TYPES) normalizedTypes[normalizeType(type)] = true;
    }
    return normalizedTypes[normalizeType(type)];
  };
})();

export default Adjustment;
