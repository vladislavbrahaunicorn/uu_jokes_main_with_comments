import UU5 from "uu5g04";
import Cfg from "../config/config.js";

import "./lightbox-body.less";

const LightboxBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.SwipeMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "Lightbox.Body",
    classNames: {
      main: Cfg.CSS + "lightbox-body",
      verticalAlign: Cfg.CSS + "lightbox-body-vertical-align-helper",
      header: Cfg.CSS + "lightbox-body-header",
      bodyContent: Cfg.CSS + "lightbox-body-content",
      white: Cfg.CSS + "lightbox-body-white-color",
      gray: Cfg.CSS + "lightbox-body-gray-color",
      counterWhite: Cfg.CSS + "lightbox-body-counter-white",
      counterGray: Cfg.CSS + "lightbox-body-counter-gray",
      controlWhite: Cfg.CSS + "lightbox-body-control-white",
      controlGray: Cfg.CSS + "lightbox-body-control-gray",
      noDecoration: Cfg.CSS + "lightbox-body-nodecoration",
      navigationArrow: Cfg.CSS + "lightbox-body-navigation-arrow",
      navigationArrowLeft: Cfg.CSS + "lightbox-body-navigation-arrow-left",
      navigationArrowRight: Cfg.CSS + "lightbox-body-navigation-arrow-right",
      preloadImage: Cfg.CSS + "lightbox-body-preload-image"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    getOption: UU5.PropTypes.func,
    setOption: UU5.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      getOption: null,
      setOption: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    let newData = Object.assign({}, this.props);
    let options = this.props.getOptions();
    newData = Object.assign(newData, options);

    return {
      data: newData.data,
      index: newData.index,
      isLoaded: newData.isLoaded,
      zoom: newData.zoom,
      blackBackground: newData.blackBackground,
      open: false
    };
  },

  componentWillReceiveProps(nextProps) {
    let newData = Object.assign({}, nextProps);
    let options = nextProps.getOptions();
    newData = Object.assign(newData, options);
    this.setData(newData);
    return this;
  },

  componentDidMount() {
    this._mounted = true;
    this._checkImageLoaded();
  },

  componentWillMount() {
    if (this._bodyContent) this._bodyContent.removeEventListener("wheel", this._mouseWheel, { passive: false });
  },

  componentDidUpdate() {
    this._checkImageLoaded();
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  onCloseModal() {
    // TODO remove after UU5.Bricks.Modal was fixed
    document.body.className = document.body.className.replace(new RegExp("modal-open", "g"), "").trim();

    window.removeEventListener("keydown", this._keyPress);
    this._isOpen = false;
    return this;
  },

  onOpenModal() {
    window.addEventListener("keydown", this._keyPress);
    this._isOpen = true;
    return this;
  },

  isOpen() {
    return this._isOpen;
  },

  setData(newData, setStateCallback) {
    this.setState(
      {
        data: newData.data,
        index: newData.index,
        isLoaded: newData.isLoaded,
        zoom: newData.zoom,
        blackBackground: newData.blackBackground
      },
      setStateCallback
    );

    return this;
  },
  //@@viewOff:interface

  //@@viewOn:componentSpecificHelpers
  _checkImageLoaded() {
    if (!this.state.isLoaded && this._mainImage) {
      let imageEl = this._mainImage.findDOMNode();
      if (imageEl.complete) this._setImageLoaded(this.state.index, imageEl);
    }
  },

  _allowZoom() {
    let { index, data } = this.state;
    if (document.getElementById("lightbox-body")) {
      let boundaries = document.getElementById("lightbox-body").getBoundingClientRect();
      let current = data[index];
      return current.height > boundaries.height || current.width > boundaries.width;
    }

    return false;
  },

  _toggleZoom() {
    let { zoom } = this.state;
    zoom = !zoom;
    this.setState({ zoom }, () => {
      if (this._bodyContent) {
        this._bodyContent.scrollTop = 0;
        this._bodyContent.scrollLeft = 0;
      }
    });
  },

  _toggleBackground() {
    let { blackBackground } = this.state;
    blackBackground = !blackBackground;
    this.setState({ blackBackground });
    this.props.setOptions({ blackBackground });
  },

  _previousImage() {
    let { index, isLoaded, data } = this.state;
    isLoaded = false;
    index--;
    index = index < 0 ? data.length - 1 : index;
    this.setState({ index, isLoaded, zoom: false });
    this.props.setOptions({ index });
  },

  _nextImage() {
    let { index, data, isLoaded } = this.state;
    isLoaded = false;
    index++;
    index %= data.length;
    this.setState({ index, isLoaded, zoom: false });
    this.props.setOptions({ index });
  },

  _getNavigationClassName(right) {
    let className = this.getClassName().navigationArrow;
    let direction = right ? this.getClassName().navigationArrowRight : this.getClassName().navigationArrowLeft;
    let color = this.state.blackBackground ? this.getClassName().white : this.getClassName().gray;
    return className.concat(" ", direction, " ", color);
  },

  _mouseWheel(e) {
    e.preventDefault();

    if (this._allowZoom()) {
      let zoom = e.deltaY < 0;

      if (zoom !== this.state.zoom) {
        this._toggleZoom();
      }
    }
  },

  _mouseDown(e) {
    e.preventDefault();

    if (e.button === 0) {
      this._handleStart(e.clientX, e.clientY);
    }
  },

  _touchStart(e) {
    this.swipeOnTouchStart(e);
    this._handleStart(e.touches[0].clientX, e.touches[0].clientY);
  },

  _handleStart(x, y) {
    if (this.state.zoom) {
      this.setState({ startX: x, startY: y, mouseDrag: true });
    }
  },

  _mouseMove(e) {
    e.preventDefault();
    this._handleMove(e, e.clientX, e.clientY);
  },

  _touchMove(e) {
    this.swipeOnTouchMove(e);
    this._handleMove(e, e.touches[0].clientX, e.touches[0].clientY);
  },

  _handleMove(event, currentX, currentY) {
    if (this.state.mouseDrag) {
      let { startX, startY } = this.state;

      event.target.parentElement.scrollTop += startY - currentY;
      event.target.parentElement.scrollLeft += startX - currentX;

      this.setState({ startX: currentX, startY: currentY });
    }
  },

  _mouseUp(e) {
    e.preventDefault();

    if (this.state.mouseDrag) {
      this.setState({ mouseDrag: false });
    }
  },

  _touchEnd(e) {
    this.swipeOnTouchEnd(e);

    if (this.state.mouseDrag) {
      this.setState({ mouseDrag: false });
    } else if (this.isSwipedRightLong() && this.getSwipeLength() > 69) {
      this._previousImage();
    } else if (this.isSwipedLeftLong() && this.getSwipeLength() > 69) {
      this._nextImage();
    }
  },

  _keyPress(event) {
    if (event.code === "ArrowLeft") {
      this._previousImage();
    } else if (event.code === "ArrowRight") {
      this._nextImage();
    } else if (event.code === "Escape") {
      this.props.closeModal();
    }
  },

  _setImageLoaded(index, imgEl) {
    let width = imgEl.naturalWidth;
    let height = imgEl.naturalHeight;
    this.setState(({ data }) => {
      data = [...data.slice(0, index), { ...data[index], width, height }, ...data.slice(index + 1)];
      return { isLoaded: true, data };
    });
  },

  _setImageError(index, e) {
    this.setState({ isLoaded: true });
  },

  _getHeader() {
    let { index, data } = this.state;
    let allowZoom = this._allowZoom();

    return (
      <UU5.Bricks.Div className={this.getClassName().header}>
        <UU5.Bricks.Text
          className={this.state.blackBackground ? this.getClassName().counterWhite : this.getClassName().counterGray}
        >
          {data.length > 1 ? index + 1 + "/" + data.length : null}
        </UU5.Bricks.Text>
        <UU5.Bricks.Span style={{ marginLeft: "auto", marginRight: "10px" }}>
          {allowZoom && (
            <UU5.Bricks.Link onClick={this._toggleZoom} className={this.getClassName("noDecoration")}>
              <UU5.Bricks.Icon
                icon={this.state.zoom ? "mdi-magnify-minus-outline" : "mdi-magnify-plus-outline"}
                style={{ marginRight: "6px" }}
                className={
                  this.state.blackBackground ? this.getClassName().controlWhite : this.getClassName().controlGray
                }
              />
            </UU5.Bricks.Link>
          )}
          <UU5.Bricks.Link onClick={this._toggleBackground} className={this.getClassName("noDecoration")}>
            <UU5.Bricks.Icon
              icon="mdi-contrast-box"
              style={{ marginRight: "12px" }}
              className={
                this.state.blackBackground ? this.getClassName().controlWhite : this.getClassName().controlGray
              }
            />
          </UU5.Bricks.Link>
          <UU5.Bricks.Link onClick={this.props.closeModal} className={this.getClassName("noDecoration")}>
            <UU5.Bricks.Icon
              icon="mdi-close"
              className={
                this.state.blackBackground ? this.getClassName().controlWhite : this.getClassName().controlGray
              }
            />
          </UU5.Bricks.Link>
        </UU5.Bricks.Span>
      </UU5.Bricks.Div>
    );
  },

  _setMainImageRef(ref) {
    this._mainImage = ref;
    if (ref && this._mounted) this._checkImageLoaded();
  },

  _setBodyDivRef(ref) {
    if (this._bodyContent) this._bodyContent.removeEventListener("wheel", this._mouseWheel, { passive: false });
    if (ref) {
      this._bodyContent = ref.findDOMNode();
      this._bodyContent.addEventListener("wheel", this._mouseWheel, { passive: false });
    } else {
      this._bodyContent = null;
    }
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let { data, index } = this.state;
    let current = data[index];
    let nextIndex = (index + 1) % data.length;
    let prevIndex = index === 0 ? data.length - 1 : index - 1;

    let props = this.getMainPropsToPass();
    props.style = props.style || {};
    props.style.background = this.state.blackBackground ? "black" : "white";

    return (
      <UU5.Bricks.Div {...props}>
        {this._getHeader(false, false)}
        <UU5.Bricks.Div
          id="lightbox-body"
          className={this.getClassName().bodyContent}
          ref_={this._setBodyDivRef}
          mainAttrs={{
            onMouseMove: this._mouseMove,
            onMouseDown: this._mouseDown,
            onMouseUp: this._mouseUp,
            onTouchStart: this._touchStart,
            onTouchMove: this._touchMove,
            onTouchEnd: this._touchEnd
          }}
        >
          {!this.state.zoom && this.state.data.length > 1 && (
            <UU5.Bricks.Link onClick={this._previousImage} className={this.getClassName("noDecoration")}>
              <UU5.Bricks.Icon className={this._getNavigationClassName(false)} icon="mdi-chevron-left" />
            </UU5.Bricks.Link>
          )}
          {!this.state.zoom && <UU5.Bricks.Span className={this.getClassName().verticalAlign} />}
          {!this.state.isLoaded && (
            <UU5.Bricks.Loading
              style={{
                display: "inline-block"
              }}
            />
          )}
          <UU5.Bricks.Image
            ref_={this._setMainImageRef}
            responsive={false}
            className={this.state.isLoaded ? undefined : this.getClassName("preloadImage")}
            src={current.src}
            authenticate={current.authenticate}
            style={this.state.zoom ? { maxWidth: "none", cursor: "move" } : { maxWidth: "100%", maxHeight: "100%" }}
            mainAttrs={{
              // TODO This is not entirely correct - "index" might be wrong if lightbox data changed during image load...
              onLoad: e => this._setImageLoaded(index, e.target),
              onError: e => this._setImageError(index, e.target)
            }}
          />
          {!this.state.zoom && this.state.data.length > 1 && (
            <UU5.Bricks.Link onClick={this._nextImage} className={this.getClassName("noDecoration")}>
              <UU5.Bricks.Icon icon="mdi-chevron-right" className={this._getNavigationClassName(true)} />
            </UU5.Bricks.Link>
          )}

          {/* preload next & previous image */}
          {nextIndex !== index && (
            <UU5.Bricks.Image
              className={this.getClassName("preloadImage")}
              responsive={false}
              src={data[nextIndex].src}
              authenticate={data[nextIndex].authenticate}
            />
          )}
          {prevIndex !== index && prevIndex !== nextIndex && (
            <UU5.Bricks.Image
              className={this.getClassName("preloadImage")}
              responsive={false}
              src={data[prevIndex].src}
              authenticate={data[prevIndex].authenticate}
            />
          )}
        </UU5.Bricks.Div>
      </UU5.Bricks.Div>
    );
  }
  //@@viewOff:render
});

export default LightboxBody;
