import UU5 from "uu5g04";
import Cfg from "../../config/config.js";
import Image from "../image.js";
import Tools, { REGEXP } from "./tools.js";

function getImageWrapperClassName({ width, height }) {
  return UU5.Common.Css.css(`
    && {
      width: ${width}px;
      height: ${height}px;
    }
  `);
}

export const ImageRowBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ImageRowBody",
    classNames: {
      main: Cfg.CSS + "image-row-body",
      imageWrapper: () =>
        UU5.Common.Css.css(`
        & + & {
          margin-left: 4px;
        }
      `)
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired,
          thumb: UU5.PropTypes.string
        })
      ])
    ).isRequired,
    effect: UU5.PropTypes.string,
    thumbSuffix: UU5.PropTypes.string,
    lightbox: UU5.PropTypes.oneOf(["local", "global", "none"]),
    authenticate: UU5.PropTypes.bool,
    minHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    maxHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    alignment: UU5.PropTypes.string,
    rowWidth: UU5.PropTypes.number,
    session: UU5.PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      effect: undefined,
      thumbSuffix: "_th",
      lightbox: "local",
      minHeight: 100,
      maxHeight: 160,
      alignment: "block",
      rowWidth: undefined,
      session: undefined,
      authenticate: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      imgList: []
    };
  },

  componentDidMount() {
    this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled && !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data)) {
      if (nextProps.data.length) {
        this._loadImages(nextProps);
      } else {
        this.setState({ imgList: [] });
      }
    } else if (
      this.props.rowWidth !== nextProps.rowWidth ||
      this.props.minHeight !== nextProps.minHeight ||
      this.props.maxHeight !== nextProps.maxHeight
    ) {
      // TODO FIX: if this gets called too quickly after the initial render, the images will probably be loaded again (if authenticated, a request will be sent twice)
      this._loadImages(nextProps);
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getRowItems(data, height, aWidth) {
    let row = [];
    let width = aWidth;
    if (data.length === 1) {
      row.push({
        lightboxSrc: data[0].lightboxSrc,
        thumb: data[0].thumb,
        caption: data[0].caption,
        width: Math.min(width, (height * data[0].width) / data[0].height),
        height: height,
        column: 0
      });
    } else {
      for (let i = 0; i < data.length; i++) {
        row.push({
          column: i,
          lightboxSrc: data[i].lightboxSrc,
          thumb: data[i].thumb,
          caption: data[i].caption,
          width: (height * data[i].width) / data[i].height,
          height: height,
          left: i === 0 ? 0 : 2,
          right: i === data.length - 1 ? 0 : 2
        });
      }
    }

    return row;
  },

  _getHeight(data, width) {
    let separator = 2 * 2;
    width = width - (data.length - 1) * separator;
    let height = data.reduce((sum, x) => {
      return sum + (x.width * 1.0) / x.height;
    }, 0);
    return width / height;
  },

  _getRowImages(imgList, width, rowMaxHeight, rowMinHeight) {
    rowMaxHeight = rowMaxHeight || 160;
    rowMinHeight = rowMinHeight || 100;

    let rowItemsData = [[]];

    for (let adjustedImgIndex = 0; adjustedImgIndex < imgList.length; adjustedImgIndex++) {
      let testImgList = imgList.slice(0, adjustedImgIndex + 1);
      let height = this._getHeight(testImgList, width);
      if (height <= rowMaxHeight) {
        if (height < rowMinHeight && adjustedImgIndex > 0) {
          break;
        }

        rowItemsData = [testImgList, height, width];
      } else {
        height = Math.min(height, rowMaxHeight);
        rowItemsData = [testImgList, height, width];
      }
    }

    return this._getRowItems(...rowItemsData);
  },

  async _loadImages(props = this.props) {
    this._dataChangeId = Math.random();
    let imgList = [];
    let dataChangeId = this._dataChangeId;

    for (let i = 0; i < props.data.length; i++) {
      const image = await this._loadImage(props.data[i], props.authenticate, props.session);

      if (dataChangeId !== this._dataChangeId) return;

      if (image) {
        let newImgList = this._getRowImages([...imgList, image], props.rowWidth, props.maxHeight, props.minHeight);
        if (newImgList.length === imgList.length) {
          break;
        } else {
          imgList = newImgList;
        }
      }
    }

    this.setAsyncState({ imgList });
  },

  _loadImage(imageData, authenticate, session) {
    if (typeof imageData === "string") {
      imageData = { src: imageData };
    }

    let thumbUrl = imageData.thumb || this._getThumbnail(imageData.src);
    let cacheMatch = this.constructor.imageCache[thumbUrl];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(thumbUrl)) {
          let token = session.getCallToken().token;
          result = new Promise(resolve => {
            let result = { ...imageData };
            Tools.fetchAuthenticatedImage(thumbUrl, token).then(
              data => {
                result.thumb = URL.createObjectURL(data.data);
                resolve(this._getImageData(result, thumbUrl));
              },
              err => {
                result.thumb = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                resolve(this._getImageData(result, thumbUrl));
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(imageData, thumbUrl);
    }

    return result;
  },

  _getImageData(imageData, cacheKey) {
    return new Promise(resolve => {
      let lightboxSrc;
      let thumb;

      if (imageData && typeof imageData === "object") {
        lightboxSrc = imageData.src;
        thumb = imageData.thumb || imageData.lightboxSrc;
      } else {
        lightboxSrc = imageData;
      }

      thumb = thumb || this._getThumbnail(lightboxSrc);

      let img = new window.Image();
      let loadingThumbnail = true;

      img.onload = () => {
        let imgObj = {
          lightboxSrc,
          thumb: loadingThumbnail ? thumb : lightboxSrc,
          width: img.width,
          height: img.height
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        if (loadingThumbnail) {
          loadingThumbnail = false;
          img.src = lightboxSrc;
          return;
        }

        resolve(null);
      };

      img.src = thumb;
    });
  },

  _getThumbnail(name) {
    let thumbnail;
    let dotIndex = name.lastIndexOf(".");

    if (dotIndex !== -1) {
      let fileName = name.substr(0, dotIndex);
      let fileExtension = name.substr(dotIndex + 1);
      if (REGEXP.fileExtension.test(fileExtension)) {
        thumbnail = fileName + this.props.thumbSuffix + "." + fileExtension;
      }
    }

    if (!thumbnail) {
      thumbnail = name + this.props.thumbSuffix;
    }

    return thumbnail;
  },

  _getLightbox() {
    if (this.props.lightbox === "global") {
      return null;
    } else if (this.props.lightbox === "none") {
      return false;
    } else {
      // this.props.lightbox === "local"
      return this.getId();
    }
  },

  _renderImages() {
    return this.state.imgList.map((image, index) => (
      <Image
        key={index}
        src={image.lightboxSrc}
        thumb={image.thumb}
        caption={image.caption}
        effect={this.props.effect}
        shape={this.props.shape}
        lightbox={this._getLightbox()}
        className={`${getImageWrapperClassName(image)} ${this.getClassName("imageWrapper")}`}
        authenticate={this.props.authenticate}
        // width={image.width}
        // height={image.height}
      />
    ));
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this._renderImages();
  }
  //@@viewOff:render
});

export default ImageRowBody;
