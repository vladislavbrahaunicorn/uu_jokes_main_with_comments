import UU5 from "uu5g04";
import Cfg from "../../config/config.js";
import Image from "../image.js";
import Tools, { REGEXP } from "./tools.js";

export const ThumbnailListBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ThumbnailListBody",
    classNames: {
      main: Cfg.CSS + "thumbnail-list-body",
      mode: Cfg.CSS + "thumbnail-list-mode-" // not called thumbnail-list-body... for backward compatibility
    },
    defaults: {
      padding: 2
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    path: UU5.PropTypes.string,
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired,
          thumb: UU5.PropTypes.string
        })
      ])
    ).isRequired,
    mode: UU5.PropTypes.oneOf(["default", "track"]),
    colWidth: UU5.PropTypes.string,
    shape: UU5.PropTypes.string,
    effect: UU5.PropTypes.string,
    thumbSuffix: UU5.PropTypes.string,
    lightbox: UU5.PropTypes.oneOf(["local", "global", "none"]),
    rowMaxHeight: UU5.PropTypes.number,
    rowMinHeight: UU5.PropTypes.number,
    lastRowMaxHeight: UU5.PropTypes.number,
    rowWidth: UU5.PropTypes.number,
    session: UU5.PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      path: "",
      data: [],
      mode: "default",
      colWidth: "xs-6 s-3 m-2 l-1 xl-1",
      shape: undefined,
      effect: undefined,
      thumbSuffix: "_th",
      lightbox: "local",
      rowMaxHeight: 160,
      rowMinHeight: 100,
      lastRowMaxHeight: undefined,
      rowWidth: undefined,
      session: undefined
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    if (this.props.globalLightbox !== undefined) {
      UU5.Common.Tools.warning('Property "globalLightbox" is deprecated! Use "globalLightbox" property instead.');
    }

    return {
      index: 0,
      imgList: [],
      boundingRect: null
    };
  },

  componentDidMount() {
    this.props.data.length > 0 && this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled && !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data)) {
      if (nextProps.data.length) {
        this._loadImages(nextProps);
      } else {
        this.setState({ imgList: [] });
      }
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  async _loadImages(props = this.props) {
    this._dataChangeId = Math.random();
    let imgList = [];
    let dataChangeId = this._dataChangeId;

    for (let i = 0; i < props.data.length; i++) {
      const image = await this._loadImage(props.data[i], props.authenticate, props.session);

      if (dataChangeId !== this._dataChangeId) return;

      if (image) {
        imgList.push(image);
        this.setAsyncState({ imgList });
      }
    }

    this.setAsyncState({ imgList });
  },

  _loadImage(imageData, authenticate, session) {
    if (typeof imageData === "string") {
      imageData = { src: imageData };
    }

    if (this.props.path) {
      imageData.src = this.props.path + imageData.src;

      if (imageData.thumb) {
        imageData.thumb = this.props.path + imageData.thumb;
      }
    }

    let thumbUrl = imageData.thumb || this._getThumbnail(imageData.src);
    let cacheMatch = this.constructor.imageCache[thumbUrl];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(thumbUrl)) {
          let token = session.getCallToken().token;
          result = new Promise(resolve => {
            let result = { ...imageData };
            Tools.fetchAuthenticatedImage(thumbUrl, token).then(
              data => {
                result.thumb = URL.createObjectURL(data.data);
                resolve(this._getImageData(result, thumbUrl));
              },
              err => {
                result.thumb = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                resolve(this._getImageData(result, thumbUrl));
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(imageData, thumbUrl);
    }

    return result;
  },

  _getImageData(imageData, cacheKey) {
    return new Promise(resolve => {
      let lightboxSrc;
      let thumb;

      if (imageData && typeof imageData === "object") {
        lightboxSrc = imageData.src;
        thumb = imageData.thumb || imageData.lightboxSrc;
      } else {
        lightboxSrc = imageData;
      }

      thumb = thumb || this._getThumbnail(lightboxSrc);

      let img = new window.Image();
      let loadingThumbnail = true;

      img.onload = () => {
        let imgObj = {
          lightboxSrc,
          thumb: loadingThumbnail ? thumb : lightboxSrc,
          width: img.width,
          height: img.height
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        if (loadingThumbnail) {
          loadingThumbnail = false;
          img.src = lightboxSrc;
          return;
        }

        resolve(null);
      };

      img.src = thumb;
    });
  },

  _getThumbnail(name) {
    let thumbnail;
    let dotIndex = name.lastIndexOf(".");

    if (dotIndex !== -1) {
      let fileName = name.substr(0, dotIndex);
      let fileExtension = name.substr(dotIndex + 1);
      if (REGEXP.fileExtension.test(fileExtension)) {
        thumbnail = fileName + this.props.thumbSuffix + "." + fileExtension;
      }
    }

    if (!thumbnail) {
      thumbnail = name + this.props.thumbSuffix;
    }

    return thumbnail;
  },

  _getLightbox() {
    if (this.props.lightbox === "global") {
      return null;
    } else if (this.props.lightbox === "none") {
      return false;
    } else if (this.props.globalLightbox === true) {
      // backward compatibility (deprecated prop)
      return null;
    } else {
      return this.getId();
    }
  },

  _getRowItems(data, width) {
    let separator = this.getDefault().padding * 2;
    width = width - (data.length - 1) * separator;
    let height = data.reduce((sum, x) => {
      return sum + (x.width * 1.0) / x.height;
    }, 0);
    return width / height;
  },

  _setHeight(data, ln, height, aWidth) {
    let row = [];
    let width = aWidth;
    if (data.length === 1) {
      row.push({
        lightboxSrc: data[0].lightboxSrc,
        thumb: data[0].thumb,
        caption: data[0].caption,
        width: Math.min(width, (height * data[0].width) / data[0].height),
        height: height,
        column: 0,
        row: ln
      });
    } else {
      for (let i = 0; i < data.length; i++) {
        row.push({
          column: i,
          row: ln,
          lightboxSrc: data[i].lightboxSrc,
          thumb: data[i].thumb,
          caption: data[i].caption,
          width: (height * data[i].width) / data[i].height,
          height: height,
          left: i === 0 ? 0 : this.getDefault().padding,
          right: i === data.length - 1 ? 0 : this.getDefault().padding
        });
      }
    }

    return row;
  },

  _getTrackGrid(data, width, rowMaxHeight, rowMinHeight, lastRowMaxHeight) {
    // Algorithm for distributing images into rows is split into 1st pass and optional 2nd pass:
    // - 1st pass - we're trying to distribute images into width W:
    //   - take AS FEW of images so that they can be fit into width W while having same height and the height is <= rowMaxHeight
    //     (preserving their aspect ratio)
    //     => how to compute the height of used images while fitting them into width W:
    //       - choose height H0 arbitrarily; scale each of images individually (preserve aspect ratio) such that they all have the height H0
    //       - after scaling, sum up their widths (W0); W0=sum(H0*imageWidth/imageHeight)
    //       - now they all have height H0, their width sum is W0 and we want to fit them into width W, so scale all of them
    //         by W/W0 factor and find out their final height H; H = H0*W/W0 = H0*W/sum(H0*imageWidth/imageHeight) = W/sum(imageWidth/imageHeight)
    //       - and that is what _getRowItems(images, W) does (with addition of handling paddings between images)
    //   - we now have 1 row of images, we want them to be at least rowMinHeight high:
    //     - if they are not and it's just 1 image then let it be that way (its width/height aspect ratio is very big)
    //     - if they are not and it's more images then drop (unprocess) the last added one and recompute height - this will
    //       actually result in used images having height > rowMaxHeight (but that's ok - it's better than having tiny row)
    //   - continue the algorithm from the start using remaining images
    //   - if there're no remaining images and the row has height > rowMaxHeight then continue with 2nd pass; otherwise end (all rows are width-aligned)
    // - 2nd pass tries to distribute images from unaligned/too high last row into previous rows:
    //   1. start from last row, going backwards; images in last row are "extras"
    //   2. move all "extras" onto the end of previous row; this will make the previous row's height smaller
    //   3. if the row height >= rowMinHeight then end (all rows are now width-aligned)
    //   4. otherwise remove as few of images from the start of the row so that the remaining images in the row
    //      compute to height >= rowMinHeight (the row becomes higher by removing images); removed images will become new "extras"
    //   5. repeat from step 2 (if there's still a previous row), otherwise 2nd pass failed and continue with next step
    //   6. use rows as computed by 1st pass (last row height is now > rowMaxHeight)
    //      - if last row height < lastRowMaxHeight then use that height (last row will be width-aligned, though a bit higher than other rows)
    //      - otherwise use rowMaxHeight for the last row (last row won't be width-aligned)
    rowMaxHeight = rowMaxHeight || [160];
    rowMinHeight = rowMinHeight || 100;

    if (!Array.isArray(rowMaxHeight)) {
      rowMaxHeight = [rowMaxHeight];
    }

    let n = 0,
      ln = 0,
      out = [],
      row = [];

    while (n < data.length) {
      let mh = rowMaxHeight[ln % rowMaxHeight.length];
      let slice = false;
      let height = data[n].height;
      let previousHeight = 0;

      for (let i = n; i < data.length; i++) {
        let test = data.slice(n, i + 1);
        previousHeight = height;
        height = this._getRowItems(test, width);
        if (height < mh) {
          if (height < rowMinHeight && i > n) {
            test = data.slice(n, i); //i-1
            n = i;
            height = previousHeight;
          } else {
            n = i + 1;
          }
          row = this._setHeight(test, ln, height, width);
          out.push(row);
          slice = true;
          break;
        }
      }
      ln++;
      if (slice) {
        continue;
      }

      if (height > mh) {
        // last row is not fully aligned (it is too narrow)
        // => perform 2nd pass backwards trying to distribute images from last row
        // to previous ones so that the last row is fully aligned too
        let height1stPass = height;
        let n1stPass = n;
        let out1stPass = [...out];
        let pending = data.slice(n);
        for (let i = out.length - 1; i >= 0 && pending.length > 0; i--) {
          let rowLength = out[i].length;
          n -= rowLength;
          let test = data.slice(n, n + rowLength).concat(pending);
          let height;
          pending = [];
          while ((height = this._getRowItems(test, width)) < rowMinHeight) {
            pending.push(test.shift());
            if (test.length <= 1) break;
          }
          out[i] = this._setHeight(test, i, height, width);
        }
        if (pending.length) {
          // it didn't work out => use the solution with narrow last row but try to widen it
          // yet without crossing lastRowMaxHeight height (and fall back to using narrow last row)
          out = out1stPass;
          let usedLastRowMaxHeight = typeof lastRowMaxHeight !== "number" ? 1.6 * mh : lastRowMaxHeight;
          let lastRow = this._setHeight(
            data.slice(n1stPass),
            ln,
            height1stPass <= usedLastRowMaxHeight ? height1stPass : mh,
            width
          );
          out.push(lastRow);
        }
      } else {
        // last row is fully aligned (sufficiently wide) => just add it
        row = this._setHeight(data.slice(n), ln, height, width);
        out.push(row);
      }
      break;
    }

    return out;
  },

  _getChildrenDefault() {
    return (
      <UU5.Bricks.Row>
        {this.state.imgList.map((photo, i) => {
          let colWidth = this.props.colWidth && this.props.colWidth.trim();
          return (
            <UU5.Bricks.Column colWidth={colWidth} key={i}>
              <Image
                src={photo.lightboxSrc}
                thumb={photo.thumb}
                caption={photo.caption}
                effect={this.props.effect}
                shape={this.props.shape}
                lightbox={this._getLightbox()}
                authenticate={this.props.authenticate}
              />
            </UU5.Bricks.Column>
          );
        })}
      </UU5.Bricks.Row>
    );
  },

  _getChildren() {
    let children;

    switch (this.props.mode) {
      case "track":
        children = this._getChildrenTrack();
        break;
      default:
        children = this._getChildrenDefault();
    }

    return children || null;
  },

  _getChildrenTrack() {
    let width = this.props.rowWidth;
    let rows = this._getTrackGrid(
      this.state.imgList,
      width,
      this.props.rowMaxHeight,
      this.props.rowMinHeight,
      this.props.lastRowMaxHeight
    );
    let result = [];
    for (let i = 0; i < rows.length; i++) {
      for (let j = 0; j < rows[i].length; j++) {
        let photo = rows[i][j];
        result.push(
          <UU5.Bricks.Div
            key={i + "-" + j}
            className={this.getClassName("mode") + this.props.mode}
            style={{
              width: photo.width,
              height: photo.height,
              marginTop: i ? this.getDefault().padding : 0,
              marginBottom: i === rows.length - 1 ? 0 : this.getDefault().padding,
              marginLeft: photo.left,
              marginRight: photo.right
            }}
          >
            <Image
              thumb={photo.thumb}
              src={photo.lightboxSrc}
              caption={photo.caption}
              effect={this.props.effect}
              lightbox={this._getLightbox()}
              height={photo.height}
              authenticate={this.props.authenticate}
            />
          </UU5.Bricks.Div>
        );
      }
    }

    return result;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this._getChildren();
  }
  //@@viewOff:render
});

export default ThumbnailListBody;
