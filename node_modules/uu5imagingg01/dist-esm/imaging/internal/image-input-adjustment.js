import * as UU5 from "uu5g04";
import "uu5g04-bricks";

import "./image-input-adjustment.less";

import Input from "./image-input.js";
import ImageInputItem from "./image-input-item.js";
import Adjustment from "../adjustment";
import Cfg from "../../config/config.js";

export const ImageInputAdjustment = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ImageInputAdjustment",
    classNames: {
      main: Cfg.CSS + "image-input-adjustment",
      wrapper: Cfg.CSS + "image-input-wrapper",
      line: Cfg.CSS + "image-input-message-line",
      lineFeedback: Cfg.CSS + "image-input-message-line-feedback-"
    },
    errors: {
      errorAdjusting:
        "Error while adjusting the image - check the adjustment settings and that the image file is not corrupted. Nested error: %s"
    },
    lsi: {
      imageError: {
        cs: "Obrázek {0} není podporován nebo je poškozen.",
        en: "The image {0} is not supported or it is damaged.",
        sk: "Obrázok {0} nie je podporovaný alebo je poškodený."
      }
    },
    opt: {
      pureRender: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: UU5.PropTypes.arrayOf(UU5.PropTypes.object),
    onChange: UU5.PropTypes.func,
    inputProps: UU5.PropTypes.object,
    lineProps: UU5.PropTypes.object,
    onRemove: UU5.PropTypes.func,
    onLoad: UU5.PropTypes.func,
    width: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    height: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    type: UU5.PropTypes.string,
    rotation: UU5.PropTypes.oneOfType([UU5.PropTypes.oneOf(["auto"]), UU5.PropTypes.number]),
    quality: UU5.PropTypes.number,
    previewWidth: UU5.PropTypes.number,
    previewHeight: UU5.PropTypes.number,
    previewShape: UU5.PropTypes.string,
    cumulativeOnChange: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      value: null,
      onChange: null,
      inputProps: null,
      lineProps: null,
      onRemove: null,
      onLoad: null,
      width: null,
      height: null,
      type: null,
      rotation: null,
      quality: null,
      previewWidth: null,
      previewHeight: null,
      previewShape: null,
      cumulativeOnChange: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentDidMount() {
    if (this.props.value) this._readjustImages(this.props.value, this.props);
  },

  componentWillReceiveProps(nextProps) {
    let needsFullReadjustment =
      nextProps.rotation != this.props.rotation ||
      nextProps.type != this.props.type ||
      nextProps.quality != this.props.quality ||
      nextProps.width != this.props.width ||
      nextProps.height != this.props.height;
    let valueHasNewItems = this._hasValueNewItems(nextProps.value, this.props.value);
    if ((needsFullReadjustment || valueHasNewItems) && nextProps.value && typeof nextProps.onChange === "function") {
      this._readjustImages(nextProps.value, nextProps, needsFullReadjustment);
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _hasValueNewItems(value, oldValue) {
    let result = false;
    if (value) {
      let existingMap = {};
      if (oldValue) oldValue.forEach(item => (existingMap[item.id] = item));
      for (let k in value) {
        if (!(k in existingMap)) {
          result = true;
          break;
        }
      }
    }
    return result;
  },

  async _readjustImages(imageItems, props, processAllItems) {
    let { cumulativeOnChange } = props;
    let cumulatedOnChangeData;

    let promises = imageItems.map(imageItem => {
      let value = imageItem.originalValue || imageItem.value;
      if (
        value instanceof Blob &&
        (processAllItems || ((imageItem.originalValue == null || imageItem.value == null) && !imageItem.error))
      ) {
        return this._adjustImage(value, props)
          .catch(error => {
            if (this.isRendered()) {
              this.showError("errorAdjusting", [error]);
            }
          })
          .then(imageData => {
            if (this.isRendered() && typeof props.onChange === "function") {
              let item;
              if (imageData) {
                let { imageFile, imageSrc } = imageData;
                item = {
                  id: imageItem.id,
                  value: imageFile,
                  originalValue: imageItem.originalValue || imageItem.value,
                  src: imageSrc,
                  name: imageFile.name
                };
              } else {
                item = {
                  id: imageItem.id,
                  value: null,
                  originalValue: imageItem.originalValue || imageItem.value,
                  src: null,
                  error: this.getLsi("imageError"),
                  name: imageItem.name || (imageItem.value || {}).name || (imageItem.originalValue || {}).name
                };
              }
              let optData = { [item.id]: item };
              if (!cumulativeOnChange) {
                let opt = { component: this, data: optData };
                props.onChange(opt);
              } else {
                cumulatedOnChangeData = { ...cumulatedOnChangeData, ...optData };
              }
            }
          });
      }
    });
    await Promise.all(promises.filter(Boolean));

    if (cumulativeOnChange && this.isRendered() && typeof props.onChange === "function") {
      let opt = { component: this, data: cumulatedOnChangeData };
      props.onChange(opt);
    }
  },

  _onChange(newFiles) {
    if (typeof this.props.onChange === "function") {
      this._readjustImages(newFiles, this.props);
    }
  },

  _adjustImage(file, props) {
    let resultImage = Promise.resolve({ imageSrc: URL.createObjectURL(file), imageFile: file });

    if (props.rotation) {
      resultImage = resultImage.then(({ imageFile, imageSrc }) => {
        URL.revokeObjectURL(imageSrc);
        return Adjustment.rotate(imageFile, props.rotation, file);
      });
    }

    if (props.width || props.height) {
      resultImage = resultImage.then(({ imageFile, imageSrc }) => {
        URL.revokeObjectURL(imageSrc);
        return Adjustment.resize(imageFile, props.width, props.height);
      });
    }

    if (props.type) {
      resultImage = resultImage.then(({ imageFile, imageSrc }) => {
        URL.revokeObjectURL(imageSrc);
        return Adjustment.changeType(imageFile, props.type, props.quality);
      });
    }

    return resultImage;
  },

  _getLine() {
    let className = this.getClassName("line");
    className += " " + this.getClassName("lineFeedback") + this.props.lineProps.feedback;
    return <UU5.Bricks.Line key="line" {...{ className }} />;
  },

  _getImages() {
    return this.props.value
      ? this.props.value.map(image => {
          if (!image.id) image.id = UU5.Common.Tools.generateUUID();
          return (
            <ImageInputItem
              key={image.id}
              error={image.error}
              readOnly={(this.props.inputProps || {}).readOnly || (this.props.inputProps || {}).disabled}
              progress={image.progress}
              imageId={image.id}
              imageSrc={image.src || image.uri}
              imageName={image.name || (image.value || {}).name || (image.originalValue || {}).name}
              onRemove={this.props.onRemove}
              previewWidth={this.props.previewWidth}
              previewHeight={this.props.previewHeight}
              previewShape={this.props.previewShape}
            />
          );
        })
      : null;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return [
      this.props.inputProps.display ? <Input key="input" {...this.props.inputProps} onChange={this._onChange} /> : null,
      this.props.value ? (
        <div key="images" className={this.getClassName("wrapper")}>
          {this._getImages()}
        </div>
      ) : null,
      this.props.lineProps.display ? this._getLine() : null
    ];
  }
  //@@viewOn:render
});

export default ImageInputAdjustment;
