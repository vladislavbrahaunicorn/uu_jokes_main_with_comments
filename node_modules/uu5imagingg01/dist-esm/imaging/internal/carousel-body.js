import UU5 from "uu5g04";
import Cfg from "../../config/config.js";
import Tools, { REGEXP } from "./tools.js";
import CarouselItem from "./carousel-item.js";
import CarouselContext from "./carousel-context.js";
import memoize from "memoize-one";

const carouselProps = {
  hideControls: true,
  hideIndicators: true,
  activeIndex: true,
  nextIcon: true,
  prevIcon: true,
  displayedItems: true,
  type: true,
  interval: true,
  stepByOne: true,
  ref_: true
};

export const CarouselBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "CarouselBody",
    classNames: {
      main: props =>
        Cfg.CSS +
        "carousel-body " +
        UU5.Common.Css.css`
        && {
          text-align: center;
          width: ${UU5.Common.Tools.fillUnit(props.width)};
        }
    `,
      carouselItem: props => UU5.Common.Css.css`
      display: flex;
      align-items: center;
      justify-content: center;
      height: ${UU5.Common.Tools.fillUnit(props.height)};
    `,
      image: props => UU5.Common.Css.css`
        && {
          & > .uu5-bricks-link {
            display: inline-block;
          }

          img.uu5-bricks-image {
            height: ${UU5.Common.Tools.fillUnit(props.height)};
            width: auto;
            max-width: 100%;
            object-fit: contain;
          }
        }

      `
    },
    opt: {
      hoc: true
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired,
          thumb: UU5.PropTypes.string
        })
      ])
    ).isRequired,
    thumbSuffix: UU5.PropTypes.string,
    authenticate: UU5.PropTypes.bool,
    session: UU5.PropTypes.object,
    width: UU5.PropTypes.number,
    height: UU5.PropTypes.number,
    hideControls: UU5.PropTypes.bool,
    hideIndicators: UU5.PropTypes.bool,
    activeIndex: UU5.PropTypes.number,
    nextIcon: UU5.PropTypes.string,
    prevIcon: UU5.PropTypes.string,
    displayedItems: UU5.PropTypes.number,
    type: UU5.PropTypes.oneOf(["circular", "final", "rewind"]),
    interval: UU5.PropTypes.number,
    stepByOne: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      thumbSuffix: "_th",
      session: undefined,
      authenticate: false,
      width: null,
      height: 500,
      hideControls: false,
      hideIndicators: false,
      activeIndex: 0,
      nextIcon: "mdi-chevron-right",
      prevIcon: "mdi-chevron-left",
      displayedItems: 1,
      type: "final",
      interval: 5000,
      stepByOne: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    this._renderImages = memoize(this._renderImages);

    return {
      imgList: [],
      activeIndex: this.props.activeIndex
    };
  },

  componentDidMount() {
    this._loadedIndexes = [];
    // make sure to always render the same instance of children. This is needed due to UU5.Bricks.Carousel
    // having a componentDidUpdate logic which, when receivening any new props (prevProps !== this.props),
    // re-renders the component without triggering the transition animations.
    this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (
      !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data) ||
      nextProps.activeIndex !== this.props.activeIndex ||
      nextProps.displayedItems !== this.props.displayedItems ||
      nextProps.stepByOne !== this.props.stepByOne ||
      nextProps.type !== this.props.type
    ) {
      this._loadedIndexes = [];
      if (nextProps.data.length) {
        this._loadImages(nextProps);
      } else {
        this.setState({ imgList: [] });
      }
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  async _loadImages(props = this.props, activeIndex, setStateCallback) {
    if (this._loadedIndexes.length < props.data.length) {
      // else all images have already been loaded and cached
      activeIndex = typeof activeIndex === "number" ? activeIndex : props.activeIndex;

      if (!props.stepByOne) {
        activeIndex = activeIndex * props.displayedItems;
      }

      this._dataChangeId = Math.random();
      let imgList = props.data.map(() => null);
      let dataChangeId = this._dataChangeId;
      let preloadNumber = props.displayedItems === 1 || props.stepByOne ? 1 : props.displayedItems;

      // load previous items
      [...new Array(preloadNumber)].reverse().forEach((_, index) => {
        let newIndex = activeIndex - (index + 1);

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // load visible items
      [...new Array(props.displayedItems)].forEach((_, index) => {
        let newIndex = activeIndex + index;

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // load next items
      [...new Array(preloadNumber)].forEach((_, index) => {
        let newIndex = activeIndex + props.displayedItems - 1 + (index + 1);

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // adjust items (over the limit or below)
      this._loadedIndexes.forEach((index, i) => {
        let isBelow = index < 0;
        let isAbove = index > imgList.length - 1;

        if (props.type === "final" && (isBelow || isAbove)) {
          this._loadedIndexes[i] = null;
        } else {
          if (isBelow) {
            this._loadedIndexes[i] = imgList.length + index;
          } else if (isAbove) {
            this._loadedIndexes[i] = index - imgList.length;
          }
        }
      });

      if (props.type !== "circular" && activeIndex + preloadNumber > imgList.length) {
        [...new Array(imgList.length - activeIndex + preloadNumber)].forEach((_, index) => {
          let newIndex = activeIndex - (index + 1);

          if (this._loadedIndexes.indexOf(newIndex) === -1) {
            this._loadedIndexes.push(newIndex);
          }
        });
      }

      this._loadedIndexes = this._loadedIndexes.filter(index => index !== null);

      for (let i = 0; i < this._loadedIndexes.length; i++) {
        let imageIndex = this._loadedIndexes[i];

        if (typeof imageIndex === "number") {
          const image = await this._loadImage(props.data[imageIndex], props.authenticate, props.session);

          if (dataChangeId !== this._dataChangeId) return;

          if (image) {
            imgList[imageIndex] = image;
          }
        }
      }

      let newState = { imgList };

      if (typeof activeIndex === "number") {
        newState.activeIndex = activeIndex;
      }

      this.setAsyncState(newState, setStateCallback);
    }
  },

  _loadImage(imageData, authenticate, session) {
    if (typeof imageData === "string") {
      imageData = { src: imageData };
    }

    let thumbUrl = imageData.thumb || this._getThumbnail(imageData.src);
    let cacheMatch = this.constructor.imageCache[thumbUrl];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(thumbUrl)) {
          let token = session.getCallToken().token;
          result = new Promise(resolve => {
            let result = { ...imageData };
            Tools.fetchAuthenticatedImage(thumbUrl, token).then(
              data => {
                result.thumb = URL.createObjectURL(data.data);
                resolve(this._getImageData(result, thumbUrl));
              },
              err => {
                result.thumb = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                resolve(this._getImageData(result, thumbUrl));
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(imageData, thumbUrl);
    }

    return result;
  },

  _getImageData(imageData, cacheKey) {
    return new Promise(resolve => {
      let lightboxSrc;
      let thumb;

      if (imageData && typeof imageData === "object") {
        lightboxSrc = imageData.src;
        thumb = imageData.thumb || imageData.lightboxSrc;
      } else {
        lightboxSrc = imageData;
      }

      thumb = thumb || this._getThumbnail(lightboxSrc);

      let img = new window.Image();
      let loadingThumbnail = true;

      img.onload = () => {
        let imgObj = {
          lightboxSrc,
          thumb: loadingThumbnail ? thumb : lightboxSrc,
          width: img.width,
          height: img.height
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        if (loadingThumbnail) {
          loadingThumbnail = false;
          img.src = lightboxSrc;
          return;
        }

        resolve(null);
      };

      img.src = thumb;
    });
  },

  _getThumbnail(name) {
    let thumbnail;
    let dotIndex = name.lastIndexOf(".");

    if (dotIndex !== -1) {
      let fileName = name.substr(0, dotIndex);
      let fileExtension = name.substr(dotIndex + 1);
      if (REGEXP.fileExtension.test(fileExtension)) {
        thumbnail = fileName + this.props.thumbSuffix + "." + fileExtension;
      }
    }

    if (!thumbnail) {
      thumbnail = name + this.props.thumbSuffix;
    }

    return thumbnail;
  },

  _onIndexChange({ activeIndex }) {
    this._loadImages(this.props, activeIndex);
  },

  _getItemData(itemId) {
    let data = this.state.imgList[itemId];

    if (data) {
      return {
        src: data.lightboxSrc,
        thumb: data.thumb,
        caption: data.caption,
        lightbox: false,
        authenticate: this.props.authenticate,
        width: "auto",
        height: "auto",
        className: this.getClassName("image")
      };
    } else {
      return null;
    }
  },

  _renderImages(imgListLength) {
    return [...new Array(imgListLength)].map((_, index) => (
      <UU5.Bricks.Carousel.Item key={index} className={this.getClassName("carouselItem")}>
        <CarouselItem id={index + ""} />
      </UU5.Bricks.Carousel.Item>
    ));
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let props = {};

    for (let propKey in carouselProps) {
      props[propKey] = this.props[propKey];
    }

    return (
      <CarouselContext.Provider value={{ getImageProps: this._getItemData }}>
        <UU5.Bricks.Carousel
          {...this.getMainPropsToPass()}
          {...props}
          displayedItems={props.displayedItems || 1}
          onIndexChange={this._onIndexChange}
        >
          {this._renderImages(this.state.imgList.length)}
        </UU5.Bricks.Carousel>
      </CarouselContext.Provider>
    );
  }
  //@@viewOff:render
});

export default CarouselBody;
