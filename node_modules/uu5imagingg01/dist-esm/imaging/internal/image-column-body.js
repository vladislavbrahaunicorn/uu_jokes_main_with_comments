import UU5 from "uu5g04";
import Cfg from "../../config/config.js";
import Image from "../image.js";
import Tools, { REGEXP } from "./tools.js";

function getImageWrapperClassName({ width, height }) {
  return UU5.Common.Css.css(`
    && {
      width: ${width}px;
      height: ${height}px;
    }
  `);
}

export const ImageColumnBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ImageColumnBody",
    classNames: {
      main: Cfg.CSS + "image-column-body",
      imageWrapper: () =>
        UU5.Common.Css.css(`
        & + & {
          margin-top: 4px;
        }
      `)
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired,
          thumb: UU5.PropTypes.string
        })
      ])
    ).isRequired,
    effect: UU5.PropTypes.string,
    thumbSuffix: UU5.PropTypes.string,
    lightbox: UU5.PropTypes.oneOf(["local", "global", "none"]),
    authenticate: UU5.PropTypes.bool,
    minWidth: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    maxWidth: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    alignment: UU5.PropTypes.string,
    session: UU5.PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      effect: undefined,
      thumbSuffix: "_th",
      lightbox: "local",
      minWidth: 100,
      maxWidth: 160,
      height: null,
      alignment: "block",
      session: undefined,
      authenticate: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      imgList: []
    };
  },

  componentDidMount() {
    this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled && !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data)) {
      if (nextProps.data.length) {
        this._loadImages(nextProps);
      } else {
        this.setState({ imgList: [] });
      }
    } else if (
      this.props.height !== nextProps.height ||
      this.props.minWidth !== nextProps.minWidth ||
      this.props.maxWidth !== nextProps.maxWidth
    ) {
      // TODO FIX: if this gets called too quickly after the initial render, the images will probably be loaded again (if authenticated, a request will be sent twice)
      this._loadImages(nextProps);
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getColItems(data, width, aHeight) {
    let row = [];
    let height = aHeight;
    if (data.length === 1) {
      row.push({
        lightboxSrc: data[0].lightboxSrc,
        thumb: data[0].thumb,
        caption: data[0].caption,
        height: Math.min(height, (width * data[0].height) / data[0].width),
        width,
        column: 0
      });
    } else {
      for (let i = 0; i < data.length; i++) {
        row.push({
          column: i,
          lightboxSrc: data[i].lightboxSrc,
          thumb: data[i].thumb,
          caption: data[i].caption,
          height: (width * data[i].height) / data[i].width,
          width,
          left: i === 0 ? 0 : 2,
          right: i === data.length - 1 ? 0 : 2
        });
      }
    }

    return row;
  },

  _getWidth(data, height) {
    let separator = 2 * 2;
    height = height - (data.length - 1) * separator;
    let width = data.reduce((sum, x) => {
      return sum + (x.height * 1.0) / x.width;
    }, 0);
    return height / width;
  },

  _getColImages(imgList, height, rowMaxWidth, rowMinWidth) {
    rowMaxWidth = rowMaxWidth || 160;
    rowMinWidth = rowMinWidth || 100;

    let rowItemsData = [[]];

    if (height) {
      let imgIndex = 0;
      for (let adjustedImgIndex = imgIndex; adjustedImgIndex < imgList.length; adjustedImgIndex++) {
        let testImgList = imgList.slice(0, adjustedImgIndex + 1);
        let width = this._getWidth(testImgList, height);
        if (width <= rowMaxWidth) {
          if (width < rowMinWidth && adjustedImgIndex > imgIndex) {
            break;
          }

          rowItemsData = [testImgList, width, height];
        } else {
          width = Math.min(width, rowMaxWidth);
          rowItemsData = [testImgList, width, height];
        }
      }
    } else {
      rowItemsData = [imgList, rowMaxWidth, Infinity];
    }

    return this._getColItems(...rowItemsData);
  },

  async _loadImages(props = this.props) {
    this._dataChangeId = Math.random();
    let imgList = [];
    let dataChangeId = this._dataChangeId;

    for (let i = 0; i < props.data.length; i++) {
      const image = await this._loadImage(props.data[i], props.authenticate, props.session);

      if (dataChangeId !== this._dataChangeId) return;

      if (image) {
        let newImgList = this._getColImages([...imgList, image], props.height, props.maxWidth, props.minWidth);
        if (newImgList.length === imgList.length) {
          break;
        } else {
          imgList = newImgList;
        }
      }
    }

    this.setAsyncState({ imgList });
  },

  _loadImage(imageData, authenticate, session) {
    if (typeof imageData === "string") {
      imageData = { src: imageData };
    }

    let thumbUrl = imageData.thumb || this._getThumbnail(imageData.src);
    let cacheMatch = this.constructor.imageCache[thumbUrl];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(thumbUrl)) {
          let token = session.getCallToken().token;
          result = new Promise(resolve => {
            let result = { ...imageData };
            Tools.fetchAuthenticatedImage(thumbUrl, token).then(
              data => {
                result.thumb = URL.createObjectURL(data.data);
                resolve(this._getImageData(result, thumbUrl));
              },
              err => {
                result.thumb = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                resolve(this._getImageData(result, thumbUrl));
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(imageData, thumbUrl);
    }

    return result;
  },

  _getImageData(imageData, cacheKey) {
    return new Promise(resolve => {
      let lightboxSrc;
      let thumb;

      if (imageData && typeof imageData === "object") {
        lightboxSrc = imageData.src;
        thumb = imageData.thumb || imageData.lightboxSrc;
      } else {
        lightboxSrc = imageData;
      }

      thumb = thumb || this._getThumbnail(lightboxSrc);

      let img = new window.Image();
      let loadingThumbnail = true;

      img.onload = () => {
        let imgObj = {
          lightboxSrc,
          thumb: loadingThumbnail ? thumb : lightboxSrc,
          width: img.width,
          height: img.height
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        if (loadingThumbnail) {
          loadingThumbnail = false;
          img.src = lightboxSrc;
          return;
        }

        resolve(null);
      };

      img.src = thumb;
    });
  },

  _getThumbnail(name) {
    let thumbnail;
    let dotIndex = name.lastIndexOf(".");

    if (dotIndex !== -1) {
      let fileName = name.substr(0, dotIndex);
      let fileExtension = name.substr(dotIndex + 1);
      if (REGEXP.fileExtension.test(fileExtension)) {
        thumbnail = fileName + this.props.thumbSuffix + "." + fileExtension;
      }
    }

    if (!thumbnail) {
      thumbnail = name + this.props.thumbSuffix;
    }

    return thumbnail;
  },

  _getLightbox() {
    if (this.props.lightbox === "global") {
      return null;
    } else if (this.props.lightbox === "none") {
      return false;
    } else {
      // this.props.lightbox === "local"
      return this.getId();
    }
  },

  _renderImages() {
    return this.state.imgList.map((image, index) => (
      <Image
        key={index}
        src={image.lightboxSrc}
        thumb={image.thumb}
        caption={image.caption}
        effect={this.props.effect}
        shape={this.props.shape}
        lightbox={this._getLightbox()}
        className={`${getImageWrapperClassName(image)} ${this.getClassName("imageWrapper")}`}
        authenticate={this.props.authenticate}
        // width={image.width}
        // height={image.height}
      />
    ));
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this._renderImages();
  }
  //@@viewOff:render
});

export default ImageColumnBody;
