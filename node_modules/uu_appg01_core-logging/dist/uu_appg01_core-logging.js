/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core-utils"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core-logging", ["module", "uu_appg01_core-utils"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core-logging"] = factory(require("module"), require("uu_appg01_core-utils"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["Logging"] = factory(root["undefined"], root["UuApp.Utils"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/4.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/4.7.2/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Logger = __webpack_require__(4);

var LoggerFactory = __webpack_require__(10);

var LogLevel = __webpack_require__(5);

var MessageFormatter = __webpack_require__(6);

var LoggerMDC = __webpack_require__(8);

module.exports = {
  Logger: Logger,
  LoggerFactory: LoggerFactory,
  LogLevel: LogLevel,
  MessageFormatter: MessageFormatter,
  LoggerMDC: LoggerMDC
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LogLevel = __webpack_require__(5);

var MessageFormatter = __webpack_require__(6);

var _require = __webpack_require__(7),
    BaseError = _require.BaseError;
/**
 * @class UuApp.Logging.Logger
 * @classdesc
 * Component for logging. Each logged message has a severity level and each logger can be
 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
 *
 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
 * are typically removed from production code), statements using Logger-s are intended to be
 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
 * configuration.
 *
 * **Configuration**
 *
 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
 * Supported environment options:
 *
 *     {
 *       "log_level": "ERROR",
 *       "My.Namespace.log_level": "WARN"
 *     }
 *
 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
 *
 * **Typical usage**
 *
 *     // get logger instance and log a message
 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
 *
 *     // if logging requires lenghty computation, it can be made conditional so that it
 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
 *     if (logger.isDebugLoggable()) {
 *       var computedValue = ...; // some lenghty computation
 *       logger.debug("Value computed to", computedValue);
 *     }
 *
 */


var Logger = /*#__PURE__*/function () {
  function Logger(name) {
    _classCallCheck(this, Logger);

    this._name = name;
    this._level = LogLevel.WARN;
    this._formatter = new MessageFormatter();
    this._outputter = console;
  }

  _createClass(Logger, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * Sets severity level of this Logger to given value. Messages with lower (less important)
     * severity will be ignored when attempted to be logged via this logger. Order of importance:
     * DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN < OFF.
     *
     * **It's strongly advised not to configure loggers directly using this method** because
     * if such code gets deployed to production, it'll effectively override settings from
     * environment and therefore could prevent logging of necessary information.
     * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
     *
     * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
     *   is given, default is used (LEVEL_WARN).
     * @method UuApp.Logging.Logger#setLevel
     */

  }, {
    key: "setLevel",
    value: function setLevel(level) {
      if (typeof level === "number") {
        this._level = level;
      } else if (typeof level === "string") {
        var lvl = LogLevel[level.toUpperCase()] !== undefined ? LogLevel[level.toUpperCase()] : Number(level);

        if (lvl !== undefined && !isNaN(lvl)) {
          this._level = lvl;
        }
      } else if (!level) {
        this._level = LogLevel.WARN;
      } else {
        throw new BaseError("Invalid logger level \"".concat(level, "\""));
      }
    }
    /**
     * @return {number} Level of this logger.
     * @method UuApp.Logging.Logger#getLevel
     */

  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._level;
    }
  }, {
    key: "setSeverityLabels",
    value: function setSeverityLabels(severityLabels) {
      this._formatter.setSeverityLabels(severityLabels);
    }
  }, {
    key: "getSeverityLabels",
    value: function getSeverityLabels() {
      return this._formatter.getSeverityLabels();
    }
  }, {
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      this._formatter.setMessageFormat(messageFormat);
    }
  }, {
    key: "getMessageFormat",
    value: function getMessageFormat() {
      return this._formatter.getMessageFormat();
    }
  }, {
    key: "setErrorFormat",
    value: function setErrorFormat(errorFormat) {
      this._formatter.setErrorFormat(errorFormat);
    }
  }, {
    key: "getErrorFormat",
    value: function getErrorFormat() {
      return this._formatter.getErrorFormat();
    }
  }, {
    key: "setCauseFormat",
    value: function setCauseFormat(causeFormat) {
      this._formatter.setCauseFormat(causeFormat);
    }
  }, {
    key: "getCauseFormat",
    value: function getCauseFormat() {
      return this._formatter.getCauseFormat();
    }
    /**
     * @return {boolean} Whether this logger logs message with severity level "DEBUG".
     * @method UuApp.Logging.Logger#isDebugLoggable
     */

  }, {
    key: "isDebugLoggable",
    value: function isDebugLoggable() {
      return this._level <= LogLevel.DEBUG;
    }
    /**
     * Logs message with severity level "DEBUG".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#debug
     */

  }, {
    key: "debug",
    value: function debug(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.DEBUG, message, error);
    }
    /**
     * @return {boolean} Whether this logger logs message with severity level "INFO".
     * @method UuApp.Logging.Logger#isInfoLoggable
     */

  }, {
    key: "isInfoLoggable",
    value: function isInfoLoggable() {
      return this._level <= LogLevel.INFO;
    }
    /**
     * Logs message with severity level "INFO".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#info
     */

  }, {
    key: "info",
    value: function info(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.INFO, message, error);
    }
    /**
     * @return {boolean} Whether this logger logs message with severity level "WARN".
     * @method UuApp.Logging.Logger#isWarnLoggable
     */

  }, {
    key: "isWarnLoggable",
    value: function isWarnLoggable() {
      return this._level <= LogLevel.WARN;
    }
    /**
     * Logs message with severity level "WARN".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#warn
     */

  }, {
    key: "warn",
    value: function warn(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.WARN, message, error);
    }
    /**
     * @return {boolean} Whether this logger logs message with severity level "ERROR".
     * @method UuApp.Logging.Logger#isErrorLoggable
     */

  }, {
    key: "isErrorLoggable",
    value: function isErrorLoggable() {
      return this._level <= LogLevel.ERROR;
    }
    /**
     * Logs message with severity level "ERROR".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */

  }, {
    key: "error",
    value: function error(message) {
      var _error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.ERROR, message, _error);
    }
    /**
     * @return {boolean} Whether this logger logs message with severity level "FATAL".
     * @method UuApp.Logging.Logger#isFatalLoggable
     */

  }, {
    key: "isFatalLoggable",
    value: function isFatalLoggable() {
      return this._level <= LogLevel.FATAL;
    }
    /**
     * Logs message with severity level "FATAL".
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */

  }, {
    key: "fatal",
    value: function fatal(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.FATAL, message, error);
    }
    /**
     * Logs message with "UNKNOWN" severity.
     *
     * @param {string} message The message to log.
     * @param {Error} error Error to be logged with message.
     * @method UuApp.Logging.Logger#error
     */

  }, {
    key: "log",
    value: function log(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._add(LogLevel.UNKNOWN, message, error);
    } // ======================== Private methods ================================

  }, {
    key: "_add",
    value: function _add(level, message, error) {
      if (this._level <= level) {
        this._write(new Date(), level, message, error);
      }
    }
  }, {
    key: "_write",
    value: function () {
      var _write2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(datetime, level, message, error) {
        var formattedMessage;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                formattedMessage = this._formatter.formatMessage(datetime, this._name, level, message, error); // TODO Add support for outputters. Currently we'll log only to the console.

                if (!(typeof window !== "undefined")) {
                  _context.next = 16;
                  break;
                }

                _context.t0 = level;
                _context.next = _context.t0 === LogLevel.FATAL ? 5 : _context.t0 === LogLevel.ERROR ? 5 : _context.t0 === LogLevel.WARN ? 7 : _context.t0 === LogLevel.INFO ? 9 : _context.t0 === LogLevel.UNKNOWN ? 9 : _context.t0 === LogLevel.DEBUG ? 11 : 13;
                break;

              case 5:
                this._outputter.error(formattedMessage);

                return _context.abrupt("break", 14);

              case 7:
                this._outputter.warn(formattedMessage);

                return _context.abrupt("break", 14);

              case 9:
                this._outputter.info(formattedMessage);

                return _context.abrupt("break", 14);

              case 11:
                this._outputter.debug(formattedMessage);

                return _context.abrupt("break", 14);

              case 13:
                this._outputter.log(formattedMessage);

              case 14:
                _context.next = 17;
                break;

              case 16:
                this._outputter.log(formattedMessage);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _write(_x, _x2, _x3, _x4) {
        return _write2.apply(this, arguments);
      }

      return _write;
    }()
  }]);

  return Logger;
}();

module.exports = Logger;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4,
  UNKNOWN: 5,
  OFF: 6
};
module.exports = LogLevel;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LogLevel = __webpack_require__(5);

var _require = __webpack_require__(7),
    BaseError = _require.BaseError;

var LoggerMDC = __webpack_require__(8); // Regexp to match formatting tags.
// @private


var FORMAT_TAGS = /(%(?:{([^}]*)})?([a-zA-Z%]))/g; // Default set of severity labels (matching standard ruby
//    {http://ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Severity.html
// Logger::Severity} with addition of level +OFF+).

var DEFAULT_SEVERITY_LABELS = "DEBUG INFO WARN ERROR FATAL ANY OFF"; //  Format of message to be used. Following tags are supported:
// <b>%%</b> - Escaped percent tag.
// * <b>%C</b> - Full {UuApp::Logging::LoggerMdc logger MDC} in JSON format.
// * <b>%d</b> - Date and time in format matching {#datetime_format}.
// * <b>%e</b> - Error formatted using {#error_format} or empty string if there is no error.
// * <b>%m</b> - Actual log message provided by application.
// * <b>%n</b> - Logger name.
// * <b>%p</b> - System process ID.
// * <b>%s</b> - Logging event severity.
// * <b>%t</b> - ID of thread where message was captured.
// * <b>%T</b> - Name of thread where message was captured.
// * <b>%{ KEY }C</b> - Custom attribute from logger {UuApp::Logging::LoggerMdc logger MDC} with name KEY.
//      Time values are printed in format matching {#datetime_format}.
// * <b>%{ FMT }d</b> - Date and time in format matching FMT.
// * <b>%{ FMT }m</b> - Log message provided by application with additional escaping based on FMT value. There are
//      two escaping variants. First is keyword +JSON+ resulting in message with escaped quotes and line separators.
//      In case of any other value, this value will be used to replace new line separators (CR(LF)).
//  * <b>%{ NUM }s</b> - Logging event severity with NUM representing total length of severity with padding.*/
// Default message format (see {#message_format} for tag description).

var DEFAULT_MESSAGE_FORMAT = "[%d] %{5}s %n: %m%e"; // Format of error. In case there is instance of error to be logged (given as explicit logger parameter or implicit
// error reference available inside rescue block), error message is injected into message replacing +%e+ tag. That
// means error format should start with some separator (e.g. new line) to be able to distinguish text of log message
// from printed error. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%b</b> - Invocation stack (backtrace), lines are joined with new line.
// * <b>%c</b> - Error class name.
// * <b>%C</b> - Error cause formatted using {#cause_format} or {#error_format}, or empty string if there is no cause.
// * <b>%i</b> - Unique error ID.
// * <b>%m</b> - Actual error message.
// * <b>%t</b> - Timestamp of error instantiation in format matching {#datetime_format}.
// * <b>%{ SEP }b</b> - Invocation stack (backtrace), lines are joined with SEP.
// * <b>%{ PFX }C</b> - Error cause with prefix PFX to be used before printing error cause).
// * <b>%{ FMT }m</b> - Error message with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped quotes and line separators. In case of any other value,
//   this value will be used to replace new line separators (CR(LF)).
// * <b>%{ FMT }t</b> - Timestamp of error instantiation in format matching FMT.
// # Default message format (see {#error_format} for tag description).

var DEFAULT_ERROR_FORMAT = "\n  %i [%t] %c: %m\n    %{\n    }b%{\n  Caused by:}C"; //# Default log messages separator.
//# @private

var ENTRY_SEPARATOR = "\n";

var MessageFormatter = /*#__PURE__*/function () {
  function MessageFormatter() {
    var messageFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var errorFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var severityLabels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, MessageFormatter);

    this.setSeverityLabels(severityLabels || DEFAULT_SEVERITY_LABELS);
    this.setMessageFormat(messageFormat || DEFAULT_MESSAGE_FORMAT);
    this.setErrorFormat(errorFormat || DEFAULT_ERROR_FORMAT);
  }

  _createClass(MessageFormatter, [{
    key: "setSeverityLabels",
    value: function setSeverityLabels(severityLabels) {
      if (severityLabels) {
        this._severityLabels = severityLabels.split(" ");
      }
    }
  }, {
    key: "getSeverityLabels",
    value: function getSeverityLabels() {
      return this._severityLabels.join(" ");
    }
  }, {
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      if (messageFormat) {
        this._messageFormat = messageFormat;
        var formatterSrc = "(function (datetime, name, severity, message, error) {\n        return ".concat(this._transformFormat(messageFormat, this._processMessageFormatTag), ";\n      }).bind(this);");
        this._messageFormatter = eval(formatterSrc);
      }
    }
  }, {
    key: "getMessageFormat",
    value: function getMessageFormat() {
      return this._messageFormat;
    }
  }, {
    key: "setErrorFormat",
    value: function setErrorFormat(errorFormat) {
      if (errorFormat) {
        this._errorFormat = errorFormat;
        var formatterSrc = "(function (error) {\n        return ".concat(this._transformFormat(errorFormat, this._processErrorFormatTag), ";\n      }).bind(this);");
        this._errorFormatter = eval(formatterSrc);
      }
    }
  }, {
    key: "getErrorFormat",
    value: function getErrorFormat() {
      return this._errorFormat;
    }
  }, {
    key: "setCauseFormat",
    value: function setCauseFormat(causeFormat) {
      if (causeFormat) {
        this._causeFormat = causeFormat;
        var formatterSrc = "(function (error) {\n        return ".concat(this._transformFormat(causeFormat, this._processErrorFormatTag), ";\n      }).bind(this);");
        this._causeFormatter = eval(formatterSrc);
      } else {
        this._causeFormat = null;
        this._causeFormatter = null;
      }
    }
  }, {
    key: "getCauseFormat",
    value: function getCauseFormat() {
      return this._causeFormat;
    }
  }, {
    key: "formatMessage",
    value: function formatMessage(datetime, name, severity, message) {
      var error = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      if (!datetime) {
        datetime = new Date();
      }

      if (!name) {
        name = "";
      }

      if (severity == null) {
        severity = LogLevel.UNKNOWN;
      }

      if (!message) {
        message = "";
      }

      return this._messageFormatter(datetime, name, severity, message, error);
    } // ======================== Private methods ================================

  }, {
    key: "_formatError",
    value: function _formatError(error) {
      return this._errorFormatter(error);
    }
  }, {
    key: "_formatCause",
    value: function _formatCause(error) {
      return (this._causeFormatter || this._errorFormatter)(error);
    }
  }, {
    key: "_processStack",
    value: function _processStack(error) {
      var result = [];
      var stack = error.stack;

      if (typeof stack === "string") {
        result = stack.split("\n");
      } else if (stack instanceof Array) {
        result = stack;
      } else if (stack) {
        result = stack.toString().split("\n");
      }

      return result;
    }
  }, {
    key: "_processMessageFormatTag",
    value: function _processMessageFormatTag(tag, opts) {
      var result;

      switch (tag) {
        case "C":
          if (opts) {
            result = "LoggerMDC.get(\"".concat(opts, "\")");
          } else {
            result = "LoggerMDC.toJson()";
          }

          break;

        case "d":
          // TODO Format date
          result = "datetime.toISOString()";
          break;

        case "e":
          result = 'error ? this._formatError(error): ""';
          break;

        case "m":
          switch (opts) {
            case null:
            case undefined:
              result = "message";
              break;

            case "JSON":
              result = 'message ? JSON.stringify(message).slice(1,-1) : ""';
              break;

            default:
              result = "message ? message.replace(/\\r\\n|\\r|\\n/g, \"".concat(opts, "\"): \"\"");
          }

          break;

        case "n":
          result = "name";
          break;

        case "p":
          // TODO Process ID
          result = '"-"';
          break;

        case "s":
          if (opts) {
            result = "(Array(".concat(opts, " + 1).join(\" \") + (this._severityLabels[severity] || \"ANY\")).slice(-").concat(opts, ")");
          } else {
            result = 'this._severityLabels[severity] || "ANY"';
          }

          break;

        case "t":
          // TODO Thread ID
          result = '"-"';
          break;

        case "T":
          // TODO Thread name
          result = '"-"';
          break;
      }

      return result;
    }
  }, {
    key: "_processErrorFormatTag",
    value: function _processErrorFormatTag(tag, opts) {
      var result;

      switch (tag) {
        case "b":
          result = "this._processStack(error).join(\"".concat(opts || ENTRY_SEPARATOR, "\")");
          break;

        case "c":
          result = 'error.name || "Error"';
          break;

        case "C":
          result = "error.cause ? (\"".concat(opts || "", "\" + this._formatCause(error.cause)) : \"\"");
          break;

        case "i":
          result = 'error.id ? error.id : "-"';
          break;

        case "m":
          var errorMessage = 'error.message ? (error.message + ((error.paramMap && Object.keys(error.paramMap).length > 0) ? " (paramMap: " + JSON.stringify(error.paramMap) + ")" : "")) : (typeof error === "string" ? error : "")';

          switch (opts) {
            case null:
            case undefined:
              result = errorMessage;
              break;

            case "JSON":
              result = "JSON.stringify(".concat(errorMessage, ").slice(1,-1)");
              break;

            default:
              result = "(".concat(errorMessage, ").replace(/\\r\\n|\\r|\\n/g, \"").concat(opts, "\")");
          }

          break;

        case "t":
          result = 'error.timestamp ? error.timestamp.toISOString() : "-"';
          break;
      }

      return result;
    }
  }, {
    key: "_transformFormat",
    value: function _transformFormat(format, callback) {
      var _this = this;

      var tags = [];
      format.replace(FORMAT_TAGS, function () {
        tags.push(Array.prototype.slice.call(arguments, 1, -2));
      });
      var result = "(\"".concat(format.replace(/"/gm, '\\"'), "\")");
      tags.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            full_tag = _ref2[0],
            opts = _ref2[1],
            tag = _ref2[2];

        var replacement;

        if (tag === "%" && !opts) {
          replacement = "%";
        } else {
          replacement = callback(tag, opts);
        }

        if (replacement === null || replacement === undefined) {
          throw new BaseError("unsupported format tag \"".concat(full_tag, "\" for ").concat(_this.constructor.name));
        }

        replacement = "\" + (".concat(replacement, ") + \"");
        result = result.replace(full_tag, replacement);
      });
      return result.replace(/\n/gm, "\\n").replace();
    }
  }]);

  return MessageFormatter;
}();

module.exports = MessageFormatter;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__7__;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(7),
    ContextStore = _require.ContextStore; // environment specific implementations


var _require2 = __webpack_require__(9),
    getFactory = _require2.getFactory,
    setFactory = _require2.setFactory;

var CTX_STORE_NAME = "uuapp.logging";
var MDC_KEY = "mdc";
/**
 * Mapped diagnostic context.
 */

var LoggerMDC = /*#__PURE__*/function () {
  function LoggerMDC() {
    _classCallCheck(this, LoggerMDC);
  }

  _createClass(LoggerMDC, null, [{
    key: "create",

    /**
     * Initializes MDC
     * @param emitters Context emitters.
     * @param fn Function within which should be MDC available
     * @returns {*} Return value of invoked function.
     */
    value: function create() {
      var emitters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var fn = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof emitters === "function") {
        fn = emitters;
        emitters = null;
      }

      return ContextStore.create(CTX_STORE_NAME, function () {
        var ctxStore = ContextStore.get(CTX_STORE_NAME);

        if (emitters) {
          emitters.forEach(function (e) {
            return ctxStore.bindEmitter(e);
          });
        }

        return fn();
      });
    }
    /**
     * Stores context attribute.
     * @param key Context attribute name.
     * @param value Context attribute value.
     */

  }, {
    key: "set",
    value: function set(key, value) {} // implementation available in get-set.js
    // due to environment differences

    /**
     * Reads value of context attribute.
     * @param key Context attribute name.
     * @returns {*} Context attribute value.
     */

  }, {
    key: "get",
    value: function get(key) {} // implementation available in get-set.js
    // due to environment differences

    /**
     * Clears MDC in current context.
     */

  }, {
    key: "clear",
    value: function clear() {
      var store = ContextStore.get(CTX_STORE_NAME);

      if (store) {
        store.set(MDC_KEY, {});
      }
    }
    /**
     * Serializes current state of MDC to JSON.
     * @returns {string} Serialized MDC
     */

  }, {
    key: "toJson",
    value: function toJson() {
      var store = ContextStore.get(CTX_STORE_NAME);

      if (store) {
        var mdc = store.get(MDC_KEY);

        if (mdc) {
          return JSON.stringify(mdc);
        }
      }

      return "{}";
    }
  }]);

  return LoggerMDC;
}(); // remapping environment specific methods


LoggerMDC.set = setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
LoggerMDC.get = getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
module.exports = LoggerMDC;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * LoggerMDC implementation of get and set
 * for Browser environment.
 */
module.exports = {
  setFactory: function setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function set(key, value) {
      var store = ContextStore.get(CTX_STORE_NAME);

      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }

      var mdc = store.get(MDC_KEY);

      if (!mdc) {
        mdc = {};
        store.set(MDC_KEY, mdc);
      }

      mdc[key] = value;
    };
  },
  getFactory: function getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function get(key) {
      var store = ContextStore.get(CTX_STORE_NAME);

      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }

      var mdc = store.get(MDC_KEY);

      if (mdc) {
        return mdc[key];
      }
    };
  }
};

function noop() {}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Logger = __webpack_require__(4);

var _require = __webpack_require__(7),
    BaseError = _require.BaseError,
    Config = _require.Config;

var loggers = {};
/**
 * @class UuApp.Logging.LoggerFactory
 * @classdesc
 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
 */

/**
 * Returns an instance of the logger with given name. Settings of the logger are
 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
 *
 * Successive calls with the same logger name return the same logger instance.
 *
 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
 *   the component that uses the logger, e.g. "My.Namespace.Component".
 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
 *   in successive calls it's ignored.
 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
 * @method UuApp.Logging.LoggerFactory.get
 */

var LoggerFactory = /*#__PURE__*/function () {
  function LoggerFactory() {
    _classCallCheck(this, LoggerFactory);
  }

  _createClass(LoggerFactory, null, [{
    key: "get",
    value: function get(name) {
      var hierarchical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof name != "string") {
        throw new BaseError("LoggerFactory.get() must be called with a string argument (logger name).");
      }

      var cname = name.toLowerCase();

      if (loggers[cname]) {
        return loggers[cname].logger;
      } else {
        var logger = new Logger(name);
        LoggerFactory.configure(logger, hierarchical);
        loggers[cname] = {
          logger: logger,
          hierarchical: hierarchical
        };
        return logger;
      }
    }
  }, {
    key: "configure",
    value: function configure(logger, hierarchical) {
      var cname = logger.getName().toString().toLowerCase();
      var logSeverityLabels = Config.get(cname + ".log_severity_labels", hierarchical !== false);
      var logMessageFormat = Config.get(cname + ".log_message_format", hierarchical !== false);
      var logErrorFormat = Config.get(cname + ".log_error_format", hierarchical !== false);
      var logCauseFormat = Config.get(cname + ".log_cause_format", hierarchical !== false);
      var logLevel = Config.get(cname + ".log_level", hierarchical !== false);
      logger.setSeverityLabels(logSeverityLabels);
      logger.setMessageFormat(logMessageFormat);
      logger.setErrorFormat(logErrorFormat);
      logger.setCauseFormat(logCauseFormat);
      logger.setLevel(logLevel);
    }
  }, {
    key: "configureAll",
    value: function configureAll() {
      Object.keys(loggers).map(function (name) {
        var reg = loggers[name];
        LoggerFactory.configure(reg.logger, reg.hirearchical);
      });
    }
  }]);

  return LoggerFactory;
}();

module.exports = LoggerFactory;

/***/ })
/******/ ]);
});