"use strict";

const LogLevel = require("./log-level.js");
const MessageFormatter = require("./message-formatter.js");
const { BaseError } = require("uu_appg01_core-utils");

/**
 * @class UuApp.Logging.Logger
 * @classdesc
 * Component for logging. Each logged message has a severity level and each logger can be
 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
 *
 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
 * are typically removed from production code), statements using Logger-s are intended to be
 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
 * configuration.
 *
 * **Configuration**
 *
 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
 * Supported environment options:
 *
 *     {
 *       "log_level": "ERROR",
 *       "My.Namespace.log_level": "WARN"
 *     }
 *
 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
 *
 * **Typical usage**
 *
 *     // get logger instance and log a message
 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
 *
 *     // if logging requires lenghty computation, it can be made conditional so that it
 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
 *     if (logger.isDebugLoggable()) {
 *       var computedValue = ...; // some lenghty computation
 *       logger.debug("Value computed to", computedValue);
 *     }
 *
 */
class Logger {
  constructor(name) {
    this._name = name;
    this._level = LogLevel.WARN;
    this._formatter = new MessageFormatter();
    this._outputter = console;
  }

  getName() {
    return this._name;
  }

  /**
   * Sets severity level of this Logger to given value. Messages with lower (less important)
   * severity will be ignored when attempted to be logged via this logger. Order of importance:
   * DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN < OFF.
   *
   * **It's strongly advised not to configure loggers directly using this method** because
   * if such code gets deployed to production, it'll effectively override settings from
   * environment and therefore could prevent logging of necessary information.
   * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
   *
   * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
   *   is given, default is used (LEVEL_WARN).
   * @method UuApp.Logging.Logger#setLevel
   */
  setLevel(level) {
    if (typeof level === "number") {
      this._level = level;
    } else if (typeof level === "string") {
      let lvl = LogLevel[level.toUpperCase()] !== undefined ? LogLevel[level.toUpperCase()] : Number(level);
      if (lvl !== undefined && !isNaN(lvl)) {
        this._level = lvl;
      }
    } else if (!level) {
      this._level = LogLevel.WARN;
    } else {
      throw new BaseError(`Invalid logger level "${level}"`);
    }
  }

  /**
   * @return {number} Level of this logger.
   * @method UuApp.Logging.Logger#getLevel
   */
  getLevel() {
    return this._level;
  }

  setSeverityLabels(severityLabels) {
    this._formatter.setSeverityLabels(severityLabels);
  }

  getSeverityLabels() {
    return this._formatter.getSeverityLabels();
  }

  setMessageFormat(messageFormat) {
    this._formatter.setMessageFormat(messageFormat);
  }

  getMessageFormat() {
    return this._formatter.getMessageFormat();
  }

  setErrorFormat(errorFormat) {
    this._formatter.setErrorFormat(errorFormat);
  }

  getErrorFormat() {
    return this._formatter.getErrorFormat();
  }

  setCauseFormat(causeFormat) {
    this._formatter.setCauseFormat(causeFormat);
  }

  getCauseFormat() {
    return this._formatter.getCauseFormat();
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "DEBUG".
   * @method UuApp.Logging.Logger#isDebugLoggable
   */
  isDebugLoggable() {
    return this._level <= LogLevel.DEBUG;
  }

  /**
   * Logs message with severity level "DEBUG".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#debug
   */
  debug(message, error = null) {
    this._add(LogLevel.DEBUG, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "INFO".
   * @method UuApp.Logging.Logger#isInfoLoggable
   */
  isInfoLoggable() {
    return this._level <= LogLevel.INFO;
  }

  /**
   * Logs message with severity level "INFO".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#info
   */
  info(message, error = null) {
    this._add(LogLevel.INFO, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "WARN".
   * @method UuApp.Logging.Logger#isWarnLoggable
   */
  isWarnLoggable() {
    return this._level <= LogLevel.WARN;
  }

  /**
   * Logs message with severity level "WARN".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#warn
   */

  warn(message, error = null) {
    this._add(LogLevel.WARN, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "ERROR".
   * @method UuApp.Logging.Logger#isErrorLoggable
   */
  isErrorLoggable() {
    return this._level <= LogLevel.ERROR;
  }

  /**
   * Logs message with severity level "ERROR".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  error(message, error = null) {
    this._add(LogLevel.ERROR, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "FATAL".
   * @method UuApp.Logging.Logger#isFatalLoggable
   */
  isFatalLoggable() {
    return this._level <= LogLevel.FATAL;
  }

  /**
   * Logs message with severity level "FATAL".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  fatal(message, error = null) {
    this._add(LogLevel.FATAL, message, error);
  }

  /**
   * Logs message with "UNKNOWN" severity.
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  log(message, error = null) {
    this._add(LogLevel.UNKNOWN, message, error);
  }

  // ======================== Private methods ================================

  _add(level, message, error) {
    if (this._level <= level) {
      this._write(new Date(), level, message, error);
    }
  }

  async _write(datetime, level, message, error) {
    let formattedMessage = this._formatter.formatMessage(datetime, this._name, level, message, error);
    // TODO Add support for outputters. Currently we'll log only to the console.
    if (typeof window !== "undefined") {
      switch (level) {
        case LogLevel.FATAL:
        case LogLevel.ERROR:
          this._outputter.error(formattedMessage);
          break;
        case LogLevel.WARN:
          this._outputter.warn(formattedMessage);
          break;
        case LogLevel.INFO:
        case LogLevel.UNKNOWN:
          this._outputter.info(formattedMessage);
          break;
        case LogLevel.DEBUG:
          this._outputter.debug(formattedMessage);
          break;
        default:
          this._outputter.log(formattedMessage);
      }
    } else {
      this._outputter.log(formattedMessage);
    }
  }

}

module.exports = Logger;
