"use strict";

const LogLevel = require("./log-level.js");
const { BaseError } = require("uu_appg01_core-utils");
const LoggerMDC = require("./logger_mdc/logger-mdc.js");

// Regexp to match formatting tags.
// @private
const FORMAT_TAGS = /(%(?:{([^}]*)})?([a-zA-Z%]))/g;

// Default set of severity labels (matching standard ruby
//    {http://ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Severity.html
// Logger::Severity} with addition of level +OFF+).
const DEFAULT_SEVERITY_LABELS = "DEBUG INFO WARN ERROR FATAL ANY OFF";

//  Format of message to be used. Following tags are supported:
// <b>%%</b> - Escaped percent tag.
// * <b>%C</b> - Full {UuApp::Logging::LoggerMdc logger MDC} in JSON format.
// * <b>%d</b> - Date and time in format matching {#datetime_format}.
// * <b>%e</b> - Error formatted using {#error_format} or empty string if there is no error.
// * <b>%m</b> - Actual log message provided by application.
// * <b>%n</b> - Logger name.
// * <b>%p</b> - System process ID.
// * <b>%s</b> - Logging event severity.
// * <b>%t</b> - ID of thread where message was captured.
// * <b>%T</b> - Name of thread where message was captured.
// * <b>%{ KEY }C</b> - Custom attribute from logger {UuApp::Logging::LoggerMdc logger MDC} with name KEY.
//      Time values are printed in format matching {#datetime_format}.
// * <b>%{ FMT }d</b> - Date and time in format matching FMT.
// * <b>%{ FMT }m</b> - Log message provided by application with additional escaping based on FMT value. There are
//      two escaping variants. First is keyword +JSON+ resulting in message with escaped quotes and line separators.
//      In case of any other value, this value will be used to replace new line separators (CR(LF)).
//  * <b>%{ NUM }s</b> - Logging event severity with NUM representing total length of severity with padding.*/

// Default message format (see {#message_format} for tag description).
const DEFAULT_MESSAGE_FORMAT = "[%d] %{5}s %n: %m%e";

// Format of error. In case there is instance of error to be logged (given as explicit logger parameter or implicit
// error reference available inside rescue block), error message is injected into message replacing +%e+ tag. That
// means error format should start with some separator (e.g. new line) to be able to distinguish text of log message
// from printed error. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%b</b> - Invocation stack (backtrace), lines are joined with new line.
// * <b>%c</b> - Error class name.
// * <b>%C</b> - Error cause formatted using {#cause_format} or {#error_format}, or empty string if there is no cause.
// * <b>%i</b> - Unique error ID.
// * <b>%m</b> - Actual error message.
// * <b>%t</b> - Timestamp of error instantiation in format matching {#datetime_format}.
// * <b>%{ SEP }b</b> - Invocation stack (backtrace), lines are joined with SEP.
// * <b>%{ PFX }C</b> - Error cause with prefix PFX to be used before printing error cause).
// * <b>%{ FMT }m</b> - Error message with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped quotes and line separators. In case of any other value,
//   this value will be used to replace new line separators (CR(LF)).
// * <b>%{ FMT }t</b> - Timestamp of error instantiation in format matching FMT.

// # Default message format (see {#error_format} for tag description).
const DEFAULT_ERROR_FORMAT = "\n  %i [%t] %c: %m\n    %{\n    }b%{\n  Caused by:}C";

//# Default log messages separator.
//# @private
const ENTRY_SEPARATOR = "\n";

class MessageFormatter {
  constructor(messageFormat = null, errorFormat = null, severityLabels = null) {
    this.setSeverityLabels(severityLabels || DEFAULT_SEVERITY_LABELS);
    this.setMessageFormat(messageFormat || DEFAULT_MESSAGE_FORMAT);
    this.setErrorFormat(errorFormat || DEFAULT_ERROR_FORMAT);
  }

  setSeverityLabels(severityLabels) {
    if (severityLabels) {
      this._severityLabels = severityLabels.split(" ");
    }
  }

  getSeverityLabels() {
    return this._severityLabels.join(" ");
  }

  setMessageFormat(messageFormat) {
    if (messageFormat) {
      this._messageFormat = messageFormat;
      let formatterSrc = `(function (datetime, name, severity, message, error) {
        return ${this._transformFormat(messageFormat, this._processMessageFormatTag)};
      }).bind(this);`;
      this._messageFormatter = eval(formatterSrc);
    }
  }

  getMessageFormat() {
    return this._messageFormat;
  }

  setErrorFormat(errorFormat) {
    if (errorFormat) {
      this._errorFormat = errorFormat;
      let formatterSrc = `(function (error) {
        return ${this._transformFormat(errorFormat, this._processErrorFormatTag)};
      }).bind(this);`;
      this._errorFormatter = eval(formatterSrc);
    }
  }

  getErrorFormat() {
    return this._errorFormat;
  }

  setCauseFormat(causeFormat) {
    if (causeFormat) {
      this._causeFormat = causeFormat;
      let formatterSrc = `(function (error) {
        return ${this._transformFormat(causeFormat, this._processErrorFormatTag)};
      }).bind(this);`;
      this._causeFormatter = eval(formatterSrc);
    } else {
      this._causeFormat = null;
      this._causeFormatter = null;
    }
  }

  getCauseFormat() {
    return this._causeFormat;
  }

  formatMessage(datetime, name, severity, message, error = null) {
    if (!datetime) {
      datetime = new Date();
    }
    if (!name) {
      name = "";
    }
    if (severity == null) {
      severity = LogLevel.UNKNOWN;
    }
    if (!message) {
      message = "";
    }
    return this._messageFormatter(datetime, name, severity, message, error);
  }

  // ======================== Private methods ================================

  _formatError(error) {
    return this._errorFormatter(error);
  }

  _formatCause(error) {
    return (this._causeFormatter || this._errorFormatter)(error);
  }

  _processStack(error) {
    let result = [];
    let stack = error.stack;
    if (typeof stack === "string") {
      result = stack.split("\n");
    } else if (stack instanceof Array) {
      result = stack;
    } else if (stack) {
      result = stack.toString().split("\n");
    }
    return result;
  }

  _processMessageFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "C":
        if (opts) {
          result = `LoggerMDC.get("${opts}")`;
        } else {
          result = "LoggerMDC.toJson()";
        }
        break;
      case "d":
        // TODO Format date
        result = "datetime.toISOString()";
        break;
      case "e":
        result = 'error ? this._formatError(error): ""';
        break;
      case "m":
        switch (opts) {
          case null:
          case undefined:
            result = "message";
            break;
          case "JSON":
            result = 'message ? JSON.stringify(message).slice(1,-1) : ""';
            break;
          default:
            result = `message ? message.replace(/\\r\\n|\\r|\\n/g, "${opts}"): ""`;
        }
        break;
      case "n":
        result = "name";
        break;
      case "p":
        // TODO Process ID
        result = '"-"';
        break;
      case "s":
        if (opts) {
          result = `(Array(${opts} + 1).join(" ") + (this._severityLabels[severity] || "ANY")).slice(-${opts})`;
        } else {
          result = 'this._severityLabels[severity] || "ANY"';
        }
        break;
      case "t":
        // TODO Thread ID
        result = '"-"';
        break;
      case "T":
        // TODO Thread name
        result = '"-"';
        break;
    }
    return result;
  }

  _processErrorFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "b":
        result = `this._processStack(error).join("${opts || ENTRY_SEPARATOR}")`;
        break;
      case "c":
        result = 'error.name || "Error"';
        break;
      case "C":
        result = `error.cause ? ("${opts || ""}" + this._formatCause(error.cause)) : ""`;
        break;
      case "i":
        result = 'error.id ? error.id : "-"';
        break;
      case "m":
        let errorMessage = 'error.message ? (error.message + ((error.paramMap && Object.keys(error.paramMap).length > 0) ? " (paramMap: " + JSON.stringify(error.paramMap) + ")" : "")) : (typeof error === "string" ? error : "")';
        switch (opts) {
          case null:
          case undefined:
            result = errorMessage;
            break;
          case "JSON":
            result = `JSON.stringify(${errorMessage}).slice(1,-1)`;
            break;
          default:
            result = `(${errorMessage}).replace(/\\r\\n|\\r|\\n/g, "${opts}")`;
        }
        break;
      case "t":
        result = 'error.timestamp ? error.timestamp.toISOString() : "-"';
        break;
    }
    return result;
  }

  _transformFormat(format, callback) {
    let tags = [];
    format.replace(FORMAT_TAGS, function() {
      tags.push(Array.prototype.slice.call(arguments, 1, -2));
    });
    let result = `("${format.replace(/"/gm, '\\"')}")`;
    tags.forEach(([full_tag, opts, tag]) => {
      let replacement;
      if (tag === "%" && !opts) {
        replacement = "%";
      } else {
        replacement = callback(tag, opts);
      }
      if (replacement === null || replacement === undefined) {
        throw new BaseError(`unsupported format tag "${full_tag}" for ${this.constructor.name}`);
      }
      replacement = `" + (${replacement}) + "`;
      result = result.replace(full_tag, replacement);
    });
    return result.replace(/\n/gm, "\\n").replace();
  }
}

module.exports = MessageFormatter;
