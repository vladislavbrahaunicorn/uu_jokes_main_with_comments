import UU5 from "uu5g04";
import createReactClass from "create-react-class";

import Cfg from "../config/config.js";
import LazyExports from "./lazy-exports.js";

import "./authors-editable-tile-dnd-hoc.less";

const { DragSource, DropTarget } = LazyExports["react-dnd"];

// handling of drop indicator (for dragSource component instance) for case that we're NOT over droppable
// target - react-dnd doesn't notify us about that on dragSource so we have to handle state transitions
// on dropTarget instances and notify dragSource instance on our own
let dragOpExtraState = {
  dropAllowedOn: {},
  dragSourceComponent: null
};
const handleDragOverChange = function({ isDragOver, canDrop, component }) {
  let { dropAllowedOn, dragSourceComponent } = dragOpExtraState;
  if (!isDragOver || !canDrop) delete dropAllowedOn[component.props.id];
  else dropAllowedOn[component.props.id] = true;
  if (dragSourceComponent) dragSourceComponent.setDragIsOverDroppableTarget(Object.keys(dropAllowedOn).length > 0);
};
const handleDraggingChange = function({ isDragging, component }) {
  // NOTE "isDragging" can change due to unmount and re-mount (we're in virtualized-list so if we scroll down
  // while drag operation is being done then the source component might be unmounted and if we scroll back up
  // a new component should become the drag source).
  if (isDragging) {
    dragOpExtraState.dragSourceComponent = component;
    dragOpExtraState.dragSourceComponent.setDragIsOverDroppableTarget(
      Object.keys(dragOpExtraState.dropAllowedOn).length > 0
    );
  } else if (component === dragOpExtraState.dragSourceComponent) {
    dragOpExtraState.dragSourceComponent = null;
  }
};

const dragSource = {
  canDrag(props) {
    return props.draggable;
  },
  beginDrag(props, monitor, component) {
    if (component && typeof component.getDecoratedComponentInstance === "function") {
      component = component.getDecoratedComponentInstance();
    }
    dragOpExtraState.dragSourceComponent = component;
    // return the data describing the dragged item
    return { id: props.id, ...props.data };
  },
  endDrag(props, monitor) {
    dragOpExtraState = {
      dropAllowedOn: {},
      dragSourceComponent: null
    };

    const dropResult = monitor.getDropResult();
    if (dropResult && dropResult.component && typeof dropResult.component.props.onDrop === "function") {
      dropResult.component.props.onDrop(dropResult);
    }
  },
  isDragging(props, monitor) {
    // our Tile-s are in react-virtualized, i.e. they might be unmounted during drag & sufficient scroll
    // => if user scrolls back (during drag operation) match the newly mounted component by ID
    return props.id === monitor.getItem().id;
  }
};

const dragPropsExpander = function(connect, monitor) {
  // which extra props to inject into component which can be dragged (Tile)
  return {
    _connectDragSource: connect.dragSource(),
    _connectDragPreview: connect.dragPreview(),
    _isDragging: monitor.isDragging(),
    _onDraggingChange: handleDraggingChange
  };
};

const dropTarget = {
  canDrop(props, monitor) {
    let item = monitor.getItem();
    return item.id !== props.id; // don't allow dropping onto the same component which is being dragged
  },
  hover(props, monitor, component) {
    if (!component) return;
    if (typeof component.getDecoratedComponentInstance === "function") {
      component = component.getDecoratedComponentInstance();
    }

    let domNode = UU5.Common.DOM.findNode(component);
    let cardNode = domNode ? domNode.lastChild : null;
    if (cardNode) {
      let cardNodeRect = cardNode.getBoundingClientRect();
      let hoverMiddleX = (cardNodeRect.right + cardNodeRect.left) / 2;
      let mouseXY = monitor.getClientOffset();
      let indicateBefore = mouseXY.x < hoverMiddleX;

      let indicatorOffset = 0;
      if (indicateBefore) {
        let prevCardNode = (((domNode.parentNode || {}).previousSibling || {}).lastChild || {}).lastChild;
        if (prevCardNode) indicatorOffset = (prevCardNode.getBoundingClientRect().right - cardNodeRect.left) / 2;
        else indicatorOffset = (domNode.parentNode.getBoundingClientRect().left - cardNodeRect.left) / 2;
        indicatorOffset += cardNodeRect.left - domNode.getBoundingClientRect().left;
      } else {
        let nextCardNode = (((domNode.parentNode || {}).nextSibling || {}).lastChild || {}).lastChild;
        if (nextCardNode) {
          indicatorOffset = (cardNodeRect.right - nextCardNode.getBoundingClientRect().left) / 2;
          indicatorOffset += domNode.getBoundingClientRect().right - cardNodeRect.right;
        }
      }
      component.setDropIndicator(indicateBefore, indicatorOffset);
    }
  },
  drop(props, monitor, component) {
    if (component && typeof component.getDecoratedComponentInstance === "function") {
      component = component.getDecoratedComponentInstance();
    }
    if (!monitor.didDrop()) {
      const item = monitor.getItem();
      return { item, component, before: component.getDropIndicator().before };
    }
  }
};

const dropPropsExpander = function(connect, monitor) {
  // which extra props to inject into component which can be dropped to (Tile)
  return {
    _connectDropTarget: connect.dropTarget(),
    _isDragOver: monitor.isOver(),
    _onDragOverChange: handleDragOverChange,
    _canDrop: monitor.isOver() && monitor.canDrop() // using "monitor.isOver() && ..." because it has much better performance this way
  };
};

export const DragDropTileHoc = (Tile, dndType, isDragSource = true, isDropTarget = true, dropBeforeOnly = false) => {
  let mainClassName = (Tile.classNames || {}).main || "";
  let getClassName = suffix =>
    Cfg.CSS +
    "authors-editable-tile-dnd-hoc" +
    (suffix ? "-" + suffix : "") +
    (mainClassName ? " " + mainClassName + (suffix ? "-" + suffix : "") : "");

  let Component = createReactClass({
    //@@viewOn:mixins
    mixins: [UU5.Common.BaseMixin],
    //@@viewOff:mixins

    //@@viewOn:statics
    statics: {
      tagName: Cfg.TAG + "AuthorsEditableTileDndHoc",
      classNames: {
        main: getClassName(),
        wrapper: getClassName("wrapper"),
        dragOver: getClassName("wrapper-drag-over"),
        dragging: getClassName("wrapper-dragging"),
        indicate: getClassName("wrapper-indicate"),
        indicateAfter: getClassName("wrapper-indicate-after"),
        dropIndicator: getClassName("drop-indicator")
      },
      opt: {
        hoc: true
      }
    },
    //@@viewOff:statics

    //@@viewOn:propTypes
    //@@viewOff:propTypes

    //@@viewOn:getDefaultProps
    //@@viewOff:getDefaultProps

    //@@viewOn:reactLifeCycle
    getInitialState() {
      return { dropIndicatorBefore: dropBeforeOnly, dropIndicatorOffset: 0 };
    },

    componentDidMount() {
      // we're firing drag*Change events even during mount because that seems to be the only way to get
      // reference to this component instance when using react-dnd and component gets re-mounted due to
      // scroll in react-virtualized list (during drag operation)
      this._fireDragOverChange();
      this._fireDraggingChange();
    },

    componentWillUnmount() {
      if (this.props._isDragOver) this._fireDragOverChange({ ...this.props, _isDragOver: false, _canDrop: false });
      if (this.props._isDragging) this._fireDraggingChange({ ...this.props, _isDragging: false });
    },

    componentDidUpdate(prevProps) {
      if (prevProps._isDragOver !== this.props._isDragOver) this._fireDragOverChange();
      if (prevProps._isDragging !== this.props._isDragging) this._fireDraggingChange();
      if (this._dropIndicator && this._card) {
        let rootNode = UU5.Common.DOM.findNode(this._rootNode);
        let rootNodeRect = rootNode.getBoundingClientRect();
        let cardNode = UU5.Common.DOM.findNode(this._card);
        let cardNodeRect = cardNode.getBoundingClientRect();
        let dropIndicatorNode = UU5.Common.DOM.findNode(this._dropIndicator);
        dropIndicatorNode.style.top = rootNodeRect.top - cardNodeRect.top + "px";
        dropIndicatorNode.style.bottom = rootNodeRect.bottom - cardNodeRect.bottom + "px";
      }
    },
    //@@viewOff:reactLifeCycle

    //@@viewOn:interface
    setDropIndicator(before, offset) {
      if (dropBeforeOnly) before = true;
      this.setState(state => {
        let result;
        if (state.dropIndicatorBefore !== before || Math.abs(offset - state.dropIndicatorOffset) > 0.5) {
          result = { dropIndicatorBefore: before, dropIndicatorOffset: offset };
        }
        return result;
      });
    },

    getDropIndicator() {
      return {
        before: this.state.dropIndicatorBefore,
        offset: this.state.dropIndicatorOffset
      };
    },

    setDragIsOverDroppableTarget(isOverDroppable) {
      this.setState(state => {
        let result;
        if (state.isOverDroppable !== isOverDroppable) result = { isOverDroppable };
        return result;
      });
    },
    //@@viewOff:interface

    //@@viewOn:overridingMethods
    //@@viewOff:overridingMethods

    //@@viewOn:private
    _fireDragOverChange(props = this.props) {
      if (typeof props._onDragOverChange === "function") {
        let opt = { isDragOver: props._isDragOver, canDrop: props._canDrop, component: this };
        props._onDragOverChange(opt);
      }
    },

    _fireDraggingChange(props = this.props) {
      if (typeof props._onDraggingChange === "function") {
        let opt = { isDragging: props._isDragging, component: this };
        props._onDraggingChange(opt);
      }
    },

    _setCardRef(comp) {
      this._card = comp;
    },

    _setDropIndicatorRef(comp) {
      this._dropIndicator = comp;
    },

    _setRootNodeRef(comp) {
      this._rootNode = comp;
    },
    //@@viewOff:private

    //@@viewOn:render
    render() {
      let { _connectDragPreview, _connectDropTarget, _isDragging, _isDragOver, draggable } = this.props;
      let { dropIndicatorBefore, dropIndicatorOffset, isOverDroppable } = this.state;

      let rootClassNames = [this.getClassName().wrapper];
      let dropIndicator;
      if (_isDragging) {
        rootClassNames.push(this.getClassName().dragging);
      }
      if (_isDragOver || (_isDragging && !isOverDroppable)) {
        // show drag-over indicator on dragSource instance also in case that we're not over a component that we can drop the item to
        if (!_isDragOver) dropIndicatorBefore = true;
        rootClassNames.push(this.getClassName().dragOver);
        rootClassNames.push(this.getClassName().indicate);
        if (!dropIndicatorBefore) rootClassNames.push(this.getClassName().indicateAfter);
      }
      dropIndicator = (
        <div
          ref={this._setDropIndicatorRef}
          className={this.getClassName().dropIndicator}
          style={{
            [dropIndicatorBefore ? "marginLeft" : "marginRight"]: dropIndicatorOffset
          }}
        />
      );

      let result = (
        <div className={rootClassNames.join(" ")} style={this.props.wrapperStyle} ref={this._setRootNodeRef}>
          {dropIndicator}
          <Tile {...this.props} _isOverDroppable={isOverDroppable} ref={this._setCardRef} />
        </div>
      );
      if (draggable && isDragSource) result = _connectDragPreview(result);
      if (isDropTarget) result = _connectDropTarget(result);

      return result;
    }
    //@@viewOff:render
  });

  if (isDragSource) Component = DragSource(dndType, dragSource, dragPropsExpander)(Component);
  if (isDropTarget) Component = DropTarget([dndType], dropTarget, dropPropsExpander)(Component);

  return Component;
};
export default DragDropTileHoc;
