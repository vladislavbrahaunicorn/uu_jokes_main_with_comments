import React from "react";
import createReactClass from "create-react-class";
import * as UU5 from "uu5g04";
import * as Plus4U5 from "uu_plus4u5g01";

import Cfg from "../config/config.js";

import { AuthorsEditableTile, AuthorsEditableIconTile } from "./authors-editable-tile.js";
import AuthorsEditableModalForm from "./authors-editable-modal-form.js";
import AuthorsEditableInlineForm from "./authors-editable-inline-form.js";
import AboutDeleteForm from "./about-delete-form.js";
import Css from "./css.js";

import "./authors-editable-list.less";

// TODO: number depends on uu5g04 UU5.Bricks.Card styles!
let ELEVATIONS = {
  0: { vertical: 0, verticalBottom: 0, horizontalHalf: 0 },
  1: { vertical: 6, verticalBottom: 4, horizontalHalf: 3 },
  2: { vertical: 11, verticalBottom: 7, horizontalHalf: 5 },
  3: { vertical: 18, verticalBottom: 11, horizontalHalf: 9 },
  4: { vertical: 23, verticalBottom: 15, horizontalHalf: 12 },
  5: { vertical: 55, verticalBottom: 35, horizontalHalf: 27 }
};

const TileList = UU5.Common.DnD.withContext(
  ({
    data,
    onDrop,
    tileMinWidth,
    tileMaxWidth,
    tileHeight,
    tileElevation,
    tileElevationHover,
    tileSpacing,
    rowSpacing,
    tile
  }) => {
    let elevationMargins = ELEVATIONS[Math.max(tileElevation, tileElevationHover)] || ELEVATIONS[0];
    return (
      <UU5.Bricks.Resize>
        {({ width, height }) => {
          let minColumnCount = Math.floor(width / tileMaxWidth) || 1;
          let maxColumnCount = Math.floor(width / tileMinWidth) || 1;
          let columnCount = minColumnCount < maxColumnCount ? minColumnCount : maxColumnCount;
          let rowCount = Math.ceil(data.length / columnCount);
          return new Array(rowCount).fill(0).map((_, index) => {
            let columnWidthCss = 100 / columnCount + "%";
            let rowStyle = {};
            if (tileHeight) rowStyle.height = tileHeight;
            if (index < rowCount - 1 && typeof rowSpacing === "number") {
              rowStyle.marginBottom = rowSpacing - elevationMargins.vertical;
            }
            return (
              <UU5.Bricks.Row key={index} display="flex" style={rowStyle} noSpacing>
                {new Array(columnCount).fill(0).map((_, i) => {
                  let item = data[index * columnCount + i];
                  let columnStyle = {};
                  if (typeof tileSpacing === "number") {
                    columnStyle.paddingRight = tileSpacing - 2 * elevationMargins.horizontalHalf;
                  }
                  let Tile = tile;
                  return (
                    <UU5.Bricks.Column
                      key={(item && item.id) || i}
                      width={columnWidthCss}
                      noSpacing
                      style={columnStyle}
                    >
                      <Tile
                        id={item ? item.id : undefined}
                        {...item}
                        data={item}
                        onDrop={onDrop}
                        elevation={tileElevation}
                        elevationHover={tileElevationHover}
                        _index={index * columnCount + i}
                        _columnIndex={i}
                        _list={data}
                      />
                    </UU5.Bricks.Column>
                  );
                })}
              </UU5.Bricks.Row>
            );
          });
        }}
      </UU5.Bricks.Resize>
    );
  }
);

export const AuthorsEditableList = createReactClass({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ScreenSizeMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "AuthorsEditableList",
    classNames: {
      main: Cfg.CSS + " " + Cfg.CSS + "authors-editable",
      topMenu: Cfg.CSS + "authors-editable-top-menu",
      deleteFormContent: Cfg.CSS + "authors-editable-delete-form-content",
      deleteFormBody: Cfg.CSS + "authors-editable-delete-form-body",
      editForm: Cfg.CSS + "authors-editable-edit-form",
      panel: Cfg.CSS + "authors-editable-edit-form-panel",
      modal: Cfg.CSS + "universal-modal"
    },
    lsi: () => Plus4U5.Environment.Lsi.App.authors
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {},
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {};
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    return {
      // authorList: this.props.authors,
      addFormActive: false
    };
  },

  componentWillReceiveProps(nextProps) {
    // this.setState({
    //   authorList: nextProps.authors
    // });
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  getAuthors() {
    return this.props.authors;
    // return this.state.authorList;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  _findAuthorIndex(authorToFind, authors) {
    return authors.findIndex(
      author =>
        (author.uuIdentity && author.uuIdentity === authorToFind.uuIdentity) ||
        (!author.uuIdentity && author.code && author.code === authorToFind.code)
      // || (!author.uuIdentity && !author.code && author.id && author.id === authorToFind.id)
    );
  },

  _addAuthor(values, controls) {
    let { onChange, authors } = this.props;

    let newAuthor = {
      name: values.name,
      role: values.role,
      content: values.content
    };
    if (values.photo) {
      newAuthor.photoFile = values.photo;
      newAuthor.src = URL.createObjectURL(values.photo);
    }
    values.uuId ? (newAuthor.uuIdentity = values.uuId) : (newAuthor.code = UU5.Common.Tools.generateUUID(8));

    let newAuthors = [...authors, newAuthor];
    if (typeof onChange === "function") onChange({ authors: newAuthors });

    this.setState({ addFormActive: false });
  },

  _onEditSave(values, controls) {
    let { onChange, authors } = this.props;
    let editedAuthor = {
      name: values.name,
      role: values.role,
      content: values.content,
      uuIdentity: values.uuId,
      code: values.code
    };
    if (values.photo instanceof Blob) {
      editedAuthor.photoFile = values.photo;
      editedAuthor.src = URL.createObjectURL(values.photo);
    } else if (!values.photo) {
      editedAuthor.photoFile = null;
      editedAuthor.src = null;
    }
    let authorIndex = this._findAuthorIndex(editedAuthor, authors);
    if (authorIndex !== -1) {
      // preserve unknown / uneditable fields (e.g. "signature")
      for (let k in authors[authorIndex]) {
        if (!(k in editedAuthor)) editedAuthor[k] = authors[authorIndex][k];
      }
      Object.keys(editedAuthor).forEach(k => {
        if (editedAuthor[k] == null) delete editedAuthor[k];
      });

      let newAuthors = [...authors];
      newAuthors[authorIndex] = editedAuthor;
      if (typeof onChange === "function") onChange({ authors: newAuthors });

      this._modalRef.close();
    }
  },

  _onEditCancel() {
    this._modalRef.close();
  },

  _openDeleteAuthorModal(author) {
    this._modalRef.open({
      header: <UU5.Bricks.Span content={this.getLsiComponent("authorsEditableDeleteHeader")} />,
      content: (
        <AboutDeleteForm
          ref_={r => (this._aboutDeleteForm = r)}
          content={this.getLsiComponent("authorsEditableDeleteText")}
          onSave={this._onDeleteSave.bind(this, author)}
          onCancel={this._onDeleteCancel}
        />
      ),
      className: this.getClassName("modal"),
      size: "m"
    });
  },

  _onDeleteSave(author) {
    let { onChange, authors } = this.props;
    let index = this._findAuthorIndex(author, authors);
    if (index !== -1) {
      let newAuthors = [...authors];
      newAuthors.splice(index, 1);
      if (typeof onChange === "function") onChange({ authors: newAuthors });
    }
    this._modalRef.close();
  },
  _onDeleteCancel() {
    this._modalRef.close();
  },

  _openAddAuthorForm() {
    this.setState({ addFormActive: true });
  },
  _onCloseAddAuthor() {
    this.setState({ addFormActive: false });
  },

  _openEditAuthorForm(author) {
    let data = {
      name: author.name,
      role: author.role,
      content: author.content,
      uuId: author.uuIdentity,
      code: author.code,
      photo: author.photoFile || (author.src ? { url: author.src } : undefined)
    };

    this._modalRef.open({
      header: <UU5.Bricks.Span content={this.getLsiComponent("authorsEditableEditHeader")} />,
      content: (
        <AuthorsEditableModalForm
          author={data}
          languages={this.props.languages}
          onSave={this._onEditSave}
          onCancel={this._onEditCancel}
        />
      ),
      className: this.getClassName("modal"),
      size: "l",
      stickyBackground: true
    });
  },

  _onListControllerChange(opt) {
    opt.component.onChangeDefault(opt);

    let { onChange, authors } = this.props;
    if (typeof onChange === "function") onChange({ authors: opt.data });
  },

  _setModalRef(ref) {
    this._modalRef = ref;
  },

  _onTileDrop({ item, before, component }) {
    let { onChange, authors } = this.props;
    if (typeof onChange === "function") {
      let aroundAuthor = component.props.data;
      let droppedAuthor = item;
      let index = aroundAuthor ? this._findAuthorIndex(aroundAuthor, authors) : authors.length; // aroundAuthor might be null if we dropped it onto "+" tile
      if (index === -1) return; // shouldn't happen
      let droppedAuthorIndex = this._findAuthorIndex(droppedAuthor, authors); // can be -1 (if it is from another list, e.g. otherAuthors)
      let newAuthors = [...authors];
      let atIndex = before ? index : index + 1;
      newAuthors.splice(atIndex, 0, droppedAuthor);
      if (droppedAuthorIndex !== -1) {
        newAuthors.splice(atIndex <= droppedAuthorIndex ? droppedAuthorIndex + 1 : droppedAuthorIndex, 1);
      }
      onChange({ authors: newAuthors });
    }
  },

  _getTileListData(authors) {
    // add "id" field on authors so that tiles are draggable
    authors.forEach(author => {
      if (!author.id) {
        Object.defineProperty(author, "id", {
          get() {
            return author.uuIdentity || author.code;
          },
          set(v) {
            delete author.id;
            author.id = v;
          },
          configurable: true,
          enumerable: false
        });
      }
    });
    return [...authors, null]; // extra item for "+" tile
  },

  _getTile(props) {
    let { _index, _columnIndex, _list, ...tileProps } = props;
    let result;
    if (!_list[_index] && (_list[_index - 1] || _index === 0)) {
      let cardClassName;
      if (_columnIndex === 0) {
        cardClassName = Css.css`min-height: ${
          this.isXs() || this.isS() ? (this.props.small ? 236 : 256) : this.props.small ? 196 : 216
        }px;`;
      }
      result = (
        <AuthorsEditableIconTile
          {...tileProps}
          icon="mdi-account-plus"
          onClick={this._openAddAuthorForm}
          small={this.props.small}
          cardClassName={cardClassName}
        />
      );
    } else if (!_list[_index]) {
      result = null;
    } else {
      result = (
        <AuthorsEditableTile
          {...tileProps}
          draggable
          editAuthor={this._openEditAuthorForm}
          deleteAuthor={this._openDeleteAuthorModal}
          small={this.props.small}
        />
      );
    }
    return result;
  },

  _getChild() {
    return (
      <UU5.Bricks.Div {...this.getMainPropsToPass()}>
        <TileList
          data={this._getTileListData(this.props.authors)}
          onDrop={this._onTileDrop}
          tileMinWidth={this.props.small ? 150 : 200}
          tileMaxWidth={this.isXs() || this.isS() ? 400 : this.props.small ? 200 : 264}
          tileElevation={this.isXs() || this.isS() ? 1 : 0}
          tileElevationHover={1}
          tileSpacing={8}
          rowSpacing={8}
          tile={this._getTile}
        />

        <AuthorsEditableInlineForm
          languages={this.props.languages}
          onClose={this._onCloseAddAuthor}
          onSave={this._addAuthor}
          addFormActive={this.state.addFormActive}
        />

        <UU5.Bricks.Modal controlled={false} ref_={this._setModalRef} />
      </UU5.Bricks.Div>
    );
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    return this._getChild();
  }
  //@@viewOff:render
});

export default AuthorsEditableList;
