/*!
 * UAF Licence for the uu5 software.
 * 
 * Copyright (c) 2016-present, Unicorn a.s.
 * All rights reserved.
 * 
 * Definitions
 * -----------
 * This licence agreement is based on the original "BSD Licence" published by
 * the Regents of the University of California in 1990.
 * 
 * The term "Software" means the uu5 package, its modules, components,
 * all program files, source code, examples, media, and documentation which are part
 * of the Software package, as well as any portion of them. The term "Author" means
 * Unicorn a.s. and all its subsidiaries and/or affiliates.
 * 
 * Licence Agreement
 * -----------------
 * 
 * Redistribution and use of this Software in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All derivative products containing user interface must display the following
 *    acknowledgement in the appropriate "About window" or website section accessible
 *    by all users of the product:
 * 
 *      This product includes following software developed by
 *      <a href="https://unicorn.com">Unicorn a.s.</a>:
 *      <a href="https://uuos9.plus4u.net/uu-dockitg01-main/78462435-86b4d5a4a030400784764ebdb972bbda/book">UAF</a>,
 *      <a href="https://uuos9.plus4u.net/uu-dockitg01-main/78462435-ed11ec379073476db0aa295ad6c00178/book">uu5</a>.
 * 
 * 4. All derivative products must not block the default uu5 browser console message containing
 *    Software version information and copyright notice of the Author.
 * 
 * 5. The use of any portion of this Software is not allowed in the products
 *    that fully or partially resemble the functionality of the Software
 *    or otherwise compete with the Software unless they are licenced under the same licence
 *    conditions and provided free of charge. Specific prior written permission is required otherwise.
 * 
 * 6. Neither the name of the Author nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * Disclaimer
 * ----------
 * THIS SOFTWARE IS PROVIDED BY AUTHOR "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(window["__webpack_jsonp_uu5richtextg01_1_12_1_uu5richtextg01"] = window["__webpack_jsonp_uu5richtextg01_1_12_1_uu5richtextg01"] || []).push([[3],{

/***/ 284:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var draft_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(105);
/* harmony import */ var draft_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(draft_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _bricks_defaults_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var _toolbar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(285);
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(278);
/* harmony import */ var _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(291);
/* harmony import */ var _bricks_plugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(292);
/* harmony import */ var _bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(280);
/* harmony import */ var _plugins_plugin_factory_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(84);
/* harmony import */ var _plugins_uu5_plugins_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(7);
/* harmony import */ var _editor_less__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(294);
/* harmony import */ var _editor_less__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_editor_less__WEBPACK_IMPORTED_MODULE_13__);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//@@viewOn:imports








 // bricks





 //@@viewOff:imports

var IS_IE = navigator.userAgent.match("Trident");
var EmptyUU5String = /^<uu5string\s*\/>$/;
var Editor = Object(_context_js__WEBPACK_IMPORTED_MODULE_3__["withEditorContext"])(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.BaseMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config_js__WEBPACK_IMPORTED_MODULE_5__["default"].TAG + "Editor",
    classNames: {
      main: function main(props, state) {
        return _config_js__WEBPACK_IMPORTED_MODULE_5__["default"].CSS + "editor" + (state.customToolbar && state.focused && props.dynamicToolbar || !props.dynamicToolbar ? " " + uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Css.css("\n                .public-DraftEditor-content,\n                .public-DraftEditorPlaceholder-root {\n                  padding-top: 40px;\n                }\n\n                && .public-DraftEditor-content::before {\n                  width: calc(100% + 16px);\n                  ".concat(props.animatedToolbar ? "transition-delay: 0.5s;" : "", "\n                }\n              ")) : "") + " " + uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Css.css("\n            .public-DraftEditorPlaceholder-root {\n              line-height: 1.5;\n            }\n\n            .public-DraftEditor-content {\n              ".concat(IS_IE ? "\n                    overflow-x: hidden;\n                    overflow-y: auto;\n                  " : "\n                    display: flex;\n                    flex-direction: column;\n                    align-items: stretch;\n\n                    & > div {\n                      overflow-x: hidden;\n                      overflow-y: auto;\n                    }\n                  ", "\n              height: ").concat(typeof props.height === "number" ? props.height + "px" : props.height, ";\n              min-height: ").concat(typeof props.minHeight === "number" ? props.minHeight + "px" : props.minHeight, ";\n              max-height: ").concat(typeof props.maxHeight === "number" ? props.maxHeight + "px" : props.maxHeight, ";\n            }\n          ")) + (props.animatedToolbar ? " " + uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Css.css("\n                .public-DraftEditor-content,\n                .public-DraftEditorPlaceholder-root {\n                  transition: padding-top 0.5s;\n                }\n              ") : "") + (props.readOnly ? " " + uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Css.css("\n                .public-DraftEditor-content {\n                  border-color: rgba(189, 189, 189, .24);\n                  background-color: rgba(255, 255, 255, .24);\n                }\n              ") : "");
      },
      bgstyleTransparent: _config_js__WEBPACK_IMPORTED_MODULE_5__["default"].CSS + "editor-transparent"
    },
    lsi: function lsi() {
      return uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Environment.Lsi.RichText.editor;
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    value: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string,
    buttons: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.arrayOf(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string),
    plugins: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.arrayOf(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.object), uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.object]),
    readOnly: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool,
    onChange: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.func,
    onBlur: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.func,
    onFocus: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.func,
    pluginExtensions: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.object,
    handleKeyCommand: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool,
    getToolbar: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.func,
    placeholder: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string,
    forceRenderModal: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool,
    bgStyle: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOf(["outline", "transparent"]),
    height: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.number, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string]),
    minHeight: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.number, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string]),
    maxHeight: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.number, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string]),
    animatedToolbar: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool,
    dynamicToolbar: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool,
    inline: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.bool
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      value: "",
      buttons: undefined,
      readOnly: undefined,
      onChange: null,
      onBlur: null,
      onFocus: null,
      plugins: null,
      pluginExtensions: undefined,
      handleKeyCommand: true,
      getToolbar: null,
      forceRenderModal: false,
      bgStyle: "outline",
      height: "auto",
      minHeight: "106px",
      maxHeight: "none",
      animatedToolbar: true,
      dynamicToolbar: true,
      inline: false
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    // process plugins - add UU5StringPlugin to be the last plugin - it returns universal component for each style, entity or block
    this._plugins = _bricks_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"].mergePlugins(this.props, _plugins_uu5_plugins_js__WEBPACK_IMPORTED_MODULE_12__["default"]).map(function (plugin) {
      return _plugins_plugin_factory_js__WEBPACK_IMPORTED_MODULE_11__["default"].createPluginFromDefinition(plugin);
    }); // sort plugins from the highest order to the lowest

    this._plugins.sort(function (p1, p2) {
      return p2.order - p1.order;
    });

    var config = _bricks_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"].processPlugins(this._plugins, this.props.pluginExtensions);

    var _buttonMap = config.buttonMap || {}; // map of button definitions fro toolbar


    this._areaConfig = config.areaConfig; // configuration for editor

    this._htmlMappings = config.htmlMappings; // mapping from html to components
    // get data for buttons from buttons defined by plugins

    var _toolbarButtons = this.props.buttons === undefined ? _bricks_defaults_js__WEBPACK_IMPORTED_MODULE_4__["EDITOR_BUTTONS"] : this.props.buttons;

    _toolbarButtons = _toolbarButtons && _toolbarButtons.reduce(function (toolbarButtons, buttonName) {
      if (_buttonMap[buttonName]) {
        toolbarButtons.push(_buttonMap[buttonName]);
      }

      return toolbarButtons;
    }, []);
    return {
      areaLoaded: false,
      buttons: _toolbarButtons,
      customToolbar: false
    };
  },
  componentDidCatch: function componentDidCatch(error) {
    // all components is unmounted ... we need to save error data to local variables and wait for call of register functions
    // in them set data to editor and show error message
    var editorState = this.getArea().getEditorState();
    uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.error(error, {
      editorState: editorState
    }); // save previous editor state

    this._errorEditorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].redo(editorState); // save error to alert bus

    this._errorMsg = this.getLsiValue("editorError"); // forse rerender of component - all child components will be mounted again

    this.forceUpdate();
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  setValue: function setValue(uu5string, opt, setStateCallback) {
    var focus = false;
    var propsFormatter;

    switch (_typeof(opt)) {
      case "object":
        if (opt) {
          focus = opt.focus !== undefined ? opt.focus : focus;
          propsFormatter = opt.propsFormatter;
        }

        break;

      case "function":
        propsFormatter = opt;
        break;

      case "boolean":
        focus = opt;
        break;
    }

    var editorState;

    if (!uu5string || EmptyUU5String.test(uu5string)) {
      editorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].createEmpty(new draft_js__WEBPACK_IMPORTED_MODULE_2__["CompositeDecorator"](this._areaConfig.decorators));
    } else {
      try {
        editorState = _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].uu5stringToEditorState(uu5string, this._areaConfig.decorators, this._getEditorItem, propsFormatter);
      } catch (e) {
        this.setError(this.getLsiValue("uu5stringToEditorError"), {
          e: e,
          uu5string: uu5string
        });
      }
    }

    this._area.setEditorState(editorState, focus, setStateCallback);

    return editorState;
  },
  getValue: function getValue() {
    var editorState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._area.getEditorState();
    var formatter = arguments.length > 1 ? arguments[1] : undefined;

    try {
      return _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].editorStateToUU5String(editorState, this._getUU5Item, formatter);
    } catch (e) {
      this.setError(this.getLsiValue("editorStateToUu5stringError"), {
        editorState: editorState,
        e: e
      });
    }
  },
  getArea: function getArea() {
    return this._area;
  },
  focus: function focus() {
    this._focus();
  },
  setCursorPosition: function setCursorPosition(cursorPosition) {
    this._focus(cursorPosition);
  },
  isMultiline: function isMultiline() {
    var uu5stringOrEditorState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._area.getEditorState();
    return Editor.isMultiline(uu5stringOrEditorState, this._plugins);
  },
  setError: function setError(msg, e) {
    if (this._alertBus) {
      this._alertBus.setAlert({
        content: msg
      });
    }

    uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.error(msg, e);
  },
  setInfo: function setInfo(msg) {
    if (this._alertBus) {
      this._alertBus.setAlert({
        content: msg,
        colorSchema: "primary"
      });
    }
  },
  //@@viewOff:interface
  //@@viewOn:overriding
  //@@viewOff:overriding
  //@@viewOn:private
  _focus: function _focus() {
    var cursorPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";
    this.getArea().focus();

    if (cursorPosition === "start") {
      this.getArea().setEditorState(_bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__["default"].moveSelectionToStart(this.getArea().getEditorState()));
    } else if (cursorPosition === "end") {
      this.getArea().setEditorState(_bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__["default"].moveSelectionToEnd(this.getArea().getEditorState()));
    }
  },
  _onChange: function _onChange(area, editorState) {
    if (typeof this.props.onChange === "function") {
      editorState = this.props.onChange(this, editorState) || editorState;
    }

    return editorState;
  },
  _onBlur: function _onBlur(e) {
    if (typeof this.props.onBlur === "function") {
      this.props.onBlur(e, this);
    }

    if (typeof this.props.getToolbar === "function") {
      var toolbar = this.props.getToolbar();
      if (toolbar) toolbar.setItems(this, []);
    } else {
      this.setState({
        focused: false
      });
    }
  },
  _registerToolbar: function _registerToolbar(toolbar) {
    this._toolbar = toolbar;

    if (this.props.getToolbar !== "function") {
      if (!this.props.dynamicToolbar) {
        this._toolbar.setItems(this, this.state.buttons);
      }

      this.setState({
        customToolbar: true
      });
    }
  },
  _registerArea: function _registerArea(area) {
    this._area = area; // init area

    if (this._errorEditorState) {
      this._areaConfig.editorState = this._errorEditorState;
      delete this._errorEditorState;
    } else if (this.props.value) {
      try {
        this._areaConfig.editorState = _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].uu5stringToEditorState(this.props.value, this._areaConfig.decorators, this._getEditorItem);
      } catch (e) {
        this.setError(this.getLsiValue("uu5stringToEditorError"), {
          e: e,
          value: this.props.value
        });
      }
    }

    this._area.set(this._areaConfig);

    this.setState({
      areaLoaded: true
    });
  },
  _registerAlertBus: function _registerAlertBus(alertBus) {
    this._alertBus = alertBus;

    if (this._errorMsg) {
      this._alertBus.setAlert({
        content: this._errorMsg
      });

      delete this._errorMsg;
    }
  },
  _getArea: function _getArea() {
    return this._area;
  },
  _getToolbar: function _getToolbar() {
    if (typeof this.props.getToolbar === "function") {
      return this.props.getToolbar();
    }

    return this._toolbar;
  },
  _getUU5Item: function _getUU5Item(type, name, props, wrapper, wrapperProps, isEmpty) {
    var result;

    for (var index = 0; index < this._plugins.length; index++) {
      var plugin = this._plugins[index];

      if (typeof plugin.toUU5Item === "function") {
        result = plugin.toUU5Item(type, name, props, wrapper, wrapperProps, isEmpty);
        if (result) break;
      }
    }

    return result;
  },
  _getEditorItem: function _getEditorItem(name, props, children, wrapper, wrapperProps) {
    return Editor._getEditorItem(this._plugins, name, props, children, wrapper, wrapperProps);
  },
  _handlePaste: function _handlePaste(text, html, editorState) {
    var uu5string;

    if (html) {
      var fragment = document.createElement("html");
      fragment.innerHTML = html; // build tag props tree and process by standard data conversion from html to content

      var body = fragment.getElementsByTagName("body")[0];

      if (body) {
        try {
          // eslint-disable-next-line react/no-find-dom-node
          var currentNode = this.findDOMNode(); // find content root node - contains better styles to filter

          var contentNode = currentNode && currentNode.querySelector(".public-DraftEditor-content");
          uu5string = _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].parseHtmlNodeListToUu5stringObject(body.childNodes, this._htmlMappings, currentNode ? getComputedStyle(contentNode || currentNode) : null);
        } catch (e) {
          this.setError(this.getLsiValue("htmlParseError"), {
            html: body,
            e: e
          });
        }
      }
    } else if (uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.UU5String.isValid(text)) {
      uu5string = text;
    }

    if (uu5string) {
      var newSelection;
      var blockDataMap = {};
      var raw;

      try {
        raw = _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].uu5stringToRaw(uu5string, blockDataMap, this._getEditorItem);
      } catch (e) {
        this.setError(this.getLsiValue("uu5stringToEditorError"), {
          uu5string: uu5string,
          e: e
        });
        return;
      }

      var toRemove = [];

      for (var i = 0; i < raw.blocks.length; i++) {
        var block = raw.blocks[i];

        if (!block.text && block._uu5richTextDataCollector) {
          toRemove.push(i);
        }
      } // remove empty helping blocks ( uu5richTextDataCollector )


      for (var _i = toRemove.length - 1; _i >= 0; _i--) {
        var indexToRemove = toRemove[_i];
        raw.blocks.splice(indexToRemove, 1);
      }

      var newContentState = editorState.getCurrentContent();
      var selection = editorState.getSelection(); // add current content state into history stack

      var undoStack = editorState.getUndoStack().push(newContentState);

      if (!editorState.getSelection().isCollapsed()) {
        newContentState = draft_js__WEBPACK_IMPORTED_MODULE_2__["Modifier"].removeRange(newContentState, selection, selection.isBackward ? "backward" : "forward");
        selection = _bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__["default"].collapseToStart(selection);
      } // check if all of created blocks are unstyled or artificial -> insert whole content into current block and dont split blocks


      var shouldSplitBLocks = !raw.blocks.every(function (block) {
        return block.type === "unstyled" && !block._uu5richTextDataCollector && !blockDataMap[block.key] || blockDataMap[block.key] && blockDataMap[block.key].artificial && Object.keys(blockDataMap[block.key]).length === 1;
      }); // if all text will be pasted into current block, empty blockDataMap

      if (!shouldSplitBLocks) {
        blockDataMap = {};
      }

      if (shouldSplitBLocks) {
        // not needed to slit block if cursor is at the end of the selected block
        if (newContentState.getBlockForKey(selection.getStartKey()).getText().length > selection.getStartOffset()) {
          newContentState = draft_js__WEBPACK_IMPORTED_MODULE_2__["Modifier"].splitBlock(newContentState, selection);
        }
      } // merge raw


      var currentRaw = Object(draft_js__WEBPACK_IMPORTED_MODULE_2__["convertToRaw"])(newContentState); // find block with focus

      var selectedBlockIndex = currentRaw.blocks.findIndex(function (block) {
        return block.key === selection.anchorKey;
      });
      var directionMap = editorState.getDirectionMap();
      var direction = directionMap.get(selection.anchorKey); // update entity map

      var entityKeyOffset = Object.keys(currentRaw.entityMap).length;

      for (var index = 0; index < raw.blocks.length; index++) {
        var _block = raw.blocks[index]; // update entity keys to prevent colisions with raw and current raw

        for (var eIndex = 0; eIndex < _block.entityRanges.length; eIndex++) {
          var entityRange = _block.entityRanges[eIndex];
          entityRange.key += entityKeyOffset;
        } // prepare map of block directions when we add block into content


        if (shouldSplitBLocks) {
          directionMap = directionMap.set(_block.key, direction);
        }
      } // merge entities from raw to currentRaw


      for (var entityKey in raw.entityMap) {
        currentRaw.entityMap[parseInt(entityKey) + entityKeyOffset + ""] = raw.entityMap[entityKey];
      }

      if (shouldSplitBLocks) {
        // splice blocks into current raw
        if (currentRaw.blocks[selectedBlockIndex].text) {
          var _currentRaw$blocks;

          (_currentRaw$blocks = currentRaw.blocks).splice.apply(_currentRaw$blocks, [selectedBlockIndex + 1, 0].concat(_toConsumableArray(raw.blocks)));
        } else {
          var _currentRaw$blocks2;

          // replace empty block
          (_currentRaw$blocks2 = currentRaw.blocks).splice.apply(_currentRaw$blocks2, [selectedBlockIndex, 1].concat(_toConsumableArray(raw.blocks)));
        } // move cursor after last added block


        var lastAddedBlock = raw.blocks[raw.blocks.length - 1];
        newSelection = {
          startOffset: lastAddedBlock.text.length,
          endOffset: lastAddedBlock.text.length,
          startKey: lastAddedBlock.key,
          endKey: lastAddedBlock.key
        };
      } else {
        var _selectedBlock$inline;

        // insert text into current block
        var selectedBlock = currentRaw.blocks[selectedBlockIndex];
        var resultText = selectedBlock.text.substring(0, selection.anchorOffset);
        var textOffset = resultText.length;
        var pastedTextLength = 0;
        var pasteInsideEntity = false;
        raw.blocks.forEach(function (block) {
          return pastedTextLength += block.text.length;
        }); // update positions of all styles and entities in block

        selectedBlock.entityRanges.forEach(function (range) {
          if (range.offset >= textOffset) {
            // entity is after cursor -> move start of entity after end of inserted text
            range.offset += pastedTextLength;
          } else if (range.offset + range.length >= textOffset) {
            // paste inside entity -> update length of entity to contain pasted text and mark paste as inside entity to remove all entities from pasted text
            pasteInsideEntity = true;
            range.length += pastedTextLength;
          }
        }); // update inline styles

        var splitStyles = [];

        for (var _i2 = 0; _i2 < selectedBlock.inlineStyleRanges.length; _i2++) {
          var range = selectedBlock.inlineStyleRanges[_i2];

          if (range.offset >= textOffset) {
            // style is after cursor -> move style after end of inserted text
            range.offset += pastedTextLength;
          } else if (range.offset + range.length >= textOffset) {
            // paste text inside style - split style into two parts
            var styleBeforeLength = textOffset - range.offset;
            var styleAfterLength = range.length - styleBeforeLength;
            range.length = styleBeforeLength;

            var newRange = _objectSpread({}, range);

            newRange.offset = textOffset + pastedTextLength;
            newRange.length = styleAfterLength;
            splitStyles.push(newRange);
          }
        } // add splited parts of inline styles into inlineStyleRanges


        (_selectedBlock$inline = selectedBlock.inlineStyleRanges).push.apply(_selectedBlock$inline, splitStyles);

        for (var blockIndex = 0; blockIndex < raw.blocks.length; blockIndex++) {
          textOffset = resultText.length;
          var _block2 = raw.blocks[blockIndex];
          resultText += _block2.text;

          if (!pasteInsideEntity) {
            for (var entityIndex = 0; entityIndex < _block2.entityRanges.length; entityIndex++) {
              var _range = _block2.entityRanges[entityIndex];
              _range.offset += textOffset;
              selectedBlock.entityRanges.push(_range);
            }
          }

          for (var styleIndex = 0; styleIndex < _block2.inlineStyleRanges.length; styleIndex++) {
            var style = _block2.inlineStyleRanges[styleIndex];
            style.offset += textOffset;
            selectedBlock.inlineStyleRanges.push(style);
          }
        }

        resultText += selectedBlock.text.substring(selection.anchorOffset);
        selectedBlock.text = resultText;
        var newSelectionOffset = selection.getStartOffset() + pastedTextLength;
        newSelection = {
          startOffset: newSelectionOffset,
          endOffset: newSelectionOffset,
          startKey: selection.getStartKey(),
          endKey: selection.getEndKey()
        };
      }

      newContentState = Object(draft_js__WEBPACK_IMPORTED_MODULE_2__["convertFromRaw"])(currentRaw);

      if (newSelection) {
        // update selection and selection history
        var _newEditorState = _bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__["default"].updateSelection(editorState, newSelection);

        newSelection = _newEditorState.getSelection();
        newContentState = newContentState.set("selectionBefore", editorState.getSelection());
        newContentState = newContentState.set("selectionAfter", _newEditorState.getSelection());
      }

      var newEditorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].set(editorState, {
        currentContent: newContentState,
        selection: newSelection || selection,
        directionMap: directionMap,
        undoStack: undoStack
      }); // set data into editor state

      for (var blockKey in blockDataMap) {
        var content = draft_js__WEBPACK_IMPORTED_MODULE_2__["Modifier"].setBlockData(newEditorState.getCurrentContent(), _bricks_selection_js__WEBPACK_IMPORTED_MODULE_10__["default"].modifySelection(editorState, {
          anchorKey: blockKey,
          focusKey: blockKey,
          anchorOffset: 0,
          focusOffset: 0
        }), blockDataMap[blockKey]);
        newEditorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].set(newEditorState, {
          currentContent: content
        });
      }

      var newContent = newEditorState.getCurrentContent();
      newContent = newContent.set("selectionAfter", newEditorState.getSelection());
      newEditorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].set(newEditorState, {
        currentContent: editorState.getCurrentContent(),
        selection: editorState.getSelection()
      });
      newEditorState = draft_js__WEBPACK_IMPORTED_MODULE_2__["EditorState"].push(newEditorState, newContent, "paste uu5string");
      this.getArea().setEditorState(newEditorState);
      return true; // handled
    }

    return false; // let handling of text to draft
  },
  _showToolbar: function _showToolbar() {
    return typeof this.props.getToolbar !== "function";
  },
  _handleFocus: function _handleFocus(event) {
    if (typeof this.props.onFocus === "function") this.props.onFocus(event);

    if (typeof this.props.getToolbar === "function") {
      var toolbar = this.props.getToolbar();
      if (toolbar) toolbar.setItems(this, this.state.buttons);
    } else {
      this.setState({
        focused: true
      });
    }
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    var mainAttrs = this.getMainAttrs();

    if (this.props.bgStyle === "transparent") {
      mainAttrs.className += " ".concat(this.getClassName("bgstyleTransparent"));
    }

    return uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("div", mainAttrs, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Bricks.AlertBus, {
      ref_: this._registerAlertBus,
      colorSchema: "danger",
      closeTimer: 5000
    }), uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(_area_js__WEBPACK_IMPORTED_MODULE_7__["default"], {
      ref_: this._registerArea,
      onChange: this._onChange,
      onBlur: this._onBlur,
      onFocus: this._handleFocus,
      readOnly: this.props.readOnly,
      getToolbar: this._getToolbar,
      handleKeyCommand: this.props.handleKeyCommand,
      onPaste: this._handlePaste,
      placeholder: this.props.placeholder,
      forceRenderModal: this.props.forceRenderModal,
      key: "area",
      id: "area"
    }), this._showToolbar() && uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(_toolbar_js__WEBPACK_IMPORTED_MODULE_6__["default"], {
      ref_: this._registerToolbar,
      className: this.getClassName("toolbar"),
      items: this.state.focused ? this.state.buttons : undefined,
      getArea: this._getArea,
      disabled: !this.state.areaLoaded || this.props.readOnly,
      key: "toolbar",
      id: "toolbar",
      animated: this.props.animatedToolbar,
      dynamic: this.props.dynamicToolbar
    }));
  } //@@viewOff:render

}));

Editor.isMultiline = function (uu5stringOrEditorState, plugins) {
  // uu5stringOrEditorState and plugins are mandatory
  if (!uu5stringOrEditorState || !plugins) {
    var msg = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.getLSIItemByLanguage(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Environment.Lsi.RichText.editor.mandatoryMethodParams);
    uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.error(msg, {
      uu5string: uu5stringOrEditorState ? "OK" : "Missing",
      plugins: plugins ? "OK" : "Missing"
    });
    throw msg;
  }

  var editorState;

  if (typeof uu5stringOrEditorState === "string") {
    var mergedPlugins = _bricks_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"].mergePlugins({
      plugins: plugins
    }, _plugins_uu5_plugins_js__WEBPACK_IMPORTED_MODULE_12__["default"]).map(function (plugin) {
      return _plugins_plugin_factory_js__WEBPACK_IMPORTED_MODULE_11__["default"].createPluginFromDefinition(plugin);
    }); // sort plugins from the highest order to the lowest

    mergedPlugins.sort(function (p1, p2) {
      return p2.order - p1.order;
    });
    var config = _bricks_plugin_js__WEBPACK_IMPORTED_MODULE_9__["default"].processPlugins(mergedPlugins);

    try {
      editorState = _bricks_data_conversion_js__WEBPACK_IMPORTED_MODULE_8__["default"].uu5stringToEditorState(uu5stringOrEditorState, config.areaConfig.decorators, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Editor._getEditorItem.apply(Editor, [mergedPlugins].concat(args));
      });
    } catch (e) {
      var _msg = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.getLSIItemByLanguage(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Environment.Lsi.RichText.editor.uu5stringToEditorError);

      uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.error(_msg, {
        e: e,
        uu5string: uu5stringOrEditorState
      });
      throw _msg;
    }
  } else {
    editorState = uu5stringOrEditorState;
  } // check if editorState has more blocks


  var blocks = editorState.getCurrentContent().getBlocksAsArray();

  if (blocks.length > 1) {
    return true;
  }

  return !!blocks[0].getText().match(/\n/);
};

Editor._getEditorItem = function (plugins, name, props, children, wrapper, wrapperProps) {
  var result = {
    matchRate: 0
  };

  var _res;

  for (var index = 0; index < plugins.length; index++) {
    var plugin = plugins[index];

    if (typeof plugin.toEditorItem === "function") {
      _res = plugin.toEditorItem(name, props, children, wrapper, wrapperProps);

      if (_res && _res.matchRate === undefined) {
        return _res;
      } else if (_res && _res.matchRate > result.matchRate) {
        result = _res;
        if (result.matchRate === 1) break;
      }
    }
  }

  return result.matchRate ? result : undefined;
};

/* harmony default export */ __webpack_exports__["default"] = (Editor);

/***/ }),

/***/ 291:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var draft_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(105);
/* harmony import */ var draft_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(draft_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _bricks_uu5string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _bricks_selection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(280);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }





var DEFAULT_TAG_ORDER = 50;

var getEmptyRaw = function getEmptyRaw() {
  return {
    blocks: [{
      type: "unstyled",
      text: "",
      inlineStyleRanges: [],
      entityRanges: [],
      depth: 0,
      key: Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["genKey"])()
    }],
    entityMap: {}
  };
};

var createPropsFormatterFn = function createPropsFormatterFn(propsFormatter) {
  return function (props) {
    if (typeof propsFormatter === "function") {
      return propsFormatter(props);
    }

    return props;
  };
};

var removeInputSupportCharacters = function removeInputSupportCharacters(string) {
  return string.replace(/[\u200b-\u200d]/g, "");
};

var formatInputString = function formatInputString(string) {
  return string.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&");
};

var removeOutputSupportCharacters = function removeOutputSupportCharacters(string) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    escapeXml: true,
    preserveEnters: false
  },
      _ref$escapeXml = _ref.escapeXml,
      escapeXml = _ref$escapeXml === void 0 ? true : _ref$escapeXml,
      _ref$preserveEnters = _ref.preserveEnters,
      preserveEnters = _ref$preserveEnters === void 0 ? false : _ref$preserveEnters;

  // remove zero width spaces
  var result = string.replace(/[\u200b-\u200d]/g, "");

  if (escapeXml) {
    // escape all & characters
    result = result.replace(/&/g, "&amp;"); // escape < and > characters

    result = result.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  if (!preserveEnters) {
    result = result.replace(/\n/g, "<br />");
  } // replace newlines


  return result;
};

var shouldReplaceBrForEnter = function shouldReplaceBrForEnter(raw, uu5stringObject, parentBlock, blockDataMap) {
  // check if uu5stringObject is br tag
  if (uu5stringObject.tag !== "br") return false; // if br has parent block it is break line not empty block

  if (parentBlock) return true; // check if it is not first block

  if (raw.blocks.length === 0) return false; // check if br is a part of artificail block

  var lastBlockKey = raw.blocks[raw.blocks.length - 1].key;
  return blockDataMap[lastBlockKey].artificial;
};

var printOpeningTag = function printOpeningTag(tag, props, isSelfClosing, blockData) {
  if (!tag || blockData && blockData.artificial) return "";

  if (blockData && blockData.isEmpty && !isSelfClosing) {
    return "<".concat(tag).concat(printProps(props), ">\u200B</").concat(tag, ">");
  }

  return "<".concat(tag).concat(printProps(props)).concat(isSelfClosing ? " />" : ">");
};

var printClosingTag = function printClosingTag(tag, blockData) {
  if (!tag || blockData && blockData.artificial) return "";
  return "</".concat(tag, ">");
};

var printProps = function printProps(props) {
  if (!props) return "";
  var stringProps = "";

  for (var name in props) {
    var value = props[name];

    var type = _typeof(value); // handle number and boolean


    if (type === "number" || value === false) {
      stringProps += " ".concat(name, "=").concat(value);
      continue;
    } else if (value === true) {
      stringProps += " ".concat(name);
      continue;
    } // convert objects except null to uu5json


    if (type === "object" && value) {
      value = "<uu5json />".concat(JSON.stringify(value));
      type = "string";
    } // handle string - escape double quotes


    if (type === "string") {
      stringProps += " ".concat(name, "=\"").concat(value.replace(/(\\)*"/g, '$1$1\\"'), "\""); // escape double quotes
    }
  }

  return stringProps;
};

var tagComparator = function tagComparator(tag1, tag2) {
  if (tag1.offset !== tag2.offset) {
    return tag1.offset - tag2.offset;
  } // sort closing tags before opening


  if (tag1.type === "closing" && tag2.type === "opening") return -1;
  if (tag2.type === "closing" && tag1.type === "opening") return 1;

  if (tag1.type === "opening") {
    // both opening tags
    if (tag1.startOffset === tag2.startOffset) {
      // sort components before styles if they starts on tha same character
      if (tag1.componentType === "component" && tag2.componentType === "style") {
        return -1;
      }

      if (tag2.componentType === "component" && tag1.componentType === "style") {
        return 1;
      } // order style elements


      if (tag1.order !== tag2.order) {
        return tag2.order - tag1.order;
      } else {
        if (tag2.endOffset === tag1.endOffset) {
          return tag1.index - tag2.index;
        } else {
          return tag2.endOffset - tag1.endOffset;
        }
      }
    }

    return tag1.startOffset - tag2.startOffset;
  } else {
    // both closing tags
    if (tag1.endOffset === tag2.endOffset) {
      // sort components before styles if they starts on tha same character
      if (tag1.componentType === "component" && tag2.componentType === "style") {
        return 1;
      }

      if (tag2.componentType === "component" && tag1.componentType === "style") {
        return -1;
      } // order style elements


      if (tag1.order !== tag2.order) {
        return tag1.order - tag2.order;
      } else {
        if (tag2.startOffset === tag1.startOffset) {
          return tag2.index - tag1.index;
        } else {
          return tag2.startOffset - tag1.startOffset;
        }
      }
    }

    return tag1.endOffset - tag2.endOffset;
  }
};

var groupSeparatorMap = {
  wrapper: 4,
  block: 3,
  entity: 2,
  inline: 1
};

var getDisplayLevel = function getDisplayLevel(display) {
  // unknown component is count as an entity
  return groupSeparatorMap[display] || groupSeparatorMap["entity"];
};

var validateChildrenDisplay = function validateChildrenDisplay(parent, parentProps, children, getEditorItem, propsFormatter) {
  var maxLevel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "block";
  // create propsFormatter function
  var propsFormatterFn = createPropsFormatterFn(propsFormatter);
  var maxDisplayLevel = getDisplayLevel(maxLevel);
  var isValid = true;
  children.forEach(function (child) {
    if (typeof child === "string") return;
    var ancestors = child.props.toObject().content || child.children;
    var childEditorItem = child.cachedEditorItem || getEditorItem(child.tag, propsFormatterFn(child.props.toObject()), ancestors, parent, parentProps);
    child.cachedEditorItem = childEditorItem;
    var childLevel = getDisplayLevel(childEditorItem.display);

    if (childLevel >= maxDisplayLevel) {
      isValid = false;
    }
  });
  return isValid;
};

var removeWhiteSpacesFromChildren = function removeWhiteSpacesFromChildren(string, children, prevWhiteSpace) {
  var parts = string.split(/(\s{2,})/g);

  if (parts) {
    // parts always have odd count of items
    if (parts[0]) {
      children.push(parts[0]);
      prevWhiteSpace.value = false;
    }

    for (var i = 1; i < parts.length; i += 2) {
      children.push(uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.parse("<uu5string /><UU5.RichText.Whitespace spaces=\"".concat(parts[i], "\" hidden=").concat(prevWhiteSpace.value, ">").concat(parts[i][0], "</UU5.RichText.Whitespace>"))[0]);
      prevWhiteSpace.value = true;

      if (parts[i + 1]) {
        children.push(parts[i + 1]);
        prevWhiteSpace.value = false;
      }
    }
  } else {
    children.push(string);
  }
};

var removeWhiteSpace = function removeWhiteSpace(uu5stringObject) {
  var prevWhiteSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    value: false
  };

  // children
  if (uu5stringObject.children) {
    var children = [];
    uu5stringObject.children.forEach(function (child) {
      if (typeof child === "string") {
        removeWhiteSpacesFromChildren(child, children, prevWhiteSpace);
      } else {
        children.push(removeWhiteSpace(child, prevWhiteSpace));
      }
    });
    uu5stringObject.children = children;
  } // content


  var contentProps = uu5stringObject.props && uu5stringObject.props.props.find(function (item) {
    return item.name === "content";
  });

  if (contentProps) {
    var content = [];
    var value = typeof contentProps.value === "string" ? [contentProps.value] : contentProps.value;
    value.forEach(function (child) {
      if (typeof child === "string") {
        // content.push(
        //   ...UU5.Common.UU5String.parse(
        //     "<uu5string />" +
        //       child.replace(/(\s{2,})/g, '<UU5.RichText.Whitespace spaces="$1"> </UU5.RichText.Whitespace>')
        //   )
        // );
        removeWhiteSpacesFromChildren(child, content, prevWhiteSpace);
      } else {
        content.push(removeWhiteSpace(child));
      }
    });
    contentProps.value = content;
  }

  return uu5stringObject;
};

var processBlockToRaw = function processBlockToRaw(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock) {
  var block = {
    key: Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["genKey"])(),
    text: "",
    type: "unstyled",
    depth: parentBlock ? parentBlock.depth + 1 : 0,
    inlineStyleRanges: [],
    entityRanges: []
  };
  raw.blocks.push(block); // if editorItem is block component create block by defined type, otherwise create unstyled block

  if (editorItem && editorItem.display === "block") {
    block.type = editorItem.type;
    blockDataMap[block.key] = editorItem.data;
  } else {
    blockDataMap[block.key] = {
      artificial: true
    };
  }

  if (children) {
    if (!Array.isArray(children)) {
      children = [children];
    }

    appendChildrenToBlock(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock);
  }

  return "";
};

var processEntityToRaw = function processEntityToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock) {
  var textOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var text = ""; // check content of entity - all nodes must be texts or inline components

  if (!validateChildrenDisplay(editorItem.type, editorItem.data ? editorItem.data.props : {}, children, getEditorItem, propsFormatter, "entity")) {
    throw "Unsupported structure of uu5string. Entity can contain only text or inline styles.";
  } // process all children


  children.forEach(function (child) {
    return text += processUU5StringObjectToRaw(raw, child, null, getEditorItem, propsFormatter, parentBlock, textOffset + text.length);
  }); // register entity to raw

  var data = editorItem.data; // inline component

  var entity = {
    offset: parentBlock.text.length + textOffset,
    length: text.length,
    key: raw.entityArray.length
  };
  parentBlock.entityRanges.push(entity);
  raw.entityArray.push({
    mutability: "MUTABLE",
    type: editorItem.type,
    data: data
  }); // cannot return empty text - that entity will not be rendered by editor. Add zws character as a content of selfclosed tags

  return text || "\u200B";
};

var processInlineToRaw = function processInlineToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock) {
  var textOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var text = ""; // check content of entity - all nodes must be texts or inline components

  if (!validateChildrenDisplay(editorItem.type, editorItem.data ? editorItem.data.props : {}, children, getEditorItem, propsFormatter, "block")) {
    throw "Unsupported structure of uu5string. Inline styles cannot contain blocks or wrappers.";
  } // process all children


  var offset = parentBlock.text.length;
  children.forEach(function (child) {
    return text += processUU5StringObjectToRaw(raw, child, null, getEditorItem, propsFormatter, parentBlock, textOffset + text.length);
  });
  var inlineStyle = {
    offset: offset + textOffset,
    length: text.length,
    style: editorItem.type
  };
  parentBlock.inlineStyleRanges.push(inlineStyle);
  return text;
};

var appendChildrenToBlock = function appendChildrenToBlock(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock) {
  var block = raw.blocks[raw.blocks.length - 1];
  children.forEach(function (child) {
    try {
      block.text += processUU5StringObjectToRaw(raw, child, blockDataMap, getEditorItem, propsFormatter, block);
    } catch (e) {
      var textLength;
      var textOffset = block.text.length;
      var key = raw.entityArray.length; // remove from raw all elements added by processing block

      if (typeof child === "string") {
        textLength = child.length;
        block.text += child;
      } else {
        var text = Object(_bricks_uu5string_js__WEBPACK_IMPORTED_MODULE_2__["removeSpecialNodes"])(child).toString();
        textLength = text.length;
        block.text += text;

        if (block.entityRanges) {
          block.entityRanges = block.entityRanges.filter(function (range) {
            var result = range.offset < textOffset;

            if (!result) {
              raw.entityarray[range.key] = undefined;
            }

            return result;
          });
        }

        if (block.inlineStyleRanges) {
          block.inlineStyleRanges = block.inlineStyleRanges.filter(function (range) {
            return range.offset < textOffset;
          });
        }
      }

      block.entityRanges = block.entityRanges || []; // add entity to block

      block.entityRanges.push({
        offset: textOffset,
        length: textLength,
        key: key
      }); // add entity

      raw.entityArray.push({
        type: "error",
        mutability: "MUTABLE"
      });
    }
  });
};

var appendUU5StringObjectToBlock = function appendUU5StringObjectToBlock(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter) {
  // try to append node into previous block node if last added block was added by algorithm
  var lastBlock = raw.blocks.length === 0 ? undefined : raw.blocks[raw.blocks.length - 1];
  var lastBlockData = lastBlock ? blockDataMap[lastBlock.key] : undefined;

  if (lastBlockData && lastBlockData.artificial || lastBlock && lastBlock._uu5richTextDataCollector) {
    if (typeof uu5stringObject === "string") {
      lastBlock.text += uu5stringObject;
    } else {
      appendChildrenToBlock(raw, undefined, [uu5stringObject], blockDataMap, getEditorItem, propsFormatter, lastBlock);
    }

    return lastBlock;
  }

  return processBlockToRaw(raw, undefined, [uu5stringObject], blockDataMap, getEditorItem, propsFormatter);
};

var processUU5StringObjectToRaw = function processUU5StringObjectToRaw(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter, parentBlock) {
  var textOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  // create propsFormatter function
  var propsFormatterFn = createPropsFormatterFn(propsFormatter); // handle string node

  if (typeof uu5stringObject === "string") {
    if (!parentBlock) {
      return appendUU5StringObjectToBlock(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter);
    }

    return formatInputString(uu5stringObject);
  } else if (!parentBlock && shouldReplaceBrForEnter(raw, uu5stringObject, parentBlock, blockDataMap)) {
    return appendUU5StringObjectToBlock(raw, "\n", blockDataMap, getEditorItem, propsFormatter);
  } // handle uu5string node props - try to take props from cache


  var props = uu5stringObject.cachedEditorItem ? uu5stringObject.cachedEditorItem.props : propsFormatterFn(uu5stringObject.props.toObject());
  if (!props) props = {};
  var children = props.content || uu5stringObject.children || [];
  var useContent = !!props.content;

  if (!Array.isArray(children)) {
    children = [children];
  }

  delete props.content; // get type of node - at first try to get item from cache, it can be set after check of children types by parent component

  var editorItem = uu5stringObject.cachedEditorItem;

  if (!editorItem) {
    editorItem = parentBlock ? getEditorItem(uu5stringObject.tag, props, children, parentBlock.type, (blockDataMap[parentBlock.key] || {}).props) : getEditorItem(uu5stringObject.tag, props, children);
  }

  uu5stringObject.cachedEditorItem = editorItem; // inline text cannot be nested right inside wrapper (e.g. ul, ol) - it should be text format

  if (parentBlock && parentBlock.display === "wrapper" && editorItem.display === "inline") {
    parentBlock.data = parentBlock.data || {};
    parentBlock.data.delimiters = parentBlock.data.delimiters || [];
    parentBlock.data.delimiters.push(children);
    return null;
  }

  if (typeof editorItem.getChildren === "function") {
    var resultChildren = editorItem.getChildren(uu5stringObject);
    editorItem.children = resultChildren.children;
    useContent = resultChildren.useContent;
    delete editorItem.getChildren;
  } // children must be an array


  if (editorItem.children && !Array.isArray(editorItem.children)) {
    editorItem.children = [editorItem.children];
  }

  if (editorItem.children) {
    children = editorItem.children;
  } else {
    editorItem.children = children;
  } // mark if result shloud be saved as a content or as a children


  if (editorItem.data && useContent) {
    editorItem.data.useContent = useContent;
  } // handle situation if input data is incorrect - for example all entites and inline styles must be defined inside block component


  if (editorItem.display !== "block" && editorItem.display !== "wrapper" && !parentBlock) {
    return appendUU5StringObjectToBlock(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter);
  }

  switch (editorItem.display) {
    case "wrapper":
      // set depth to wrapper
      // if wrapper has no parent (is top level component) set depth to -1 because its child needs to have set depth 0 ( they haven"t any parent component )
      // if wrapper has parent block, takes parent block's depth and its child will rise depth by 1
      editorItem.depth = parentBlock ? parentBlock.depth : -1; // only process child nodes - wrapper is skipped

      children.forEach(function (child) {
        return processUU5StringObjectToRaw(raw, child, blockDataMap, getEditorItem, propsFormatter, editorItem, textOffset);
      });
      return "";

    case "block":
      return processBlockToRaw(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock);

    case "entity":
      return processEntityToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset);

    case "inline":
      return processInlineToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset);

    default:
      // process as unknown entity
      editorItem.type = parentBlock ? "unknown" : "unstyled";
      editorItem.display = parentBlock ? "entity" : "block";
      editorItem.data = editorItem.data || {};
      editorItem.data.tag = uu5stringObject.tag; // show content of unknown tag as a string

      return parentBlock ? processEntityToRaw(raw, editorItem, uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.contentToString(children), getEditorItem, parentBlock, textOffset) : processBlockToRaw(raw, editorItem, uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.contentToString(children), getEditorItem, parentBlock);
  }
};

var normalizeStyleName = function normalizeStyleName(styleName) {
  // translate from font-size to fontSize
  return styleName.replace(/-([a-z])/g, function (_, $1) {
    return $1.toUpperCase();
  }).trim();
};

var nodeAttributesToProps = function nodeAttributesToProps(nodeAttributes) {
  if (!nodeAttributes || nodeAttributes.length === 0) return {};
  var props = {};

  for (var i = 0; i < nodeAttributes.length; i++) {
    var propName = nodeAttributes[i].name; // handle change name of attributes class and for to correct JS attribute/prop names

    if (propName === "class") propName = "className";
    if (propName === "for") propName = "htmlFor";
    props[propName] = nodeAttributes[i].value;
  } // parse style attribute to object


  if (props.style) {
    var propsStyle = {};
    var styles = props.style.split(";");

    for (var _i = 0; _i < styles.length; _i++) {
      if (!styles[_i]) continue;

      var match = styles[_i].match(/^\s*(.*?):\s*(.*?)\s*$/);

      if (match) {
        propsStyle[normalizeStyleName(match[1])] = match[2];
      }
    }

    props.style = propsStyle;
  }

  return props;
};

var translateComponents = function translateComponents(comp, htmlMappings, stylesFilter, parentNode, trimSpaces) {
  if (!htmlMappings) return;
  var resultComp = new uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.Object();
  var usedStyles = {};
  var handledProps = {
    style: true,
    className: true
  }; // possible filtering styles by stylesFilter ( styles from editor's root )

  if (comp.props.style && stylesFilter) {
    for (var styleName in comp.props.style) {
      if (comp.props.style[styleName] === stylesFilter[styleName]) {
        usedStyles[styleName] = true;
      }
    }
  }

  var lastAncestor;

  for (var index = 0; index < htmlMappings.length; index++) {
    var rule = htmlMappings[index]; // check tagName

    if (rule.tagName && rule.tagName !== true && rule.tagName !== comp.tagName) {
      // comp does not match tagName with rule
      continue;
    } // possible to check className - not needed now


    if (rule.className) {
      // check if element has class name
      if (!comp.props.className) {
        continue;
      } // check className of the component


      if (typeof rule.className === "string" && rule.className !== comp.props.className) {
        continue;
      } else if (_typeof(rule.className) === "object" && rule.className instanceof RegExp && !comp.props.className.match(rule.className)) {
        continue;
      }
    }

    var matchedStyle = {}; // check styles

    if (rule.style) {
      if (rule.style === true) {
        // copy all unused styles into style prop
        if (comp.props && comp.props.style) {
          for (var _styleName in comp.props.style) {
            if (usedStyles[_styleName]) {
              continue;
            }

            usedStyles[_styleName] = true;
            matchedStyle[_styleName] = comp.props.style[_styleName];
          }
        }
      } else {
        if (!comp.props || !comp.props.style) {
          // cannot match style
          continue;
        }

        var matchStyles = true;
        var compStyle = comp.props.style;

        for (var _styleName2 in rule.style) {
          if (usedStyles[_styleName2]) {
            // this rule try to use same style as another successful processed rule. Any style cannot be used twice.
            matchStyles = false;
            break;
          }

          var value = rule.style[_styleName2];

          if (compStyle[_styleName2]) {
            if (_typeof(value) === "object" && value instanceof RegExp) {
              if (compStyle[_styleName2].match(value)) {
                matchedStyle[_styleName2] = value;
              } else {
                matchStyles = false;
                break;
              }
            } else if (value === true || value === compStyle[_styleName2]) {
              matchedStyle[_styleName2] = true; // only mark style to be used if
            } else {
              matchStyles = false;
              break;
            }
          } else {
            matchStyles = false;
            break;
          }
        } // styles does not match -> process next rule


        if (!matchStyles) continue;
      }
    }

    var processingComponent = resultComp; // process rule result

    var ruleResult = typeof rule.result === "function" ? rule.result(comp) : rule.result;

    if (!ruleResult) {
      continue;
    } // rule match - add tagName and styles into resultNode


    if (rule.tagName !== true) {
      if (rule.final) {
        resultComp.tag = ruleResult.tagName;
      } else {
        processingComponent = new uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.Object(ruleResult.tagName, undefined, resultComp.children);
        resultComp.children = [processingComponent];

        if (!lastAncestor) {
          lastAncestor = processingComponent;
        }
      }
    } // add all props to result component


    if (ruleResult.props) {
      var _loop = function _loop(propName) {
        // add prop as handled to prevent rewrite set value from comp
        handledProps[propName] = true;
        var prop = processingComponent.props.props.find(function (prop) {
          return prop.name === propName;
        });
        var propValue = ruleResult.props[propName];

        var propValueType = _typeof(propValue); // create new prop if does not exists


        if (!prop) {
          prop = {
            name: propName
          };
          processingComponent.props.props.push(prop);
        } // set new value and value type to prop


        prop.value = propValueType === "object" ? "<uu5json />".concat(JSON.stringify(propValue)) : propValue;
        prop.valueType = propValueType;
      };

      for (var propName in ruleResult.props) {
        _loop(propName);
      }
    } // add all styles to result component and remove them from original


    if (ruleResult.style || rule.style === true) {
      // find property style or create new one if does not exists
      var styleProp = processingComponent.props.props.find(function (prop) {
        return prop.name === "style";
      });

      if (!styleProp) {
        // create new empty style property
        styleProp = {
          name: "style",
          valueType: "uu5json",
          value: {}
        };
        processingComponent.props.props.push(styleProp);
      }

      var styleSource = ruleResult.style ? ruleResult.style : matchedStyle;

      for (var _styleName3 in styleSource) {
        var styleValue = styleSource[_styleName3];
        if (styleValue === true) styleValue = comp.props.style[_styleName3];
        styleProp.value[_styleName3] = styleValue;
      }
    }

    for (var _styleName4 in matchedStyle) {
      var matchedStyleValue = matchedStyle[_styleName4];

      if (matchedStyleValue === true) {
        usedStyles[_styleName4] = true;
      } else if (_typeof(matchedStyleValue) === "object" && matchedStyleValue instanceof RegExp) {
        // remove matched style from attribute
        comp.props.style[_styleName4] = comp.props.style[_styleName4].replace(matchedStyleValue, ""); // if whitepsaces are only characters left in style after remove, then mark style as used to disallow match in another rule

        if (comp.props.style[_styleName4].match(/^\s*$/)) {
          usedStyles[_styleName4] === true;
        }
      }
    }

    if (rule.final) break;
  } // last ancestor is definde only if any children was added into children


  if (!resultComp.tag && lastAncestor) {
    // children is here always only one component - missing top component is replaced by only children
    resultComp = resultComp.children[0];
  } // if cannot translate original component to new one, return original component


  if (resultComp.tag) {
    // process children
    lastAncestor = lastAncestor || resultComp;
    lastAncestor.children = comp.childNodes.length ? DataConversion.parseHtmlNodeListToUu5stringObject(comp.childNodes, htmlMappings, stylesFilter, parentNode, trimSpaces) : undefined;

    for (var _propName in comp.props) {
      if (handledProps[_propName]) continue;
      resultComp.props.props.push({
        name: _propName,
        value: comp.props[_propName]
      });
    }

    return resultComp;
  } else {
    // return processed children
    return DataConversion.parseHtmlNodeListToUu5stringObject(comp.childNodes, htmlMappings, stylesFilter, parentNode, trimSpaces);
  }
};

var DataConversion = {
  editorStateToRaw: function editorStateToRaw(editorState) {
    return Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["convertToRaw"])(editorState.getCurrentContent());
  },
  editorStateToUU5String: function editorStateToUU5String(editorState, getUU5Item, propsFormatterFn) {
    var propsFormatter = function propsFormatter(props) {
      if (!props) return undefined;

      if (propsFormatterFn) {
        return propsFormatterFn(JSON.parse(JSON.stringify(props))) || props;
      } else {
        return props;
      }
    };

    var content = editorState.getCurrentContent();
    var raw = Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["convertToRaw"])(content); // check if editor is not empty

    var empty = true;

    for (var bi = 0; bi < raw.blocks.length; bi++) {
      var block = raw.blocks[bi];

      if (block.text) {
        empty = false;
        break;
      }
    }

    if (empty) return "";
    var uu5string = "<uu5string />";
    var wrappers = []; // hold wrapper element for each level

    var blockItems = [];
    var lastWhitespace = false; // indicate if last character in of the previous block was replaced by whitespace

    var blockDatas = [];

    for (var _bi = 0; _bi < raw.blocks.length; _bi++) {
      var _block = raw.blocks[_bi];
      var blockData = content.getBlockForKey(_block.key).getData().toJSON();

      if (blockData.artificial) {
        // remove artificial block meta information if is set on another block type then default or has set some props
        blockData.artificial = _block.type === "unstyled" && (!_block.data || !_block.data.props || !_block.data.props.size) && ( // preserve to remove div from two blocks right after each other
        _bi === 0 || !blockDatas[_bi - 1].artificial) && ( // next or previour blocks should not be <br /> (empty unstyled block)
        !raw.blocks[_bi + 1] || raw.blocks[_bi + 1].text && raw.blocks[_bi + 1].type === "unstyled") && (_bi === 0 || raw.blocks[_bi - 1].text && raw.blocks[_bi - 1].type === "unstyled");
      }

      blockDatas.push(blockData);
    }

    var _loop2 = function _loop2(_bi2) {
      var block = raw.blocks[_bi2];
      var nextBlock = _bi2 === raw.blocks.length - 1 ? null : raw.blocks[_bi2 + 1];
      var blockData = blockDatas[_bi2];
      var blockProps = blockData.props;
      var wrapper = wrappers.length > 0 && wrappers[wrappers.length - 1] || {};
      var uu5BlockItem = block.type === "error" ? {
        tag: null,
        opts: {
          preserveEnters: true
        }
      } : getUU5Item("block", block.type, blockProps, wrapper.tag, wrapper.props, !block.text);
      uu5BlockItem.opts = uu5BlockItem.opts || {}; // need to sort wrappers and blocks to correct end tags

      var toClose = []; // close all blocks with same or higher depth

      for (var _i4 = blockItems.length - 1; _i4 >= 0; _i4--) {
        var blockItem = blockItems[_i4];
        if (blockItem.depth < block.depth) break; // uu5string += printClosingTag(blockItems.pop().item.tag);

        blockItems.pop();
        toClose.push({
          tag: blockItem.item.tag,
          depth: blockItem.depth,
          blockData: blockItem.blockData
        });
      }

      var preserveWrapper = false;

      while (wrappers.length > 0 && wrappers[wrappers.length - 1].depth >= block.depth) {
        var _wrapper = wrappers.pop(); // do not print closing tag of wrapper


        if (_wrapper.depth === block.depth && _wrapper.tag === uu5BlockItem.wrapper) {
          preserveWrapper = true;
          wrappers.push(_wrapper);
          break;
        } // print closing wrapper tag
        // uu5string += printClosingTag(wrapper.tag);


        toClose.push({
          tag: _wrapper.tag,
          depth: _wrapper.depth - 0.5
        });
      } // sort toClose array by depth of tags


      toClose.sort(function (tag1, tag2) {
        return tag2.depth - tag1.depth;
      });

      for (var _i5 = 0; _i5 < toClose.length; _i5++) {
        uu5string += printClosingTag(toClose[_i5].tag, toClose[_i5].blockData);
      }

      if (uu5BlockItem.wrapper) {
        // add new wrapper if it is preserved
        if (!preserveWrapper) {
          // add wrapper to array
          wrappers.push({
            tag: uu5BlockItem.wrapper,
            props: blockData.wrapperProps,
            depth: block.depth
          }); // print opening wrapper tag

          uu5string += printOpeningTag(uu5BlockItem.wrapper, propsFormatter(uu5BlockItem.wrapperProps));
        }
      }

      if (!uu5BlockItem.tag) {
        // components only closed in uu5string block component
        uu5string += removeOutputSupportCharacters(block.text, _objectSpread({
          escapeXml: false
        }, uu5BlockItem.opts));
      } else if (uu5BlockItem.isSelfClosed || removeOutputSupportCharacters(block.text).length === 0 && (!nextBlock || nextBlock.depth <= block.depth) && (!block.entityRanges || block.entityRanges.length === 0)) {
        // print wrappers delimiter if block is wrapped
        // TODO
        // selfclosed block is defined as selfclosed or is empty and does not contain inner block
        blockData.isEmpty = true;
        uu5string += printOpeningTag(uu5BlockItem.tag, propsFormatter(uu5BlockItem.props), uu5BlockItem.isSelfClosed, blockData);
      } else {
        // print wrappers delimiter if block is wrapped
        // TODO
        // print opening tag and add block into blocks array
        uu5string += printOpeningTag(uu5BlockItem.tag, propsFormatter(uu5BlockItem.props), false, blockData);
        blockItems.push({
          depth: block.depth,
          item: uu5BlockItem,
          blockData: blockData
        }); // set inline styles into tags array

        var tags = [];
        var charUpdates = [];

        for (var _index = 0; _index < block.inlineStyleRanges.length; _index++) {
          var range = block.inlineStyleRanges[_index];
          var uu5InlineItem = getUU5Item("inline", range.style, null);

          if (!uu5InlineItem.tag) {
            if (uu5InlineItem.replaceChar) {
              var update = uu5InlineItem.replaceChar(block.text.substring(range.offset, range.offset + range.length));

              if (update) {
                update.offset += range.offset;
                update.length = range.length;
                charUpdates.push(update);
              }
            }

            continue;
          }

          var isSelfClosing = uu5InlineItem.isSelfClosed || removeOutputSupportCharacters(block.text.substr(range.offset, range.length)).length === 0;
          var tagIndex = tags.length; // opening tag

          tags.push({
            type: "opening",
            componentType: "style",
            offset: range.offset,
            startOffset: range.offset,
            endOffset: range.offset + range.length,
            name: uu5InlineItem.tag,
            props: uu5InlineItem.props,
            isSelfClosing: isSelfClosing,
            index: tagIndex,
            order: uu5InlineItem.order || DEFAULT_TAG_ORDER,
            getChildren: uu5InlineItem.fn
          }); // closing or selfclosing tag

          if (!isSelfClosing) {
            tags.push({
              type: "closing",
              componentType: "style",
              offset: range.offset + range.length,
              startOffset: range.offset,
              endOffset: range.offset + range.length,
              name: uu5InlineItem.tag,
              props: uu5InlineItem.props,
              index: tagIndex,
              order: uu5InlineItem.order || DEFAULT_TAG_ORDER
            });
          }
        } // set inline components(entities) into tags array


        for (var _index2 = 0; _index2 < block.entityRanges.length; _index2++) {
          var _range = block.entityRanges[_index2];
          var entity = raw.entityMap[_range.key]; // skip empty or removed entities

          if (!entity.type) continue;
          var uu5EntityItem = entity.type === "error" ? {
            tag: null,
            opts: {
              preserveEnters: true
            }
          } : getUU5Item("entity", entity.type, entity.data.props);

          var _isSelfClosing = uu5EntityItem.isSelfClosed || entity.data.useContent || removeOutputSupportCharacters(block.text.substr(_range.offset, _range.length)).length === 0;

          if (entity.data.useContent) {
            if (!uu5EntityItem.props) {
              uu5EntityItem.props = {
                content: block.text.substring(_range.offset, _range.length)
              };
            } else {
              uu5EntityItem.props.content = block.text.substring(_range.offset, _range.offset + _range.length);
            }
          }

          var _tagIndex = tags.length; // opening tag

          tags.push({
            type: "opening",
            componentType: "component",
            offset: _range.offset,
            startOffset: _range.offset,
            endOffset: _range.offset + _range.length,
            name: uu5EntityItem.tag,
            props: uu5EntityItem.props,
            isSelfClosing: _isSelfClosing,
            index: _tagIndex,
            order: uu5EntityItem.order || DEFAULT_TAG_ORDER,
            opts: uu5EntityItem.opts
          }); // closing or selfclosing tag

          if (!_isSelfClosing) {
            tags.push({
              type: "closing",
              componentType: "component",
              offset: _range.offset + _range.length,
              startOffset: _range.offset,
              endOffset: _range.offset + _range.length,
              name: uu5EntityItem.tag,
              props: uu5EntityItem.props,
              index: _tagIndex,
              order: uu5EntityItem.order || DEFAULT_TAG_ORDER,
              opts: uu5EntityItem.opts
            });
          }
        } // sort array of tags


        tags.sort(tagComparator); // sort update by index from the lowest

        charUpdates.sort(function (a, b) {
          return a.offset - b.offset;
        }); // remove spaces which are hidden and wasn't lead by showed space

        var last = lastWhitespace ? -1 : -2; // if last character of previous block wasnt replaced by whitespace, set unreachable index

        for (var spaceIndex = 0; spaceIndex < charUpdates.length; spaceIndex++) {
          var space = charUpdates[spaceIndex]; // if current space is hidden and there is no space right before it -> remove space

          if (space.hidden && space.offset !== last + 1) {
            // first node in the block - check ending of uu5string, because uu5string removes whitespace components
            if (space.offset === 0) {
              if (uu5string.match(/\s{2,}(<[^>]*>)*$/)) {
                // space is right after another big space
                space.hidden = false;
                last = space.offset;
              } else {
                space.replace = "";
              }
            } else {
              if (block.text.substring(0, space.offset).match(/\s{2,}(<[^>]*>)*$/)) {
                // space is right after another big space
                space.hidden = false;
                last = space.offset;
              } else {
                space.replace = "";
              }
            }
          } else {
            last = space.offset;
          }
        } // find last non hidden whitespace


        var textLength = block.text.length;

        for (var _i6 = charUpdates.length - 1; _i6 >= 0; _i6--) {
          var whitespace = charUpdates[_i6]; // shorten text about length of whitepsace elements

          textLength -= whitespace.length; // check if whitespace is at the end of the block's text

          lastWhitespace = whitespace.offset === textLength; // if whitespace is shown => return result (true or false)
          // if whitespace is not at the end of the text return false

          if (!whitespace.hidden || !lastWhitespace) {
            break;
          }
        }

        var updateIndex = 0;
        var allCharsUpdated = updateIndex === charUpdates.length; // print tags into string

        var opened = [];
        var text = block.text;
        var index = 0; // defines how many parent components disable escaping < and > characters - escaping xml is disabled by returning undefined tag - so any content is taken as components

        var escapeLevel = 0;
        tags.forEach(function (tag) {
          // print text
          var next = tag.offset;

          if (next !== index) {
            if (!allCharsUpdated && next > charUpdates[updateIndex].offset) {
              var offset = index; // print all character replaces and text between them

              while (!allCharsUpdated && offset < next) {
                // calculate offset of the next item
                var nextOffset = charUpdates[updateIndex].offset; // check if next replace should be done here

                if (nextOffset > next) break; // replace selected char

                uu5string += removeOutputSupportCharacters(text.substring(offset, nextOffset), _objectSpread({
                  escapeXml: escapeLevel === 0
                }, opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts));
                uu5string += charUpdates[updateIndex].replace; // update offset and index

                offset = nextOffset + 1;
                updateIndex++;
                allCharsUpdated = charUpdates.length === updateIndex;
              } // print resting text


              uu5string += removeOutputSupportCharacters(text.substring(offset, next), _objectSpread({
                escapeXml: escapeLevel === 0
              }, opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts));
            } else {
              uu5string += removeOutputSupportCharacters(text.substring(index, next), _objectSpread({
                escapeXml: escapeLevel === 0
              }, opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts));
            }
          }

          index = next;

          if (tag.type === "opening") {
            if (!tag.name) escapeLevel++; // before print opening tag of component - close all styles

            var mustCloseStyles = tag.componentType === "component" && opened.length && !tag.isSelfClosing && tag.name || tag.componentType === "style" && opened.length && opened[opened.length - 1].componentType === "style" && opened[opened.length - 1].order < tag.order; // update index for self closing tags - they contain support characters

            if (tag.isSelfClosing) {
              index = tag.endOffset;
            }

            var temp;

            if (mustCloseStyles) {
              if (tag.componentType === "component") {
                temp = [].concat(opened).reverse();
              } else {
                temp = [];

                for (var styleIndex = opened.length - 1; styleIndex >= 0; styleIndex--) {
                  var style = opened[styleIndex];

                  if (style.componentType === "component" || style.order >= tag.order) {
                    break;
                  }

                  temp.push(style);
                }
              }

              temp.forEach(function (item) {
                uu5string += printClosingTag(item.name);
                item.offset = next;
                item.startOffset = next;
              }); // clear array of opened styles

              opened.splice(opened.length - temp.length, temp.length);
            } // print opening tag


            uu5string += printOpeningTag(tag.name, propsFormatter(tag.props), tag.isSelfClosing);

            if (!tag.isSelfClosing) {
              // add tag to stack
              opened.push(tag);
            } // reopen all styles


            if (mustCloseStyles) {
              temp.sort(tagComparator);
              temp.forEach(function (item) {
                uu5string += printOpeningTag(item.name, propsFormatter(item.props));
                opened.push(item);
              });
            }
          } else {
            if (tag.alreadyClosed) return; // this closing tag was already closed so simply skip to next tag

            if (!tag.name) escapeLevel--; // find index of opening tag in stack

            var openTagIndex = opened.length - 1;

            for (; openTagIndex >= 0; openTagIndex--) {
              var openedTag = opened[openTagIndex];

              if (openedTag.index === tag.index) {
                break;
              }
            }

            if (openTagIndex === opened.length - 1) {
              // print closing tag
              uu5string += printClosingTag(tag.name); // remove opening tag

              opened.pop();
            } else {
              var _loop3 = function _loop3(openedIndex) {
                var closingTag = opened[openedIndex];
                uu5string += printClosingTag(closingTag.name);

                if (closingTag.endOffset === tag.endOffset) {
                  // remove tags which should ends in same position as currently closed tag
                  opened.splice(openedIndex, 1);

                  var _closingTag = tags.find(function (tag) {
                    return tag.type === "closing" && tag.index === closingTag.index;
                  });

                  _closingTag.alreadyClosed = true;
                }
              };

              // fix crossing tags - close opened tags from last
              for (var openedIndex = opened.length - 1; openedIndex > openTagIndex; openedIndex--) {
                _loop3(openedIndex);
              } // print tag


              uu5string += printClosingTag(tag.name); // reopen crossing tags from first
              // reorder tags stack

              var openingTags = opened.slice(openTagIndex + 1);
              openingTags.forEach(function (item) {
                item.offset = next;
                item.startOffset = next;
              }); // tag which ending first must be ordered as last to minimalize crossing tags

              openingTags.sort(tagComparator);
              opened.splice.apply(opened, [openTagIndex + 1, openingTags.length].concat(_toConsumableArray(openingTags))); // print reordered tags

              for (var _index3 = openTagIndex + 1; _index3 < opened.length; _index3++) {
                var openingTag = opened[_index3];
                uu5string += printOpeningTag(openingTag.name, propsFormatter(openingTag.props));
              } // remove closed tag from stack
              // console.log(`Removing tag from opened: ${opened[openedIndex]}`);


              opened.splice(openTagIndex, 1);
            }
          }
        }); // print rest of the text
        // print all character replaces and text between them

        while (!allCharsUpdated) {
          // calculate offset of the next item
          var nextOffset = charUpdates[updateIndex].offset; // replace selected char

          uu5string += removeOutputSupportCharacters(text.substring(index, nextOffset), _objectSpread({
            escapeXml: escapeLevel === 0
          }, opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts));
          uu5string += charUpdates[updateIndex].replace; // update offset and index
          // move index of printed text after last update

          index = nextOffset + 1;
          updateIndex++;
          allCharsUpdated = charUpdates.length === updateIndex;
        } // print rest of the text


        uu5string += removeOutputSupportCharacters(text.substring(index), _objectSpread({
          escapeXml: escapeLevel === 0
        }, uu5BlockItem.opts));
      }
    };

    for (var _bi2 = 0; _bi2 < raw.blocks.length; _bi2++) {
      _loop2(_bi2);
    } // sort unclosed blocks and wrappers


    var toClose = [];

    for (var i = 0; i < blockItems.length; i++) {
      toClose.push({
        depth: blockItems[i].depth,
        tag: blockItems[i].item.tag,
        blockData: blockItems[i].blockData
      });
    }

    for (var _i2 = 0; _i2 < wrappers.length; _i2++) {
      // lower depth of wrappers to ensure that wrapper is closer after block with the same depth
      toClose.push({
        depth: wrappers[_i2].depth - 0.5,
        tag: wrappers[_i2].tag
      });
    } // sort toClose array by depth of tags


    toClose.sort(function (tag1, tag2) {
      return tag2.depth - tag1.depth;
    }); // print wrapper's and block's end tags

    for (var _i3 = 0; _i3 < toClose.length; _i3++) {
      uu5string += printClosingTag(toClose[_i3].tag, toClose[_i3].blockData);
    }

    return uu5string;
  },
  uu5stringToRaw: function uu5stringToRaw(uu5string, blockDataMap, getEditorItem, propsFormatter) {
    if (!uu5string) {
      return getEmptyRaw();
    }

    var uu5stringObject;

    try {
      uu5stringObject = typeof uu5string === "string" ? uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.parse(removeInputSupportCharacters(uu5string)) : uu5string;
    } catch (e) {
      return {
        blocks: [{
          type: "error",
          text: uu5string.replace(/^<uu5string\s*\/>/, ""),
          inlineStyleRanges: [],
          entityRanges: [],
          depth: 0,
          key: Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["genKey"])()
        }],
        entityMap: {}
      };
    } // Experimentaly disabled removal of white spaces
    // uu5stringObject = removeWhiteSpace({ children: uu5stringObject }).children;
    // handle empty uu5string


    if (!uu5stringObject.length) {
      return getEmptyRaw();
    }

    var raw = {
      blocks: [],
      entityArray: []
    };
    uu5stringObject.forEach(function (block) {
      if (block.tag === "UU5.RichText.EndBlock") {
        // add special block to collect all inline styling and entities
        // consider to remove empty blocks after process all data
        raw.blocks.push({
          key: Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["genKey"])(),
          text: "",
          type: "unstyled",
          depth: 0,
          inlineStyleRanges: [],
          entityRanges: [],
          _uu5richTextDataCollector: true // this means, that all inline sibling will be pleced inside this container like it is a parent

        });
        return;
      }

      processUU5StringObjectToRaw(raw, block, blockDataMap, getEditorItem, propsFormatter);
    }); // convert entityArray to entityMap

    raw.entityMap = {};
    raw.entityArray.forEach(function (item, index) {
      raw.entityMap[index] = item;
    });
    delete raw.entityArray;
    return raw;
  },
  uu5stringToEditorState: function uu5stringToEditorState(uu5string) {
    var customDecorators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var getEditorItem = arguments.length > 2 ? arguments[2] : undefined;
    var propsFormatterFn = arguments.length > 3 ? arguments[3] : undefined;
    // keep support for other draft default block types and add our myCustomBlock type
    var decorators = new draft_js__WEBPACK_IMPORTED_MODULE_1__["CompositeDecorator"](customDecorators); // uu5string = uu5string.replace(/(\s{2,})/g, '<UU5.RichText.Whitespace value="$1"> </UU5.RichText.Whitespace>');
    // create new state for editor from content

    var editorState;
    var isUU5String = uu5string && (_typeof(uu5string) === "object" || uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].REGEXP.uu5string.test(uu5string)); // go through all text nodes and replace whitepaces

    if (isUU5String) {
      // draft raw object cannot contain data for blocks, so we must save them separately and after creation of
      // editor state, we set them directly into state by block keys
      var blockDataMap = {};
      editorState = draft_js__WEBPACK_IMPORTED_MODULE_1__["EditorState"].createWithContent(Object(draft_js__WEBPACK_IMPORTED_MODULE_1__["convertFromRaw"])(DataConversion.uu5stringToRaw(uu5string, blockDataMap, getEditorItem, propsFormatterFn)), decorators); // set data into editor state

      for (var blockKey in blockDataMap) {
        var content = draft_js__WEBPACK_IMPORTED_MODULE_1__["Modifier"].setBlockData(editorState.getCurrentContent(), _bricks_selection_js__WEBPACK_IMPORTED_MODULE_3__["default"].modifySelection(editorState, {
          anchorKey: blockKey,
          focusKey: blockKey,
          anchorOffset: 0,
          focusOffset: 0
        }), blockDataMap[blockKey]);
        editorState = draft_js__WEBPACK_IMPORTED_MODULE_1__["EditorState"].push(editorState, content, "parse from uu5string");
      }
    } else if (uu5string) {
      editorState = draft_js__WEBPACK_IMPORTED_MODULE_1__["EditorState"].createWithContent(draft_js__WEBPACK_IMPORTED_MODULE_1__["ContentState"].createFromText(uu5string), decorators);
    } else {
      draft_js__WEBPACK_IMPORTED_MODULE_1__["EditorState"].createEmpty(decorators);
    } // create new content from uu5string


    return editorState;
  },
  parseHtmlNodeListToUu5stringObject: function parseHtmlNodeListToUu5stringObject(nodeList, htmlMappings, stylesFilter) {
    var parentBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var trimWhiteSpaces = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var dataModel = [];
    var cachedString = "";
    var trimLeft = !trimWhiteSpaces; // console.log(nodeList);

    nodeList.forEach(function (node, index) {
      var value;

      switch (node.nodeType) {
        case 1:
          // node
          // remove trailing line breaks to prevent duplication
          if (index === nodeList.length - 1 && node.tagName.toLowerCase() === "br") break; // add cached text into data model

          if (cachedString) {
            dataModel.push(cachedString);
            cachedString = "";
          } // handle node


          {
            var tagName = node.tagName.toLowerCase();
            value = translateComponents({
              tagName: tagName,
              props: nodeAttributesToProps(node.attributes),
              childNodes: node.childNodes
            }, htmlMappings, stylesFilter, true, false);
            trimLeft = trimLeft || !!value;

            if (!parentBlock && tagName === "div") {
              var blockEndingComponent = new uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].UU5String.Object();
              blockEndingComponent.tag = "UU5.RichText.EndBlock";
              dataModel.push(blockEndingComponent);
            }
          }
          break;

        case 3:
          // text
          value = node.textContent; // remove leading whitespaces

          if (!trimLeft) {
            value = value.replace(/^\s*/, "");
            trimLeft = !!value;
          } // cache string and add it to data model with next component - at the end remove ending whitespaces


          cachedString += value;
          value = null; // value = node.textContent.replace(/[\n\r]/g, "");

          break;
      }

      if (value) {
        if (Array.isArray(value)) {
          dataModel = dataModel.concat(value);
        } else {
          dataModel.push(value);
        }
      }
    });

    if (cachedString) {
      if (trimWhiteSpaces) {
        cachedString = cachedString.replace(/\s*$/, "");
      }

      dataModel.push(cachedString);
    }

    return dataModel;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (DataConversion);

/***/ }),

/***/ 292:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(279);
/* harmony import */ var _block_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _plugins_uu5_unstyled_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _plugins_uu5_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50);
/* harmony import */ var _plugins_uu5_whitespace_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(53);







var REQUIRED_PLUGIN_MAP = {
  unstyled: _plugins_uu5_unstyled_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  error: _plugins_uu5_error_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  whitespace: _plugins_uu5_whitespace_js__WEBPACK_IMPORTED_MODULE_6__["default"]
};
var WEIGHTS = {
  tagName: 100,
  className: 10,
  style: 2,
  final: -1
};

var calculateWeight = function calculateWeight(mapping) {
  var weight = 0;

  if (mapping.tagName) {
    weight += WEIGHTS.tagName;
  }

  if (mapping.classNames) {
    if (Array.isArray(mapping.classNames)) {
      weight += WEIGHTS.className * mapping.classNames.length;
    } else {
      weight += WEIGHTS.className;
    }
  }

  if (mapping.style) {
    weight += Object.keys(mapping.style).length * WEIGHTS.style;
  }

  if (mapping.final) {
    weight += WEIGHTS.final;
  }

  return weight;
};

var sortMappings = function sortMappings(mapping1, mapping2) {
  var order1 = mapping1.order;

  if (!order1) {
    order1 = calculateWeight(mapping1);
    mapping1.order = order1;
  }

  var order2 = mapping2.order;

  if (!order2) {
    order2 = calculateWeight(mapping2);
    mapping2.order = order2;
  }

  return order2 - order1;
};

var Plugin = {
  processPlugins: function processPlugins(plugins) {
    var pluginExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var blockRendererFnMap; // map of block render maps

    var result = {
      buttonMap: {},
      // map of button definitions fro toolbar
      htmlMappings: [],
      areaConfig: {
        commands: [],
        customStyleMap: {},
        // map of inline styles
        blockRenderMap: {},
        // map of block renderer functions
        getEditationFormMap: {},
        decorators: [],
        // set of decorators
        entityOptions: {}
      }
    }; // process plugins

    plugins.forEach(function (plugin) {
      // push commands to global array
      if (plugin.commands) {
        result.areaConfig.commands = result.areaConfig.commands.concat(plugin.commands);
      } // process all buttons - clone necesary properties and merge extensions into props


      if (plugin.buttonMap) {
        var buttonMap = plugin.buttonMap;
        var extension = pluginExtensions[plugin.name]; // process extension for this plugin

        if (extension) {
          for (var name in extension) {
            if (name === "buttonMap") {
              var extButtonMap = extension.buttonMap; // merge extensions to button

              for (var buttonName in extButtonMap) {
                if (!buttonMap[buttonName]) {
                  // there is posibility to create whole new button
                  continue;
                } // shallow clone button props to prevent changes in original button definition shared between more editors


                var button = buttonMap[buttonName];
                var resultButton = {};

                for (var key in button) {
                  resultButton[key] = button[key];
                }

                resultButton.props = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.merge(resultButton.props, extButtonMap[buttonName]);
                buttonMap[buttonName] = resultButton;
              }

              continue;
            } // copy new value to plugin definition


            plugin[name] = extension[name];
          }
        } // bind all getProps methods to plugin


        for (var _buttonName in buttonMap) {
          var _button = buttonMap[_buttonName];

          if (_button.getProps) {
            _button.getProps = _button.getProps.bind(plugin);
          }
        }

        result.buttonMap = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.merge(result.buttonMap, buttonMap);
      } // process all defined inline styles


      if (plugin.customStyleMap) {
        result.areaConfig.customStyleMap = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.merge(result.areaConfig.customStyleMap, plugin.customStyleMap);
      } // process all blocks


      if (plugin.blockMap) {
        for (var blockName in plugin.blockMap) {
          var block = plugin.blockMap[blockName];

          if (block.rendererFn) {
            blockRendererFnMap = blockRendererFnMap || {}; // initialization

            blockRendererFnMap[blockName] = block.rendererFn;
          }

          if (block.renderMap) {
            result.areaConfig.blockRenderMap[blockName] = block.renderMap; // wrapper cannot be set directly due to contentMixin expandChildProps method
            // this method clone wrapper but we need to be able to have one instance of object in multiple wrappers

            if (block.renderMap.wrapperName) {
              result.areaConfig.blockRenderMap[blockName].wrapper = (_environment_js__WEBPACK_IMPORTED_MODULE_3__["default"].wrapperMap || {})[block.renderMap.wrapperName];
            }
          }
        }
      } // process editation forms


      if (plugin.getEditationFormMap) {
        for (var formName in plugin.getEditationFormMap) {
          result.areaConfig.getEditationFormMap[formName] = plugin.getEditationFormMap[formName];
        }
      } // process decorators


      if (plugin.entities) {
        // transform entities to array and then process all entities
        var entities = Array.isArray(plugin.entities) ? plugin.entities : [plugin.entities];
        entities.forEach(function (entity) {
          result.areaConfig.decorators.push({
            component: entity.component,
            strategy: entity.strategy || _entity_js__WEBPACK_IMPORTED_MODULE_1__["default"].getDefaultStrategy(entity.name || plugin.name)
          });
        });
      } // process entity options from toEditorItemDefs


      if (plugin.toEditorItemDefs) {
        plugin.toEditorItemDefs.forEach(function (item) {
          if (item.type === "entity") {
            // set only valid options - now is only option preserveEnters
            if (item.preserveEnters) {
              result.areaConfig.entityOptions[item.name] = {
                preserveEnters: item.preserveEnters
              };
            }
          }
        });
      } // process html mappings


      if (plugin.htmlMappings) {
        result.htmlMappings = result.htmlMappings.concat(Array.isArray(plugin.htmlMappings) ? plugin.htmlMappings : [plugin.htmlMappings]);
      }

      if (blockRendererFnMap) {
        result.areaConfig.blockRendererFn = _block_js__WEBPACK_IMPORTED_MODULE_2__["default"].createBlockRendererFn(blockRendererFnMap);
      }
    }); // sort mapping by order

    result.htmlMappings.sort(sortMappings);
    return result;
  },
  mergePlugins: function mergePlugins(props, pluginMap) {
    // merge plugins with existing plugins if props.plugins is set by an object, if plugins is set as an array, then replace all plugins by new one
    var result = [];
    var addedPlugins = {};
    var requiredPluginMap = {
      unstyled: false,
      error: false
    };

    if (props && props.plugins) {
      if (Array.isArray(props.plugins)) {
        props.plugins.forEach(function (plugin) {
          result.push(plugin);

          if (requiredPluginMap[plugin.name] === false) {
            requiredPluginMap[plugin.name] = true;
          }
        });

        for (var pluginName in requiredPluginMap) {
          if (requiredPluginMap[pluginName]) continue;
          result.push(pluginMap[pluginName] || REQUIRED_PLUGIN_MAP[pluginName]);
        }

        return result;
      } else {
        for (var _pluginName in props.plugins) {
          result.push(props.plugins[_pluginName]);
          addedPlugins[_pluginName] = true;
        }
      }
    }

    for (var _pluginName2 in pluginMap) {
      // do not add already added plugins
      if (addedPlugins[_pluginName2]) continue;
      result.push(pluginMap[_pluginName2]);
    } // for inline mode keep only inline plugins


    if (props.inline) {
      result = result.filter(function (p) {
        var pDef = p.toJSON();
        if (requiredPluginMap.hasOwnProperty(pDef.name)) return true;
        return pDef.type !== "block";
      });
    }

    return result;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Plugin);

/***/ }),

/***/ 293:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);

var Block = {
  createBlockRendererFn: function createBlockRendererFn(blockRenderFnMap) {
    return function (block) {
      var type = block.getType();
      var data = block.getData();
      var props = data.get("props");

      if (props) {
        // props is imutable map
        props = props.toJSON();
      } else {
        props = {};
      }

      var customBlock = blockRenderFnMap[type];

      if (typeof customBlock === "function") {
        return {
          component: customBlock,
          props: props
        };
      } else {
        return uu5g04__WEBPACK_IMPORTED_MODULE_0__["Common"].Tools.merge({
          props: props
        }, customBlock);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Block);

/***/ }),

/***/ 294:
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(295);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":false}

options.transform = transform
options.insertInto = function anonymous(
) {
return __webpack_require__(16)();
};

var update = __webpack_require__(17)(content, options);

if(content.locals) module.exports = content.locals;



/***/ }),

/***/ 295:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// Module
exports.push([module.i, ".uu5-richtext-editor {\n  position: relative;\n}\n.uu5-richtext-editor-transparent .public-DraftEditor-content {\n  background: transparent;\n}\n.uu5-richtext-editor .uu5-richtext-toolbar {\n  border: none;\n  border-radius: 0;\n  position: absolute;\n  top: 2px;\n  left: 2px;\n  right: 2px;\n  height: 33px;\n}\n.uu5-richtext-editor .uu5-richtext-toolbar > div::after {\n  content: \"\";\n  display: block;\n  height: 0;\n  position: absolute;\n  left: -2px;\n  width: calc(100% + 4px);\n  border-bottom: 1px solid #bdbdbd;\n}\n.uu5-richtext-editor .public-DraftEditor-content {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.uu5-richtext-editor .public-DraftEditor-content .uu5-bricks-ul > .uu5-bricks-li > div {\n  display: inline-block;\n}\n", ""]);



/***/ })

}]);