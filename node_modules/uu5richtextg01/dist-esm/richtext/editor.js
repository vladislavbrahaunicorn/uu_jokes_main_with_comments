//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import { CompositeDecorator, EditorState, Modifier, convertToRaw, convertFromRaw } from "draft-js";
import { EditorContext as Context } from "./context.js";
import { EDITOR_BUTTONS } from "./bricks/defaults.js";

import Config from "./config.js";
import Toolbar from "./toolbar.js";
import Area from "./area.js";
import DataConversion from "./bricks/data-conversion.js";

// bricks
import Plugin from "./bricks/plugin.js";
import Selection from "./bricks/selection.js";
import PluginFactory from "./plugins/PluginFactory.js";

import pluginMap from "./plugins/uu5/plugins.js";

import "./editor.less";
//@@viewOff:imports

const IS_IE = navigator.userAgent.match("Trident");
const EmptyUU5String = /^<uu5string\s*\/>$/;

const withContext = Component => {
  // disable context for jest tests - enzyme doesn't support React 16.3 Context API
  if (!UU5.Common.Context.create) return Component;
  let forwardRef = UU5.Common.Reference.forward((props, ref) => {
    const definedProps = {};
    for (let propName in props) {
      if (props[propName] !== undefined) {
        definedProps[propName] = props[propName];
      }
    }
    return <Context.Consumer>{context => <Component ref={ref} {...context} {...definedProps} />}</Context.Consumer>;
  });

  forwardRef.isUu5PureComponent = true;
  forwardRef.displayName = `forwardRef(${Component.displayName || Component.name || "Component"})`;
  forwardRef.tagName = Component.tagName;

  return forwardRef;
};

export const Editor = withContext(
  UU5.Common.VisualComponent.create({
    //@@viewOn:mixins
    mixins: [UU5.Common.BaseMixin],
    //@@viewOff:mixins

    //@@viewOn:statics
    statics: {
      tagName: Config.TAG + "Editor",
      classNames: {
        main: (props, state) =>
          Config.CSS +
          "editor" +
          ((state.customToolbar && state.focused && props.dynamicToolbar) || !props.dynamicToolbar
            ? " " +
              UU5.Common.Css.css(`
                .public-DraftEditor-content,
                .public-DraftEditorPlaceholder-root {
                  padding-top: 40px;
                }

                && .public-DraftEditor-content::before {
                  width: calc(100% + 16px);
                  ${props.animatedToolbar ? "transition-delay: 0.5s;" : ""}
                }
              `)
            : "") +
          " " +
          UU5.Common.Css.css(`
            .public-DraftEditorPlaceholder-root {
              line-height: 1.5;
            }

            .public-DraftEditor-content {
              ${
                IS_IE
                  ? `
                    overflow-x: hidden;
                    overflow-y: auto;
                  `
                  : `
                    display: flex;
                    flex-direction: column;
                    align-items: stretch;

                    & > div {
                      overflow-x: hidden;
                      overflow-y: auto;
                    }
                  `
              }
              height: ${typeof props.height === "number" ? props.height + "px" : props.height};
              min-height: ${typeof props.minHeight === "number" ? props.minHeight + "px" : props.minHeight};
              max-height: ${typeof props.maxHeight === "number" ? props.maxHeight + "px" : props.maxHeight};
            }
          `) +
          (props.animatedToolbar
            ? " " +
              UU5.Common.Css.css(`
                .public-DraftEditor-content,
                .public-DraftEditorPlaceholder-root {
                  transition: padding-top 0.5s;
                }
              `)
            : "") +
          (props.readOnly
            ? " " +
              UU5.Common.Css.css(`
                .public-DraftEditor-content {
                  border-color: rgba(189, 189, 189, .24);
                  background-color: rgba(255, 255, 255, .24);
                }
              `)
            : ""),
        bgstyleTransparent: Config.CSS + "editor-transparent"
      },
      lsi: () => UU5.Environment.Lsi.RichText.editor
    },
    //@@viewOff:statics

    //@@viewOn:propTypes
    propTypes: {
      value: UU5.PropTypes.string,
      buttons: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
      plugins: UU5.PropTypes.oneOfType([UU5.PropTypes.arrayOf(UU5.PropTypes.object), UU5.PropTypes.object]),
      readOnly: UU5.PropTypes.bool,
      onChange: UU5.PropTypes.func,
      onBlur: UU5.PropTypes.func,
      onFocus: UU5.PropTypes.func,
      pluginExtensions: UU5.PropTypes.object,
      handleKeyCommand: UU5.PropTypes.bool,
      getToolbar: UU5.PropTypes.func,
      placeholder: UU5.PropTypes.string,
      forceRenderModal: UU5.PropTypes.bool,
      bgStyle: UU5.PropTypes.oneOf(["outline", "transparent"]),
      height: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
      minHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
      maxHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
      animatedToolbar: UU5.PropTypes.bool,
      dynamicToolbar: UU5.PropTypes.bool
    },
    //@@viewOff:propTypes

    //@@viewOn:getDefaultProps
    getDefaultProps() {
      return {
        value: "",
        buttons: undefined,
        readOnly: undefined,
        onChange: null,
        onBlur: null,
        onFocus: null,
        plugins: null,
        pluginExtensions: undefined,
        handleKeyCommand: true,
        getToolbar: null,
        forceRenderModal: false,
        bgStyle: "outline",
        height: "auto",
        minHeight: "106px",
        maxHeight: "none",
        animatedToolbar: true,
        dynamicToolbar: true
      };
    },
    //@@viewOff:getDefaultProps

    //@@viewOn:reactLifeCycle
    getInitialState() {
      // process plugins - add UU5StringPlugin to be the last plugin - it returns universal component for each style, entity or block
      this._plugins = Plugin.mergePlugins(this.props, pluginMap).map(plugin =>
        PluginFactory.createPluginFromDefinition(plugin)
      );
      // sort plugins from the highest order to the lowest
      this._plugins.sort((p1, p2) => p2.order - p1.order);

      let config = Plugin.processPlugins(this._plugins, this.props.pluginExtensions);

      const _buttonMap = config.buttonMap || {}; // map of button definitions fro toolbar
      this._areaConfig = config.areaConfig; // configuration for editor
      this._htmlMappings = config.htmlMappings; // mapping from html to components

      // get data for buttons from buttons defined by plugins
      let _toolbarButtons = this.props.buttons === undefined ? EDITOR_BUTTONS : this.props.buttons;
      _toolbarButtons =
        _toolbarButtons &&
        _toolbarButtons.reduce((toolbarButtons, buttonName) => {
          if (_buttonMap[buttonName]) {
            toolbarButtons.push(_buttonMap[buttonName]);
          }

          return toolbarButtons;
        }, []);

      return { areaLoaded: false, buttons: _toolbarButtons, customToolbar: false };
    },

    componentDidCatch(error) {
      // all components is unmounted ... we need to save error data to local variables and wait for call of register functions
      // in them set data to editor and show error message
      let editorState = this.getArea().getEditorState();
      UU5.Common.Tools.error(error, { editorState });
      // save previous editor state
      this._errorEditorState = EditorState.redo(editorState);
      // save error to alert bus
      this._errorMsg = this.getLsiValue("editorError");
      // forse rerender of component - all child components will be mounted again
      this.forceUpdate();
    },
    //@@viewOff:reactLifeCycle

    //@@viewOn:interface
    setValue(uu5string, opt, setStateCallback) {
      let focus = false;
      let propsFormatter;
      switch (typeof opt) {
        case "object":
          if (opt) {
            focus = opt.focus !== undefined ? opt.focus : focus;
            propsFormatter = opt.propsFormatter;
          }
          break;
        case "function":
          propsFormatter = opt;
          break;
        case "boolean":
          focus = opt;
          break;
      }
      let editorState;
      if (!uu5string || EmptyUU5String.test(uu5string)) {
        editorState = EditorState.createEmpty(new CompositeDecorator(this._areaConfig.decorators));
      } else {
        try {
          editorState = DataConversion.uu5stringToEditorState(
            uu5string,
            this._areaConfig.decorators,
            this._getEditorItem,
            propsFormatter
          );
        } catch (e) {
          this.setError(this.getLsiValue("uu5stringToEditorError"), { e, uu5string: uu5string });
        }
      }
      this._area.setEditorState(editorState, focus, setStateCallback);
      return editorState;
    },

    getValue(editorState = this._area.getEditorState(), formatter) {
      try {
        return DataConversion.editorStateToUU5String(editorState, this._getUU5Item, formatter);
      } catch (e) {
        this.setError(this.getLsiValue("editorStateToUu5stringError"), { editorState, e });
      }
    },

    getArea() {
      return this._area;
    },

    focus() {
      this._focus();
    },

    setCursorPosition(cursorPosition) {
      this._focus(cursorPosition);
    },

    isMultiline(uu5stringOrEditorState = this._area.getEditorState()) {
      return Editor.isMultiline(uu5stringOrEditorState, this._plugins);
    },

    setError(msg, e) {
      if (this._alertBus) {
        this._alertBus.setAlert({ content: msg });
      }
      UU5.Common.Tools.error(msg, e);
    },

    setInfo(msg) {
      if (this._alertBus) {
        this._alertBus.setAlert({ content: msg, colorSchema: "primary" });
      }
    },

    //@@viewOff:interface

    //@@viewOn:overriding
    //@@viewOff:overriding

    //@@viewOn:private
    _focus(cursorPosition = "default") {
      this.getArea().focus();
      if (cursorPosition === "start") {
        this.getArea().setEditorState(Selection.moveSelectionToStart(this.getArea().getEditorState()));
      } else if (cursorPosition === "end") {
        this.getArea().setEditorState(Selection.moveSelectionToEnd(this.getArea().getEditorState()));
      }
    },

    _onChange(area, editorState) {
      if (typeof this.props.onChange === "function") {
        editorState = this.props.onChange(this, editorState) || editorState;
      }
      return editorState;
    },

    _onBlur(e) {
      if (typeof this.props.onBlur === "function") {
        this.props.onBlur(e, this);
      }

      if (typeof this.props.getToolbar === "function") {
        const toolbar = this.props.getToolbar();
        if (toolbar) toolbar.setItems(this, []);
      } else {
        this.setState({ focused: false });
      }
    },

    _registerToolbar(toolbar) {
      this._toolbar = toolbar;

      if (this.props.getToolbar !== "function") {
        if (!this.props.dynamicToolbar) {
          this._toolbar.setItems(this, this.state.buttons);
        }

        this.setState({ customToolbar: true });
      }
    },

    _registerArea(area) {
      this._area = area;
      // init area
      if (this._errorEditorState) {
        this._areaConfig.editorState = this._errorEditorState;
        delete this._errorEditorState;
      } else if (this.props.value) {
        try {
          this._areaConfig.editorState = DataConversion.uu5stringToEditorState(
            this.props.value,
            this._areaConfig.decorators,
            this._getEditorItem
          );
        } catch (e) {
          this.setError(this.getLsiValue("uu5stringToEditorError"), { e, value: this.props.value });
        }
      }

      this._area.set(this._areaConfig);
      this.setState({ areaLoaded: true });
    },

    _registerAlertBus(alertBus) {
      this._alertBus = alertBus;
      if (this._errorMsg) {
        this._alertBus.setAlert({ content: this._errorMsg });
        delete this._errorMsg;
      }
    },

    _getArea() {
      return this._area;
    },

    _getToolbar() {
      if (typeof this.props.getToolbar === "function") {
        return this.props.getToolbar();
      }
      return this._toolbar;
    },

    _getUU5Item(type, name, props, wrapper, wrapperProps, isEmpty) {
      let result;
      for (let index = 0; index < this._plugins.length; index++) {
        let plugin = this._plugins[index];
        if (typeof plugin.toUU5Item === "function") {
          result = plugin.toUU5Item(type, name, props, wrapper, wrapperProps, isEmpty);
          if (result) break;
        }
      }

      return result;
    },

    _getEditorItem(name, props, children, wrapper, wrapperProps) {
      return Editor._getEditorItem(this._plugins, name, props, children, wrapper, wrapperProps);
    },

    _handlePaste(text, html, editorState) {
      let uu5string;
      if (html) {
        let fragment = document.createElement("html");
        fragment.innerHTML = html;

        // build tag props tree and process by standard data conversion from html to content
        let body = fragment.getElementsByTagName("body")[0];
        if (body) {
          try {
            // eslint-disable-next-line react/no-find-dom-node
            let currentNode = this.findDOMNode();
            // find content root node - contains better styles to filter
            let contentNode = currentNode && currentNode.querySelector(".public-DraftEditor-content");
            uu5string = DataConversion.parseHtmlNodeListToUu5stringObject(
              body.childNodes,
              this._htmlMappings,
              currentNode ? getComputedStyle(contentNode || currentNode) : null
            );
          } catch (e) {
            this.setError(this.getLsiValue("htmlParseError"), { html: body, e });
          }
        }
      } else if (UU5.Common.UU5String.isValid(text)) {
        uu5string = text;
      }

      if (uu5string) {
        let newSelection;
        let blockDataMap = {};
        let raw;
        try {
          raw = DataConversion.uu5stringToRaw(uu5string, blockDataMap, this._getEditorItem);
        } catch (e) {
          this.setError(this.getLsiValue("uu5stringToEditorError"), { uu5string, e });
          return;
        }
        let toRemove = [];
        for (let i = 0; i < raw.blocks.length; i++) {
          let block = raw.blocks[i];
          if (!block.text && block._uu5richTextDataCollector) {
            toRemove.push(i);
          }
        }
        // remove empty helping blocks ( uu5richTextDataCollector )
        for (let i = toRemove.length - 1; i >= 0; i--) {
          let indexToRemove = toRemove[i];
          raw.blocks.splice(indexToRemove, 1);
        }
        let newContentState = editorState.getCurrentContent();
        let selection = editorState.getSelection();
        // add current content state into history stack
        let undoStack = editorState.getUndoStack().push(newContentState);

        if (!editorState.getSelection().isCollapsed()) {
          newContentState = Modifier.removeRange(
            newContentState,
            selection,
            selection.isBackward ? "backward" : "forward"
          );
          selection = Selection.collapseToStart(selection);
        }

        // check if all of created blocks are unstyled or artificial -> insert whole content into current block and dont split blocks
        let shouldSplitBLocks = !raw.blocks.every(
          block =>
            (block.type === "unstyled" && (!block._uu5richTextDataCollector && !blockDataMap[block.key])) ||
            (blockDataMap[block.key] &&
              blockDataMap[block.key].artificial &&
              Object.keys(blockDataMap[block.key]).length === 1)
        );

        // if all text will be pasted into current block, empty blockDataMap
        if (!shouldSplitBLocks) {
          blockDataMap = {};
        }

        if (shouldSplitBLocks) {
          // not needed to slit block if cursor is at the end of the selected block
          if (newContentState.getBlockForKey(selection.getStartKey()).getText().length > selection.getStartOffset()) {
            newContentState = Modifier.splitBlock(newContentState, selection);
          }
        }

        // merge raw
        let currentRaw = convertToRaw(newContentState);

        // find block with focus
        let selectedBlockIndex = currentRaw.blocks.findIndex(block => block.key === selection.anchorKey);
        let directionMap = editorState.getDirectionMap();
        let direction = directionMap.get(selection.anchorKey);

        // update entity map
        let entityKeyOffset = Object.keys(currentRaw.entityMap).length;

        for (let index = 0; index < raw.blocks.length; index++) {
          let block = raw.blocks[index];
          // update entity keys to prevent colisions with raw and current raw
          for (let eIndex = 0; eIndex < block.entityRanges.length; eIndex++) {
            let entityRange = block.entityRanges[eIndex];
            entityRange.key += entityKeyOffset;
          }
          // prepare map of block directions when we add block into content
          if (shouldSplitBLocks) {
            directionMap = directionMap.set(block.key, direction);
          }
        }

        // merge entities from raw to currentRaw
        for (let entityKey in raw.entityMap) {
          currentRaw.entityMap[parseInt(entityKey) + entityKeyOffset + ""] = raw.entityMap[entityKey];
        }

        if (shouldSplitBLocks) {
          // splice blocks into current raw
          if (currentRaw.blocks[selectedBlockIndex].text) {
            currentRaw.blocks.splice(selectedBlockIndex + 1, 0, ...raw.blocks);
          } else {
            // replace empty block
            currentRaw.blocks.splice(selectedBlockIndex, 1, ...raw.blocks);
          }

          // move cursor after last added block
          let lastAddedBlock = raw.blocks[raw.blocks.length - 1];
          newSelection = {
            startOffset: lastAddedBlock.text.length,
            endOffset: lastAddedBlock.text.length,
            startKey: lastAddedBlock.key,
            endKey: lastAddedBlock.key
          };
        } else {
          // insert text into current block
          let selectedBlock = currentRaw.blocks[selectedBlockIndex];
          let resultText = selectedBlock.text.substring(0, selection.anchorOffset);
          let textOffset = resultText.length;
          let pastedTextLength = 0;
          let pasteInsideEntity = false;
          raw.blocks.forEach(block => (pastedTextLength += block.text.length));
          // update positions of all styles and entities in block
          selectedBlock.entityRanges.forEach(range => {
            if (range.offset >= textOffset) {
              // entity is after cursor -> move start of entity after end of inserted text
              range.offset += pastedTextLength;
            } else if (range.offset + range.length >= textOffset) {
              // paste inside entity -> update length of entity to contain pasted text and mark paste as inside entity to remove all entities from pasted text
              pasteInsideEntity = true;
              range.length += pastedTextLength;
            }
          });

          // update inline styles
          let splitStyles = [];
          for (let i = 0; i < selectedBlock.inlineStyleRanges.length; i++) {
            let range = selectedBlock.inlineStyleRanges[i];
            if (range.offset >= textOffset) {
              // style is after cursor -> move style after end of inserted text
              range.offset += pastedTextLength;
            } else if (range.offset + range.length >= textOffset) {
              // paste text inside style - split style into two parts
              let styleBeforeLength = textOffset - range.offset;
              let styleAfterLength = range.length - styleBeforeLength;
              range.length = styleBeforeLength;
              let newRange = { ...range };
              newRange.offset = textOffset + pastedTextLength;
              newRange.length = styleAfterLength;
              splitStyles.push(newRange);
            }
          }
          // add splited parts of inline styles into inlineStyleRanges
          selectedBlock.inlineStyleRanges.push(...splitStyles);

          for (let blockIndex = 0; blockIndex < raw.blocks.length; blockIndex++) {
            textOffset = resultText.length;
            let block = raw.blocks[blockIndex];
            resultText += block.text;
            if (!pasteInsideEntity) {
              for (let entityIndex = 0; entityIndex < block.entityRanges.length; entityIndex++) {
                let range = block.entityRanges[entityIndex];
                range.offset += textOffset;
                selectedBlock.entityRanges.push(range);
              }
            }
            for (let styleIndex = 0; styleIndex < block.inlineStyleRanges.length; styleIndex++) {
              let style = block.inlineStyleRanges[styleIndex];
              style.offset += textOffset;
              selectedBlock.inlineStyleRanges.push(style);
            }
          }
          resultText += selectedBlock.text.substring(selection.anchorOffset);
          selectedBlock.text = resultText;

          let newSelectionOffset = selection.getStartOffset() + pastedTextLength;
          newSelection = {
            startOffset: newSelectionOffset,
            endOffset: newSelectionOffset,
            startKey: selection.getStartKey(),
            endKey: selection.getEndKey()
          };
        }

        newContentState = convertFromRaw(currentRaw);

        if (newSelection) {
          // update selection and selection history
          let _newEditorState = Selection.updateSelection(editorState, newSelection);
          newSelection = _newEditorState.getSelection();
          newContentState = newContentState.set("selectionBefore", editorState.getSelection());
          newContentState = newContentState.set("selectionAfter", _newEditorState.getSelection());
        }

        let newEditorState = EditorState.set(editorState, {
          currentContent: newContentState,
          selection: newSelection || selection,
          directionMap,
          undoStack
        });

        // set data into editor state
        for (let blockKey in blockDataMap) {
          let content = Modifier.setBlockData(
            newEditorState.getCurrentContent(),
            Selection.modifySelection(editorState, {
              anchorKey: blockKey,
              focusKey: blockKey,
              anchorOffset: 0,
              focusOffset: 0
            }),
            blockDataMap[blockKey]
          );
          newEditorState = EditorState.set(newEditorState, { currentContent: content });
        }
        let newContent = newEditorState.getCurrentContent();
        newContent = newContent.set("selectionAfter", newEditorState.getSelection());
        newEditorState = EditorState.set(newEditorState, {
          currentContent: editorState.getCurrentContent(),
          selection: editorState.getSelection()
        });
        newEditorState = EditorState.push(newEditorState, newContent, "paste uu5string");

        this.getArea().setEditorState(newEditorState);
        return true; // handled
      }

      return false; // let handling of text to draft
    },

    _showToolbar() {
      return typeof this.props.getToolbar !== "function";
    },

    _handleFocus(event) {
      if (typeof this.props.onFocus === "function") this.props.onFocus(event);

      if (typeof this.props.getToolbar === "function") {
        const toolbar = this.props.getToolbar();
        if (toolbar) toolbar.setItems(this, this.state.buttons);
      } else {
        this.setState({ focused: true });
      }
    },
    //@@viewOff:private

    //@@viewOn:render
    render() {
      const mainAttrs = this.getMainAttrs();
      if (this.props.bgStyle === "transparent") {
        mainAttrs.className += ` ${this.getClassName("bgstyleTransparent")}`;
      }
      return (
        <div {...mainAttrs}>
          <UU5.Bricks.AlertBus ref_={this._registerAlertBus} colorSchema="danger" closeTimer={5000} />
          <Area
            ref_={this._registerArea}
            onChange={this._onChange}
            onBlur={this._onBlur}
            onFocus={this._handleFocus}
            readOnly={this.props.readOnly}
            getToolbar={this._getToolbar}
            handleKeyCommand={this.props.handleKeyCommand}
            onPaste={this._handlePaste}
            placeholder={this.props.placeholder}
            forceRenderModal={this.props.forceRenderModal}
            key="area"
            id="area"
          />
          {this._showToolbar() && (
            <Toolbar
              ref_={this._registerToolbar}
              className={this.getClassName("toolbar")}
              items={this.state.focused ? this.state.buttons : undefined}
              getArea={this._getArea}
              disabled={!this.state.areaLoaded || this.props.readOnly}
              key="toolbar"
              id="toolbar"
              animated={this.props.animatedToolbar}
              dynamic={this.props.dynamicToolbar}
            />
          )}
        </div>
      );
    }
    //@@viewOff:render
  })
);

Editor.isMultiline = function(uu5stringOrEditorState, plugins) {
  // uu5stringOrEditorState and plugins are mandatory
  if (!uu5stringOrEditorState || !plugins) {
    const msg = UU5.Common.Tools.getLSIItemByLanguage(UU5.Environment.Lsi.RichText.editor.mandatoryMethodParams);
    UU5.Common.Tools.error(msg, {
      uu5string: uu5stringOrEditorState ? "OK" : "Missing",
      plugins: plugins ? "OK" : "Missing"
    });
    throw msg;
  }
  let editorState;
  if (typeof uu5stringOrEditorState === "string") {
    const mergedPlugins = Plugin.mergePlugins({ plugins }, pluginMap).map(plugin =>
      PluginFactory.createPluginFromDefinition(plugin)
    );

    // sort plugins from the highest order to the lowest
    mergedPlugins.sort((p1, p2) => p2.order - p1.order);

    const config = Plugin.processPlugins(mergedPlugins);

    try {
      editorState = DataConversion.uu5stringToEditorState(
        uu5stringOrEditorState,
        config.areaConfig.decorators,
        (...args) => Editor._getEditorItem(mergedPlugins, ...args)
      );
    } catch (e) {
      const msg = UU5.Common.Tools.getLSIItemByLanguage(UU5.Environment.Lsi.RichText.editor.uu5stringToEditorError);
      UU5.Common.Tools.error(msg, { e, uu5string: uu5stringOrEditorState });
      throw msg;
    }
  } else {
    editorState = uu5stringOrEditorState;
  }

  // check if editorState has more blocks
  const blocks = editorState.getCurrentContent().getBlocksAsArray();
  if (blocks.length > 1) {
    return true;
  }

  return !!blocks[0].getText().match(/\n/);
};

Editor._getEditorItem = function(plugins, name, props, children, wrapper, wrapperProps) {
  let result = { matchRate: 0 };
  let _res;
  for (let index = 0; index < plugins.length; index++) {
    let plugin = plugins[index];
    if (typeof plugin.toEditorItem === "function") {
      _res = plugin.toEditorItem(name, props, children, wrapper, wrapperProps);
      if (_res && _res.matchRate === undefined) {
        return _res;
      } else if (_res && _res.matchRate > result.matchRate) {
        result = _res;
        if (result.matchRate === 1) break;
      }
    }
  }

  return result.matchRate ? result : undefined;
};

export default Editor;
