import * as UU5 from "uu5g04";
import Config from "./config.js";
import ToolbarButton from "./toolbar-button.js";

import Style from "./bricks/style.js";

import "./toolbar.less";

const iconWidth = 32;

export const Toolbar = UU5.Common.LsiMixin.withContext(
  UU5.Common.VisualComponent.create({
    //@@viewOn:mixins
    mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.ResizeMixin, UU5.Common.LsiMixin],
    //@@viewOff:mixins

    //@@viewOn:statics
    statics: {
      tagName: Config.TAG + "Toolbar",
      classNames: {
        main: (props, state) =>
          Config.CSS +
          "toolbar " +
          UU5.Common.Css.css(`
            max-height: 34px;
            border: 1px solid #BDBDBD;
            ${props.dynamic && state.empty ? "height: 0; border: none;" : ""}
            pointer-events: ${state.empty && props.dynamic ? "none" : "auto"};
            overflow: ${state.empty && props.dynamic ? "hidden" : "visible"};
            ${
              !state.empty && props.dynamic && props.animated
                ? "animation-name: uu5-richtext-toolbar-show; animation-duration: 0.5s;"
                : ""
            };

            & > * {
              position: relative;
              ${props.animated && props.dynamic ? "transition: top 0.5s;" : ""}
            }

            && > * {
              top: ${props.dynamic && state.empty ? -35 : 0}px;
            }
          `),
        invisible: () => UU5.Common.Css.css("visibility: hidden;"),
        background: () =>
          UU5.Common.Css.css(`
            height: 32px;
            background: #FFFFFF;
          `)
      }
    },
    //@@viewOff:statics

    //@@viewOn:propTypes
    propTypes: {
      items: UU5.PropTypes.arrayOf(
        UU5.PropTypes.shape({
          icon: UU5.PropTypes.string,
          items: UU5.PropTypes.arrayOf(
            UU5.PropTypes.shape({
              label: UU5.PropTypes.oneOfType([UU5.PropTypes.string, UU5.PropTypes.object, UU5.PropTypes.func]),
              value: UU5.PropTypes.string,
              usePrefix: UU5.PropTypes.bool
            })
          ),
          label: UU5.PropTypes.oneOfType([UU5.PropTypes.string, UU5.PropTypes.object, UU5.PropTypes.func]),
          type: UU5.PropTypes.oneOf(["inline", "block", "entity", "custom", "customEntity", "customBlock"]),
          value: UU5.PropTypes.string
        })
      ),
      getArea: UU5.PropTypes.func,
      animated: UU5.PropTypes.bool,
      dynamic: UU5.PropTypes.bool
    },
    //@@viewOff:propTypes

    //@@viewOn:getDefaultProps
    getDefaultProps() {
      return {
        items: [],
        getArea: null,
        animated: false,
        dynamic: true
      };
    },
    //@@viewOff:getDefaultProps

    //@@viewOn:reactLifeCycle
    getInitialState() {
      this._buttons = new Array(this.props.items.length);
      return {
        maxIcons: 9999,
        editorState: null,
        getArea: this.props.getArea,
        items: this.props.items,
        visible: false, // hide toolbar before first measure, otherwise icons overflow from container
        empty: !this.props.items || !this.props.items.length
      };
    },

    componentWillReceiveProps(nextProps) {
      // eslint-disable-next-line react/prop-types
      if (this.props.controlled) {
        let newState = {};

        if (nextProps.getArea !== this.state.getArea && typeof nextProps.getArea === "function") {
          let area = nextProps.getArea();
          let nextEditorState = area.getEditorState();
          if (area && this.state.editorState !== nextEditorState) {
            newState.editorState = nextEditorState;
          }
          newState.getArea = nextProps.getArea;
        }

        if (nextProps.items.length > this.props.items.length) {
          let _buttons = new Array(nextProps.items.length);
          for (let i = 0; i < this._buttons.length; i++) {
            _buttons[i] = this._buttons[i];
          }
          this._buttons = _buttons;
        }

        if (nextProps.items && nextProps.items.length) {
          newState.items = nextProps.items;
          newState.empty = false;
          // indicates that toolbar will be animated
        } else {
          newState.empty = true;
        }

        this.setState(newState);
      }
    },
    //@@viewOff:reactLifeCycle

    //@@viewOn:interface
    update(editorState) {
      this.setState({ editorState }, () => {
        for (let i = 0; i < this._buttons.length; i++) {
          let button = this._buttons[i];
          // not each button should have API for opening and closing button
          if (button && typeof button.isOpen === "function" && button.isOpen()) {
            button.close();
          }
        }
      });
    },

    setItems(editor, items) {
      this.setState(state => {
        let newState = {
          getArea: editor.getArea,
          items: items && items.length ? items : this.props.dynamic ? state.items : items,
          empty: !items || !items.length,
          editorState: editor.getArea().getEditorState()
        };
        return newState;
      });
    },
    //@@viewOff:interface

    //@@viewOn:overriding
    onResize_(oldWidth, newWidth) {
      let newMaxIcons = Math.max(Math.floor(newWidth / iconWidth), 0);
      let oldMaxIcons = this.state.maxIcons;
      if (newMaxIcons && newMaxIcons !== oldMaxIcons) {
        // it will always be lower after first render (if any icons are set) - this ensure set state visible to true
        if (oldMaxIcons !== newMaxIcons) {
          this.setState({ maxIcons: newMaxIcons, visible: true });
        }
      }
    },
    //@@viewOff:overriding

    //@@viewOn:private
    _onButtonClick(opt, callback) {
      if (typeof this.state.getArea !== "function") return;
      let area = this.state.getArea();
      if (!area) return;

      if (typeof opt.onClick === "function") {
        // process specific logic set by button
        let newEditorState = area.getEditorState();
        newEditorState = opt.onClick(newEditorState, area) || newEditorState;
        // update editor state
        area.setEditorState(newEditorState, callback);
      } else {
        // process standard change of editor state by inline styles, blocks or entities
        switch (opt.type) {
          case "inline":
            area.toggleInlineStyle(opt.value, opt.preserveStyle, opt.focus);
            break;
          case "block":
            area.toggleBlockType(opt.value);
            break;
          case "entity":
            // this method will set new editor state itself => stop next processing
            area.editSelectedComponent(opt.value, opt.component, opt.component, opt.onClick);
            break;
        }
      }
    },

    _isItemSelected(editorState, item) {
      return (
        !this.isDisabled() &&
        (editorState
          ? typeof item.isSelected === "function"
            ? item.isSelected(editorState, item)
            : Style.isSelected(editorState, item.type, item.value)
          : false)
      );
    },

    _getItems(editorState = this.state.editorState, items = this.state.items, parentItem) {
      let newItems = [];
      items.forEach((item, index) => {
        let result = UU5.Common.Tools.mergeDeep(item);
        result.props = result.props || {};
        if (parentItem) {
          result.value = parentItem.ignorePrefix ? result.value : `${parentItem.value}.${result.value}`;
          result.type = result.type || parentItem.type;
        }

        result.disabled =
          this.isDisabled() ||
          (editorState ? (typeof item.isDisabled === "function" ? item.isDisabled(editorState) : false) : true);

        result.selected = this._isItemSelected(editorState, result);

        if (typeof result.getProps === "function") {
          result.props = UU5.Common.Tools.merge(result.props, result.getProps(editorState, this.props.getArea, this));
        }

        result.label = this._getLsiItem(result.label);
        result.dropdownItemLabel = this._getLsiItem(result.dropdownItemLabel);

        if (result.props.items || result.items) {
          result.items = this._getItems(editorState, result.props.items || result.items, result);
          delete result.props.items;
        }

        if (!parentItem && index >= this.state.maxIcons) {
          if (index === this.state.maxIcons) {
            // pop last item in array and replace it by more item. Reset label of last item too.
            let lastItem = newItems.pop();
            newItems.push({
              value: "",
              icon: "mdi-dots-horizontal",
              items: [lastItem],
              props: { buttonProps: { pullRight: true } },
              disabled: this.isDisabled()
            });
          }

          newItems[this.state.maxIcons - 1].items.push(result);
        } else {
          newItems.push(result);
        }
      });

      return newItems;
    },

    _getLsiItem(lsi) {
      if (lsi && typeof lsi === "object") {
        return this.getLsiItem(lsi);
      } else if (typeof lsi === "function") {
        return this.getLsiItem(lsi());
      } else {
        return lsi;
      }
    },

    _getLocalizedItems(items) {
      if (!items || !Array.isArray(items)) {
        return items;
      }

      let result = [];
      for (let index = 0; index < items.length; index++) {
        let item = items[index];
        let resultItem = {};

        for (let propName in item) {
          if (propName === "label" || propName === "tooltip") {
            resultItem[propName] = this._getLsiItem(item[propName]);
            continue;
          }
          if (propName === "items") {
            resultItem[propName] = this._getLocalizedItems(item[propName]);
          }
          resultItem[propName] = item[propName];
        }

        result.push(resultItem);
      }

      return result;
    },

    _registerButton(index, button) {
      this._buttons[index] = button;
    },

    _renderButtons() {
      return this._getItems().map((item, index) => {
        let ButtonComponent = item.button || ToolbarButton;
        let onClick = opt => {
          opt.onClick = opt.onClick || item.onClick;
          this._onButtonClick(opt);
        };
        return (
          <ButtonComponent
            // eslint-disable-next-line react/jsx-no-bind
            ref_={button => this._registerButton(index, button)}
            key={index}
            className="uu5-richtext-toolbar-button"
            icon={item.icon}
            onClick={onClick}
            type={item.type || "custom"}
            value={item.value}
            getArea={this.state.getArea}
            disabled={item.disabled}
            pressed={item.selected}
            label={this._getLsiItem(item.label)}
            items={this._getLocalizedItems(item.items)}
            colorSchema="custom"
            tooltip={this._getLsiItem(item.tooltip || item.label)}
            preserveStyle={item.preserveStyle}
            {...item.props}
            baseline={true}
          />
        );
      });
    },
    //@@viewOff:private

    //@@viewOn:render
    render() {
      // if (!this.state.items || !this.state.items.length) return null;
      let mainProps = this.getMainPropsToPass();
      mainProps.disabled = false;
      if (!this.state.visible) {
        mainProps.className += ` ${this.getClassName("invisible")}`;
      }
      return (
        <UU5.Bricks.Div {...mainProps}>
          <div className={this.getClassName("background")}>
            {this.state.items && this.state.items.length ? this._renderButtons() : null}
          </div>
        </UU5.Bricks.Div>
      );
    }
    //@@viewOff:render
  })
);

export default Toolbar;
