//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Config from "./config.js";
import {
  Editor,
  EditorState,
  ContentState,
  CompositeDecorator,
  DefaultDraftBlockRenderMap,
  KeyBindingUtil,
  Modifier,
  RichUtils,
  convertToRaw,
  getDefaultKeyBinding
} from "draft-js";
import Immutable from "immutable";

import Entity from "./bricks/entity.js";
import Selection from "./bricks/selection.js";
import Style from "./bricks/style.js";

import "./area.less";
//@@viewOff:imports

const MAX_DEPTH = 10;

export const Area = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Config.TAG + "Area",
    classNames: {
      main: Config.CSS + "area"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: UU5.PropTypes.string,
    onChange: UU5.PropTypes.func,
    onBlur: UU5.PropTypes.func,
    onFocus: UU5.PropTypes.func,
    onPaste: UU5.PropTypes.func,
    readOnly: UU5.PropTypes.bool,
    handleKeyCommand: UU5.PropTypes.bool,
    getToolbar: UU5.PropTypes.func,
    placeholder: UU5.PropTypes.string,
    forceRenderModal: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      value: "",
      onChange: null,
      onBlur: null,
      onFocus: null,
      onPaste: null,
      readOnly: undefined,
      handleKeyCommand: false,
      getToolbar: null,
      forceRenderModal: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  // rename editorState to data
  getInitialState() {
    this._enterCommands = [{ shiftKey: true, fn: this._handleLineBreaks }];
    this._tabCommands = [];
    this._otherCommands = [];
    return {
      editorState: this.props.value
        ? EditorState.createWithContent(ContentState.createFromText(this.props.value))
        : EditorState.createEmpty(),
      readOnly: this.props.readOnly,
      customStyleMap: {},
      customStyleFns: [],
      blockRenderMap: DefaultDraftBlockRenderMap,
      getEditationFormMap: {}
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.readOnly !== undefined && nextProps.readOnly !== this.props.readOnly) {
      this.setState({ readOnly: nextProps.readOnly });
    }
  },

  componentDidMount() {
    this._updateStyles();
  },

  componentDidUpdate() {
    this._updateStyles();
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  setEditorState(editorState, focus = true, seStateCallback) {
    if (!editorState) {
      editorState = EditorState.createEmpty();
    }
    let newState = { editorState };
    // editorState may contain unknown inline styles, parse them and update customStyleMap if there is some unknown inline style with correct format
    let customStyleMap = this._updateCustomStyleMap(editorState);
    if (customStyleMap) {
      newState.customStyleMap = customStyleMap;
    }
    this._handleChangeState(newState, seStateCallback, focus);
    return this;
  },

  modifyEditorState(editorState, updateObj, historyLog) {
    let { currentContent, ...otherUpdates } = updateObj;
    let newEditorState = editorState;
    if (otherUpdates) {
      newEditorState = EditorState.set(newEditorState, otherUpdates);
    }
    if (currentContent) {
      if (historyLog) {
        // save previous content to History
        newEditorState = EditorState.push(newEditorState, currentContent, historyLog);
      } else {
        // modify editorState without save to history
        newEditorState = EditorState.set(newEditorState, { currentContent });
      }
    }

    return newEditorState;
  },

  updateEditorState(editorState, updateObj, focus, setStateCallback) {
    return this.setEditorState(EditorState.set(editorState, updateObj), focus, setStateCallback);
  },

  getEditorState() {
    return this.state.editorState;
  },

  setReadOnly(readOnly = true, setStateCallback) {
    this.setState({ readOnly: readOnly }, setStateCallback);
    return this;
  },

  isReadOnly() {
    return this.state.readOnly;
  },

  addInlineStyle(name, style) {
    this.setState(state => {
      // handle styles defined as a function
      if (typeof style === "function") {
        // check if style is not already exist
        if (state.customStyleFns.find(item => item.name === name)) {
          return;
        }
        return { customStyleFns: [...state.customStyleFns, { name, style }] };
      }

      // check if someone tries to change existing style
      if (state.customStyleMap && state.customStyleMap[name]) {
        return;
      }
      let newStyleMap = state.customStyleMap ? JSON.parse(JSON.stringify(state.customStyleMap)) : {};
      newStyleMap[name] = style;
      return { customStyleMap: newStyleMap };
    });
    return this;
  },

  setCustomStyleMap(customStyleMap) {
    let styleMap = {};
    let styleFns = [];
    for (let name in customStyleMap) {
      let style = customStyleMap[name];
      if (typeof style === "function") {
        styleFns.push({ name, style });
      } else {
        styleMap[name] = style;
      }
    }
    this.setState({ customStyleMap: styleMap, customStyleFns: styleFns });
    return this;
  },

  setBlockRenderMap(blockRenderMap) {
    // keep support for other draft default block types and add our myCustomBlock type
    this.setState({ blockRenderMap: this._createBlockRenderMap(blockRenderMap) });
    return this;
  },

  setBlockRendererFn(blockRendererFn) {
    this.setState({ blockRendererFn });
    return this;
  },

  setDecorators(decorators) {
    this.setState({ editorState: this._createEditorStateWithDecorators(decorators) });
    return this;
  },

  set(config) {
    let newState = {};

    // process blockRendererFn
    if (config.blockRendererFn) {
      newState.blockRendererFn = config.blockRendererFn;
    }

    // process blockRenderMap
    if (config.blockRenderMap) {
      newState.blockRenderMap = this._createBlockRenderMap(config.blockRenderMap);
    }

    // customStyleMap
    if (config.customStyleMap) {
      let styleMap = {};
      let styleFns = [];
      for (let name in config.customStyleMap) {
        let style = config.customStyleMap[name];
        if (typeof style === "function") {
          styleFns.push({ name, style });
        } else {
          styleMap[name] = style;
        }
      }
      newState.customStyleMap = styleMap;
      newState.customStyleFns = styleFns;
    }

    // getEditationFormMap - map of functions that returns editation form
    if (config.getEditationFormMap) {
      newState.getEditationFormMap = config.getEditationFormMap;
    }

    // process editorState and decorators
    if (config.editorState) {
      // dont process decorators - editor state contains information about decorators
      newState.editorState = config.editorState;

      // update customStyleMap - only if editor state was set
      let updatedStyleMap = this._updateCustomStyleMap(
        newState.editorState,
        newState.customStyleMap || this.state.customStyleMap
      );
      if (updatedStyleMap) {
        newState.customStyleMap = updatedStyleMap;
      }
    } else if (config.decorators) {
      newState.editorState = this._createEditorStateWithDecorators(config.decorators);
    }

    // empty commands
    this._enterCommands = [{ shiftKey: true, fn: this._handleLineBreaks }];
    this._entityOptions = config.entityOptions;
    // error plugin does not send its options by this config - only decorator so we add it manually
    this._entityOptions.error = { preserveEnters: true };
    this._otherCommands = [];
    this._tabCommands = [];
    if (config.commands) {
      config.commands.forEach(command => {
        if (command.keyCode === 13) {
          this._enterCommands.push(command);
        } else if (command.keyCode === 9) {
          this._tabCommands.push(command);
        } else {
          this._otherCommands.push({ ...command, code: "cmd_" + this._otherCommands.length });
        }
      });
    }

    this.setState(newState);
    return this;
  },

  toggleInlineStyle(inlineStyle, preserveStyle, focus) {
    let state = { editorState: Style.toggleInline(this.getEditorState(), inlineStyle, preserveStyle) };
    let callback;

    if (focus) {
      callback = this.focus;
    }

    // check if inline style is defined
    // if doesn't try to parse style from its string representation
    if (!this.state.customStyleMap[inlineStyle]) {
      let styleParts = inlineStyle.match(/^[^.]+\.([^:]+):(.*)$/);
      if (styleParts) {
        let customStyleMap = JSON.parse(JSON.stringify(this.state.customStyleMap));
        let style = {};
        style[styleParts[1]] = styleParts[2];
        customStyleMap[inlineStyle] = style;
        state.customStyleMap = customStyleMap;
      }
    }

    this._handleChangeState(state, callback);
    return this;
  },

  toggleBlockStyle(blockStyles, setStateCallback) {
    this._updateEditorStateByFn(setStateCallback, Style.toggleSelectedBlocksStyles, blockStyles);
    return this;
  },

  toggleBlockType(blockType, setStateCallback) {
    this._updateEditorStateByFn(setStateCallback, Style.toggleBlock, blockType);
    return this;
  },

  editSelectedComponent(entityName, button, aroundElement, setStateCallback) {
    // check if some editation is already in propgress
    if (this._openedDialogParams) {
      let onlyCloseDialog = this._openedDialogParams.entityName === entityName;
      this._closeDialog(true);
      // if is started editation of the same component - only close dialog
      if (onlyCloseDialog) {
        return;
      }
    }
    // find selected entity - startOffset is inside entity
    let editorState = this.getEditorState();
    const entityKey = Entity.getCurrentEntityKey(editorState);
    const entity = entityKey ? Entity.getEntityByKey(editorState, entityKey) : null;
    const getEditationForm = this.state.getEditationFormMap[entityName];
    // check if selected entity is the one we want to edit
    if (entity && entity.getType() === entityName) {
      // update selection to select whole entity - need to get text of entity
      let newEditorState = Entity.seÄºectEntity(editorState, entityKey);
      let data = entity.getData();
      // show eidtation form
      newEditorState =
        this._showComponentForm(
          newEditorState,
          entityName,
          button,
          aroundElement,
          getEditationForm,
          data,
          true,
          setStateCallback
        ) || newEditorState;
      this.setEditorState(newEditorState);
    } else {
      // show editation form
      this._showComponentForm(
        editorState,
        entityName,
        button,
        aroundElement,
        getEditationForm,
        undefined,
        false,
        setStateCallback
      );
    }
  },

  createEntity(editorState, setStateCallback, entityName, text = "\u200b", data, opts = {}) {
    const entityKey = Entity.create(editorState, entityName, opts.isMutable, data);

    // update inline component
    let newEditorState = RichUtils.toggleLink(editorState, editorState.getSelection(), entityKey);
    // replace text of selection
    if (text !== null) {
      let content = Modifier.replaceText(
        newEditorState.getCurrentContent(),
        newEditorState.getSelection(),
        text,
        undefined,
        entityKey
      );
      // update editor content
      newEditorState = EditorState.push(newEditorState, content, "create entity");
    }

    // update selection - set selection after component and update state
    if (!opts.preserveSelection) {
      Selection.moveSelectionAfterEntity(newEditorState, entityKey, editorState =>
        this.setEditorState(editorState, undefined, setStateCallback)
      );
    } else {
      this.setEditorState(newEditorState, undefined, setStateCallback);
    }
  },

  focus() {
    if (this.state.readOnly) {
      // prevent focusing readonly instance of editor
      return;
    }
    let editorState = this.getEditorState();
    let newEditorState = EditorState.set(editorState, {
      selection: editorState.getSelection().set("hasFocus", true),
      forceSelection: true,
      nativelyRenderedContent: null
    });
    this.setEditorState(newEditorState, false, () => {
      if (typeof this.props.onFocus === "function") {
        this.props.onFocus();
      }
    });
    return;
  },

  getStyles() {
    return this._styles;
  },

  // API for work with entity
  selectCurrentEntity(editorState, entityName) {
    return Entity.selectCurrentEntity(editorState, entityName);
  },

  // API for work with styles
  toggleBlockStyles(editorState, block, blockStyle, toggleFn) {
    return Style.toggleBlockStyles(editorState, block, blockStyle, toggleFn);
  },

  toggleSelectedBlocksStyles(editorState, blockStyle, toggleFn) {
    return Style.toggleSelectedBlocksStyles(editorState, blockStyle, toggleFn);
  },

  getCurrentStylesWithPrefix(editorState, prefix) {
    return Style.getCurrentStylesWithPrefix(editorState, prefix);
  },

  toggleBlock(editorState, blockType) {
    return Style.toggleBlock(editorState, blockType);
  },

  removeInlineStyle(editorState, inlineStyle) {
    return Style.removeInline(editorState, inlineStyle);
  },

  // API fro work with Selection
  updateSelection(editorState, update) {
    return Selection.updateSelection(editorState, update);
  },

  updateSelectedBlocks(editorState, update) {
    return Selection.updateSelectedBlocks(editorState, update);
  },
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private
  _updateEditorStateByFn(setStateCallback, fn, ...params) {
    this.setState(state => {
      let newEditorState = fn(state.editorState, ...params);
      if (newEditorState) {
        this._notifyOnChange(newEditorState);
        return { editorState: newEditorState };
      }
    }, setStateCallback);
  },

  _notifyOnChange(editorState) {
    // update toolbar
    if (typeof this.props.getToolbar === "function") {
      let toolbar = this.props.getToolbar();
      if (toolbar) {
        toolbar.update(editorState);
      }
    }
  },

  _onChange(editorState, setStateCallback, focusEditor) {
    this._handleChangeState({ editorState }, setStateCallback, focusEditor);
  },

  _handleChangeState(state, setStateCallback, focusEditor) {
    // call onChange props function
    if (typeof this.props.onChange === "function") {
      state.editorState = this.props.onChange(this, state.editorState) || state.editorState;
    }

    this.setState(state, () => {
      this._notifyOnChange(this.state.editorState);
      if (focusEditor && !this.state.readOnly) {
        this._editor.focus();
      }
      return typeof setStateCallback === "function" && setStateCallback();
    });
  },

  _handleTab(event) {
    const editorState = this.getEditorState();

    // call all commands
    for (let i = 0; i < this._tabCommands.length; i++) {
      let command = this._tabCommands[i];
      if (
        (command.shiftKey || false) === event.shiftKey &&
        (command.ctrlKey || false) === event.ctrlKey &&
        (command.altKey || false) === event.altKey
      ) {
        let result = command.fn(editorState, this);
        if (result) {
          // command was handled -> prevent default behavior
          event.stopPropagation();
          event.preventDefault();
          return result;
        }
      }
    }

    const newEditorState = RichUtils.onTab(event, editorState, MAX_DEPTH);
    if (newEditorState !== editorState) {
      this.setEditorState(newEditorState);
    }
  },

  _handleKeyCommand(command) {
    // run default key commands
    let editorState = RichUtils.handleKeyCommand(this.getEditorState(), command);

    // RichUtils.handleKeyCommand returns null as a result for Enter key
    if (editorState && editorState !== this.getEditorState()) {
      // update editorState and mark command as handled
      this.setEditorState(editorState);
      return "handled";
    } else {
      // apply custom commands
      for (let i = 0; i < this._otherCommands.length; i++) {
        let cmd = this._otherCommands[i];
        if (cmd.code === command) {
          editorState = cmd.fn(this.getEditorState(), this);
          if (editorState) {
            if (typeof editorState === "object") {
              this.setEditorState(editorState);
            }
            return "handled";
          }
        }
      }
    }

    return "not-handled";
  },

  _handleReturn(event, editorState) {
    // call all commands
    for (let i = 0; i < this._enterCommands.length; i++) {
      let command = this._enterCommands[i];
      if (
        (command.shiftKey || false) === event.shiftKey &&
        (command.ctrlKey || false) === event.ctrlKey &&
        (command.altKey || false) === event.altKey
      ) {
        let result = command.fn(editorState, this);
        if (result) {
          event.stopPropagation();
          event.preventDefault();
          return result;
        }
      }
    }

    if (event.shiftKey) {
      this._onChange(RichUtils.insertSoftNewline(editorState));
      return true;
    }

    return false;
  },

  _handleLineBreaks(editorState, area) {
    // for shift + enter manually insert line break to prevent breaking entity into two parts
    // find entity and check if enter is pressed inside uu5string
    let selection = editorState.getSelection();
    let content = editorState.getCurrentContent();
    let block = content.getBlockForKey(selection.getStartKey());
    let entityKey = block.getEntityAt(selection.getEndOffset());
    if (entityKey) {
      let entity = content.getEntity(entityKey);
      let entityOptions = this._entityOptions[entity.getType()];
      if (entityOptions && entityOptions.preserveEnters) {
        // add \n char into text and move cursor after that character
        area.setEditorState(Selection.insertText(editorState, "\n"));
        return true;
      }
    }
    return false;
  },

  _registerEditor(editor) {
    this._editor = editor;
  },

  _createEditorStateWithDecorators(decorators, editorContent = this.getEditorState().getCurrentContent()) {
    let compositeDecorators = new CompositeDecorator(decorators);
    return EditorState.createWithContent(editorContent, compositeDecorators);
  },

  _createBlockRenderMap(blockRenderMap) {
    return blockRenderMap ? Immutable.Map(blockRenderMap) : DefaultDraftBlockRenderMap;
  },

  // component editation
  _showComponentForm(
    editorState,
    entityName,
    button,
    aroundElement,
    getEditationForm,
    data = {},
    isEdit = false,
    setStateCallback
  ) {
    // handle non existing element - show form around selection
    if (!aroundElement) {
      // use native selection API to find selected node
      let selection = getSelection();
      let selectedNode = selection.anchorNode || selection.focusNode;
      while (selectedNode.nodeType !== 1) {
        selectedNode = selectedNode.parentNode;
      }
      aroundElement = selectedNode;
    }
    // get content for modal from plugin
    let text = Selection.getSelectedText(editorState);
    // this._pluginMap[entityName].getEditationForm
    if (typeof getEditationForm === "function") {
      let formDef = getEditationForm(
        entityName,
        text,
        data,
        (...props) => {
          this._addComponent(editorState, setStateCallback, ...props);
          // close modal
          this._closeDialog();
        },
        () => {
          this._closeDialog();
        },
        isEdit
      );
      this._openDialog(formDef, button, aroundElement, entityName);
    } else {
      if (isEdit) {
        // selection is inside existing entity => remove entity
        return Selection.removeEntityFromSelection(editorState, editorState.getSelection());
      } else {
        this._addComponent(editorState, setStateCallback, entityName, text, data, { preserveSelection: true });
      }
    }
  },

  _addComponent(editorState, setStateCallback, entityName, text, data, opts) {
    // update entity by new data
    this.createEntity(editorState, setStateCallback, entityName, text, data, opts);
  },

  _registerModal(modal) {
    this._modal = modal;
  },

  _registerPopover(popover) {
    this._popover = popover;
  },

  _openDialog(opts, button, aroundElement, entityName) {
    // close opened dialog
    if (this._openedDialogParams) {
      this._closeDialog(true);
    }
    this._openedDialogParams = { opts, button, aroundElement, entityName };
    // open new dialog
    this.setReadOnly(true, () => {
      let { isPopover, ...props } = opts;
      if (isPopover) {
        if (button && typeof button.press === "function") {
          button.press();
        }
        if (props.onClose) {
          props.onClose = (...params) => {
            props.onClose(...params);
            this._onClosePopover(...params);
          };
        }
        this._popover.open({
          onClose: this._onClosePopover,
          aroundElement: aroundElement,
          position: "bottom",
          offset: 4,
          ...props
        });
      } else {
        this._modal.open(props);
      }
    });
  },

  _closeDialog(preventStateChange) {
    if (!this._openedDialogParams) return; // no opened dialog registered
    this._openedDialogParams.opts.isPopover ? this._closePopover() : this._closeModal(preventStateChange);
  },

  _closeModalAndEnableEditor() {
    this._closeModal();
  },

  _closeModal(preventStateChange) {
    if (preventStateChange) {
      this._modal.close(false);
    } else {
      this.setReadOnly(false, () => {
        this._modal.close(false);
        this.focus();
      });
    }
    delete this._openedDialogParams;
  },

  _closePopover() {
    this.setReadOnly(false, () => {
      this._popover.close();
      this._onClosePopover(true);
      this.focus();
    });
  },

  _onClosePopover(preventStateChange) {
    if (!this._openedDialogParams) return; // no opened dialog registered
    // enable editor
    if (!preventStateChange) {
      this.setReadOnly(false);
    }
    if (this._openedDialogParams.button && typeof this._openedDialogParams.button.pressUp === "function") {
      this._openedDialogParams.button.pressUp();
    }
    delete this._openedDialogParams;
  },

  _updateCustomStyleMap(editorState = this.state.editorState, customStyleMap = this.state.customStyleMap) {
    let raw = convertToRaw(editorState.getCurrentContent());
    let updated = false;
    for (let i = 0; i < raw.blocks.length; i++) {
      let block = raw.blocks[i];
      if (block.inlineStyleRanges) {
        for (let styleIndex = 0; styleIndex < block.inlineStyleRanges.length; styleIndex++) {
          let styleName = block.inlineStyleRanges[styleIndex].style;
          // check if style is already in styleMap
          if (!customStyleMap[styleName]) {
            // try to parse style
            let postfix = styleName.match(/^[^.]+\.(.*)$/);
            if (!postfix) continue;
            let parts = postfix[1].split(";");
            let styleDefinition = {};
            for (let partIndex = 0; partIndex < parts.length; partIndex++) {
              let styleParts = parts[partIndex].match(/^([^:]+):(.+)$/);
              // let styleParts = styleName.match(/^[^.]+\.([^:]+):(.*)$/);
              if (styleParts) {
                // add style into styleMap
                if (!updated) {
                  updated = true;
                  // clone customStyleMap - only first time
                  customStyleMap = JSON.parse(JSON.stringify(customStyleMap));
                }

                styleDefinition[styleParts[1]] = styleParts[2];
              }
            }

            // update style map
            if (Object.keys(styleDefinition).length) {
              customStyleMap[styleName] = styleDefinition;
            }
          }
        }
      }
    }

    if (updated) {
      return customStyleMap;
    }
  },

  _keyBindingFn(e) {
    if (KeyBindingUtil.hasCommandModifier(e)) {
      for (let i = 0; i < this._otherCommands.length; i++) {
        let cmd = this._otherCommands[i];
        if (cmd.alt && !e.altKey) continue;
        if (cmd.keyCode !== e.which) continue;
        return cmd.code;
      }

      // handle CTRL/CMD + X to to fix default Draft's behavior
      if (e.keyCode === 88 /* X key */) {
        // draft reads scroll position from our inner scrollbar and after cut of text draft updates scroll position on parent scrollbar
        // to disable this behavior we need to temporary overwrite method restoreEditorDOM to remove input paramter scrollPosition
        let fn = this._editor.restoreEditorDOM;
        this._editor.restoreEditorDOM = () => {
          this._editor.restoreEditorDOM = fn;
          this._editor.restoreEditorDOM();
        };
        return null; // let process standart cut operation by draft
      }
      // block key for command "code" - creates code block
      // we want to allow only inline formatting - bold, italic, underline
      if (e.keyCode === 74 /* J key */) {
        return null;
      }
    }

    return getDefaultKeyBinding(e);
  },

  _handlePaste(text, html, editorState) {
    if (typeof this.props.onPaste === "function") {
      return this.props.onPaste(text, html, editorState);
    }

    return false; // not handled
  },

  _showPlaceholder() {
    const editorState = this.getEditorState();
    const content = editorState.getCurrentContent();
    const blocks = content.getBlocksAsArray();
    if (blocks.length === 1 && blocks[0].getType() === "unstyled" && !blocks[0].getText()) {
      return this.props.placeholder;
    }
  },

  _updateStyles() {
    // eslint-disable-next-line react/no-find-dom-node
    this._styles = getComputedStyle(this.findDOMNode());
  },

  _customStyleFn(styleSet, block) {
    let styleObj = {};
    let result = {};
    styleSet.forEach(item => {
      let style = this.state.customStyleMap[item];
      if (style) {
        styleObj = { ...styleObj, ...style };
      }
    });
    for (let i = 0; i < this.state.customStyleFns.length; i++) {
      let styleFn = this.state.customStyleFns[i];
      if (styleSet.get(styleFn.name)) {
        let res = styleFn.style(styleObj, block);
        if (res) {
          result = { ...result, ...res };
          styleObj = { ...styleObj, ...res };
        }
      }
    }

    return result;
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    return (
      <UU5.Common.Fragment>
        <Editor
          ref={this._registerEditor}
          {...this.getMainAttrs()}
          placeholder={this._showPlaceholder()}
          readOnly={this.isReadOnly()}
          editorState={this.getEditorState()}
          onChange={this._onChange}
          onTab={this._handleTab}
          customStyleMap={this.state.customStyleMap}
          customStyleFn={this._customStyleFn}
          blockRendererFn={this.state.blockRendererFn}
          blockRenderMap={this.state.blockRenderMap}
          keyBindingFn={this.props.handleKeyCommand ? this._keyBindingFn : undefined}
          handleKeyCommand={this.props.handleKeyCommand ? this._handleKeyCommand : undefined}
          onBlur={this.props.onBlur}
          onFocus={this.props.onFocus}
          handlePastedText={this._handlePaste}
          handleReturn={this._handleReturn}
        />
        <UU5.Bricks.PortalModal
          ref_={this._registerModal}
          onClose={this._closeModalAndEnableEditor}
          forceRender={this.props.forceRenderModal}
        />
        <UU5.Bricks.PortalPopover ref={this._registerPopover} />
      </UU5.Common.Fragment>
    );
  }
  //@@viewOff:render
});

export default Area;
