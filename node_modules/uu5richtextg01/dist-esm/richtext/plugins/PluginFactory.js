import * as UU5 from "uu5g04";
import Immutable from "immutable";

//default commands for changing styles, entites and blocks
const COMMANDS = {
  inline: (editorState, area, name) => {
    area.toggleInlineStyle(name);
    return true;
  },
  block: (editorState, area, blockName) => {
    area.toggleBlockType(blockName);
    return true;
  },
  entity: (editorState, area, entityName) => {
    area.editSelectedComponent(entityName);
    return true;
  }
};

// for now is support only for one style
const generateType = (prefix, style, propsStyle) => {
  let result = prefix + ".";
  let count = 0;
  for (let styleName in style) {
    result += `${count > 0 ? ";" : ""}${styleName}:${propsStyle[styleName]}`;
  }

  return result;
};

const toEditorItem = function(tag, props, children, wrapper, wrapperProps) {
  let returnProps = true;
  if (!props) {
    props = {};
    returnProps = false;
  }
  let result = null;
  let def;
  let maxMatchRate = 0;

  this.toEditorItemDefs &&
    this.toEditorItemDefs.forEach(tagDef => {
      if (
        tagDef.tagName &&
        (tagDef.tagName === true || tagDef.tagName === tag) &&
        (!tagDef.wrapperTagName || tagDef.wrapperTagName === wrapper) &&
        (tagDef.type !== "entity" || typeof tagDef.fn === "function" || (children && children.length > 0))
      ) {
        let matchRate = getMatchRate(tagDef.style, props.style);
        if (matchRate > maxMatchRate) {
          def = tagDef;
          maxMatchRate = matchRate;
        }
      }
    });

  if (def) {
    if (def.fn) {
      result = def.fn(tag, props, children, wrapper, wrapperProps);
      result.display = result.display || this.type;
      result.value = result.value || this.name;
      if (result.props) {
        result.data = result.data || {};
        result.data.props = result.props;
        delete result.props;
      }
    } else if (def.prefix && def.style && props.style && this.type === "inline") {
      result = {
        display: this.type,
        type: generateType(def.prefix, def.style, props.style)
      };
    } else {
      result = {
        display: def.type,
        type: def.name
      };
      if (returnProps) {
        result.data = { props };
      }
    }

    if (!def.preserveEnters) {
      result.children = result.children || children;
      if (Array.isArray(result.children)) {
        result.children = result.children.map(child => {
          if (child && child.tag === "br") {
            return "\n";
          }
          return child;
        });
      }
    }

    result.matchRate = maxMatchRate;
  }

  return result;
};

const toObject = function(type, name, props = {}, parent, parentProps, isEmpty) {
  let result;
  // find correct definition
  let def =
    this.toObjectDefs &&
    this.toObjectDefs.find(def => {
      if (def.type !== type) return;
      if (def.name) {
        return def.name === name;
      } else if (def.prefix) {
        return def.prefix === name.split(".")[0];
      } else {
        return this.name === name;
      }
    });

  // use definition to return corret result
  if (def) {
    // use specific function of specific tagName and style
    if (def.fn) {
      result = def.fn(type, name, props, parent, parentProps, isEmpty);
    } else {
      result = {
        tag: def.tagName
      };
      if (def.order) {
        result.order = def.order;
      }
      if (def.wrapperTagName) {
        result.wrapper = def.wrapperTagName;
      }
      if (def.style) {
        let style = JSON.parse(JSON.stringify(def.style));
        if (def.prefix) {
          let parts = name.split(".");
          for (let key in style) {
            style[key] = style[key].replace(/\${([0-9]+)}/g, (_, numstring) => {
              let num = parseInt(numstring);
              let styleValue = numstring;
              if (parts[num]) {
                let values = parts[num].split(":");
                styleValue = values[values.length - 1];
              }
              return styleValue;
            });
          }
        }
        result.props = UU5.Common.Tools.merge(props, { style: style });
      } else {
        result.props = props;
      }
    }
    result.opts = { preserveEnters: !!def.preserveEnters };
  }
  return result;
};

const getMatchRate = (requestedStyle, propsStyle) => {
  const maxWeight = propsStyle ? Object.keys(propsStyle).length : 0;
  let weight = 0;
  if (requestedStyle && propsStyle) {
    for (let style in requestedStyle) {
      if (!(requestedStyle[style] === true && propsStyle[style]) && propsStyle[style] !== requestedStyle[style]) {
        return 0;
      }
      weight++;
    }
    return weight / maxWeight;
  }

  return !requestedStyle ? 1 : 0; // return full conformity if any style is not requested
};

const getBlockMapItemFromDefinition = def => {
  let blockItem = {
    rendererFn: def.component
  };

  if (def.element || def.wrapper || def.wrapperName) {
    blockItem.renderMap = {
      element: def.element,
      wrapper: def.wrapper,
      wrapperName: def.wrapperName
    };
  }

  return blockItem;
};

let PluginCache = Immutable.Map();

const PluginFactory = {
  /* Create plugin and cache it. */
  createPluginFromDefinition(pluginDefinition) {
    // check if plugin is not already cached
    let result = PluginCache.get(pluginDefinition);
    if (result) return result;

    // check if plugin is defined by object or Immutable Map
    let json = Immutable.Map.isMap(pluginDefinition) ? pluginDefinition.toJSON() : pluginDefinition;
    result = PluginFactory.createPlugin(
      json.name,
      json.type,
      json.buttonDefs,
      json.toEditorItemDefs,
      json.toObjectDefs,
      json.commands,
      json.opts
    );

    // cache created plugin
    PluginCache = PluginCache.set(pluginDefinition, result);

    return result;
  },
  /*
  createPlugin

  @param name - name of the plugin
  @param buttonDefs ( optional )
    arrayOf objects or single object of type
      icon
      label
      name
      value
  @param toEditorItemDefs (optional)
    arrayOf object or single object of type:
      tagName - name of the tag in string representation
      style - map of styles and its values - if value of style is true, then any value is correct
      inlineStyle - map of styles for styleMap. These styles are not used for parsing text to editor items
      name - name of style/entity/block in Draft ( optional ) - if is not set it is used name of the plugin
      type - type of editor item
      fn - special fn to return editor item ( optional )
  @param toObjectDefs ( optional if plugin name is used as a name of the style )
    arrayOf objects or single object of type:
      name - name of the draft style/entity/block ( optional if plugin name is used as a name of the style )
      prefix - prefix of the draft style ( optional )
      tagName
      style
      fn - special function to return {tag, props} representation of the style ( optional if prefix is not set )
  @param opts ( optional )
    object of type:
      customStyleMap - style map for inline style elements
      htmlMappings - array of mappings from html to components
      blockMap - map of blocks
  */
  createPlugin(name, type = "custom", buttonDefs, toEditorItemDefs, toObjectDefs, commands, opts = {}) {
    let plugin = { name, type };

    if (commands) {
      plugin.commands = Array.isArray(commands) ? commands : [commands];
      plugin.commands = plugin.commands.map(cmd => {
        if (typeof cmd.fn !== "function") {
          let pluginType = cmd.type || type;
          // get default fn or set empty
          return {
            ...cmd,
            fn: COMMANDS[pluginType]
              ? (editorState, area) => COMMANDS[pluginType](editorState, area, name)
              : () =>
                  UU5.Common.Tools.warning(
                    `Command function for shortcut (${cmd.altKey ? "ALT + " : ""}${cmd.ctrlKey ? "CTRL + " : ""}${
                      cmd.shiftKey ? "SHIFT + " : ""
                    }${cmd.keyCode}) in plugin ${name} does not found.`
                  )
          };
        }
        return cmd;
      });
    }

    plugin.order = opts.order || 50;

    if (opts.htmlMappings) {
      plugin.htmlMappings = JSON.parse(JSON.stringify(opts.htmlMappings));
    }

    if (opts.customStyleMap) {
      plugin.customStyleMap = JSON.parse(JSON.stringify(opts.customStyleMap));
    }

    if (opts.blockMap) {
      plugin.blockMap = {};
      for (let defName in opts.blockMap) {
        let blockItem = getBlockMapItemFromDefinition(opts.blockMap[defName]);
        plugin.blockMap[defName] = blockItem;
      }
    }

    if (opts.entityMap) {
      // process entities
      plugin.entities = [];
      for (let entityName in opts.entityMap) {
        // if strategy is not defined, it will be added stadard strategy in plugin.processPlugins
        let def = opts.entityMap[entityName];
        plugin.entities.push({ name: entityName, component: def.component, strategy: def.strategy });
      }
    }

    // init transform rules for editor
    if (toEditorItemDefs) {
      plugin.toEditorItemDefs = Array.isArray(toEditorItemDefs) ? toEditorItemDefs : [toEditorItemDefs];
      // if rule does not contain name add it same as name of the plugin
      plugin.toEditorItemDefs = plugin.toEditorItemDefs.map(def => {
        // init definitions
        def.name = def.name || name;
        def.type = def.type || type;

        // process all definitions
        // process inline styles
        if (def.type === "inline" && (def.styleFn || def.style || def.inlineStyle)) {
          if (!plugin.customStyleMap) plugin.customStyleMap = {};
          // don't rewrite existing styles
          if (!plugin.customStyleMap[def.name]) {
            plugin.customStyleMap[def.name] = def.styleFn || def.style || def.inlineStyle;
          }
        }

        // process entities
        if (def.type === "entity" && def.component) {
          if (!plugin.entities) plugin.entities = [];
          // if strategy is not defined, it will be added stadard strategy in plugin.processPlugins
          plugin.entities.push({ component: def.component, strategy: def.strategy });
        }

        // process blocks
        if (def.type === "block" && def.component) {
          if (!plugin.blockMap) plugin.blockMap = {};
          let blockItem = getBlockMapItemFromDefinition(def);

          plugin.blockMap[def.name] = blockItem;
        }

        if (def.getEditationForm) {
          if (!plugin.getEditationFormMap) plugin.getEditationFormMap = {};
          plugin.getEditationFormMap[def.name] = def.getEditationForm;
        }

        if (def.htmlAliases) {
          // htmlAliases is array or single alias
          let aliases = Array.isArray(def.htmlAliases) ? def.htmlAliases : [def.htmlAliases];
          // check if htmlMappings is already on plugin
          if (!plugin.htmlMappings) {
            plugin.htmlMappings = [];
          }

          // process all aliases and link them with current def
          aliases.forEach(alias => {
            let mapping = {
              tagName: alias.tagName,
              style: alias.style,
              className: alias.className,
              result: alias.result || {
                tagName: def.tagName,
                style: def.style
              },
              final: alias.final !== undefined ? alias.final : type !== "inline" // by default set entity and block mapping as final
            };

            if (alias.order) {
              mapping.order = alias.order;
            }

            plugin.htmlMappings.push(mapping);
          });
        }

        // return definition
        return def;
      });

      // init map of toObjectDefs - add name same as plugin name if is not set
      if (toObjectDefs) {
        plugin.toObjectDefs = Array.isArray(toObjectDefs) ? toObjectDefs : [toObjectDefs];
        plugin.toObjectDefs = plugin.toObjectDefs.map(def => {
          // each definition must have defined prefix or name
          if (!def.prefix) {
            def.name = def.name || name;
          }
          def.type = def.type || type;
          return def;
        });
      } else {
        // create new set of definition from toEditorItemDefs
        plugin.toObjectDefs = [];
        plugin.toEditorItemDefs.forEach(def => {
          if (def.skipToObjectRule) return;
          plugin.toObjectDefs.push({
            name: def.name || name,
            tagName: def.tagName,
            style: def.style,
            type: def.type || type,
            wrapperTagName: def.wrapperTagName
          });
        });
      }
    }

    // process defined buttons
    if (buttonDefs) {
      if (!Array.isArray(buttonDefs)) {
        buttonDefs = [buttonDefs];
      }
      plugin.buttonMap = {};
      buttonDefs.forEach(button => {
        plugin.buttonMap[button.name || name] = {
          icon: button.icon,
          label: button.label,
          dropdownItemLabel: button.dropdownItemLabel || button.label,
          type: button.type || type,
          value: button.value || name,
          items: button.items,
          button: button.button,
          props: button.props,
          getProps: button.getProps,
          isSelected: button.isSelected,
          isDisabled: button.isDisabled,
          onClick: button.onClick,
          ignorePrefix: button.ignorePrefix,
          preserveStyle: button.preserveStyle
        };
      });
    }

    plugin.toEditorItem = toEditorItem;
    plugin.toUU5Item = toObject;

    return plugin;
  }
};

export default PluginFactory;
