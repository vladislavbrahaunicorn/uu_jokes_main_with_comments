/* eslint-disable no-unreachable */
import UU5 from "uu5g04";

import Immutable from "immutable";

const PLUGIN_NAME = "blockIndent";

const MAX_LEVEL = 10;
const STEP = 8;

const isListItem = block => {
  return block.type === "ordered-list-item" || block.type === "unordered-list-item";
};

const isValidListUpdate = (block, prevBlock, direction) => {
  if (isListItem(prevBlock)) {
    return direction < 0 ? block.depth + direction >= 0 : block.depth + direction - prevBlock.depth <= 1;
  }
};

const handleTabShiftKey = (editorState, area) => handleTabKey(editorState, area, true);

const handleTabKey = (editorState, area, shiftKey = false) => {
  // remove last list item if is empty and user press enter key
  let selection = editorState.getSelection();
  let content = editorState.getCurrentContent();
  let block = content.getBlockForKey(selection.getStartKey());
  if (isListItem(block)) {
    let prevBlock = content.getBlockBefore(block.getKey());
    if (prevBlock && isValidListUpdate(block, prevBlock, shiftKey ? -1 : 1)) {
      area.setEditorState(indent(editorState, area, shiftKey ? -1 : 1));
    }
    return true;
  }
  return false;
};

const indent = (editorState, area, direction) => {
  // block updates of list items if first item cannot be updated
  let blockListUpdates = false;
  let isListUpdate = undefined;
  let notListEditorState = editorState;

  // need to update selection to contain all nested list items ( at the end of update is needed to set back original selection )
  let selection = editorState.getSelection();
  let newEditorState;
  let blocks = editorState.getCurrentContent().getBlocksAsArray();
  let lastSelectedBlockKey = selection.getEndKey();
  let lastBSelectedBlockIndex = blocks.findIndex(block => block.getKey() === lastSelectedBlockKey);
  let lastSelectedBlock = blocks[lastBSelectedBlockIndex];
  // check if last selected item is list item
  if (isListItem(lastSelectedBlock)) {
    let i;
    // find all nested list items and select them to apply TAB on them
    for (i = lastBSelectedBlockIndex + 1; i < blocks.length; i++ ) {
      if (isListItem(blocks[i]) && blocks[i].depth > lastSelectedBlock.depth) {
        continue;
      } else {
        break;
      }
    }
    let lastListItemKey = blocks[i - 1].getKey();
    if (lastSelectedBlockKey !== lastListItemKey) {
      // update selection
      newEditorState = area.updateSelection(editorState, {
        endKey: lastListItemKey,
        endOffset: blocks[i - 1].getText().length
      });
    }
  }

  let listEditorState = area.updateSelectedBlocks(newEditorState || editorState, (block, index, blocks) => {
    // remember if first selected item is block or list item => doesn't update list if selection starts before it and vice versa
    if (isListUpdate === undefined) {
      isListUpdate = isListItem(block);
    }

    // udpate selected block
    if (isListItem(block)) {
      // check if selection starts in list
      if (!isListUpdate) {
        return;
      }
      // cannot change level of first block
      if (index === 0 || blockListUpdates || !isValidListUpdate(block, blocks[index - 1], direction)) {
        // block all other updates of block level
        blockListUpdates = true;
        return;
      }

      return block.set("depth", block.depth + direction);
    } else {
      // check if selection doesn't start in a list
      if (isListUpdate) {
        return;
      }

      // update editor state
      notListEditorState = area.toggleBlockStyles(notListEditorState, block, undefined, style => {
        // update margin left style
        let marginLeft = style.marginLeft;
        marginLeft = (marginLeft && parseInt(marginLeft)) || 0;

        // check validity of set another step
        if ((!marginLeft && direction === -1) || (marginLeft >= MAX_LEVEL * STEP && direction === 1)) {
          return;
        }

        // add step
        marginLeft = Math.min(Math.max(0, marginLeft + direction * STEP), MAX_LEVEL * STEP);

        if (marginLeft === 0) {
          delete style.marginLeft;
        } else {
          style.marginLeft = marginLeft + "px";
        }

        return style;
      });

      // chenges of content is handled by toggleBlockStyle function
      return null;
    }
  });

  // set back original selecection
  return isListUpdate
    ? area.updateSelection(listEditorState, {
        startKey: selection.getStartKey(),
        startOffset: selection.getStartOffset(),
        endKey: selection.getEndKey(),
        endOffset: selection.getEndOffset()
      })
    : notListEditorState;
};

const isDisabled = (editorState, direction) => {
  let selection = editorState.getSelection();
  let currentContent = editorState.getCurrentContent();
  let block = currentContent.getBlockForKey(selection.getStartKey());
  if (isListItem(block)) {
    let blocks = currentContent.getBlocksAsArray();
    let index = blocks.findIndex(item => item === block);
    // cannot change depth of first item in the block
    if (index === 0) return false;

    let prevBlock = blocks[index - 1];
    return !isValidListUpdate(block, prevBlock, direction);
  } else {
    let data = block.getData().toJSON();
    let style = (data.props && data.props.style) || {};
    if (direction === -1) {
      return !style.marginLeft || parseInt(style.marginLeft) <= 0;
    } else {
      return style.marginLeft && parseInt(style.marginLeft) >= MAX_LEVEL * STEP;
    }
  }
};

const pluginDef = Immutable.Map(
  Immutable.fromJS({
    name: PLUGIN_NAME,
    type: "custom",
    buttonDefs: [
      {
        name: "blockIndentIncrease",
        icon: "mdi-format-indent-increase",
        label: () => UU5.Environment.Lsi.RichText.plugins.blockIndent.increaseIndentLabel,
        onClick: (editorState, area) => {
          return indent(editorState, area, 1);
        },
        isSelected: () => false,
        isDisabled: editorState => isDisabled(editorState, 1)
      },
      {
        name: "blockIndentDecrease",
        icon: "mdi-format-indent-decrease",
        label: () => UU5.Environment.Lsi.RichText.plugins.blockIndent.decreaseIndentLabel,
        onClick: (editorState, area) => {
          return indent(editorState, area, -1);
        },
        isSelected: () => false,
        isDisabled: editorState => isDisabled(editorState, -1)
      }
    ],
    commands: [
      {
        keyCode: 9,
        fn: handleTabKey
      },
      {
        keyCode: 9,
        shiftKey: true,
        fn: handleTabShiftKey
      }
    ],
    opts: { htmlMappings: { tagName: true, style: { marginLeft: true }, result: { style: { marginLeft: true } } } }
  })
);

export default pluginDef;
