//@@viewOn:imports
import * as UU5 from "uu5g04";
import "uu5g04-bricks";
//@@viewOff:imports

const ListWrapper = UU5.Common.VisualComponent.create({
  displayName: "UU5.RichText.ListWrapper",

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    getBlockData: UU5.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private
  _renderInnerListItems(listDepth) {
    let result = [];
    // get list type from first item
    let listType = this.props.children[this._index].props.children.props.block.getType();
    while (this._index < this.props.children.length) {
      let child = this.props.children[this._index];
      let block = child.props.children.props.block;
      let depth = block.getDepth();
      let type = block.getType();

      // current node is in lower depth then list - end current list
      if (depth < listDepth) {
        break;
      }

      // current node is in higher depth then list - add inner list as list item
      if (depth > listDepth) {
        result.push(this._renderInnerList());
        // index is on the first unprocessed item
        continue;
      }

      // check type change in depth 0 - in other depths this should not happen
      if (listDepth === 0 && type !== listType) {
        break;
      }

      // mark list item as processed
      this._index++;
      let nextList = null;
      let nextItem = this._index < this.props.children.length ? this.props.children[this._index] : null;
      if (nextItem && nextItem.props.children.props.block.getDepth() > depth) {
        nextList = this._renderInnerList();
      }
      result.push(
        <UU5.Bricks.Li id={block.getKey()} key={block.getKey()}>
          {child}
          {nextList}
        </UU5.Bricks.Li>
      );
    }

    return result;
  },

  _renderInnerList() {
    let firstChild = this.props.children[this._index];
    let { block, blockProps } = firstChild.props.children.props;
    blockProps = blockProps || {};
    let depth = block.getDepth();
    let type = block.getType();
    if (type === "ordered-list-item") {
      return (
        <UU5.Bricks.Ol {...blockProps} id={block.getKey()} key={block.getKey()}>
          {this._renderInnerListItems(depth)}
        </UU5.Bricks.Ol>
      );
    } else {
      return (
        <UU5.Bricks.Ul {...blockProps} id={block.getKey()} key={block.getKey()}>
          {this._renderInnerListItems(depth)}
        </UU5.Bricks.Ul>
      );
    }
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let result = [];
    this._index = 0;
    while (this._index < this.props.children.length) {
      result.push(this._renderInnerList());
    }
    return result;
  }
  //@@viewOff:render
});

export default ListWrapper;
