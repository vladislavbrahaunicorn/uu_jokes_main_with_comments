import { EditorState, CharacterMetadata } from "draft-js";

const Selection = {
  getSelectedText(editorState = this.state.editorState) {
    const selection = editorState.getSelection();
    let text = "";
    if (selection.isCollapsed()) {
      return text;
    }

    let isInside = false;
    const content = editorState.getCurrentContent();
    const blocks = content.getBlocksAsArray();
    for (let index in blocks) {
      let block = blocks[index];
      if (block.getKey() === selection.getStartKey()) {
        isInside = true;

        if (block.getKey() === selection.getEndKey()) {
          text = block.getText().substring(selection.getStartOffset(), selection.getEndOffset());
          break;
        }

        text = block.getText().substring(selection.getStartOffset());
        continue;
      }

      // skip block if is outside of selection
      if (!isInside) continue;

      if (block.getKey() === selection.getEndKey()) {
        text += block.getText().substring(0, selection.getEndOffset());
        isInside = false;
        break;
      }

      // append text
      text += block.getText();
    }

    return text;
  },

  moveSelectionAfterEntity(editorState, entityKey, callback) {
    let contentBlock = Selection.getSelectedBlock(editorState);
    contentBlock.findEntityRanges(
      character => character.getEntity() === entityKey,
      (startOffset, endOffset) => {
        callback(Selection.updateSelection(editorState, { startOffset: endOffset, endOffset }));
      }
    );
  },

  getSelectedBlock(editorState) {
    const selection = editorState.getSelection();
    const content = editorState.getCurrentContent();
    const blockKey = selection.getAnchorKey();
    return content.getBlockForKey(blockKey);
  },

  updateSelection(editorState, { startOffset, endOffset, startKey, endKey }) {
    let selection = editorState.getSelection();
    if (selection.getIsBackward()) {
      selection = Selection.modifySelection(editorState, {
        focusOffset: startOffset,
        focusKey: startKey,
        anchorOffset: endOffset,
        anchorKey: endKey
      });
    } else {
      selection = Selection.modifySelection(editorState, {
        focusOffset: endOffset,
        focusKey: endKey,
        anchorOffset: startOffset,
        anchorKey: startKey
      });
    }
    return EditorState.forceSelection(editorState, selection);
  },

  moveSelectionToEnd(editorState) {
    const blocks = editorState.getCurrentContent().getBlocksAsArray();
    const lastBlock = blocks[blocks.length - 1];
    const textLength = lastBlock.getText().length;
    return Selection.updateSelection(editorState, {
      startKey: lastBlock.getKey(),
      endKey: lastBlock.getKey(),
      startOffset: textLength,
      endOffset: textLength
    });
  },

  moveSelectionToStart(editorState) {
    const blocks = editorState.getCurrentContent().getBlocksAsArray();
    const firstBlock = blocks[0];
    return Selection.updateSelection(editorState, {
      startKey: firstBlock.getKey(),
      endKey: firstBlock.getKey(),
      startOffset: 0,
      endOffset: 0
    });
  },

  modifySelection(editorState, opts) {
    let selection = editorState.getSelection();
    return Selection.modify(selection, opts);
  },

  modify(selection, { anchorKey, anchorOffset, focusKey, focusOffset }) {
    selection = anchorKey ? selection.set("anchorKey", anchorKey) : selection;
    selection = anchorOffset !== undefined ? selection.set("anchorOffset", anchorOffset) : selection;
    selection = focusKey ? selection.set("focusKey", focusKey) : selection;
    return focusOffset !== undefined ? selection.set("focusOffset", focusOffset) : selection;
  },

  removeEntityFromSelection(editorState, selection) {
    let contentState = editorState.getCurrentContent();
    let blockMap = contentState.getBlockMap();
    let block = blockMap.get(selection.getAnchorKey());
    let chars = block.getCharacterList();
    let start = selection.getStartOffset();
    let end = selection.getEndOffset();

    let current;
    while (start < end) {
      current = chars.get(start);
      chars = chars.set(start, CharacterMetadata.applyEntity(current, null));
      start++;
    }
    let updatedBlock = block.set("characterList", chars);
    let newContentState = contentState.merge({
      blockMap: blockMap.set(updatedBlock.getKey(), updatedBlock)
    });

    return EditorState.push(editorState, newContentState, "remove entity from selection");
  },

  collapse(selection, toStart = true) {
    // if selection is backward then focus is earlier in the document than anchor
    let newSelection =
      selection.isBackward === toStart
        ? Selection.modify(selection, {
            anchorKey: selection.focusKey,
            anchorOffset: selection.focusOffset,
            focusKey: selection.focusKey,
            focusOffset: selection.focusOffset
          })
        : Selection.modify(selection, {
            anchorKey: selection.anchorKey,
            anchorOffset: selection.anchorOffset,
            focusKey: selection.anchorKey,
            focusOffset: selection.anchorOffset
          });

    return newSelection.set("isBackward", false);
  },

  collapseToStart(selection) {
    return Selection.collapse(selection);
  },

  collapseToEnd(selection) {
    return Selection.collapse(selection, false);
  },

  insertText(editorState, text) {
    let selection = editorState.getSelection();
    let content = editorState.getCurrentContent();
    let block = content.getBlockForKey(selection.getStartKey());
    // let entityKey = block.getEntityAt(selection.getEndOffset());
    const startOffset = selection.getStartOffset();
    const endOffset = selection.getEndOffset();

    let newCharacterList = block.getCharacterList();

    // remove all deleted characters
    for (let i = endOffset; i > startOffset; i--) {
      newCharacterList = newCharacterList.remove(i);
    }

    // add new character to correctly shift styles and entities
    newCharacterList = newCharacterList.insert(startOffset + 1, newCharacterList.get(startOffset));

    // update text
    let newBlock = block.set(
      "text",
      block.getText().substring(0, startOffset) + "\n" + block.getText().substring(endOffset)
    );
    // update character list
    newBlock = newBlock.set("characterList", newCharacterList);

    // move selection after enter key
    let newSelection = selection.set("anchorOffset", startOffset + 1).set("focusOffset", startOffset + 1);

    // replace original block in content by new one
    let newContent = content.setIn(["blockMap", block.getKey()], newBlock);

    return EditorState.push(EditorState.set(editorState, { selection: newSelection }), newContent, "insert text");
  },

  /**
   * Walk through all blocks in editor and for each selected block call updateFn with block as a parameter.
   *
   * @param editorState - state of an editor
   * @param updateFn - function, which takes block as first parameter, index in blocks array as second parameter and array of blocks as third parameter. Method returns updated block or null.
   *
   * @returns new editorState with updated blocks.
   */
  updateSelectedBlocks(editorState, updateFn) {
    let selection = editorState.getSelection();
    let content = editorState.getCurrentContent();
    let newContent = content;
    let blocks = editorState.getCurrentContent().getBlocksAsArray();

    let isInsideSelection = false;
    for (let i = 0; i < blocks.length; i++) {
      let block = blocks[i];
      // current block is first processed block
      if (block.getKey() === selection.getStartKey()) {
        isInsideSelection = true;
      }

      // current block is before first selected block
      if (!isInsideSelection) continue;

      // update current block
      let newBlock = updateFn(block, i, blocks);

      // replace original block by updated => if block was updated then returned block is new object, because block is immutable object
      if (newBlock && newBlock !== block) {
        newContent = newContent.setIn(["blockMap", newBlock.getKey()], newBlock);
        // add new block to processed array to allow get changed object in next iteration
        blocks[i] = newBlock;
      }

      // current block was last processed block => break loop
      if (block.getKey() === selection.getEndKey()) {
        break;
      }
    }

    // return new editorState with updated content
    return EditorState.push(editorState, newContent, "updateSelectedBlocks");
  }
};

export default Selection;
