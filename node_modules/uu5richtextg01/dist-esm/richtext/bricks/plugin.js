import UU5 from "uu5g04";

import Entity from "./entity.js";
import Block from "./block.js";
import Environment from "../environment.js";

import UnstyledPlugin from "../plugins/uu5/unstyled.js";
import ErrorPlugin from "../plugins/uu5/error.js";
import WhiteSpacePlugin from "../plugins/uu5/whitespace.js";

const REQUIRED_PLUGIN_MAP = {
  unstyled: UnstyledPlugin,
  error: ErrorPlugin,
  whitespace: WhiteSpacePlugin
};

const WEIGHTS = {
  tagName: 100,
  className: 10,
  style: 2,
  final: -1
};

const calculateWeight = mapping => {
  let weight = 0;
  if (mapping.tagName) {
    weight += WEIGHTS.tagName;
  }
  if (mapping.classNames) {
    if (Array.isArray(mapping.classNames)) {
      weight += WEIGHTS.className * mapping.classNames.length;
    } else {
      weight += WEIGHTS.className;
    }
  }
  if (mapping.style) {
    weight += Object.keys(mapping.style).length * WEIGHTS.style;
  }

  if (mapping.final) {
    weight += WEIGHTS.final;
  }

  return weight;
};

const sortMappings = (mapping1, mapping2) => {
  let order1 = mapping1.order;
  if (!order1) {
    order1 = calculateWeight(mapping1);
    mapping1.order = order1;
  }
  let order2 = mapping2.order;
  if (!order2) {
    order2 = calculateWeight(mapping2);
    mapping2.order = order2;
  }

  return order2 - order1;
};

const Plugin = {
  processPlugins: (plugins, pluginExtensions = {}) => {
    let blockRendererFnMap; // map of block render maps
    let result = {
      buttonMap: {}, // map of button definitions fro toolbar
      htmlMappings: [],
      areaConfig: {
        commands: [],
        customStyleMap: {}, // map of inline styles
        blockRenderMap: {}, // map of block renderer functions
        getEditationFormMap: {},
        decorators: [], // set of decorators
        entityOptions: {}
      }
    };

    // process plugins
    plugins.forEach(plugin => {
      // push commands to global array
      if (plugin.commands) {
        result.areaConfig.commands = result.areaConfig.commands.concat(plugin.commands);
      }
      // process all buttons - clone necesary properties and merge extensions into props
      if (plugin.buttonMap) {
        let buttonMap = plugin.buttonMap;
        let extension = pluginExtensions[plugin.name];
        // process extension for this plugin
        if (extension) {
          for (let name in extension) {
            if (name === "buttonMap") {
              let extButtonMap = extension.buttonMap;

              // merge extensions to button
              for (let buttonName in extButtonMap) {
                if (!buttonMap[buttonName]) {
                  // there is posibility to create whole new button
                  continue;
                }

                // shallow clone button props to prevent changes in original button definition shared between more editors
                let button = buttonMap[buttonName];
                let resultButton = {};
                for (let key in button) {
                  resultButton[key] = button[key];
                }
                resultButton.props = UU5.Common.Tools.merge(resultButton.props, extButtonMap[buttonName]);
                buttonMap[buttonName] = resultButton;
              }
              continue;
            }

            // copy new value to plugin definition
            plugin[name] = extension[name];
          }
        }

        // bind all getProps methods to plugin
        for (let buttonName in buttonMap) {
          let button = buttonMap[buttonName];
          if (button.getProps) {
            button.getProps = button.getProps.bind(plugin);
          }
        }

        result.buttonMap = UU5.Common.Tools.merge(result.buttonMap, buttonMap);
      }

      // process all defined inline styles
      if (plugin.customStyleMap) {
        result.areaConfig.customStyleMap = UU5.Common.Tools.merge(
          result.areaConfig.customStyleMap,
          plugin.customStyleMap
        );
      }

      // process all blocks
      if (plugin.blockMap) {
        for (let blockName in plugin.blockMap) {
          let block = plugin.blockMap[blockName];
          if (block.rendererFn) {
            blockRendererFnMap = blockRendererFnMap || {}; // initialization
            blockRendererFnMap[blockName] = block.rendererFn;
          }
          if (block.renderMap) {
            result.areaConfig.blockRenderMap[blockName] = block.renderMap;
            // wrapper cannot be set directly due to contentMixin expandChildProps method
            // this method clone wrapper but we need to be able to have one instance of object in multiple wrappers
            if (block.renderMap.wrapperName) {
              result.areaConfig.blockRenderMap[blockName].wrapper = (Environment.wrapperMap || {})[
                block.renderMap.wrapperName
              ];
            }
          }
        }
      }

      // process editation forms
      if (plugin.getEditationFormMap) {
        for (let formName in plugin.getEditationFormMap) {
          result.areaConfig.getEditationFormMap[formName] = plugin.getEditationFormMap[formName];
        }
      }

      // process decorators
      if (plugin.entities) {
        // transform entities to array and then process all entities
        let entities = Array.isArray(plugin.entities) ? plugin.entities : [plugin.entities];
        entities.forEach(entity => {
          result.areaConfig.decorators.push({
            component: entity.component,
            strategy: entity.strategy || Entity.getDefaultStrategy(entity.name || plugin.name)
          });
        });
      }

      // process entity options from toEditorItemDefs
      if (plugin.toEditorItemDefs) {
        plugin.toEditorItemDefs.forEach(item => {
          if (item.type === "entity") {
            // set only valid options - now is only option preserveEnters
            if (item.preserveEnters) {
              result.areaConfig.entityOptions[item.name] = { preserveEnters: item.preserveEnters };
            }
          }
        });
      }

      // process html mappings
      if (plugin.htmlMappings) {
        result.htmlMappings = result.htmlMappings.concat(
          Array.isArray(plugin.htmlMappings) ? plugin.htmlMappings : [plugin.htmlMappings]
        );
      }

      if (blockRendererFnMap) {
        result.areaConfig.blockRendererFn = Block.createBlockRendererFn(blockRendererFnMap);
      }
    });

    // sort mapping by order
    result.htmlMappings.sort(sortMappings);

    return result;
  },

  mergePlugins: (props, pluginMap) => {
    // merge plugins with existing plugins if props.plugins is set by an object, if plugins is set as an array, then replace all plugins by new one
    let result = [];
    let addedPlugins = {};

    if (props && props.plugins) {
      if (Array.isArray(props.plugins)) {
        let requiredPluginMap = { unstyled: false, error: false };
        props.plugins.forEach(plugin => {
          result.push(plugin);
          if (requiredPluginMap[plugin.name] === false) {
            requiredPluginMap[plugin.name] = true;
          }
        });
        for (let pluginName in requiredPluginMap) {
          if (requiredPluginMap[pluginName]) continue;
          result.push(pluginMap[pluginName] || REQUIRED_PLUGIN_MAP[pluginName]);
        }
        return result;
      } else {
        for (let pluginName in props.plugins) {
          result.push(props.plugins[pluginName]);
          addedPlugins[pluginName] = true;
        }
      }
    }

    for (let pluginName in pluginMap) {
      // do not add already added plugins
      if (addedPlugins[pluginName]) continue;
      result.push(pluginMap[pluginName]);
    }

    return result;
  }
};

export default Plugin;
