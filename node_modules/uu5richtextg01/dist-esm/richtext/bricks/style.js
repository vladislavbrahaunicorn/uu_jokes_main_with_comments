import { EditorState, Modifier, RichUtils } from "draft-js";

import Selection from "./selection.js";

const UL_TYPE = "unordered-list-item";
const OL_TYPE = "ordered-list-item";

const checkListItemsLevel = (block, anotherBlock) => {
  return (
    block &&
    anotherBlock &&
    anotherBlock.getDepth() >= block.getDepth() &&
    ((anotherBlock.getDepth() !== 0 && (anotherBlock.getType() === UL_TYPE || anotherBlock.getType() === OL_TYPE)) ||
      (anotherBlock.getDepth() === 0 && anotherBlock.getType() === block.getType()))
  );
};

export const Style = {
  /*
    @param editorState [EditorState] - state of the editor
    @param styleName [string] - name of the style
    @returns new editor state
  */
  toggleInline(editorState, styleName, preserveStyle) {
    let separatorIndex = styleName.indexOf(".");

    // at first remove all styles from same style group - styleName is defined like a StyleGroup.Name
    if (separatorIndex !== -1) {
      // get name of prefix
      let prefix = styleName.substr(0, separatorIndex);
      let regExp = new RegExp(`^${prefix}\\.`);
      // find all styles in selection with prefix
      let toRemove = Style.getStylesFromSelection(editorState).filter(item => item.match(regExp));
      // add set styleName only if it isn't on start of selection
      let addStyleName = preserveStyle || !editorState.getCurrentInlineStyle().has(styleName);

      // remove all founded styles with same prefix
      editorState = Style.removeInline(editorState, toRemove);

      // add style if it wasn't set before
      if (addStyleName && styleName.length > separatorIndex + 1) {
        editorState = RichUtils.toggleInlineStyle(editorState, styleName);
      }

      return editorState;
    }

    return RichUtils.toggleInlineStyle(editorState, styleName);
  },

  /* 
    @param editorState [EditorState] - state of editor
    @param styleNames [string or array of strings] - inline styles to remove from editor state
    @returns new editor state
   */
  removeInline(editorState, styleNames) {
    if (typeof styleNames === "string") {
      if (styleNames === "*") {
        styleNames = Style.getAllStyleNamesFromSelection(editorState);
      } else {
        styleNames = [styleNames];
      }
    }

    let newEditorState = editorState;

    // filter whitespace formating -> this format sets only meta information about original structure
    styleNames = styleNames.filter(style => !style.match(/^whitespace\./));

    // remove all inline styles from array
    styleNames.forEach(item => {
      // only cursor without selection
      if (newEditorState.getSelection().isCollapsed()) {
        if (newEditorState.getCurrentInlineStyle().has(item)) {
          newEditorState = RichUtils.toggleInlineStyle(newEditorState, item);
        }
      } else {
        // remove inline from whole selection
        let content = Modifier.removeInlineStyle(
          newEditorState.getCurrentContent(),
          newEditorState.getSelection(),
          item
        );
        newEditorState = EditorState.set(newEditorState, { currentContent: content });
      }
    });

    // switch editorState contents to enable push new content into history
    let newContent = newEditorState.getCurrentContent();
    newEditorState = EditorState.set(newEditorState, { currentContent: editorState.getCurrentContent() });

    return EditorState.push(newEditorState, newContent, "remove inline styles");
  },

  /*
    @param editorState [EditorState] - state of editor
    @param blockType [string] - type of new block
    @returns [EditorState] updated editor state
   */
  toggleBlock: (editorState, blockType) => {
    let newEditorState = editorState;
    let selection = editorState.getSelection();
    let currentContent = editorState.getCurrentContent();
    let block = currentContent.getBlockForKey(selection.getStartKey());

    // handle change of list types block
    if (
      (block.getType() === UL_TYPE || block.getType() === OL_TYPE) &&
      (blockType === UL_TYPE || blockType === OL_TYPE) &&
      block.getType() !== blockType
    ) {
      let blockDepth = block.getDepth();
      // find all blocks in this level and change blockType for all of this blocks
      let blockKeysToProcess = [block.getKey()];

      // process list blocks before current block
      let blockBefore = currentContent.getBlockBefore(block.getKey());
      while (checkListItemsLevel(block, blockBefore)) {
        if (blockBefore.getDepth() === blockDepth) {
          blockKeysToProcess.push(blockBefore.getKey());
        }
        blockBefore = currentContent.getBlockBefore(blockBefore.getKey());
      }

      // process list block after current block
      let blockAfter = currentContent.getBlockAfter(block.getKey());
      while (checkListItemsLevel(block, blockAfter)) {
        if (blockAfter.getDepth() === blockDepth) {
          blockKeysToProcess.push(blockAfter.getKey());
        }
        blockAfter = currentContent.getBlockAfter(blockAfter.getKey());
      }

      // store original selection
      let originalSelection = editorState.getSelection();

      // update block types
      for (let i = 0; i < blockKeysToProcess.length; i++) {
        let key = blockKeysToProcess[i];

        // select blocks
        let newSelection = Selection.modifySelection(editorState, {
          anchorKey: key,
          anchorOffset: 0,
          focusKey: key,
          focusOffset: currentContent.getBlockForKey(key).getText().length
        });

        // update selected block type
        newEditorState = RichUtils.toggleBlockType(
          EditorState.set(newEditorState, { selection: newSelection }),
          blockType
        );
      }

      // return original selection
      newEditorState = EditorState.set(newEditorState, { selection: originalSelection });

      // update depth of changed block - draft reset block's depth to 0
      let newContent = newEditorState.getCurrentContent();
      let blockMap = newContent.getBlockMap();
      for (let i = 0; i < blockKeysToProcess.length; i++) {
        let key = blockKeysToProcess[i];
        // update depth of the block
        let updatedBlock = newContent.getBlockForKey(key).set("depth", blockDepth);
        // update blockMap
        blockMap = blockMap.set(key, updatedBlock);
      }

      // set updated block map back to content
      newContent = newContent.set("blockMap", blockMap);
      newEditorState = EditorState.push(newEditorState, newContent, "toggle block");
    } else {
      newEditorState = RichUtils.toggleBlockType(editorState, blockType);
    }

    return newEditorState;
  },

  toggleSelectedBlocksStyles(editorState, blockStyles, updateStyleFn) {
    let newEditorState = editorState;
    Selection.updateSelectedBlocks(editorState, block => {
      newEditorState = Style.toggleBlockStyles(newEditorState, block, blockStyles, updateStyleFn);
      // all changes in editorState is made locally here => return null to block updates of unused editorState ( optimalization )
      return null;
    });

    return newEditorState;
  },

  /*
    @param editorState
    @param blockStyles [array of objects] - array contains objects defining styles to update. Each object is composited by name of css style and its value
    @returns [EditorState] updated editor state
  */
  toggleBlockStyles(editorState, block, blockStyles, updateStyleFn) {
    let selection = editorState.getSelection();
    // update only for first block of selection
    selection = Selection.modifySelection(editorState, {
      anchorKey: block.getKey(),
      anchorOffset: 0,
      focusKey: block.getKey(),
      focusOffset: 0
    });
    let currentContent = editorState.getCurrentContent();
    let data = block.getData().toJSON();
    data.props = data.props || {};
    let props = data.props;
    props.style = props.style || {};
    let style = props.style;
    if (typeof updateStyleFn === "function") {
      props.style = updateStyleFn(style) || style;
    } else {
      if (blockStyles.every(item => style[item.name] === item.value)) {
        // remove styles
        blockStyles.forEach(item => delete style[item.name]);
      } else {
        blockStyles.forEach(item => (style[item.name] = item.value));
      }
    }
    if (Object.keys(style).length === 0) {
      delete props.style;
    }
    let newContent = Modifier.setBlockData(currentContent, selection, data);

    return EditorState.push(editorState, newContent, "toggle block style");
  },

  /*
    @param editorState [EditorState] - state of editor
    @param type ["inline" or "block"] - type of style to check
    @param name [string] - name of a style or block or entity to check
    @return bool
   */
  isSelected(editorState, type, name) {
    if (!editorState) return false;

    let block;
    let entity;
    let entityKey;
    let selection = editorState.getSelection();
    let content = editorState.getCurrentContent();
    let result = false;

    switch (type) {
      case "inline":
        result = editorState.getCurrentInlineStyle().has(name);
        break;
      case "block":
        block = content.getBlockForKey(selection.getAnchorKey());
        result = !!block && block.getType() === name;
        break;
      case "entity":
        block = content.getBlockForKey(selection.getAnchorKey());
        entityKey = block && block.getEntityAt(selection.getStartOffset());
        if (entityKey) {
          entity = content.getEntity(entityKey);
          result = entity.type === name;
        }
        break;
    }

    return result;
  },

  /*
    Returns all inline styles used in selection.

    @param editorState [EditorState] - state of editor
    @returns [array of strings] - array of styles used in selection
   */
  getStylesFromSelection(editorState) {
    let result = [];
    let selection = editorState.getSelection();
    if (selection.isCollapsed()) {
      for (let style of editorState.getCurrentInlineStyle().keys()) result.push(style);
    } else {
      let startKey = selection.getStartKey();
      let endKey = editorState.getSelection().getEndKey();
      let content = editorState.getCurrentContent();
      let block = content.getBlockForKey(startKey);

      let styles = {};

      // iterate through all blocks in selection
      while (block) {
        block.getCharacterList().forEach(character => character.getStyle().forEach(style => (styles[style] = true)));
        let currentKey = block.getKey();
        block = currentKey === endKey ? null : content.getBlockAfter(currentKey);
      }
      for (let style in styles) result.push(style);
    }

    return result;
  },

  getCurrentStylesWithPrefix(editorState, prefix) {
    let result = [];
    let regexp = new RegExp(`^${prefix}\\.`);
    let styles = editorState.getCurrentInlineStyle().keys();
    for (let style of styles) {
      if (style.match(regexp)) {
        result.push(style);
      }
    }
    return result;
  },

  getAllStyleNamesFromSelection(editorState) {
    let result = [];
    let selection = editorState.getSelection();
    let insideSelection = false;
    let singleBlockSelection = selection.getEndKey() === selection.getStartKey();
    let startOffset = selection.getStartOffset();
    let endOffset = selection.getEndOffset();
    if (singleBlockSelection) {
      let block = editorState.getCurrentContent().getBlockForKey(editorState.getSelection().anchorKey);
      let styles;
      block.findStyleRanges(
        charMetaData => {
          styles = charMetaData.getStyle().toJS();
          return styles.length > 0;
        },
        (startIndex, endIndex) => {
          if (
            (startIndex >= startOffset && startIndex < endOffset) ||
            (endIndex > startOffset && endIndex <= endOffset) ||
            (startIndex < startOffset && endIndex > endOffset)
          ) {
            result = result.concat(styles);
          }
        }
      );
    } else {
      let resultMap = {};
      let blocks = editorState.getCurrentContent().getBlocksAsArray();
      for (let i = 0; i < blocks.length; i++) {
        let block = blocks[i];

        // process first block
        if (block.getKey() === selection.getStartKey()) {
          let styles;
          block.findStyleRanges(
            charMetaData => {
              styles = charMetaData.getStyle().toJS();
              return true;
            },
            startIndex => {
              if (startIndex >= selection.getStartOffset()) {
                styles.forEach(styleName => (resultMap[styleName] = true));
              }
            }
          );
          insideSelection = true;
          if (block.getKey() === selection.getEndKey()) {
            break;
          } else {
            continue;
          }
        }

        // process last block
        if (block.getKey() === selection.getEndKey()) {
          let styles;
          block.findStyleRanges(
            charMetaData => {
              styles = charMetaData.getStyle().toJS();
              return true;
            },
            startIndex => {
              if (startIndex < selection.getEndOffset()) {
                styles.forEach(styleName => (resultMap[styleName] = true));
              }
            }
          );
          break;
        }

        // skip blocks before selected block
        if (!insideSelection) continue;

        // process blocks inside selection
        let styles;
        block.findStyleRanges(
          charMetaData => (styles = charMetaData.getStyle().toJS()),
          startIndex => {
            if (startIndex < selection.getEndOffset()) {
              styles.forEach(styleName => (resultMap[styleName] = true));
            }
          }
        );
      }
      for (let styleName in resultMap) {
        result.push(styleName);
      }
    }

    return result;
  }
};

export default Style;
