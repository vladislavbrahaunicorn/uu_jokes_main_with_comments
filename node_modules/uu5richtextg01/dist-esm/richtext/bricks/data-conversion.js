import * as UU5 from "uu5g04";
import {
  CompositeDecorator,
  ContentState,
  EditorState,
  Modifier,
  convertToRaw,
  convertFromRaw,
  genKey
} from "draft-js";

import { removeSpecialNodes } from "../bricks/uu5string.js";

import Selection from "../bricks/selection.js";

const DEFAULT_TAG_ORDER = 50;

const getEmptyRaw = () => {
  return {
    blocks: [
      {
        type: "unstyled",
        text: "",
        inlineStyleRanges: [],
        entityRanges: [],
        depth: 0,
        key: genKey()
      }
    ],
    entityMap: {}
  };
};

const createPropsFormatterFn = propsFormatter => {
  return props => {
    if (typeof propsFormatter === "function") {
      return propsFormatter(props);
    }

    return props;
  };
};

const removeInputSupportCharacters = string => {
  return string.replace(/[\u200b-\u200d]/g, "");
};

const formatInputString = string => {
  return string
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<")
    .replace(/&amp;/g, "&");
};

const removeOutputSupportCharacters = (
  string,
  { escapeXml = true, preserveEnters = false } = { escapeXml: true, preserveEnters: false }
) => {
  // remove zero width spaces
  let result = string.replace(/[\u200b-\u200d]/g, "");
  if (escapeXml) {
    // escape all & characters
    result = result.replace(/&/g, "&amp;");
    // escape < and > characters
    result = result.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  if (!preserveEnters) {
    result = result.replace(/\n/g, "<br />");
  }
  // replace newlines
  return result;
};

const shouldReplaceBrForEnter = (raw, uu5stringObject, parentBlock, blockDataMap) => {
  // check if uu5stringObject is br tag
  if (uu5stringObject.tag !== "br") return false;

  // if br has parent block it is break line not empty block
  if (parentBlock) return true;

  // check if it is not first block
  if (raw.blocks.length === 0) return false;

  // check if br is a part of artificail block
  const lastBlockKey = raw.blocks[raw.blocks.length - 1].key;
  return blockDataMap[lastBlockKey].artificial;
};

const printOpeningTag = (tag, props, isSelfClosing, blockData) => {
  if (!tag || (blockData && blockData.artificial)) return "";
  if (blockData && blockData.isEmpty && !isSelfClosing) {
    return `<${tag}${printProps(props)}>\u200b</${tag}>`;
  }
  return `<${tag}${printProps(props)}${isSelfClosing ? " />" : ">"}`;
};

const printClosingTag = (tag, blockData) => {
  if (!tag || (blockData && blockData.artificial)) return "";
  return `</${tag}>`;
};

const printProps = props => {
  if (!props) return "";
  let stringProps = "";
  for (let name in props) {
    let value = props[name];
    let type = typeof value;

    // handle number and boolean
    if (type === "number" || value === false) {
      stringProps += ` ${name}=${value}`;
      continue;
    } else if (value === true) {
      stringProps += ` ${name}`;
      continue;
    }

    // convert objects except null to uu5json
    if (type === "object" && value) {
      value = `<uu5json />${JSON.stringify(value)}`;
      type = "string";
    }

    // handle string - escape double quotes
    if (type === "string") {
      stringProps += ` ${name}="${value.replace(/(\\)*"/g, '$1$1\\"')}"`; // escape double quotes
    }
  }

  return stringProps;
};

const tagComparator = (tag1, tag2) => {
  if (tag1.offset !== tag2.offset) {
    return tag1.offset - tag2.offset;
  }
  // sort closing tags before opening
  if (tag1.type === "closing" && tag2.type === "opening") return -1;
  if (tag2.type === "closing" && tag1.type === "opening") return 1;

  if (tag1.type === "opening") {
    // both opening tags
    if (tag1.startOffset === tag2.startOffset) {
      // sort components before styles if they starts on tha same character
      if (tag1.componentType === "component" && tag2.componentType === "style") {
        return -1;
      }
      if (tag2.componentType === "component" && tag1.componentType === "style") {
        return 1;
      }

      // order style elements
      if (tag1.order !== tag2.order) {
        return tag2.order - tag1.order;
      } else {
        if (tag2.endOffset === tag1.endOffset) {
          return tag1.index - tag2.index;
        } else {
          return tag2.endOffset - tag1.endOffset;
        }
      }
    }
    return tag1.startOffset - tag2.startOffset;
  } else {
    // both closing tags
    if (tag1.endOffset === tag2.endOffset) {
      // sort components before styles if they starts on tha same character
      if (tag1.componentType === "component" && tag2.componentType === "style") {
        return 1;
      }
      if (tag2.componentType === "component" && tag1.componentType === "style") {
        return -1;
      }

      // order style elements
      if (tag1.order !== tag2.order) {
        return tag1.order - tag2.order;
      } else {
        if (tag2.startOffset === tag1.startOffset) {
          return tag2.index - tag1.index;
        } else {
          return tag2.startOffset - tag1.startOffset;
        }
      }
    }
    return tag1.endOffset - tag2.endOffset;
  }
};

const groupSeparatorMap = {
  wrapper: 4,
  block: 3,
  entity: 2,
  inline: 1
};

const getDisplayLevel = display => {
  // unknown component is count as an entity
  return groupSeparatorMap[display] || groupSeparatorMap["entity"];
};

const validateChildrenDisplay = (parent, parentProps, children, getEditorItem, propsFormatter, maxLevel = "block") => {
  // create propsFormatter function
  const propsFormatterFn = createPropsFormatterFn(propsFormatter);
  const maxDisplayLevel = getDisplayLevel(maxLevel);
  let isValid = true;
  children.forEach(child => {
    if (typeof child === "string") return;
    let ancestors = child.props.toObject().content || child.children;
    let childEditorItem =
      child.cachedEditorItem ||
      getEditorItem(child.tag, propsFormatterFn(child.props.toObject()), ancestors, parent, parentProps);
    child.cachedEditorItem = childEditorItem;
    let childLevel = getDisplayLevel(childEditorItem.display);
    if (childLevel >= maxDisplayLevel) {
      isValid = false;
    }
  });

  return isValid;
};

const removeWhiteSpacesFromChildren = (string, children, prevWhiteSpace) => {
  let parts = string.split(/(\s{2,})/g);
  if (parts) {
    // parts always have odd count of items
    if (parts[0]) {
      children.push(parts[0]);
      prevWhiteSpace.value = false;
    }
    for (let i = 1; i < parts.length; i += 2) {
      children.push(
        UU5.Common.UU5String.parse(
          `<uu5string /><UU5.RichText.Whitespace spaces="${parts[i]}" hidden=${prevWhiteSpace.value}>${
            parts[i][0]
          }</UU5.RichText.Whitespace>`
        )[0]
      );
      prevWhiteSpace.value = true;

      if (parts[i + 1]) {
        children.push(parts[i + 1]);
        prevWhiteSpace.value = false;
      }
    }
  } else {
    children.push(string);
  }
}

const removeWhiteSpace = (uu5stringObject, prevWhiteSpace = { value: false }) => {
  // children
  if (uu5stringObject.children) {
    let children = [];
    uu5stringObject.children.forEach(child => {
      if (typeof child === "string") {
        removeWhiteSpacesFromChildren(child, children, prevWhiteSpace);
      } else {
        children.push(removeWhiteSpace(child, prevWhiteSpace));
      }
    });
    uu5stringObject.children = children;
  }

  // content
  let contentProps = uu5stringObject.props && uu5stringObject.props.props.find(item => item.name === "content");
  if (contentProps) {
    let content = [];
    let value = typeof contentProps.value === "string" ? [contentProps.value] : contentProps.value;
    value.forEach(child => {
      if (typeof child === "string") {
        // content.push(
        //   ...UU5.Common.UU5String.parse(
        //     "<uu5string />" +
        //       child.replace(/(\s{2,})/g, '<UU5.RichText.Whitespace spaces="$1"> </UU5.RichText.Whitespace>')
        //   )
        // );
        removeWhiteSpacesFromChildren(child, content, prevWhiteSpace);
      } else {
        content.push(removeWhiteSpace(child));
      }
    });
    contentProps.value = content;
  }

  return uu5stringObject;
};

const processBlockToRaw = (raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock) => {
  let block = {
    key: genKey(),
    text: "",
    type: "unstyled",
    depth: parentBlock ? parentBlock.depth + 1 : 0,
    inlineStyleRanges: [],
    entityRanges: []
  };
  raw.blocks.push(block);

  // if editorItem is block component create block by defined type, otherwise create unstyled block
  if (editorItem && editorItem.display === "block") {
    block.type = editorItem.type;
    blockDataMap[block.key] = editorItem.data;
  } else {
    blockDataMap[block.key] = { artificial: true };
  }

  if (children) {
    if (!Array.isArray(children)) {
      children = [children];
    }
    appendChildrenToBlock(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock);
  }

  return "";
};

const processEntityToRaw = (raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset = 0) => {
  let text = "";
  // check content of entity - all nodes must be texts or inline components
  if (
    !validateChildrenDisplay(
      editorItem.type,
      editorItem.data ? editorItem.data.props : {},
      children,
      getEditorItem,
      propsFormatter,
      "entity"
    )
  ) {
    throw "Unsupported structure of uu5string. Entity can contain only text or inline styles.";
  }

  // process all children
  children.forEach(
    child =>
      (text += processUU5StringObjectToRaw(
        raw,
        child,
        null,
        getEditorItem,
        propsFormatter,
        parentBlock,
        textOffset + text.length
      ))
  );

  // register entity to raw
  let data = editorItem.data;

  // inline component
  let entity = {
    offset: parentBlock.text.length + textOffset,
    length: text.length,
    key: raw.entityArray.length
  };
  parentBlock.entityRanges.push(entity);
  raw.entityArray.push({
    mutability: "MUTABLE",
    type: editorItem.type,
    data
  });

  // cannot return empty text - that entity will not be rendered by editor. Add zws character as a content of selfclosed tags
  return text || "\u200b";
};

const processInlineToRaw = (raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset = 0) => {
  let text = "";
  // check content of entity - all nodes must be texts or inline components
  if (
    !validateChildrenDisplay(
      editorItem.type,
      editorItem.data ? editorItem.data.props : {},
      children,
      getEditorItem,
      propsFormatter,
      "block"
    )
  ) {
    throw "Unsupported structure of uu5string. Inline styles cannot contain blocks or wrappers.";
  }

  // process all children
  let offset = parentBlock.text.length;
  children.forEach(
    child =>
      (text += processUU5StringObjectToRaw(
        raw,
        child,
        null,
        getEditorItem,
        propsFormatter,
        parentBlock,
        textOffset + text.length
      ))
  );
  let inlineStyle = {
    offset: offset + textOffset,
    length: text.length,
    style: editorItem.type
  };
  parentBlock.inlineStyleRanges.push(inlineStyle);

  return text;
};

const appendChildrenToBlock = (raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock) => {
  let block = raw.blocks[raw.blocks.length - 1];
  children.forEach(child => {
    try {
      block.text += processUU5StringObjectToRaw(raw, child, blockDataMap, getEditorItem, propsFormatter, block);
    } catch (e) {
      let textLength;
      let textOffset = block.text.length;
      const key = raw.entityArray.length;
      // remove from raw all elements added by processing block
      if (typeof child === "string") {
        textLength = child.length;
        block.text += child;
      } else {
        let text = removeSpecialNodes(child).toString();
        textLength = text.length;
        block.text += text;
        if (block.entityRanges) {
          block.entityRanges = block.entityRanges.filter(range => {
            let result = range.offset < textOffset;
            if (!result) {
              raw.entityarray[range.key] = undefined;
            }
            return result;
          });
        }
        if (block.inlineStyleRanges) {
          block.inlineStyleRanges = block.inlineStyleRanges.filter(range => range.offset < textOffset);
        }
      }
      block.entityRanges = block.entityRanges || [];
      // add entity to block
      block.entityRanges.push({
        offset: textOffset,
        length: textLength,
        key
      });
      // add entity
      raw.entityArray.push({ type: "error", mutability: "MUTABLE" });
    }
  });
};

const appendUU5StringObjectToBlock = (raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter) => {
  // try to append node into previous block node if last added block was added by algorithm
  let lastBlock = raw.blocks.length === 0 ? undefined : raw.blocks[raw.blocks.length - 1];
  let lastBlockData = lastBlock ? blockDataMap[lastBlock.key] : undefined;
  if ((lastBlockData && lastBlockData.artificial) || (lastBlock && lastBlock._uu5richTextDataCollector)) {
    if (typeof uu5stringObject === "string") {
      lastBlock.text += uu5stringObject;
    } else {
      appendChildrenToBlock(raw, undefined, [uu5stringObject], blockDataMap, getEditorItem, propsFormatter, lastBlock);
    }
    return lastBlock;
  }
  return processBlockToRaw(raw, undefined, [uu5stringObject], blockDataMap, getEditorItem, propsFormatter);
};

const processUU5StringObjectToRaw = (
  raw,
  uu5stringObject,
  blockDataMap,
  getEditorItem,
  propsFormatter,
  parentBlock,
  textOffset = 0
) => {
  // create propsFormatter function
  const propsFormatterFn = createPropsFormatterFn(propsFormatter);
  // handle string node
  if (typeof uu5stringObject === "string") {
    if (!parentBlock) {
      return appendUU5StringObjectToBlock(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter);
    }
    return formatInputString(uu5stringObject);
  } else if (!parentBlock && shouldReplaceBrForEnter(raw, uu5stringObject, parentBlock, blockDataMap)) {
    return appendUU5StringObjectToBlock(raw, "\n", blockDataMap, getEditorItem, propsFormatter);
  }

  // handle uu5string node props - try to take props from cache
  let props = uu5stringObject.cachedEditorItem
    ? uu5stringObject.cachedEditorItem.props
    : propsFormatterFn(uu5stringObject.props.toObject());
  if (!props) props = {};
  let children = props.content || uu5stringObject.children || [];
  let useContent = !!props.content;
  if (!Array.isArray(children)) {
    children = [children];
  }
  delete props.content;

  // get type of node - at first try to get item from cache, it can be set after check of children types by parent component
  let editorItem = uu5stringObject.cachedEditorItem;
  if (!editorItem) {
    editorItem = parentBlock
      ? getEditorItem(
          uu5stringObject.tag,
          props,
          children,
          parentBlock.type,
          (blockDataMap[parentBlock.key] || {}).props
        )
      : getEditorItem(uu5stringObject.tag, props, children);
  }
  uu5stringObject.cachedEditorItem = editorItem;

  // inline text cannot be nested right inside wrapper (e.g. ul, ol) - it should be text format
  if (parentBlock && parentBlock.display === "wrapper" && editorItem.display === "inline") {
    parentBlock.data = parentBlock.data || {};
    parentBlock.data.delimiters = parentBlock.data.delimiters || [];
    parentBlock.data.delimiters.push(children);
    return null;
  }

  if (typeof editorItem.getChildren === "function") {
    let resultChildren = editorItem.getChildren(uu5stringObject);
    editorItem.children = resultChildren.children;
    useContent = resultChildren.useContent;
    delete editorItem.getChildren;
  }

  // children must be an array
  if (editorItem.children && !Array.isArray(editorItem.children)) {
    editorItem.children = [editorItem.children];
  }

  if (editorItem.children) {
    children = editorItem.children;
  } else {
    editorItem.children = children;
  }

  // mark if result shloud be saved as a content or as a children
  if (editorItem.data && useContent) {
    editorItem.data.useContent = useContent;
  }

  // handle situation if input data is incorrect - for example all entites and inline styles must be defined inside block component
  if (editorItem.display !== "block" && editorItem.display !== "wrapper" && !parentBlock) {
    return appendUU5StringObjectToBlock(raw, uu5stringObject, blockDataMap, getEditorItem, propsFormatter);
  }

  switch (editorItem.display) {
    case "wrapper":
      // set depth to wrapper
      // if wrapper has no parent (is top level component) set depth to -1 because its child needs to have set depth 0 ( they haven"t any parent component )
      // if wrapper has parent block, takes parent block's depth and its child will rise depth by 1
      editorItem.depth = parentBlock ? parentBlock.depth : -1;
      // only process child nodes - wrapper is skipped
      children.forEach(child =>
        processUU5StringObjectToRaw(raw, child, blockDataMap, getEditorItem, propsFormatter, editorItem, textOffset)
      );
      return "";
    case "block":
      return processBlockToRaw(raw, editorItem, children, blockDataMap, getEditorItem, propsFormatter, parentBlock);
    case "entity":
      return processEntityToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset);
    case "inline":
      return processInlineToRaw(raw, editorItem, children, getEditorItem, propsFormatter, parentBlock, textOffset);
    default:
      // process as unknown entity
      editorItem.type = parentBlock ? "unknown" : "unstyled";
      editorItem.display = parentBlock ? "entity" : "block";
      editorItem.data = editorItem.data || {};
      editorItem.data.tag = uu5stringObject.tag;
      // show content of unknown tag as a string
      return parentBlock
        ? processEntityToRaw(
            raw,
            editorItem,
            UU5.Common.UU5String.contentToString(children),
            getEditorItem,
            parentBlock,
            textOffset
          )
        : processBlockToRaw(
            raw,
            editorItem,
            UU5.Common.UU5String.contentToString(children),
            getEditorItem,
            parentBlock
          );
  }
};

const normalizeStyleName = styleName => {
  // translate from font-size to fontSize
  return styleName
    .replace(/-([a-z])/g, (_, $1) => {
      return $1.toUpperCase();
    })
    .trim();
};

const nodeAttributesToProps = nodeAttributes => {
  if (!nodeAttributes || nodeAttributes.length === 0) return {};

  let props = {};

  for (let i = 0; i < nodeAttributes.length; i++) {
    let propName = nodeAttributes[i].name;

    // handle change name of attributes class and for to correct JS attribute/prop names
    if (propName === "class") propName = "className";
    if (propName === "for") propName = "htmlFor";

    props[propName] = nodeAttributes[i].value;
  }

  // parse style attribute to object
  if (props.style) {
    let propsStyle = {};
    let styles = props.style.split(";");
    for (let i = 0; i < styles.length; i++) {
      if (!styles[i]) continue;
      let match = styles[i].match(/^\s*(.*?):\s*(.*?)\s*$/);
      if (match) {
        propsStyle[normalizeStyleName(match[1])] = match[2];
      }
    }

    props.style = propsStyle;
  }

  return props;
};

const translateComponents = (comp, htmlMappings, stylesFilter, parentNode, trimSpaces) => {
  if (!htmlMappings) return;

  let resultComp = new UU5.Common.UU5String.Object();
  let usedStyles = {};
  let handledProps = { style: true, className: true };
  // possible filtering styles by stylesFilter ( styles from editor's root )
  if (comp.props.style && stylesFilter){
    for (let styleName in comp.props.style) {
      if (comp.props.style[styleName] === stylesFilter[styleName]) {
        usedStyles[styleName] = true;
      }
    }
  }
  let lastAncestor;

  for (let index = 0; index < htmlMappings.length; index++) {
    let rule = htmlMappings[index];

    // check tagName
    if (rule.tagName && rule.tagName !== true && rule.tagName !== comp.tagName) {
      // comp does not match tagName with rule
      continue;
    }

    // possible to check className - not needed now
    if (rule.className) {
      // check if element has class name
      if (!comp.props.className) {
        continue;
      }

      // check className of the component
      if (typeof rule.className === "string" && rule.className !== comp.props.className) {
        continue;
      } else if (
        typeof rule.className === "object" &&
        rule.className instanceof RegExp &&
        !comp.props.className.match(rule.className)
      ) {
        continue;
      }
    }

    let matchedStyle = {};
    // check styles
    if (rule.style) {
      if (rule.style === true) {
        // copy all unused styles into style prop
        if (comp.props && comp.props.style) {
          for (let styleName in comp.props.style) {
            if (usedStyles[styleName]) {
              continue;
            }
            usedStyles[styleName] = true;
            matchedStyle[styleName] = comp.props.style[styleName];
          }
        }
      } else {
        if (!comp.props || !comp.props.style) {
          // cannot match style
          continue;
        }
        let matchStyles = true;
        let compStyle = comp.props.style;
        for (let styleName in rule.style) {
          if (usedStyles[styleName]) {
            // this rule try to use same style as another successful processed rule. Any style cannot be used twice.
            matchStyles = false;
            break;
          }
          let value = rule.style[styleName];
          if (compStyle[styleName]) {
            if (typeof value === "object" && value instanceof RegExp) {
              if (compStyle[styleName].match(value)) {
                matchedStyle[styleName] = value;
              } else {
                matchStyles = false;
                break;
              }
            } else if (value === true || value === compStyle[styleName]) {
              matchedStyle[styleName] = true; // only mark style to be used if
            } else {
              matchStyles = false;
              break;
            }
          } else {
            matchStyles = false;
            break;
          }
        }

        // styles does not match -> process next rule
        if (!matchStyles) continue;
      }
    }

    let processingComponent = resultComp;

    // process rule result
    let ruleResult = typeof rule.result === "function" ? rule.result(comp) : rule.result;

    if (!ruleResult) {
      continue;
    }

    // rule match - add tagName and styles into resultNode
    if (rule.tagName !== true) {
      if (rule.final) {
        resultComp.tag = ruleResult.tagName;
      } else {
        processingComponent = new UU5.Common.UU5String.Object(ruleResult.tagName, undefined, resultComp.children);
        resultComp.children = [processingComponent];
        if (!lastAncestor) {
          lastAncestor = processingComponent;
        }
      }
    }

    // add all props to result component
    if (ruleResult.props) {
      for (let propName in ruleResult.props) {
        // add prop as handled to prevent rewrite set value from comp
        handledProps[propName] = true;
        let prop = processingComponent.props.props.find(prop => prop.name === propName);
        let propValue = ruleResult.props[propName];
        let propValueType = typeof propValue;

        // create new prop if does not exists
        if (!prop) {
          prop = { name: propName };
          processingComponent.props.props.push(prop);
        }

        // set new value and value type to prop
        prop.value = propValueType === "object" ? `<uu5json />${JSON.stringify(propValue)}` : propValue;
        prop.valueType = propValueType;
      }
    }

    // add all styles to result component and remove them from original
    if (ruleResult.style || rule.style === true) {
      // find property style or create new one if does not exists
      let styleProp = processingComponent.props.props.find(prop => prop.name === "style");
      if (!styleProp) {
        // create new empty style property
        styleProp = {
          name: "style",
          valueType: "uu5json",
          value: {}
        };
        processingComponent.props.props.push(styleProp);
      }

      let styleSource = ruleResult.style ? ruleResult.style : matchedStyle;
      for (let styleName in styleSource) {
        let styleValue = styleSource[styleName];
        if (styleValue === true) styleValue = comp.props.style[styleName];
        styleProp.value[styleName] = styleValue;
      }
    }

    for (let styleName in matchedStyle) {
      let matchedStyleValue = matchedStyle[styleName];
      if (matchedStyleValue === true) {
        usedStyles[styleName] = true;
      } else if (typeof matchedStyleValue === "object" && matchedStyleValue instanceof RegExp) {
        // remove matched style from attribute
        comp.props.style[styleName] = comp.props.style[styleName].replace(matchedStyleValue, "");
        // if whitepsaces are only characters left in style after remove, then mark style as used to disallow match in another rule
        if (comp.props.style[styleName].match(/^\s*$/)) {
          usedStyles[styleName] === true;
        }
      }
    }

    if (rule.final) break;
  }

  // last ancestor is definde only if any children was added into children
  if (!resultComp.tag && lastAncestor) {
    // children is here always only one component - missing top component is replaced by only children
    resultComp = resultComp.children[0];
  }

  // if cannot translate original component to new one, return original component
  if (resultComp.tag) {
    // process children
    lastAncestor = lastAncestor || resultComp;
    lastAncestor.children = comp.childNodes.length
      ? DataConversion.parseHtmlNodeListToUu5stringObject(comp.childNodes, htmlMappings, stylesFilter, parentNode, trimSpaces)
      : undefined;

    for (let propName in comp.props) {
      if (handledProps[propName]) continue;
      resultComp.props.props.push({
        name: propName,
        value: comp.props[propName]
      });
    }

    return resultComp;
  } else {
    // return processed children
    return DataConversion.parseHtmlNodeListToUu5stringObject(comp.childNodes, htmlMappings, stylesFilter, parentNode, trimSpaces);
  }
};

const DataConversion = {
  editorStateToRaw(editorState) {
    return convertToRaw(editorState.getCurrentContent());
  },

  editorStateToUU5String(editorState, getUU5Item, propsFormatterFn) {
    const propsFormatter = props => {
      if (!props) return undefined;

      if (propsFormatterFn) {
        return propsFormatterFn(JSON.parse(JSON.stringify(props))) || props;
      } else {
        return props;
      }
    };
    const content = editorState.getCurrentContent();
    const raw = convertToRaw(content);

    // check if editor is not empty
    let empty = true;
    for (let bi = 0; bi < raw.blocks.length; bi++) {
      let block = raw.blocks[bi];
      if (block.text) {
        empty = false;
        break;
      }
    }

    if (empty) return "";

    let uu5string = "<uu5string />";
    let wrappers = []; // hold wrapper element for each level
    let blockItems = [];
    let lastWhitespace = false; // indicate if last character in of the previous block was replaced by whitespace
    let blockDatas = [];
    for (let bi = 0; bi < raw.blocks.length; bi++) {
      let block = raw.blocks[bi];
      let blockData = content
        .getBlockForKey(block.key)
        .getData()
        .toJSON();
      if (blockData.artificial) {
        // remove artificial block meta information if is set on another block type then default or has set some props
        blockData.artificial =
          block.type === "unstyled" &&
          (!block.data || !block.data.props || !block.data.props.size) &&
          // preserve to remove div from two blocks right after each other
          (bi === 0 || !blockDatas[bi - 1].artificial) &&
          // next or previour blocks should not be <br /> (empty unstyled block)
          (!raw.blocks[bi + 1] || (raw.blocks[bi + 1].text && raw.blocks[bi + 1].type === "unstyled")) &&
          (bi === 0 || (raw.blocks[bi - 1].text && raw.blocks[bi - 1].type === "unstyled"));
      }

      blockDatas.push(blockData);
    }
    for (let bi = 0; bi < raw.blocks.length; bi++) {
      let block = raw.blocks[bi];
      let nextBlock = bi === raw.blocks.length - 1 ? null : raw.blocks[bi + 1];
      let blockData = blockDatas[bi];
      let blockProps = blockData.props;
      let wrapper = (wrappers.length > 0 && wrappers[wrappers.length - 1]) || {};
      let uu5BlockItem =
        block.type === "error"
          ? { tag: null, opts: { preserveEnters: true } }
          : getUU5Item("block", block.type, blockProps, wrapper.tag, wrapper.props, !block.text);
      uu5BlockItem.opts = uu5BlockItem.opts || {};

      // need to sort wrappers and blocks to correct end tags
      let toClose = [];
      // close all blocks with same or higher depth
      for (let i = blockItems.length - 1; i >= 0; i--) {
        let blockItem = blockItems[i];
        if (blockItem.depth < block.depth) break;

        // uu5string += printClosingTag(blockItems.pop().item.tag);
        blockItems.pop();
        toClose.push({ tag: blockItem.item.tag, depth: blockItem.depth, blockData: blockItem.blockData });
      }

      let preserveWrapper = false;
      while (wrappers.length > 0 && wrappers[wrappers.length - 1].depth >= block.depth) {
        let wrapper = wrappers.pop();
        // do not print closing tag of wrapper
        if (wrapper.depth === block.depth && wrapper.tag === uu5BlockItem.wrapper) {
          preserveWrapper = true;
          wrappers.push(wrapper);
          break;
        }

        // print closing wrapper tag
        // uu5string += printClosingTag(wrapper.tag);
        toClose.push({ tag: wrapper.tag, depth: wrapper.depth - 0.5 });
      }

      // sort toClose array by depth of tags
      toClose.sort((tag1, tag2) => tag2.depth - tag1.depth);

      for (let i = 0; i < toClose.length; i++) {
        uu5string += printClosingTag(toClose[i].tag, toClose[i].blockData);
      }

      if (uu5BlockItem.wrapper) {
        // add new wrapper if it is preserved
        if (!preserveWrapper) {
          // add wrapper to array
          wrappers.push({
            tag: uu5BlockItem.wrapper,
            props: blockData.wrapperProps,
            depth: block.depth
          });
          // print opening wrapper tag
          uu5string += printOpeningTag(uu5BlockItem.wrapper, propsFormatter(uu5BlockItem.wrapperProps));
        }
      }
      if (!uu5BlockItem.tag) {
        // components only closed in uu5string block component
        uu5string += removeOutputSupportCharacters(block.text, { escapeXml: false, ...uu5BlockItem.opts });
      } else if (
        uu5BlockItem.isSelfClosed ||
        (removeOutputSupportCharacters(block.text).length === 0 &&
          (!nextBlock || nextBlock.depth <= block.depth) &&
          (!block.entityRanges || block.entityRanges.length === 0))
      ) {
        // print wrappers delimiter if block is wrapped
        // TODO

        // selfclosed block is defined as selfclosed or is empty and does not contain inner block
        blockData.isEmpty = true;
        uu5string += printOpeningTag(
          uu5BlockItem.tag,
          propsFormatter(uu5BlockItem.props),
          uu5BlockItem.isSelfClosed,
          blockData
        );
      } else {
        // print wrappers delimiter if block is wrapped
        // TODO
        
        // print opening tag and add block into blocks array
        uu5string += printOpeningTag(uu5BlockItem.tag, propsFormatter(uu5BlockItem.props), false, blockData);
        blockItems.push({ depth: block.depth, item: uu5BlockItem, blockData });

        // set inline styles into tags array
        let tags = [];
        let charUpdates = [];

        for (let index = 0; index < block.inlineStyleRanges.length; index++) {
          let range = block.inlineStyleRanges[index];
          let uu5InlineItem = getUU5Item("inline", range.style, null);
          if (!uu5InlineItem.tag) {
            if (uu5InlineItem.replaceChar) {
              let update = uu5InlineItem.replaceChar(block.text.substring(range.offset, range.offset + range.length));
              if (update) {
                update.offset += range.offset;
                update.length = range.length;
                charUpdates.push(update);
              }
            }
            continue;
          };
          let isSelfClosing =
            uu5InlineItem.isSelfClosed ||
            removeOutputSupportCharacters(block.text.substr(range.offset, range.length)).length === 0;

          let tagIndex = tags.length;
          // opening tag
          tags.push({
            type: "opening",
            componentType: "style",
            offset: range.offset,
            startOffset: range.offset,
            endOffset: range.offset + range.length,
            name: uu5InlineItem.tag,
            props: uu5InlineItem.props,
            isSelfClosing: isSelfClosing,
            index: tagIndex,
            order: uu5InlineItem.order || DEFAULT_TAG_ORDER,
            getChildren: uu5InlineItem.fn
          });

          // closing or selfclosing tag
          if (!isSelfClosing) {
            tags.push({
              type: "closing",
              componentType: "style",
              offset: range.offset + range.length,
              startOffset: range.offset,
              endOffset: range.offset + range.length,
              name: uu5InlineItem.tag,
              props: uu5InlineItem.props,
              index: tagIndex,
              order: uu5InlineItem.order || DEFAULT_TAG_ORDER
            });
          }
        }

        // set inline components(entities) into tags array
        for (let index = 0; index < block.entityRanges.length; index++) {
          let range = block.entityRanges[index];
          let entity = raw.entityMap[range.key];

          // skip empty or removed entities
          if (!entity.type) continue;

          let uu5EntityItem =
            entity.type === "error"
              ? { tag: null, opts: { preserveEnters: true } }
              : getUU5Item("entity", entity.type, entity.data.props);

          let isSelfClosing =
            uu5EntityItem.isSelfClosed ||
            entity.data.useContent ||
            removeOutputSupportCharacters(block.text.substr(range.offset, range.length)).length === 0;

          if (entity.data.useContent) {
            if (!uu5EntityItem.props) {
              uu5EntityItem.props = { content: block.text.substring(range.offset, range.length) };
            } else {
              uu5EntityItem.props.content = block.text.substring(range.offset, range.offset + range.length);
            }
          }

          let tagIndex = tags.length;

          // opening tag
          tags.push({
            type: "opening",
            componentType: "component",
            offset: range.offset,
            startOffset: range.offset,
            endOffset: range.offset + range.length,
            name: uu5EntityItem.tag,
            props: uu5EntityItem.props,
            isSelfClosing: isSelfClosing,
            index: tagIndex,
            order: uu5EntityItem.order || DEFAULT_TAG_ORDER,
            opts: uu5EntityItem.opts
          });

          // closing or selfclosing tag
          if (!isSelfClosing) {
            tags.push({
              type: "closing",
              componentType: "component",
              offset: range.offset + range.length,
              startOffset: range.offset,
              endOffset: range.offset + range.length,
              name: uu5EntityItem.tag,
              props: uu5EntityItem.props,
              index: tagIndex,
              order: uu5EntityItem.order || DEFAULT_TAG_ORDER,
              opts: uu5EntityItem.opts
            });
          }
        }

        // sort array of tags
        tags.sort(tagComparator);

        // sort update by index from the lowest
        charUpdates.sort((a,b) => a.offset - b.offset);
        // remove spaces which are hidden and wasn't lead by showed space
        let last = lastWhitespace ? -1 : -2; // if last character of previous block wasnt replaced by whitespace, set unreachable index
        for (let spaceIndex = 0; spaceIndex < charUpdates.length; spaceIndex++) {
          let space = charUpdates[spaceIndex];

          // if current space is hidden and there is no space right before it -> remove space
          if (space.hidden && space.offset !== last + 1) {
            // first node in the block - check ending of uu5string, because uu5string removes whitespace components
            if (space.offset === 0) {
              if (uu5string.match(/\s{2,}(<[^>]*>)*$/)) {
                // space is right after another big space
                space.hidden = false;
                last = space.offset;
              } else {
                space.replace = "";
              }
            } else {
              if (block.text.substring(0, space.offset).match(/\s{2,}(<[^>]*>)*$/)) {
                // space is right after another big space
                space.hidden = false;
                last = space.offset;
              } else {
                space.replace = "";
              }
            }
          } else {
            last = space.offset;
          }
        }

        // find last non hidden whitespace
        let textLength = block.text.length;
        for (let i = charUpdates.length - 1; i >= 0; i--) {
          let whitespace = charUpdates[i];

          // shorten text about length of whitepsace elements
          textLength -= whitespace.length;
          // check if whitespace is at the end of the block's text
          lastWhitespace = whitespace.offset === textLength;

          // if whitespace is shown => return result (true or false)
          // if whitespace is not at the end of the text return false
          if (!whitespace.hidden || !lastWhitespace) {
            break;
          }
        }

        let updateIndex = 0;
        let allCharsUpdated = updateIndex === charUpdates.length;

        // print tags into string
        let opened = [];
        const text = block.text;
        let index = 0;
        // defines how many parent components disable escaping < and > characters - escaping xml is disabled by returning undefined tag - so any content is taken as components
        let escapeLevel = 0;
        tags.forEach(tag => {
          // print text
          let next = tag.offset;
          if (next !== index) {
            if (!allCharsUpdated && next > charUpdates[updateIndex].offset) {
              let offset = index;
              // print all character replaces and text between them
              while (!allCharsUpdated && offset < next) {
                // calculate offset of the next item
                let nextOffset = charUpdates[updateIndex].offset;

                // check if next replace should be done here
                if (nextOffset > next) break;

                // replace selected char
                uu5string += removeOutputSupportCharacters(text.substring(offset, nextOffset), {
                  escapeXml: escapeLevel === 0,
                  ...(opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts)
                });

                uu5string += charUpdates[updateIndex].replace;

                // update offset and index
                offset = nextOffset + 1;
                updateIndex++;
                allCharsUpdated = charUpdates.length === updateIndex;
              }

              // print resting text
              uu5string += removeOutputSupportCharacters(text.substring(offset, next), {
                escapeXml: escapeLevel === 0,
                ...(opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts)
              });
            } else {
              uu5string += removeOutputSupportCharacters(text.substring(index, next), {
                escapeXml: escapeLevel === 0,
                ...(opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts)
              });
            }
          }
          index = next;
          if (tag.type === "opening") {
            if (!tag.name) escapeLevel++;
            // before print opening tag of component - close all styles
            let mustCloseStyles =
              (tag.componentType === "component" && opened.length && !tag.isSelfClosing && tag.name) ||
              (tag.componentType === "style" &&
                opened.length &&
                opened[opened.length - 1].componentType === "style" &&
                opened[opened.length - 1].order < tag.order);
            // update index for self closing tags - they contain support characters
            if (tag.isSelfClosing) {
              index = tag.endOffset;
            }
            let temp;
            if (mustCloseStyles) {
              if (tag.componentType === "component") {
                temp = [...opened].reverse();
              } else {
                temp = [];
                for (let styleIndex = opened.length - 1; styleIndex >= 0; styleIndex--) {
                  let style = opened[styleIndex];
                  if (style.componentType === "component" || style.order >= tag.order) {
                    break;
                  }
                  temp.push(style);
                }
              }
              temp.forEach(item => {
                uu5string += printClosingTag(item.name);
                item.offset = next;
                item.startOffset = next;
              });
              // clear array of opened styles
              opened.splice(opened.length - temp.length, temp.length);
            }
            // print opening tag
            uu5string += printOpeningTag(tag.name, propsFormatter(tag.props), tag.isSelfClosing);
            if (!tag.isSelfClosing) {
              // add tag to stack
              opened.push(tag);
            }

            // reopen all styles
            if (mustCloseStyles) {
              temp.sort(tagComparator);
              temp.forEach(item => {
                uu5string += printOpeningTag(item.name, propsFormatter(item.props));
                opened.push(item);
              });
            }
          } else {
            if (tag.alreadyClosed) return; // this closing tag was already closed so simply skip to next tag
            if (!tag.name) escapeLevel--;
            // find index of opening tag in stack
            let openTagIndex = opened.length - 1;
            for (; openTagIndex >= 0; openTagIndex--) {
              let openedTag = opened[openTagIndex];
              if (openedTag.index === tag.index) {
                break;
              }
            }

            if (openTagIndex === opened.length - 1) {
              // print closing tag
              uu5string += printClosingTag(tag.name);
              // remove opening tag
              opened.pop();
            } else {
              // fix crossing tags - close opened tags from last
              for (let openedIndex = opened.length - 1; openedIndex > openTagIndex; openedIndex--) {
                let closingTag = opened[openedIndex];
                uu5string += printClosingTag(closingTag.name);
                if (closingTag.endOffset === tag.endOffset) {
                  // remove tags which should ends in same position as currently closed tag
                  opened.splice(openedIndex, 1);
                  let _closingTag = tags.find(tag => tag.type === "closing" && tag.index === closingTag.index);
                  _closingTag.alreadyClosed = true;
                }
              }

              // print tag
              uu5string += printClosingTag(tag.name);

              // reopen crossing tags from first
              // reorder tags stack
              let openingTags = opened.slice(openTagIndex + 1);
              openingTags.forEach(item => {
                item.offset = next;
                item.startOffset = next;
              });
              // tag which ending first must be ordered as last to minimalize crossing tags
              openingTags.sort(tagComparator);
              opened.splice(openTagIndex + 1, openingTags.length, ...openingTags);
              // print reordered tags
              for (let index = openTagIndex + 1; index < opened.length; index++) {
                let openingTag = opened[index];
                uu5string += printOpeningTag(openingTag.name, propsFormatter(openingTag.props));
              }

              // remove closed tag from stack
              // console.log(`Removing tag from opened: ${opened[openedIndex]}`);
              opened.splice(openTagIndex, 1);
            }
          }
        });

        // print rest of the text
        // print all character replaces and text between them
        while (!allCharsUpdated) {
          // calculate offset of the next item
          let nextOffset = charUpdates[updateIndex].offset;

          // replace selected char
          uu5string += removeOutputSupportCharacters(text.substring(index, nextOffset), {
            escapeXml: escapeLevel === 0,
            ...(opened && opened.length > 0 ? opened[opened.length - 1].opts : uu5BlockItem.opts)
          });

          uu5string += charUpdates[updateIndex].replace;

          // update offset and index
          // move index of printed text after last update
          index = nextOffset + 1;
          updateIndex++;
          allCharsUpdated = charUpdates.length === updateIndex;
        }

        // print rest of the text
        uu5string += removeOutputSupportCharacters(text.substring(index), {
          escapeXml: escapeLevel === 0,
          ...uu5BlockItem.opts
        });
      }
    }

    // sort unclosed blocks and wrappers
    let toClose = [];
    for (let i = 0; i < blockItems.length; i++) {
      toClose.push({
        depth: blockItems[i].depth,
        tag: blockItems[i].item.tag,
        blockData: blockItems[i].blockData
      });
    }
    for (let i = 0; i < wrappers.length; i++) {
      // lower depth of wrappers to ensure that wrapper is closer after block with the same depth
      toClose.push({
        depth: wrappers[i].depth - 0.5,
        tag: wrappers[i].tag
      });
    }

    // sort toClose array by depth of tags
    toClose.sort((tag1, tag2) => tag2.depth - tag1.depth);

    // print wrapper's and block's end tags
    for (let i = 0; i < toClose.length; i++) {
      uu5string += printClosingTag(toClose[i].tag, toClose[i].blockData);
    }

    return uu5string;
  },

  uu5stringToRaw(uu5string, blockDataMap, getEditorItem, propsFormatter) {
    if (!uu5string) {
      return getEmptyRaw();
    }

    let uu5stringObject;
    try {
      uu5stringObject =
        typeof uu5string === "string" ? UU5.Common.UU5String.parse(removeInputSupportCharacters(uu5string)) : uu5string;
    } catch (e) {
      return {
        blocks: [
          {
            type: "error",
            text: uu5string.replace(/^<uu5string\s*\/>/, ""),
            inlineStyleRanges: [],
            entityRanges: [],
            depth: 0,
            key: genKey()
          }
        ],
        entityMap: {}
      };
    }

    uu5stringObject = removeWhiteSpace({ children: uu5stringObject }).children;

    // handle empty uu5string
    if (!uu5stringObject.length) {
      return getEmptyRaw();
    }

    let raw = {
      blocks: [],
      entityArray: []
    };

    uu5stringObject.forEach(block => {
      if (block.tag === "UU5.RichText.EndBlock") {
        // add special block to collect all inline styling and entities
        // consider to remove empty blocks after process all data
        raw.blocks.push({
          key: genKey(),
          text: "",
          type: "unstyled",
          depth: 0,
          inlineStyleRanges: [],
          entityRanges: [],
          _uu5richTextDataCollector: true // this means, that all inline sibling will be pleced inside this container like it is a parent
        });
        return;
      }
      processUU5StringObjectToRaw(raw, block, blockDataMap, getEditorItem, propsFormatter);
    });

    // convert entityArray to entityMap
    raw.entityMap = {};
    raw.entityArray.forEach((item, index) => {
      raw.entityMap[index] = item;
    });
    delete raw.entityArray;

    return raw;
  },

  uu5stringToEditorState(uu5string, customDecorators = [], getEditorItem, propsFormatterFn) {
    // keep support for other draft default block types and add our myCustomBlock type
    let decorators = new CompositeDecorator(customDecorators);

    // uu5string = uu5string.replace(/(\s{2,})/g, '<UU5.RichText.Whitespace value="$1"> </UU5.RichText.Whitespace>');

    // create new state for editor from content
    let editorState;
    let isUU5String = uu5string && (typeof uu5string === "object" || UU5.Common.REGEXP.uu5string.test(uu5string));

    // go through all text nodes and replace whitepaces
    

    if (isUU5String) {
      // draft raw object cannot contain data for blocks, so we must save them separately and after creation of
      // editor state, we set them directly into state by block keys
      let blockDataMap = {};
      editorState = EditorState.createWithContent(
        convertFromRaw(DataConversion.uu5stringToRaw(uu5string, blockDataMap, getEditorItem, propsFormatterFn)),
        decorators
      );

      // set data into editor state
      for (let blockKey in blockDataMap) {
        let content = Modifier.setBlockData(
          editorState.getCurrentContent(),
          Selection.modifySelection(editorState, {
            anchorKey: blockKey,
            focusKey: blockKey,
            anchorOffset: 0,
            focusOffset: 0
          }),
          blockDataMap[blockKey]
        );
        editorState = EditorState.push(editorState, content, "parse from uu5string");
      }
    } else if (uu5string) {
      editorState = EditorState.createWithContent(ContentState.createFromText(uu5string), decorators);
    } else {
      EditorState.createEmpty(decorators);
    }
    // create new content from uu5string
    return editorState;
  },

  parseHtmlNodeListToUu5stringObject(
    nodeList,
    htmlMappings,
    stylesFilter,
    parentBlock = false,
    trimWhiteSpaces = true
  ) {
    let dataModel = [];
    let cachedString = "";
    let trimLeft = !trimWhiteSpaces;
    // console.log(nodeList);
    nodeList.forEach(node => {
      let value;
      switch (node.nodeType) {
        case 1:
          // node

          // add cached text into data model
          if (cachedString) {
            dataModel.push(cachedString);
            cachedString = "";
          }

          // handle node
          {
            const tagName = node.tagName.toLowerCase();
            value = translateComponents(
              {
                tagName,
                props: nodeAttributesToProps(node.attributes),
                childNodes: node.childNodes
              },
              htmlMappings,
              stylesFilter,
              true,
              false
            );
            trimLeft = trimLeft || !!value;

            if (!parentBlock && tagName === "div") {
              let blockEndingComponent = new UU5.Common.UU5String.Object();
              blockEndingComponent.tag = "UU5.RichText.EndBlock";
              dataModel.push(blockEndingComponent);
            }
          }
          break;
        case 3:
          // text
          value = node.textContent;

          // remove leading whitespaces
          if (!trimLeft) {
            value = value.replace(/^\s*/, "");
            trimLeft = !!value;
          }
          // cache string and add it to data model with next component - at the end remove ending whitespaces
          cachedString += value;
          value = null;
          // value = node.textContent.replace(/[\n\r]/g, "");
          break;
      }

      if (value) {
        if (Array.isArray(value)) {
          dataModel = dataModel.concat(value);
        } else {
          dataModel.push(value);
        }
      }
    });

    if (cachedString) {
      if (trimWhiteSpaces) {
        cachedString = cachedString.replace(/\s*$/, "");
      }
      dataModel.push(cachedString);
    }

    return dataModel;
  }
};

export default DataConversion;
