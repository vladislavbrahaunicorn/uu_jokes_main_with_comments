"use strict";

var _session2 = require("./session.js");

var _tools = _interopRequireDefault(require("./tools"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO Mocking UuApp Session should be somewhere else (uu_appg01-test?).
try {
  // NOTE Mocking uu_appg01_oidc via jest.doMock can be done only if that module is actually
  // installed. If it is not, Jest resolver will throw an error which has no code so
  // we would have to check the message to identify this scenario (this is the case if the module
  // is re-mapped via moduleNameMapper)
  //   => instead try to resolve the module's package.json which will throw standard error
  // with code MODULE_NOT_FOUND and skip mocking in such case.
  require.resolve("uu_appg01_oidc/package.json");

  jest.doMock("uu_appg01_oidc", function () {
    var Oidc = jest.requireActual("uu_appg01_oidc"); // INFO
    // 1. MockAuthenticationService uses instance of Session. These store mocked state of authentication.
    // 2. Then there is MockSession which conforms to uu5g04 requirements about session (IdentityMixin, SessionMixin).
    //    From the point of view of uu_appg01_oidc this is "legacyApi" and is forwarded to classes in point 1.
    // 3. Additionally, MockSession has API for managing session state in tests as needed by uu5g04-test.

    var MockAuthenticationService = /*#__PURE__*/function () {
      function MockAuthenticationService() {
        _classCallCheck(this, MockAuthenticationService);
      }

      _createClass(MockAuthenticationService, null, [{
        key: "getServiceName",
        value: function getServiceName() {
          return "oidcg02";
        }
      }, {
        key: "restoreSession",
        value: function restoreSession() {
          return this.initPromise;
        }
      }, {
        key: "isRestoringSession",
        value: function isRestoringSession() {
          return !this.initComplete;
        }
      }, {
        key: "addListener",
        value: function addListener(eventName, listener) {
          if (!this._listeners[eventName]) this._listeners[eventName] = [];

          this._listeners[eventName].push(listener);

          return this.removeListener.bind(this, eventName, listener);
        }
      }, {
        key: "removeListener",
        value: function removeListener(eventName, listener) {
          var listeners = this._listeners[eventName];
          if (listeners) this._listeners[eventName] = listeners.filter(function (fn) {
            return fn !== listener;
          });
        }
      }, {
        key: "authenticate",
        value: function () {
          var _authenticate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this = this;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _tools.default.act(function () {
                      return _this.initPromise;
                    });

                  case 2:
                    this._triggerEvent("sessionChanged", oidcSession);

                    return _context.abrupt("return", oidcSession);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function authenticate() {
            return _authenticate.apply(this, arguments);
          }

          return authenticate;
        }()
      }, {
        key: "isAuthenticating",
        value: function isAuthenticating() {
          return !this._initComplete;
        }
      }, {
        key: "getCurrentSession",
        value: function getCurrentSession() {
          return oidcSession;
        }
      }, {
        key: "isSessionExpiring",
        value: function isSessionExpiring() {
          return !!this._expiring;
        }
      }, {
        key: "_triggerEvent",
        value: function _triggerEvent(eventName, payload) {
          var listeners = this._listeners[eventName];

          if (listeners) {
            _tools.default.act(function () {
              var event = {
                type: eventName,
                data: payload
              };
              listeners.forEach(function (fn) {
                return fn(event);
              });
            });
          }
        }
      }]);

      return MockAuthenticationService;
    }();

    _defineProperty(MockAuthenticationService, "_listeners", {});

    _defineProperty(MockAuthenticationService, "_expiresAt", 0);

    _defineProperty(MockAuthenticationService, "_expiring", false);

    _defineProperty(MockAuthenticationService, "initComplete", false);

    _defineProperty(MockAuthenticationService, "initPromise", new Promise(function (resolve, reject) {
      MockAuthenticationService._initPromiseResolve = resolve;
      MockAuthenticationService._initPromiseReject = reject;
    }));

    var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(Oidc.AuthenticationService)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var k = _step.value;

        if (MockAuthenticationService[k] === undefined) {
          var origFn = Oidc.AuthenticationService[k];
          if (typeof origFn !== "function" || k === "constructor") continue;
          MockAuthenticationService[k] = jest.fn();
        }
      } // override real method on real AuthnSvc because uu_appg01_oidc automatically performs
      // restoreSession() on its own

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    Oidc.AuthenticationService.restoreSession = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", oidcSession);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    var Session = /*#__PURE__*/function () {
      function Session() {
        _classCallCheck(this, Session);

        this._identity = null;
        this._attributes = {};
        this._idToken = "token-for-tests";
      } // getId() {}
      // getAuthenticationId() {}
      // getAuthenticationTime() {}


      _createClass(Session, [{
        key: "getAuthenticationLevelOfAssurance",
        value: function getAuthenticationLevelOfAssurance() {
          return this._identity ? this._identity.loginLevelOfAssurance : null;
        }
      }, {
        key: "getIdentity",
        value: function getIdentity() {
          if (!this._identity) return this._identity;
          return new Identity(this._identity.uuIdentity, this._identity);
        }
      }, {
        key: "getClientIdentity",
        value: function getClientIdentity() {}
      }, {
        key: "getApplicationIdentity",
        value: function getApplicationIdentity() {}
      }, {
        key: "isAuthenticated",
        value: function isAuthenticated() {
          return !!this._identity;
        }
      }, {
        key: "getCallTokenScope",
        value: function getCallTokenScope() {}
      }, {
        key: "getCallToken",
        value: function () {
          var _getCallToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(scope) {
            var opts,
                _args3 = arguments;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                    return _context3.abrupt("return", (opts && opts.excludeAuthenticationType ? "" : "Bearer ") + this._idToken);

                  case 2:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function getCallToken(_x) {
            return _getCallToken.apply(this, arguments);
          }

          return getCallToken;
        }()
      }, {
        key: "close",
        value: function () {
          var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this._identity = null;
                    return _context4.abrupt("return", MockAuthenticationService._triggerEvent("sessionChanged", this));

                  case 2:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function close() {
            return _close.apply(this, arguments);
          }

          return close;
        }()
      }, {
        key: "assertTrustiness",
        value: function assertTrustiness() {}
      }, {
        key: "getAttribute",
        value: function getAttribute(name) {
          if (!this._identity) return;
          var map = {
            email: this._identity.email,
            sub: this._identity.id,
            loa: this._identity.levelOfAssurance // loginLevelOfAssurance: supportedAcrValues.indexOf(this._identity.levelOfAssurance),

          };
          return map[name];
        }
      }, {
        key: "getLogoutUri",
        value: function getLogoutUri() {}
      }, {
        key: "getAuthenticationContext",
        value: function getAuthenticationContext() {}
      }, {
        key: "getExpiresAt",
        value: function getExpiresAt() {
          return MockAuthenticationService._expiresAt;
        }
      }, {
        key: "getState",
        value: function getState() {}
      }]);

      return Session;
    }();

    var Identity = /*#__PURE__*/function () {
      function Identity(uuIdentity, data) {
        _classCallCheck(this, Identity);

        this._uuIdentity = uuIdentity;

        if (typeof data === "string") {
          this._name = data;
        } else if (data) {
          this._name = data.name;
          this._type = data.type;
          this._levelOfAssurance = data.levelOfAssurance;
          this._loginLevelOfAssurance = data.loginLevelOfAssurance;
        }
      }

      _createClass(Identity, [{
        key: "getUuIdentity",
        value: function getUuIdentity() {
          return this._uuIdentity;
        }
      }, {
        key: "getName",
        value: function getName() {
          return this._name;
        }
      }, {
        key: "getType",
        value: function getType() {
          return this._type;
        }
      }, {
        key: "getLevelOfAssurance",
        value: function getLevelOfAssurance() {
          return this._levelOfAssurance;
        } // TODO Only for backward compatibility, drop for "1.0.0" release

      }, {
        key: "getUUIdentity",
        value: function getUUIdentity() {
          return this.getUuIdentity();
        }
      }]);

      return Identity;
    }(); // addLegacyAPI methods (copied from uu_appg01_oidc's oidcg01-session-wrapper.js)


    Object.defineProperty(Session, "currentSession", {
      get: function get() {
        return mockSession;
      }
    });
    Object.defineProperty(Session, "initComplete", {
      get: function get() {
        return !MockAuthenticationService.isRestoringSession();
      }
    });
    Object.defineProperty(Session, "initPromise", {
      get: function get() {
        return MockAuthenticationService.restoreSession().then(function () {
          return mockSession;
        });
      }
    });

    function addLegacyApi(session, AuthenticationService) {
      Object.defineProperty(session, "initComplete", {
        get: function get() {
          return !AuthenticationService.isRestoringSession();
        }
      });
      Object.defineProperty(session, "initPromise", {
        get: function get() {
          return AuthenticationService.restoreSession().then(function () {
            return session;
          });
        }
      }); // NOTE In optimal case this wrapper would always use AuthenticationService.getCurrentSession().
      // However that's not possible if we're finishing session restore because the "sessionChanged" event
      // is triggerred sooner than AuthnService._primaryProvider gets updated. So if an app uses
      // e.g. getIdentity() inside of the sessionChanged event handler, we would forward it to AS.getCurrentSession()
      // which would return empty session / session from not-yet-updated _primaryProvider.
      // => during events use the g02 session instance which was sent to the event, otherwise use getCurrentSession()

      var runningG02Session = null;

      var getG02Session = function getG02Session() {
        return runningG02Session || AuthenticationService.getCurrentSession();
      };

      session.getIdentity = function () {
        var g02Session = getG02Session();
        var identity = g02Session.getIdentity();
        if (!identity) return identity;
        identity.id = g02Session.getAttribute("sub");
        identity.name = identity.getName();
        identity.type = identity.getType();
        identity.email = g02Session.getAttribute("email");
        identity.uuIdentity = identity.getUuIdentity();
        identity.levelOfAssurance = identity.getLevelOfAssurance();
        identity.loginLevelOfAssurance = g02Session.getAuthenticationLevelOfAssurance();
        return identity;
      };

      session.getClaims = function () {
        return getG02Session()._attributes;
      };

      session.getCallToken = function () {
        var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (typeof scope === "string" || Array.isArray(scope)) {
          return getG02Session().getCallToken(scope, opts);
        } else {
          // If scope was not defined, return legacy value
          var _session = getG02Session();

          return {
            token: _session._idToken,
            tokenType: _session._idToken ? "Bearer" : null
          };
        }
      };

      session.isExpiring = function () {
        return AuthenticationService.isSessionExpiring();
      };

      session.isAuthenticated = function () {
        return getG02Session().isAuthenticated();
      };

      session.login = function (options) {
        var opts = _objectSpread({}, options);

        var authnSvcOpts = {};

        if (opts.access_token && opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
          authnSvcOpts = {
            os8Token: opts.access_token
          };
          delete opts.access_token;
          delete opts.token_type_hint;
        }

        Object.assign(authnSvcOpts, opts);
        return AuthenticationService.authenticate(authnSvcOpts).then(function () {
          return session;
        });
      };

      session.logout = function () {
        return getG02Session().close();
      };

      var _legacyListeners = {};

      session.addListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        var unregFn = AuthenticationService.addListener(eventType, function (_ref2) {
          var type = _ref2.type,
              data = _ref2.data;
          var origRunningG02Session = runningG02Session;
          if (data instanceof Session) runningG02Session = data;

          try {
            var g01Type = type;
            var g01Data = data instanceof Session ? session : data;

            if (type === "sessionChanged") {
              g01Type = "identityChange";
              g01Data = session.getIdentity();
            }

            var legacyEvent = {
              type: g01Type,
              data: g01Data
            };
            return listenerFn(legacyEvent);
          } finally {
            runningG02Session = origRunningG02Session;
          }
        });
        var map = _legacyListeners[eventType];
        if (!map) map = _legacyListeners[eventType] = new Map();
        map.set(listenerFn, unregFn);
        return unregFn;
      };

      session.removeListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        var map = _legacyListeners[eventType];
        var unregFn = map ? map.get(listenerFn) : null;
        if (!unregFn) return false;
        map.delete(listenerFn);
        return unregFn();
      };

      var _legacyIdentityChangeListeners = new Map();

      session.addIdentityChangeListener = function (listenerFn) {
        var unregFn = session.addListener("identityChange", function (e) {
          return listenerFn(e.data);
        });

        _legacyIdentityChangeListeners.set(listenerFn, unregFn);

        return unregFn;
      };

      session.removeIdentityChangeListener = function (listenerFn) {
        var unregFn = _legacyIdentityChangeListeners.get(listenerFn);

        if (!unregFn) return false;

        _legacyIdentityChangeListeners.delete(listenerFn);

        return unregFn();
      };

      session.getAuthenticationContext = function () {
        return getG02Session().getAuthenticationContext();
      };
    } // mock Session with extra API for manipulating with session state


    var MockSession = /*#__PURE__*/function (_Session) {
      _inherits(MockSession, _Session);

      var _super = _createSuper(MockSession);

      function MockSession() {
        _classCallCheck(this, MockSession);

        return _super.apply(this, arguments);
      }

      _createClass(MockSession, [{
        key: "mockSetPending",
        value: function mockSetPending() {
          MockAuthenticationService.initComplete = false;
          MockAuthenticationService.initPromise = new Promise(function (resolve, reject) {
            MockAuthenticationService._initPromiseResolve = resolve;
            MockAuthenticationService._initPromiseReject = reject;
          });
          oidcSession._identity = null;
          MockAuthenticationService._expiring = false;
          MockAuthenticationService._expiresAt = 0;
        }
      }, {
        key: "mockSetIdentity",
        value: function () {
          var _mockSetIdentity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(identity) {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    oidcSession._identity = identity;

                    MockAuthenticationService._triggerEvent("sessionChanged", oidcSession);

                    if (MockAuthenticationService.initComplete) {
                      _context5.next = 7;
                      break;
                    }

                    MockAuthenticationService.initComplete = true;

                    MockAuthenticationService._initPromiseResolve(this); // have to wait for this because IdentityMixin might be waiting for initPromise and we want
                    // such listeners to be finished when we return from this fn


                    _context5.next = 7;
                    return _tools.default.act(function () {
                      return MockAuthenticationService.initPromise;
                    });

                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function mockSetIdentity(_x2) {
            return _mockSetIdentity.apply(this, arguments);
          }

          return mockSetIdentity;
        }()
      }, {
        key: "mockSetExpiring",
        value: function mockSetExpiring(expiring) {
          if (!oidcSession._identity && expiring) {
            console.warn("Cannot set 'expiring' flag on session - use Session.mockSetIdentity(...) first.");
            return;
          }

          MockAuthenticationService._expiring = expiring;
          MockAuthenticationService._expiresAt = expiring ? Date.now() + 5 * 60 * 1000 : Date.now() + 12 * 60 * 60 * 1000;

          if (expiring) {
            MockAuthenticationService._triggerEvent("sessionExpiring", {
              expiresAt: MockAuthenticationService._expiresAt
            });
          } else if (oidcSession._identity) {
            MockAuthenticationService._triggerEvent("sessionExtended", {
              expiresAt: MockAuthenticationService._expiresAt
            });
          }
        }
      }, {
        key: "mockReset",
        value: function mockReset() {
          MockAuthenticationService.initComplete = false;
          MockAuthenticationService.initPromise = new Promise(function (resolve, reject) {
            MockAuthenticationService._initPromiseResolve = resolve;
            MockAuthenticationService._initPromiseReject = reject;
          });
          oidcSession._identity = null;
          MockAuthenticationService._listeners = {};
          MockAuthenticationService._expiring = false;
          MockAuthenticationService._expiresAt = 0;
        }
      }]);

      return MockSession;
    }(Session);

    var oidcSession = new Session();
    var mockSession = new MockSession();
    addLegacyApi(mockSession, MockAuthenticationService);
    _session2.Session.instance = mockSession;
    return _objectSpread(_objectSpread({}, Oidc), {}, {
      AuthenticationService: MockAuthenticationService,
      Session: Session
    });
  });
} catch (e) {
  if (e.code !== "MODULE_NOT_FOUND") throw e;
}