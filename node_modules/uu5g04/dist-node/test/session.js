"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Session = void 0;

var _uu5g = _interopRequireDefault(require("uu5g04"));

var _tools = _interopRequireDefault(require("./tools"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TEST_IDENTITY = {
  id: "a8c5f13c239f820003dd4aff",
  // JWT claim "sub"
  name: "Test User",
  type: "uuPerson",
  uuIdentity: "1-9999",
  email: "test.user@example.org",
  // JWT claim "email"
  levelOfAssurance: 0,
  // JWT claim "loa"
  loginLevelOfAssurance: 1 // index of "loa" in supported acr values

}; // minimal Session class (copying API of OIDC Session)

var MockSession = /*#__PURE__*/function () {
  function MockSession() {
    _classCallCheck(this, MockSession);

    this.mockReset();
  }

  _createClass(MockSession, [{
    key: "login",
    value: function () {
      var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(opts) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _tools.default.act(function () {
                  return _this.initPromise;
                });

              case 2:
                this._triggerEvent("identityChange", this.getIdentity());

                return _context.abrupt("return", this);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function login(_x) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _tools.default.act(function () {
                  return Promise.resolve();
                });

              case 2:
                this._identity = null;

                this._triggerEvent("identityChange", this.getIdentity());

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }, {
    key: "isAuthenticated",
    value: function isAuthenticated() {
      return this._identity != null;
    }
  }, {
    key: "isExpiring",
    value: function isExpiring() {
      return this._expiring;
    }
  }, {
    key: "getIdentity",
    value: function getIdentity() {
      return this._identity;
    }
  }, {
    key: "getCallToken",
    value: function getCallToken() {
      return {
        token: "token-for-tests",
        type: "Bearer"
      };
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      if (!this._listeners[eventName]) this._listeners[eventName] = [];

      this._listeners[eventName].push(listener);
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      var listeners = this._listeners[eventName];
      if (listeners) this._listeners[eventName] = listeners.filter(function (fn) {
        return fn !== listener;
      });
    }
  }, {
    key: "_triggerEvent",
    value: function _triggerEvent(eventName, payload) {
      var listeners = this._listeners[eventName];

      if (listeners) {
        _tools.default.act(function () {
          var event = {
            type: eventName,
            data: payload
          };
          listeners.forEach(function (fn) {
            return fn(event);
          });
        });
      }
    } // extra mock methods for controlling the session state

  }, {
    key: "mockSetPending",
    value: function mockSetPending() {
      var _this2 = this;

      this.initComplete = false;
      this.initPromise = new Promise(function (resolve, reject) {
        _this2._initPromiseResolve = resolve;
        _this2._initPromiseReject = reject;
      });
      this._identity = null;
      this._expiring = false;
      this._expiresAt = 0;
    }
  }, {
    key: "mockSetIdentity",
    value: function () {
      var _mockSetIdentity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(identity) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._identity = identity;

                this._triggerEvent("identityChange", this._identity);

                if (this.initComplete) {
                  _context3.next = 7;
                  break;
                }

                this.initComplete = true;

                this._initPromiseResolve(this); // have to wait for this because IdentityMixin might be waiting for initPromise and we want
                // such listeners to be finished when we return from this fn


                _context3.next = 7;
                return _tools.default.act(function () {
                  return _this3.initPromise;
                });

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function mockSetIdentity(_x2) {
        return _mockSetIdentity.apply(this, arguments);
      }

      return mockSetIdentity;
    }()
  }, {
    key: "mockSetExpiring",
    value: function mockSetExpiring(expiring) {
      if (!this._identity && expiring) {
        console.warn("Cannot set 'expiring' flag on session - use Session.mockSetIdentity(...) first.");
        return;
      }

      this._expiring = expiring;
      this._expiresAt = expiring ? Date.now() + 5 * 60 * 1000 : Date.now() + 12 * 60 * 60 * 1000;
      if (expiring) this._triggerEvent("sessionExpiring", {
        expiresAt: this._expiresAt
      });else if (this._identity) this._triggerEvent("sessionExtended", {
        expiresAt: this._expiresAt
      });
    }
  }, {
    key: "mockReset",
    value: function mockReset() {
      var _this4 = this;

      this.initComplete = false;
      this.initPromise = new Promise(function (resolve, reject) {
        _this4._initPromiseResolve = resolve;
        _this4._initPromiseReject = reject;
      });
      this._identity = null;
      this._listeners = {};
      this._expiring = false;
      this._expiresAt = 0;
    }
  }]);

  return MockSession;
}();

MockSession.currentSession = new MockSession();
var Session = {
  TEST_IDENTITY: TEST_IDENTITY,
  instance: MockSession.currentSession,
  setPending: function setPending() {
    return Session.instance.mockSetPending();
  },
  // must be async because we need to wait for Session.initPromise
  setIdentity: function setIdentity(identity) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", Session.instance.mockSetIdentity(identity));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  },
  setExpiring: function setExpiring() {
    var expiring = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return Session.instance.mockSetExpiring(expiring);
  },
  reset: function reset() {
    return Session.instance.mockReset();
  }
};
exports.Session = Session;
beforeEach( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
  return regeneratorRuntime.wrap(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return Session.setIdentity(Session.TEST_IDENTITY);

        case 2:
          _uu5g.default.Environment.session = Session.instance;

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _callee5);
})));
afterEach( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
  var _events;

  return regeneratorRuntime.wrap(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _uu5g.default.Environment.session = null;
          Session.reset();
          _events = _uu5g.default.Environment.EventListener._events;
          if (_events) _events.delete(Session.instance);

        case 4:
        case "end":
          return _context6.stop();
      }
    }
  }, _callee6);
})));