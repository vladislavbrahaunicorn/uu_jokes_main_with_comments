"use strict";

/**
 * Cache item.
 * @private
 */
class Item {

  /**
   * Creates new instance of cache item.
   * @param key Item name
   * @param value Item value
   * @param exp Item expiration
   */
  constructor(key, value, exp) {
    this.key = key;
    this.value = value;
    this.exp = exp;
    this.next = null;
    this.prev = null;
  }

  /**
   * Checks if item is expired.
   * @returns {boolean} True if item is expired
   */
  isExpired() {
    return this.exp > -1 && this.exp <= Date.now();
  }

  /**
   * Returns object representation of cache item.
   * @returns {*[]} Array containing key, value end expiration (in this order)
   */
  toJSON() {
    return [this.key, this.value, this.exp];
  }

}

/**
 * Browser friendly implementation of LRU cache.
 */
class Cache {

  /**
   * Creates new instance of cache.
   * @param {Object|null} opts Cache options
   * @param {number} opts.maxSize Maximal number of items to be stored
   * @param {number} opts.maxAge How long (in milliseconds) should items be stored
   */
  constructor(opts = {}) {
    if (typeof opts.maxSize === 'number') {
      this._maxSize = opts.maxSize;
    } else {
      this._maxSize = -1;
    }
    if (typeof opts.maxAge === 'number') {
      this._maxAge = opts.maxAge;
    } else {
      this._maxAge = -1;
    }
    this._size = 0;
    this._items = {};
    this._first = null;
    this._last = null;
  }

  /**
   * Stores value into cache.
   * @param key Key to access cached value
   * @param value Value to be cached
   * @param maxAge How long (in milliseconds) should this value be stored (overrides global maxAge)
   * @returns {*} Value previously stored under this key (or null if none)
   */
  set(key, value, maxAge = null) {
    let origValue = null;
    maxAge = typeof maxAge === "number" ? maxAge : this._maxAge;
    let exp = maxAge > -1 ? maxAge + Date.now() : -1;
    let newItem = new Item(key, value, exp);
    if (this._items[key]) {
      origValue = this.delete(key);
    } else {
      // If cache is full we have to prune it
      if (this._maxSize > -1 && this._size >= this._maxSize) {
        this._prune(1);
      }
    }
    // Set new item to front of list
    this._push(newItem);
    // Return original value (if any)
    return origValue;
  }

  /**
   * Returns value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or null)
   */
  get(key) {
    let item = this._items[key];
    let value = null;
    if (item) {
      if (item.isExpired()) {
        // It item is expired, just delete it
        this._remove(item);
      } else {
        value = item.value;
        this._touch(item);
      }
    }
    return value;
  }

  /**
   * Deletes value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or null)
   */
  delete(key) {
    let value = null;
    if (this._items[key]) {
      let item = this._items[key];
      if (!item.isExpired()) {
        // In case item is not expired, return value of deleted item
        value = item.value;
      }
      this._remove(item);
    }
    return value;
  }

  /**
   * Clears cache.
   */
  clear() {
    this._size = 0;
    this._items = {};
    this._first = null;
    this._last = null;
  }

  /**
   * Returns actual cache size.
   * @returns {number}
   */
  getSize() {
    return this._size;
  }

  /**
   * Returns object representation of cache item.
   * @returns {Array} List of cached items
   */
  toJSON() {
    let items = [];
    // Serialize from last to ensure correct order on restore
    let item = this._last;
    while (item) {
      items.push(item.toJSON());
      item = item.prev;
    }
    return [this._maxSize, this._maxAge, items];
  }

  /**
   * Initializes cache from serialized value (clears any existing data).
   * @param json Serialized cache
   */
  fromJSON(json) {
    this.clear();
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    let [maxSize, maxAge, items] = json;
    this._maxSize = maxSize;
    this._maxAge = maxAge;
    for (let [key, value, exp] of items) {
      this._push(new Item(key, value, exp));
    }
  }

  /**
   * Iterates through cached items (from newest to oldest)
   * @param callback Function receiving two parameters - item key and value.
   *    Function may return false to stop the loop.
   */
  forEach(callback) {
    if (typeof callback !== 'function') {
      throw new BaseError(`Parameter must be function`);
    }
    let item = this._first;
    let doNext = null;
    while (item) {
      doNext = callback(item.key, item.value);
      if (typeof doNext === 'boolean' && !doNext) {
        break;
      } else {
        item = item.next;
      }
    }
  }

  /**
   * Pushes new item to cache.
   * @param item Cached item
   * @private
   */
  _push(item) {
    // Set previous first item after new item
    item.next = this._first;
    item.prev = null;
    if (this._first) {
      this._first.prev = item;
    }
    // Set new item to first place
    this._first = item;
    if (!this._last) {
      // If case was emtpy, first item is also last
      this._last = item;
    }
    // Store the item
    this._items[item.key] = item;
    this._size++;
  }

  /**
   * Moves item to fist position.
   * @param item Touched item
   * @private
   */
  _touch(item) {
    // If item is already first do nothing
    if (item.prev) {
      // Link previous item with next of moved item
      item.prev.next = item.next;
      if (item.next) {
        // Link next item with prev of moded item
        item.next.prev = item.prev;
      } else {
        // In case we are moving last item, update tail
        this._last = item.prev;
      }
      // Set previous first item after moved item
      item.next = this._first;
      item.prev = null;
      if (this._first) {
        this._first.prev = item;
      }
      // Set moved item to first place
      this._first = item;
    }
  }

  /**
   * Removes item from cache.
   * @param item Item to be removed
   * @private
   */
  _remove(item) {
    if (item.prev) {
      // Link previous item with next of deleted item
      item.prev.next = item.next;
    } else {
      // In case we are deleting first item, update head
      this._first = item.next;
    }
    if (item.next) {
      // Link next item with prev of deleted item
      item.next.prev = item.prev;
    } else {
      // In case we are deleting last item, update tail
      this._last = item.prev;
    }
    // Delete the item
    delete this._items[item.key];
    this._size--;
  }

  /**
   * Prune at least specified number of items, first delete
   * expired ones, then delete from last item until given
   * number of items to be deleted is reached.
   * @param atLeast Number of items to be removed
   * @private
   */
  _prune(atLeast = 1) {
    let deleted = 0;
    // Delete all expired items first
    let item = this._last;
    while (item) {
      if (item.isExpired()) {
        this._remove(item);
        deleted++;
      }
      item = item.prev;
    }
    // Delete remaining number of items
    if (deleted < atLeast) {
      let item = this._last;
      for (let i = 0; i < (atLeast - deleted); i++) {
        this._remove(item);
        item = item.prev;
        // Break in case all items are gone
        if (!item) {
          break;
        }
      }
    }
  }

}

module.exports = Cache;
