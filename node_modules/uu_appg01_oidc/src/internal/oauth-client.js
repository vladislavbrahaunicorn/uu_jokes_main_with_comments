"use strict";

const JsonWebToken = require("jsonwebtoken");
const {BaseError} = require("uu_appg01_core-utils");
const {AppClient, ApplicationError} = require("uu_appg01_core-appclient");
const {InvalidCredentials, AuthenticationError} = require("uu_appg01_core-authentication");
const {PerflogHandler, RemoteErrorHandler, TransformParametersHandler} = require("uu_appg01_core-appclient");
const SyncCallNotPossible = require("./sync-call-not-possible.js");
const Discovery = require("./discovery.js");
const Jwks = require("./jwks.js");
const Base64 = require("./base64.js");
const Cache = require("./cache.js");

const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
const APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, TransformParametersHandler];

const OAUTH_CLIENT_ID = "client_id";
const OAUTH_CLIENT_SECRET = "client_secret";
const MEDIA_FORM_ENCODED = "application/x-www-form-urlencoded";
const MEDIA_JSON = "application/json";

const OAUTH_CODE = "code";
const OAUTH_SCOPE = "scope";
const OAUTH_SCOPE_OPENID = "openid";
const OAUTH_GRANT_TYPE = "grant_type";
const OAUTH_GRANT_TYPE_CODE = "authorization_code";
const OAUTH_PARAM_TOKEN = "token";
const OAUTH_PARAM_TOKEN_TYPE_HINT = "token_type_hint";
const OAUTH_PARAM_REDIRECT_URI = "redirect_uri";

const OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD = "password";
const OAUTH_USERNAME = "username";
const OAUTH_PASSWORD = "password";
const OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials";
const OAUTH_GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
const OAUTH_REFRESH_TOKEN = "refresh_token";
const OAUTH_SUBJECT_TOKEN = "subject_token";
const OAUTH_SUBJECT_TOKEN_TYPE = "subject_token_type";

const OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
const OAUTH_TOKEN_TYPE_ACCESS_TOKEN = "access_token";
const OAUTH_TOKEN_TYPE_REFRESH_TOKEN = "refresh_token";
const OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_ID_TOKEN}`;
const OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_ACCESS_TOKEN}`;
const OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_REFRESH_TOKEN}`;
const OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE = "urn:ietf:params:oauth:grant-type:token-exchange";

const CLIENT_PRIVATE_KEY = "client_private_key";
const CLIENT_TOKEN_ALG = "RS256";
const CLIENT_TOKEN_TTL = 10 * 60;
const OAUTH_CLIENT_ASSERTION = "client_assertion";
const OAUTH_CLIENT_ASSERTION_TYPE = "client_assertion_type";
const OAUTH_CLIENT_ASSERTION_BEARER = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";

const DEFAULT_TOKEN_CACHE_SIZE = 2048;
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;

const ID_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
const DEFAULT_ACCESS_TOKEN_PATTERN = ".^";
const DEFAULT_REFRESH_TOKEN_PATTERN = ".^";

// TODO Constant for workaround to allow sending of word values to G01
const G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
const G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];

class OAuthClient {

  constructor(serviceUri, opts = {}) {
    if (!serviceUri) {
      throw new BaseError("Service URI must be defined");
    }
    let tokenCacheSize = opts.tokenCacheSize ? Number(opts.tokenCacheSize) : DEFAULT_TOKEN_CACHE_SIZE;
    this._tokenCache = new Cache({maxSize: tokenCacheSize});
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._discovery = new Discovery(serviceUri, opts);
    this._jwks = new Jwks(this._discovery, opts);
    let perflogEnabled = (typeof opts.perflogEnabled === "boolean") ? opts.perflogEnabled : true;
    let interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {interceptors}));
    this._metadata = null;
    this._serviceUri = serviceUri;
    this._defaultScope = opts.defaultScope != null ? opts.defaultScope : OAUTH_SCOPE_OPENID;
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
  }

  getServiceUri() {
    return this._serviceUri;
  }

  async getMetadata() {
    this._metadata = await this._discovery.getMetadata();
    return this._metadata;
  }

  getMetadataSync() {
    if (!this._metadata) {
      throw new SyncCallNotPossible("Asynchronous method getMetadata must be invoked prior to synchronous invocation");
    }
    return this._metadata;
  }

  async getIssuer() {
    return (await this.getMetadata()).issuer;
  }

  async getSupportedAcrValues() {
    return (await this.getMetadata()).acr_values_supported || [];
  }

  getSupportedAcrValuesSync() {
    return this.getMetadataSync().acr_values_supported || [];
  }

  async getUserInfoUri() {
    return (await this.getMetadata()).userinfo_endpoint;
  }

  async getEndSessionUri() {
    return (await this.getMetadata()).end_session_endpoint;
  }

  getEndSessionUriSync() {
    return this.getMetadataSync().end_session_endpoint
  }

  async getCheckSessionIframeUri() {
    return (await this.getMetadata()).check_session_iframe;
  }

  async getAuthorizationUri(reponseType, redirectUri, clientCredentials, acrValues, scope = null) {
    // Initialize metadata
    await this.getMetadata();
    // And delegate to synchronous function (which now has access to freshly loaded metadata)
    return this.getAuthorizationUriSync(reponseType, redirectUri, clientCredentials, acrValues, scope);
  }

  getAuthorizationUriSync(reponseType, redirectUri, clientCredentials, acrValues, scope = null) {
    let authzUri = `${this.getMetadataSync().authorization_endpoint}?`;
    authzUri += `response_type=${encodeURIComponent(reponseType)}&`;
    authzUri += `redirect_uri=${encodeURIComponent(redirectUri)}&`;
    authzUri += `client_id=${encodeURIComponent(clientCredentials.client_id)}&`;
    authzUri += `scope=${encodeURIComponent(this._getOidcScope(scope))}`;
    if (acrValues) {
      let supportedAcrValues = this.getSupportedAcrValuesSync();
      if (supportedAcrValues && supportedAcrValues.length > 0) {
        // TODO Workaround for renaming of "medium" acrValue on G02 server
        let requestedValuesStr = acrValues.toString();
        if (supportedAcrValues.includes("medium")) {
          requestedValuesStr = requestedValuesStr.replace("standard", "medium");
        } else if (supportedAcrValues.includes("standard")) {
          requestedValuesStr = requestedValuesStr.replace("medium", "standard");
        }
        // ...end of workaround
        let requestedValues = requestedValuesStr.split(" ");
        let transformedValues = [];
        requestedValues.forEach(requestedValue => {
          if (supportedAcrValues.includes(requestedValue)) {
            transformedValues.push(requestedValue);
          } else {
            let requestedValueOrd = Number(requestedValue);
            if (supportedAcrValues.includes(requestedValueOrd)) {
              transformedValues.push(requestedValueOrd);
            } else if (supportedAcrValues[requestedValueOrd]) {
              transformedValues.push(supportedAcrValues[requestedValueOrd]);
              // TODO Workaround to allow sending of word values to G01
            } else if ((requestedValueOrd = G02_ACR_VALUES_OLD.indexOf(requestedValue)) > -1 || (requestedValueOrd = G02_ACR_VALUES.indexOf(requestedValue)) > -1) {
              transformedValues.push(requestedValueOrd);
            }
            // ...end of workaround
          }
        });
        transformedValues = transformedValues.filter(p => (p == null ? false : true));
        // TODO Workaround for G01 which accepts only single acr value
        // and uses acr value ordering (thus lowest number is selected)
        if (transformedValues.length > 1 && !isNaN(transformedValues[0])) {
          transformedValues = [Math.min(...transformedValues)];
        }
        // ...end of workaround
        if (transformedValues.length > 0) {
          authzUri += `&acr_values=${encodeURIComponent(transformedValues.join(" "))}`;
        }
      }
    }
    return authzUri;
  }

  async grantAuthorizationCodeToken(authorizationCode, clientCredentials, redirectUri, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CODE;
    params[OAUTH_CODE] = authorizationCode;
    params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    if (redirectUri) {
      params[OAUTH_PARAM_REDIRECT_URI] = redirectUri;
    }
    return await this._grantToken(params, clientCredentials);
  }

  async grantResourceOwnerPasswordCredentialsToken(username, password, clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD;
    params[OAUTH_USERNAME] = username;
    params[OAUTH_PASSWORD] = password;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }

  async grantImplicitFlowToken() {
    throw new BaseError("Method not implemented.");
  }

  async grantHybridFlowToken() {
    throw new BaseError("Method not implemented.");
  }

  async grantClientCredentialsToken(clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }

  async refreshToken(refreshToken, clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_REFRESH_TOKEN;
    params[OAUTH_REFRESH_TOKEN] = refreshToken;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }

  async exchangeToken(token, clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE;
    params[OAUTH_SUBJECT_TOKEN] = token;
    if (token.match(ID_TOKEN_REGEX)) {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    }
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }

  async introspectToken(token, clientCredentials = null) {
    let metadata = await this.getMetadata();
    let introspectTokenUri = metadata.token_introspection_endpoint;
    let params = {};
    params[OAUTH_PARAM_TOKEN] = token;
    let tokenTypeHint = this._getTokenTypeHint(token);
    if (tokenTypeHint) {
      params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
    }
    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (clientCredentials) {
      let authnHeader = await this._createClientAuthnHeader(clientCredentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }
    let result = null;
    try {
      result = await this._client.post(introspectTokenUri, params, {headers});
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    if (!result.active) {
      throw new InvalidCredentials("Invalid credentials.");
    }
    return result.data;
  }

  async revokeToken(token, clientCredentials = null) {
    let metadata = await this.getMetadata();
    let revokeTokenUri = metadata.token_revocation_endpoint;

    let params = {};
    params[OAUTH_PARAM_TOKEN] = token;
    let tokenTypeHint = this._getTokenTypeHint(token);
    if (tokenTypeHint) {
      params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
    }

    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (clientCredentials) {
      let authnHeader = await this._createClientAuthnHeader(clientCredentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }

    let result = null;
    try {
      result = await this._client.post(revokeTokenUri, params, {headers});
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    return result.data;
  }

  async parseToken(token, verify = true, clientCredentials = null) {
    if (typeof verify === "object") {
      clientCredentials = verify;
      verify = true;
    }
    let claims;
    if (token.match(ID_TOKEN_REGEX)) {
      claims = await this._jwks.decodeToken(token, verify);
    } else {
      claims = await this.introspectToken(token, clientCredentials);
      if (verify) {
        this._jwks.verifyExpiration(claims);
      }
    }
    return claims;
  }

  cacheToken(tokenKey, expireAt, token) {
    expireAt = expireAt - this._tokenTimeLeeway * 2;
    let ttl = (expireAt * 1000) - Date.now();
    if (ttl > 0) {
      this._tokenCache.set(tokenKey, token, ttl);
    }
  }

  getToken(tokenKey) {
    return this._tokenCache.get(tokenKey);
  }

  deleteToken(tokenKey) {
    return this._tokenCache.delete(tokenKey);
  }

  listTokens(callback) {
    this._tokenCache.forEach(callback);
  }

  // ======================== Private methods ================================

  async _grantToken(params, credentials = null) {
    let metadata = await this.getMetadata();
    let grantTokenUri = metadata.token_endpoint;

    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (credentials) {
      let authnHeader = await this._createClientAuthnHeader(credentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = credentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }

    let result = null;
    try {
      result = await this._client.post(grantTokenUri, params, {headers});
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    return result.data;
  }

  async _createClientAuthnHeader(credentials) {
    let authnHeader = null;
    if (credentials[CLIENT_PRIVATE_KEY]) {
      let metadata = await this.getMetadata();
      let opts = {
        algorithm: CLIENT_TOKEN_ALG,
        jwtid: Math.random().toString(16).substring(2, 10),
        audience: metadata.token_endpoint,
        issuer: credentials[OAUTH_CLIENT_ID],
        subject: credentials[OAUTH_CLIENT_ID],
        expiresIn: CLIENT_TOKEN_TTL
      };
      authnHeader = `Bearer ${JsonWebToken.sign({}, credentials[CLIENT_PRIVATE_KEY], opts)}`;
    } else {
      let username = credentials[OAUTH_CLIENT_ID];
      let password = credentials[OAUTH_CLIENT_SECRET];
      // avoid/encode ':' -  is reserved for basic authentication
      username = encodeURIComponent(username);
      authnHeader = `Basic ${Base64.encode(`${username}:${password}`)}`;
    }
    return authnHeader;
  }

  _getOidcScope(scope) {
    let oidcScope = null;
    if (Array.isArray(scope)) {
      oidcScope = `${this._defaultScope} ${scope.join(" ")}`;
    } else if (scope) {
      oidcScope = `${this._defaultScope} ${scope}`;
    } else {
      oidcScope = this._defaultScope;
    }
    return oidcScope;
  }

  _getTokenTypeHint(token) {
    if (this._accessTokenPattern.test(token)) {
      return OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN
    } else if (this._refreshTokenPattern.test(token)) {
      return OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN
    } else if (ID_TOKEN_REGEX.test(token)) {
      return OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN
    } else {
      return null;
    }
  }

}

module.exports = OAuthClient;
