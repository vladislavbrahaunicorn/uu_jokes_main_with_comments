"use strict";

const {BaseError} = require("uu_appg01_core-utils");
const {AppClient} = require("uu_appg01_core-appclient");
const {InvalidCredentials} = require("uu_appg01_core-authentication");
const {PerflogHandler, RemoteErrorHandler, TransformParametersHandler} = require("uu_appg01_core-appclient");
const Cache = require("./persistent-cache.js");
const Jwt = require("./jwt.js");

const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
const APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, TransformParametersHandler];

const LEEWAY = 5 * 60;
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
const JWKS_CACHE_SIZE = 16;
const DEFAULT_JWKS_CACHE_TTL = 60 * 60;
const DEFAULT_JWT_ALG = "RS256";

const JWKS_CACHE = new Cache("jwks", {maxSize: JWKS_CACHE_SIZE});

class Jwks {

  constructor(discovery, opts = {}) {
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwksCacheTtl = (opts.jwksCacheTtl ? Number(opts.jwksCacheTtl) : DEFAULT_JWKS_CACHE_TTL) * 1000;
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    let perflogEnabled = (typeof opts.perflogEnabled === "boolean") ? opts.perflogEnabled : true;
    let interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {interceptors}));
  }

  async getPublicKeyData(kid) {
    let jwks = await this.getPublicKeySet();
    let publicKeyData = jwks && jwks.keys.find(pk => pk.kid === kid);
    if (!publicKeyData) {
      jwks = await this.getPublicKeySet(true);
      publicKeyData = jwks && jwks.keys.find(pk => pk.kid === kid);
      if (!publicKeyData) {
        throw new InvalidCredentials(`Unable to obtain public JWK key with jwk_id=${kid} from ${(await this._discovery.getMetadata()).issuer}.`);
      }
    }
    return publicKeyData;
  }

  async getPublicKeySet(refresh = false) {
    let metadata = await this._discovery.getMetadata();
    let issuerUri = metadata.issuer;
    let jwks = JWKS_CACHE.get(issuerUri);
    if (!jwks || refresh) {
      jwks = (await this._client.get(metadata.jwks_uri)).data;
      JWKS_CACHE.set(issuerUri, jwks, this._jwksCacheTtl);
    }
    return jwks;
  }

  async decodeToken(token, verify = true) {
    let parsedToken = null;
    try {
      parsedToken = await Jwt.decode(token, {complete: true});
    } catch (e) {
      throw new InvalidCredentials("Token is not valid.", e);
    }
    if (verify) {
      let publicKeyData = await this.getPublicKeyData(parsedToken.header.kid);
      let verificationOptions = {};
      verificationOptions.issuer = (await this._discovery.getMetadata()).issuer;
      let algorithm = publicKeyData.alg;
      if (!algorithm) {
        algorithm = ((await this._discovery.getMetadata()).id_token_signing_alg_values_supported || [])[0];
        if (!algorithm) {
          algorithm = DEFAULT_JWT_ALG;
        }
      }
      verificationOptions.algorithms = algorithm;
      verificationOptions.clockTolerance = LEEWAY;
      try {
        await Jwt.verify(token, publicKeyData, verificationOptions);
      } catch (e) {
        throw new InvalidCredentials("Token is not valid or is expired.", e);
      }
    }
    return parsedToken.payload;
  }

  verifyExpiration(decodedToken) {
    if (decodedToken.exp < (Date.now() / 1000 - this._tokenTimeLeeway)) {
      throw new InvalidCredentials("Token is not valid or is expired.");
    }
  }

}

module.exports = Jwks;
