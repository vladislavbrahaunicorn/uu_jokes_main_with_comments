"use strict";

const {Config, BaseError} = require("uu_appg01_core-utils");
const Util = require("util");
const Fs = require("fs");
const fsReadFile = Util.promisify(Fs.readFile);
const fsExists = Util.promisify(Fs.exists);

const CONFIG_PREFIX = "uu_app_oidc_providers_";
const UNREGISTERED_CLIENT_ID_PREFIX = "uu-oidc:unregistered-client:";

// TODO Generate default client name based on fingerprint
const DEFAULT_CLIENT_NAME = Math.random().toString(16).substring(2, 10);

/**
 * Helper class for providing Oidc Client credentials.
 */
class ClientCredentialsProvider {

  /**
   * Allows setting of custom credentials provider.
   * @param provider
   * @returns {function(*)} Instance of previous provider
   */
  static setExternalProvider(provider) {
    let origProvider = this._externalProvider;
    this._externalProvider = provider;
    return origProvider;
  }

  /**
   * Returns OIDC client credentials for given service.
   * @param serviceName Name of registered authentication service.
   * @returns {Object} Client credentials
   */
  static async getClientCredentials(serviceName) {
    let credentials;
    if (this._externalProvider) {
      // Read credentials from external provider (if available)
      credentials = await this._externalProvider.getClientCredentials(serviceName);
    }
    if (!credentials) {
      // Read credentials from configuration (try also legacy configuration)
      credentials = Config.get(`${CONFIG_PREFIX}${serviceName}_client_credentials`) || Config.get("uu_oidc_client_credentials");
    }
    if (!credentials && this._externalProvider) {
      // Read unregistered client credentials from external provider (if available)
      credentials = await this._externalProvider.getUnregisteredCredentials(serviceName);
    }
    if (!credentials) {
      // Provide default credentials of unregistered client
      let clientId = Config.get(`${CONFIG_PREFIX}${serviceName}_unregistered_client_id`) || `${UNREGISTERED_CLIENT_ID_PREFIX}${DEFAULT_CLIENT_NAME}`;
      let clientSecret = Config.get(`${CONFIG_PREFIX}${serviceName}_unregistered_client_secret`) || null;
      return {client_id: clientId, client_secret: clientSecret};
    } else if (typeof credentials === "string") {
      // Load credentials from file
      return await this._getFromFile(credentials);
    } else {
      // Load credentials from hash
      return this._getFromHash(credentials);
    }
  }

  /**
   * Loads credentials from password file.
   * @param credentials Path to password file
   * @returns {*} Loaded credentials
   * @private
   */
  static async _getFromFile(credentials) {
    if (!(await fsExists(credentials))) {
      throw new BaseError(`Credentials file ${credentials} does not exist`);
    }
    let fileContent = await fsReadFile(credentials, "utf8");
    let parsedFile = JSON.parse(fileContent);
    return this._fromHash(parsedFile);
  }

  /**
   * Loads credentials from object
   * @param credentials Credentials object
   * @returns {*} Loaded credentials
   * @private
   */
  static _getFromHash(credentials) {
    if (!credentials) {
      throw new BaseError("Credentials cannot be empty.");
    }
    let clientId = credentials.client_id || credentials.clientId || credentials.accessCode1 || credentials.access_code1 || credentials.clientAccessCode1;
    let clientSecret = credentials.client_secret || credentials.clientSecret || credentials.accessCode2 || credentials.access_code2 || credentials.clientAccessCode2;
    let clientPrivateKey = credentials.client_private_key || credentials.clientPrivateKey;
    return {client_id: clientId, client_secret: clientSecret, client_private_key: clientPrivateKey};
  }

}

ClientCredentialsProvider._externalProvider = null;

module.exports = ClientCredentialsProvider;
