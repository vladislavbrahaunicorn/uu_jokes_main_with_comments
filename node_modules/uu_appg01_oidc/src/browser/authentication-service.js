"use strict";

const {
  AuthenticationService: CoreAuthenticationService,
  InvalidCredentials
} = require("uu_appg01_core-authentication");
const { Config, BaseError } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AppClient } = require("uu_appg01_core-appclient");
const DefaultServiceLoader = require("../internal/default-service-loader.js");
const OAuthClient = require("../internal/oauth-client.js");
const Session = require("../session.js");
const ImplicitFlow = require("./internal/implicit-flow.js");
const CodeFlow = require("./internal/code-flow.js");
const Os8Flow = require("./internal/os8-flow.js");
const ClientCredentialsProvider = require("./internal/client-credentials-provider.js");
const SessionStateChangeNotifier = require("./internal/session-state-change-notifier.js");
const BrowserSession = require("./internal/browser-session.js");

const DEFAULT_LEGACY_SERVICE_NAME = "uu_oidcg01_main";
const DEFAULT_SERVICE_NAME = "uu_oidcg01_main";
const META_SERVICE_NAME = "uu_appg01_oidc";

const CONFIG_RESTORE_SESSION_ON_LOAD = "uu_app_oidc_restore_session_on_load";
const CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
const CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const SECONDARY_PROVIDERS_ENABLED_CFG = "uu_app_oidc_secondary_providers_enabled";
const CONFIG_REDIRECT_URI_KEY = "uu_app_oidc_redirect_uri";
const CONFIG_AUTHN_FLOW_OVERRIDE = "uu_app_oidc_authn_flow_override";
const DEFAULT_RESTORE_SESSION_ON_LOAD = true;
const DEFAULT_AUTHN_TYPE = "implicit";
const DEFAULT_SCOPE_MODE = "allUseCases";

const ID_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

const BASE_ELEMENT = document.querySelector("base");
const APP_BASE_URI = location.protocol + "//" + location.host + ((BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "") || "/");
const CANONICAL_APP_BASE_URI = ((new RegExp("uu.app.cbu=([^;]+)")).exec(document.cookie) || [])[1];

/**
 * Frontend implementation of authentication service based on uuOIDC.
 */
class AuthenticationService {

  /**
   * Internal function invoked once page is loaded.
   * @return {Promise<void>}
   * @private
   */
  static async _onPageLoad(callToken) {
    if (!this._onPageLoadPromise) {
      this._onPageLoadFinished = false;
      let onPageLoadInternal = async function () {
        let restoreOnLoad = Config.getBoolean(CONFIG_RESTORE_SESSION_ON_LOAD);
        if (restoreOnLoad == null) {
          restoreOnLoad = DEFAULT_RESTORE_SESSION_ON_LOAD;
        }
        if (restoreOnLoad) {
          await this.restoreSession({callToken});
        } else {
          // In case restore of session is not enabled, we have to do some
          // initialization anyway in order to interactive authentication to
          // work (Browsers are limiting maximum number of awaits when
          // displaying popup, therefore these data must be loaded beforehand).
          let primaryProvider = this._providers[this._primaryProvider];
          if (primaryProvider) {
            await primaryProvider._loadAsyncData();
          }
        }
        this._onPageLoadFinished = true;
      }.bind(this);
      this._onPageLoadPromise = onPageLoadInternal();
    }
    return this._onPageLoadPromise;
  }

  /**
   * Load and initialize authentication service(s)
   * @private
   */
  static load(reconfigure = false) {
    DefaultServiceLoader.load(AuthenticationService, reconfigure);
  }

  /**
   * Creates new instance of uuOIDC authentication service and registers it
   * as authentication service with given name.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  static create(name, opts = {}) {
    // Do not allow reinitialization of already registered services
    let force = opts.force || false;
    if (!force && this._providers[name]) {
      return;
    }

    let authService = new this(name, opts);
    // Register service in global authentication service component
    if (name === DEFAULT_SERVICE_NAME || name === DEFAULT_LEGACY_SERVICE_NAME) {
      CoreAuthenticationService._register(DEFAULT_SERVICE_NAME, authService);
      CoreAuthenticationService._register(DEFAULT_LEGACY_SERVICE_NAME, authService);
    } else {
      CoreAuthenticationService._register(name, authService);
    }
    // Register oidc meta-service to be able to use multiple oidc providers via generic API
    CoreAuthenticationService._register(META_SERVICE_NAME, this);
    // Store service localy
    // (to be able to choose service based on tokens)
    // In local store, use only new name
    if (name === DEFAULT_LEGACY_SERVICE_NAME) {
      name = DEFAULT_SERVICE_NAME;
    }
    this._providers[name] = authService;
    if (!this._primaryProvider) {
      this._primaryProvider = name;
    }
    this._restoreSessionPromise = null;
    this._isRestoringSession = false;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
  }

  /**
   * Authenticates user (using primary authentication service).
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently find out authentication state).
   * @param {String} options.language What language the login page should use.
   * @param {String} options.os8Token Authenticates the user using uuOS8 token.
   * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
   * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, none]). Applied only if scope is not explicitly set.
   * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
   * @returns {Promise<Session>} User session for authenticated user.
   */
  static async authenticate(options, scope = null) {
    if (!this._onPageLoadPromise) {
      // Workaround for IE 11 (due to unreliable promises, authenticate
      // method can be invoked before onPageLoad is called)
      this._onPageLoad(null);
    }
    if (!this._onPageLoadFinished) {
      // May block popup but ensures authentication works in case popup
      // is not used, and allows for next authentication with popup works
      await this._onPageLoadPromise;
    }
    let primaryProvider = this._providers[this._primaryProvider];
    return await primaryProvider.authenticate(options, scope);
  }

  /**
   * Returns whether an authentication of primary authentication service is in progress.
   * @returns {boolean} Whether an authentication of primary authentication service is in progress.
   */
  static isAuthenticating() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.isAuthenticating() : null;
  }

  /**
   * Returns name of primary authentication service.
   * @returns {String} Name of primary authentication service
   */
  static getServiceName() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getServiceName() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   */
  static async getServiceUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? (await primaryProvider.getServiceUri()) : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   * @deprecated
   */
  static getProviderUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getProviderUri() : null;
  }

  /**
   * Returns current session of primary authentication service or null if the user is not logged in.
   * @returns {Session} Current session of primary authentication service or null if the user is not logged in.
   */
  static getCurrentSession() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getCurrentSession() : null;
  }

  /**
   * Restores session of primary authentication service.
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @returns {Promise<Session>} Promise resolved when session restoration ends.
   */
  static async restoreSession(options = {}) {
    if (!this._restoreSessionPromise) {
      this._isRestoringSession = true;
      let restoreSessionInternal = async function () {
        let secondaryProvidersEnabled = Config.getBoolean(SECONDARY_PROVIDERS_ENABLED_CFG);
        if (secondaryProvidersEnabled == null) {
          secondaryProvidersEnabled = false;
        }
        if (!secondaryProvidersEnabled || Object.keys(this._providers).length === 1) {
          try {
            return await this._providers[this._primaryProvider].restoreSession(options);
          } finally {
            this._isRestoringSession = false; 
          }
        } else {
          this._logger.debug("Trying to restore session for any available authentication service.");
          let sortedProviders = [];
          sortedProviders.push(this._providers[this._primaryProvider]);
          for (let provider of Object.values(this._providers)) {
            if (provider.getServiceName() !== this._primaryProvider) {
              sortedProviders.push(provider);
            }
          }
          let authenticationErrors = [];
          let session = null;
          let origPrimaryProvider = this._primaryProvider;
          for (let provider of sortedProviders) {
            this._primaryProvider = provider.getServiceName();
            try {
              session = await provider.restoreSession(options);
              if (session.getIdentity()) {
                this._logger.debug(`Setting ${provider.getServiceName()} as default service.`);
                break;
              }
            } catch (e) {
              authenticationErrors.push([provider.getServiceName(), e]);
            }
            this._primaryProvider = origPrimaryProvider;
          }
          if (!session.getIdentity()) {
            this._logger.debug(`No existing session found, keeping ${this._primaryProvider} as default service.`);
            if (authenticationErrors.length > 0) {
              // Log authentication errors
              for (let [serviceName, error] of authenticationErrors) {
                this._logger.error(`Authentication with ${serviceName} failed.`, error);
              }
              // "Throw" last of errors
              this._isRestoringSession = false;
              throw authenticationErrors.pop()[1];
            } else {
              this._isRestoringSession = false;
              return session;
            }
          } else {
            this._isRestoringSession = false;
            return session;
          }
        }
      }.bind(this);
      this._restoreSessionPromise = restoreSessionInternal();
    }
    return this._restoreSessionPromise;
  }

  /**
   * Returns whether the session of primary authentication service is in process of being restored.
   * @returns {boolean} Whether the session of primary authentication service is in process of being restored.
   */
  static isRestoringSession() {
    return this._isRestoringSession;
  }

  /**
   * Adds listener for specified event on primary authentication service.
   * Listener is a function accepting an event object, which contains following fields:
   *
   * * **type** The type of the event, e.g. "sessionChanged".
   * * **data** The data passed to the event.
   * @param {string} eventType The event to register listener for.
   * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
   * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
   */
  static addListener(eventType, listenerFn) {
    let removeFnList = [];
    for (let provider of Object.values(this._providers)) {
      removeFnList.push(provider.addListener(eventType, listenerFn));
    }
    return function () {
      for (let removeFn of removeFnList) {
        removeFn();
      }
    };
  }

  /**
   * Removes listener for specified event on primary authentication service.
   * @param {string} eventType The event to remove listener for.
   * @param {function(Event)} listenerFn The listener (function) to unregister.
   * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
   */
  static removeListener(eventType, listenerFn) {
    for (let provider of Object.values(this._providers)) {
      provider.removeListener(eventType, listenerFn)
    }
  }

  /**
   * Returns whether the user (global) session of primary authentication service is expiring.
   * @returns {boolean} Whether the user (global) session of primary authentication service is expiring.
   */
  static isSessionExpiring() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.isSessionExpiring() : null;
  }

  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  constructor(name, opts = {}) {
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    // Allow configuration via legacy parameters but do not allow creation
    // without any options (only using defaults).
    this._serviceUri = opts.serviceUri || opts.uu_oidc_server_uri;
    if (!this._serviceUri && opts.uu_oidc_server_tenant_id) {
      let tenant = opts.uu_oidc_server_tenant_id;
      this._serviceUri = `https://oidc.plus4u.net/uu-oidcg01-main/${tenant}`;
    }
    if (!this._serviceUri) {
      throw new BaseError(`There is no service URI defined for service ${this._serviceName}`);
    }
    this._oauthClient = new OAuthClient(this._serviceUri, opts);
    this._emptySession = BrowserSession.from(Session._createEmptySession(), undefined, undefined, undefined, undefined, this);
    this._currentSession = this._emptySession;
    this._runningAuthnPromise = null;
    this._restoreSessionPromise = null;
    this._isRestoringSession = false;
    this._listeners = [];
    this._globalSessionExpiring = false;
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false) || "low standard high veryHigh";
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._defaultScopeMode = Config.getString(CONFIG_PREFIX + this._serviceName + "_default_call_token_scope_mode") || DEFAULT_SCOPE_MODE;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");

    let redirectUri = Config.getString(CONFIG_REDIRECT_URI_KEY);
    if (!redirectUri) {
      let legacyRedirectUri = Config.getString("uuoidc.redirectUri");
      if (!legacyRedirectUri && !Config.getBoolean("uu_app_oidc_backend_available")) legacyRedirectUri = "callbacks/oidc-callback.html";
      if (legacyRedirectUri) {
        // relative to assets base
        redirectUri = this._toFullUrl(legacyRedirectUri);
      } else {
        // relative to app base
        redirectUri = this._toFullAppUrl("/oidc/callback");
      }
    } else {
      redirectUri = this._toFullAppUrl(redirectUri);
    }
    this._redirectUri = redirectUri;

    this._authnFlow = null;
    this._loadAuthnFlowPromise = this._loadAuthnFlow();

    this._autoLogoutSupportInitialized = false;
    this._autoTokenRefreshInitialized = false;
    this._sessionExtendedAndExpiringSupportInitialized = false;
    this._sessionStateChangeNotifierInitialized = false;
  }

  /**
   * Returns name of authentication service
   * @returns {String} Name of authentication service
   */
  getServiceName() {
    return this._serviceName;
  }

  /**
   * Returns URI of authentication service
   * @returns {String} URI of authentication service
   */
  async getServiceUri() {
    return await this._oauthClient.getIssuer();
  }

  /**
   * Returns URI of authentication service.
   * @returns {String|Uri|*} URI of authentication service
   * @deprecated
   */
  getProviderUri() {
    return this._serviceUri;
  }

  /**
   * Returns current session or null if the user is not logged in.
   * @returns {Session} Current session or null if the user is not logged in.
   */
  getCurrentSession() {
    return this._currentSession;
  }

  /**
   * Restores session, i.e. checks whether to user is logged in on remote server
   * and initializes session if (s)he is.
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @returns {Promise<Session>} Promise resolved when session restoration ends. In case of failure
   *   the promise is still resolved successfully but with null.
   */
  async restoreSession(options = {}) {
    // NOTE All invocations return the same promise, i.e. this method restores session single time only.
    if (!this._restoreSessionPromise) {
      this._isRestoringSession = true;
      this._logger.debug(`Trying to restore session for ${this.getServiceName()}.`);
      let {acrValues, maxAge, callToken} = options || {};
      let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      let session = BrowserSession.loadFromCache(this, clientCredentials.client_id);
      let restoreSessionFn;
      let restoreSessionArgs;
      if (session && session.matches(acrValues || this._defaultAcrValues, maxAge || this._defaultMaxAge)) {
        this._logger.debug(`Session for ${this.getServiceName()} loaded from cache.`);
        restoreSessionFn = this._authenticateBySession.bind(this);
        restoreSessionArgs = session;
      } else if (callToken) {
        this._logger.warn(`Trying to initialize session by access_token for ${this.getServiceName()}. This method is deprecated and is going to be removed!`);
        restoreSessionFn = this._authenticateByCallToken.bind(this);
        restoreSessionArgs = callToken;
      } else {
        restoreSessionFn = this.authenticate.bind(this);
        restoreSessionArgs = {prompt: "none", acrValues, maxAge};
      }
      this._restoreSessionPromise = restoreSessionFn(restoreSessionArgs).then(
          r => {
            this._logger.debug(`Session for ${this.getServiceName()} restored.`);
            this._isRestoringSession = false;
            return r;
          },
          e => {
            if (e && ((e.code && e.code.match(/(interaction|login|account_selection|consent)_required/i)) || (e.message && e.message.match(/interaction required/i)))) {
              this._logger.debug(`Restore of session for ${this.getServiceName()} failed, user interaction is required (${e.code}).`);
            } else {
              this._logger.error(`Restore of session for ${this.getServiceName()} failed.`, e);
            }
            this._isRestoringSession = false;
            return this._currentSession;
          }
      );
    }
    return this._restoreSessionPromise;
  }

  /**
   * Returns whether the session is in process of being restored.
   * @returns {boolean} Whether the session is in process of being restored.
   */
  isRestoringSession() {
    return this._isRestoringSession;
  }

  /**
   * Invokes immediate session check.
   * @returns {null} Result of check is propagated to attached listeners.
   */
  checkSession() {
    if (this._sessionChecker) {
      this._sessionChecker._checkState();
    }
    return null;
  }

  /**
   * Authenticates user (using primary authentication service).
   * @param {Object|null} options Options
   * @param {Object} options.authenticationContext Custom object for persisting application state during authentication process (passed context is returned
   *                   when user is sucessfully authenticated allowing application to continue with its flow which was interrupted by authentication)
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently
   *                   find out authentication state) and "registration" (shows registration page instead of login form).
   * @param {String} options.language What language the login page should use.
   * @param {String} options.os8Token Authenticates the user using uuOS8 token.
   * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
   * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, none]). Applied only if scope is not explicitly set.
   * @param {String} options.loginHint Optional identification of user which we want to authenticate (usable with prompt "login" and "registration")
   * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
   * @returns {Promise<Session>} User session for authenticated user.
   */
  async authenticate(options, scope = null) {
    if (this._runningAuthnPromise && this._equalsArray(this._runningAuthnArgs, Array.prototype.slice.call(arguments))) {
      let { uiComponent } = this._runningAuthnPromise;
      if (uiComponent && typeof uiComponent.focus === "function") uiComponent.focus();
      return this._runningAuthnPromise;
    }

    let flow;
    if (options && options.os8Token) {
      flow = new Os8Flow(this._oauthClient, this._serviceName, this._redirectUri);
    } else {
      if (!this._authnFlow) {
        await this._loadAuthnFlowPromise;
      }
      flow = this._authnFlow;
    }
    let scopeMode = options && options.scopeMode ? options.scopeMode : this._defaultScopeMode;
    if ((!scope || scope.length == 0) && scopeMode !== "none") {
      scope = CANONICAL_APP_BASE_URI || APP_BASE_URI;
      scope = scope.replace(/\/$/, "");
    }
    try {
      this._runningAuthnArgs = Array.prototype.slice.call(arguments);
      this._runningAuthnPromise = flow.authenticate(options, scope);

      let result = await this._runningAuthnPromise;
      let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
      let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
      session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
      session._authConstraints = {
        scope: result.scope,
        acrValues: result.acrValues,
        maxAge: result.maxAge
      };
      this._currentSession = session;
      this._initHandlers();
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
        session.storeToCache(result.clientId);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }

  /**
   * Returns whether an authentication is in progress.
   * @returns {boolean} Whether an authentication is in progress.
   */
  isAuthenticating() {
    return !!this._runningAuthnPromise;
  }

  /**
   * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
   *
   * * **type** The type of the event, e.g. "sessionChanged".
   * * **data** The data passed to the event.
   * @param {string} eventType The event to register listener for.
   * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
   * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
   */
  addListener(eventType, listenerFn) {
    let list = this._listeners[eventType];
    if (!list) list = this._listeners[eventType] = [];
    list.push(listenerFn);
    return this.removeListener.bind(this, eventType, listenerFn);
  }

  /**
   * Removes listener for specified event.
   * @param {string} eventType The event to remove listener for.
   * @param {function(Event)} listenerFn The listener (function) to unregister.
   * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
   */
  removeListener(eventType, listenerFn) {
    let list = this._listeners[eventType];
    if (!list) return false;
    let idx = list.indexOf(listenerFn);
    if (idx != -1) list.splice(idx, 1);
    return idx != -1;
  }

  /**
   * Returns whether the user (global) session is expiring.
   * @returns {boolean} Whether the user (global) session is expiring.
   */
  isSessionExpiring() {
    return this._globalSessionExpiring;
  }

  // ======================== Private methods ================================

  async _loadAsyncData() {
    await this._oauthClient.getMetadata();
    await ClientCredentialsProvider.getClientCredentials(this._serviceName);
  }

  async _loadAuthnFlow() {
    let authnFlowOverride = Config.get(CONFIG_AUTHN_FLOW_OVERRIDE);
    if (authnFlowOverride) {
      if (typeof authnFlowOverride === "string") {
        try {
          this._authnFlow = await SystemJS.import(authnFlowOverride);
        } catch (e) {
          throw new BaseError("Unable to load authentication flow override.", e);
        }
      } else if (typeof authnFlowOverride === "object") {
        this._authnFlow = authnFlowOverride;
      } else {
        throw new BaseError(`Authentication flow override '${authnFlowOverride}' is not supported.`);
      }
    } else {
      let authenticationType = Config.getString(CONFIG_PREFIX + this._serviceName + "_authentication_type") || DEFAULT_AUTHN_TYPE;
      if (authenticationType === "implicit") {
        this._authnFlow = new ImplicitFlow(this._oauthClient, this._serviceName, this._redirectUri, APP_BASE_URI);
      } else if (authenticationType === "code") {
        this._authnFlow = new CodeFlow(this._oauthClient, this._serviceName, this._redirectUri, APP_BASE_URI);
      } else {
        throw new BaseError(`Authentication type '${authenticationType}' is not supported.`);
      }
    }
  }

  async _authenticateBySession(session) {
    let mockRunningAuthPromise = async function() {
      // Load data which are normally loaded during authentication
      // (we need to load them so they are available synchronously later)
      await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      await this._oauthClient.getSupportedAcrValues();
      return {
        session,
        authCtx: session.getAuthenticationContext(),
        globalSessionExpiresAt: session.getExpiresAt(),
        globalSessionState: session.getState()
      };
    }.bind(this);
    try {
      this._runningAuthnPromise = mockRunningAuthPromise();
      await this._runningAuthnPromise;
      this._currentSession = session;
      this._initHandlers();
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }

  async _authenticateByCallToken(callToken) {
    let mockRunningAuthPromise = async function() {
      let claims;
      let idToken;
      let accessToken;
      // Parse and validate call token
      if (callToken.match(ID_TOKEN_REGEX)) {
        claims = await this._oauthClient.parseToken(callToken);
        idToken = callToken;
      } else {
        let appClient = new AppClient({baseUri: CANONICAL_APP_BASE_URI || APP_BASE_URI});
        let headers = {authorization: `Bearer ${callToken}`};
        let params = {_: Date.now()}; // cache buster parameter
        claims = (await appClient.get("oidc/introspect", params, {headers})).data;
        accessToken = callToken
      }
      let issuer = await this._oauthClient.getIssuer();
      if (claims.iss !== issuer) {
        throw new InvalidCredentials("Token is not trusted (unknown token issuer).");
      }
      // Load client credentials which are normally loaded during authentication
      // (we need to load them so they are available synchronously later)
      await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
      // Prepare session instance
      let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, claims, idToken, accessToken);
      session = BrowserSession.from(session, null, null, null, null, this);
      // Override session.getCallToken() to return only token it was initialized with
      session.getCallToken = async function(scope = null, opts = {}) {
        let token = this._idToken || this._accessToken;
        if (token) {
          let excludeAuthType = opts ? opts.excludeAuthenticationType : false;
          if (excludeAuthType === true) {
            return token;
          } else {
            return `Bearer ${token}`;
          }
        } else {
          return null;
        }
      }.bind(session);
      // Override session.close() to do not invoke remote logout
      session.close = async function() {
        this.removeFromCache();
        if (this._authenticated && (typeof this._onCloseListener === "function")) {
          this._onCloseListener(this);
        }
        this._authenticated = false;
        this._idToken = null;
        this._accessToken = null;
      }.bind(session);
      return {session};
    }.bind(this);
    try {
      this._runningAuthnPromise = mockRunningAuthPromise();
      let {session} = await this._runningAuthnPromise;
      this._currentSession = session;
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }

  _initHandlers() {
    if (!this._autoLogoutSupportInitialized) {
      this._initAutoLogoutSupport();
      this._autoLogoutSupportInitialized = true;
    }
    if (!this._autoTokenRefreshInitialized) {
      this._initAutoTokenRefresh();
      this._autoTokenRefreshInitialized = true;
    }
    if (!this._sessionExtendedAndExpiringSupportInitialized) {
      this._initSessionExtendedAndExpiringSupport();
      this._sessionExtendedAndExpiringSupportInitialized = true;
    }
    if (!this._sessionStateChangeNotifierInitialized) {
      this._initSessionStateChangeNotifier();
      this._sessionStateChangeNotifierInitialized = true;
    } else if (this._sessionChecker) {
      this._sessionChecker.enable();
    }
  }

  _initAutoLogoutSupport() {
    // auto-logout when server-side session reaches its expiration time (or when token
    // reaches its expiration time in case that server-side session info is not available)
    // triggering registered sessionChanged listeners
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
    // (so that info from new token gets checked again).
    let autoLogoutTimeout;
    this.addListener("sessionChanged", event => {
      if (autoLogoutTimeout) {
        clearTimeout(autoLogoutTimeout);
        autoLogoutTimeout = null;
      }
      if (!this._currentSession || !this._currentSession.isAuthenticated()) return;

      // plan local logout
      let expiresAt = this._currentSession.getExpiresAt() || 1000 * (this._currentSession.getAttribute("exp") || 0);
      if (!expiresAt) return;
      let now = Date.now();
      let delay = Math.max(0, expiresAt - now);
      this._logger.debug(`Planning local auto-logout at ${this._toTimeString(new Date(now + delay))}.`);
      autoLogoutTimeout = setTimeout(() => {
        autoLogoutTimeout = null;
        this._localLogout();
      }, delay);
    });
  }

  _initAutoTokenRefresh() {
    // support for session auto-refresh when its nearing expiration
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
    // (so that token refreshing gets re-planned / cleaned).
    let tokenRefreshEnabled = Config.getBoolean(CONFIG_PREFIX + this._serviceName + "_token_refresh_enabled");
    if (tokenRefreshEnabled == null) tokenRefreshEnabled = Config.getBoolean("uuoidc.tokenRefreshEnabled");
    if (tokenRefreshEnabled == null) tokenRefreshEnabled = true;
    let tokenRefreshLeeway = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_leeway");
    if (tokenRefreshLeeway == null) tokenRefreshLeeway = Config.getNumber("uuoidc.tokenRefreshLeeway");
    if (tokenRefreshLeeway == null) tokenRefreshLeeway = 5 * 60;
    let tokenRefreshFailureRetryInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_failure_retry_interval");
    if (tokenRefreshFailureRetryInterval == null) tokenRefreshFailureRetryInterval = Config.getNumber("uuoidc.tokenRefreshFailureRetryInterval");
    if (tokenRefreshFailureRetryInterval == null || tokenRefreshFailureRetryInterval < 0) tokenRefreshFailureRetryInterval = 30;
    if (tokenRefreshFailureRetryInterval) tokenRefreshFailureRetryInterval = Math.max(5, tokenRefreshFailureRetryInterval);
    this._tokenRefreshFailureRetryInterval = tokenRefreshFailureRetryInterval;

    let sessionRefreshTimeout;
    this.addListener("sessionChanged", e => {
      if (!tokenRefreshEnabled) return;

      if (sessionRefreshTimeout) {
        clearTimeout(sessionRefreshTimeout);
        sessionRefreshTimeout = null;
      }
      let expiresAt = this._currentSession && this._currentSession.isAuthenticated() && this._currentSession.getAttribute("exp") * 1000;
      if (!expiresAt) return;

      // plan token refresh
      let delay;
      let now = Date.now();
      let validity = expiresAt - now;
      if (validity < (tokenRefreshLeeway * 1000)) {
        this._logger.warn(`Received token with unexpectedly short expiration time of ${Math.floor(validity/1000)}s. Either session is ` +
          `nearing expiration, or current configuration of automatic token refresh is not suitable for used oidc provider.`);
        delay = validity - Math.floor(validity / 10); // refresh when expiration time is at 90%
      } else {
        delay = validity - (tokenRefreshLeeway * 1000);
      }
      delay = Math.max(delay, 1000);  // wait at least 1s between 2 token refreshes
      this._logger.debug(`Planning token auto-refresh at ${this._toTimeString(new Date(now + delay))}.`);
      sessionRefreshTimeout = setTimeout(() => {
        sessionRefreshTimeout = null;
        this._silentTokenRefresh();
      }, delay);
    });
  }

  _initSessionExtendedAndExpiringSupport() {
    // support for "session extended" notification
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
    const LEEWAY_MILLIS = 10 * 1000;
    let activeSessionExpiresAtMillis;
    this.addListener("sessionChanged", e => {
      let globalSessionExpiresAt = this._currentSession.getExpiresAt() || 0;
      let wasExtended = activeSessionExpiresAtMillis && globalSessionExpiresAt > activeSessionExpiresAtMillis + LEEWAY_MILLIS;
      activeSessionExpiresAtMillis = globalSessionExpiresAt;
      if (wasExtended) {
        this._globalSessionExpiring = false;
        let expiresAt = activeSessionExpiresAtMillis;
        // we're currently processing "sessionChanged" listeners so let them finish and run "sessionExtended" afterwards
        setTimeout(() => {
          this._triggerEvent("sessionExtended", { expiresAt: expiresAt });
        }, 0);
      }
    });

    // support for "session expiring" notification
    // NOTE Must be after "session extended" functionality (so that unblocking done there
    // gets performed sooner than the code below).
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
    let sessionExpiringNotificationTime = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_expiring_notification_time");
    if (sessionExpiringNotificationTime == null) sessionExpiringNotificationTime = Config.getNumber("uuoidc.sessionExpiringNotificationTime");
    if (sessionExpiringNotificationTime == null) sessionExpiringNotificationTime = 30 * 60;
    let prevUuIdentity = undefined;
    let sessionExpiringTimeout;
    this.addListener("sessionChanged", e => {
      if (sessionExpiringNotificationTime <= 0) return; // disabled

      if (sessionExpiringTimeout) {
        clearTimeout(sessionExpiringTimeout);
        sessionExpiringTimeout = null;
      }
      let newIdentity = this._currentSession && this._currentSession.isAuthenticated() && this._currentSession.getIdentity();
      let newUuIdentity = newIdentity && newIdentity.getUuIdentity();
      if (newUuIdentity != prevUuIdentity) this._globalSessionExpiring = false;
      prevUuIdentity = newUuIdentity;

      let expiresAt = this._currentSession.getExpiresAt();
      if (!expiresAt) return; // not logged in || "session expiring" notification not supported on server
      if (this._globalSessionExpiring) return; // don't trigger "session expiring" multiple times for the same session

      let now = Date.now();
      let delay = Math.max(0, expiresAt - now - sessionExpiringNotificationTime * 1000);
      this._logger.debug(`Planning sessionExpiring notification at ${this._toTimeString(new Date(now + delay))}.`);
      sessionExpiringTimeout = setTimeout(() => {
        sessionExpiringTimeout = null;
        this._globalSessionExpiring = true;
        this._triggerEvent("sessionExpiring", { expiresAt: expiresAt });
      }, delay);
    });
    this.addListener("sessionExpiring", e => {
      let expiresAt = e.data.expiresAt;
      let delay = Math.floor((expiresAt - Date.now()) / 2);
      if (delay > 5000) { // below 5 seconds, it is probably impossible to finish re-authentication (session is practically expired)
        if (sessionExpiringTimeout) {
          clearTimeout(sessionExpiringTimeout);
        }
        sessionExpiringTimeout = setTimeout(() => {
          sessionExpiringTimeout = null;
          this._globalSessionExpiring = true;
          this._triggerEvent("sessionExpiring", {expiresAt: expiresAt});
        }, delay);
      }
    });
  }

  async _initSessionStateChangeNotifier() {
    // add session state checking which, in case that we were logged in and a logout
    // against OIDC is detected (e.g. in another browser tab), will log us out
    let sessionCheckInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_check_interval");
    if (sessionCheckInterval == null) sessionCheckInterval = Config.getNumber("uuoidc.sessionCheckInterval");
    if (sessionCheckInterval == null) sessionCheckInterval = 5;
    if (sessionCheckInterval && (await this._authnFlow.isCheckSessionSupported())) {
      let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      let clientId = clientCredentials.client_id;
      this._sessionChecker = new SessionStateChangeNotifier(this._authnFlow, sessionCheckInterval, clientId, () => this._currentSession.getState());
      this._sessionChecker.onStateChange(() => {
        this._logger.info("Session state change detected.");
        // check login state against OpenID server (basically renew the token,
        // possibly logging out if the current user on OpenID server differs from ours)
        this._silentTokenRefresh(true);
      });
      this._sessionChecker.onStateUnknown(() => {
        this._logger.info("Unexpected session loss detected.");
        this._triggerEvent("sessionLost");
      });
    }
  }

  _triggerEvent(eventType, data) {
    this._logger.debug(`Launching event "${eventType}".`);
    let list = this._listeners[eventType];
    if (list) {
      let e = {
        type: eventType,
        data: data
      };
      list.forEach(it => it.call(this, e));
    }
  }

  _onSessionClose(session) {
    this._localLogout();
  }

  _localLogout() {
    this._logger.debug("Performing local-logout.");
    this._currentSession.removeFromCache();
    if (this._currentSession != this._emptySession) {
      this._currentSession = this._emptySession;
      this._globalSessionExpiring = false;
      this._triggerEvent("sessionChanged", this._currentSession);
    }
    if (this._sessionChecker) {
      this._sessionChecker.disable();
    }
  }

  /**
   * Tries to re-authenticate the user silently:
   * - if we are locally logged out => do nothing
   * - if a user is logged in (on remote) and it's the same user as ours => use the new token
   * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
   * - if a user is not logged in (on remote) => perform local logout
   */
  async _silentTokenRefresh(aSkipIfPlanned) {
    if (aSkipIfPlanned && (this._silentTokenRefreshTimeout || this._silentTokenRefreshInProgress > 0)) return;

    if (this._silentTokenRefreshTimeout) {
      clearTimeout(this._silentTokenRefreshTimeout);
      delete this._silentTokenRefreshTimeout;
    }
    let invocationCount = 0;
    let doSilentRenew = async () => {
      if (!this._currentSession || !this._currentSession.isAuthenticated()) return; // no-op (we're logged out and don't want to silently auto-login)

      this._logger.debug("Silent token refresh - starting.");
      ++this._silentTokenRefreshInProgress;
      ++invocationCount;
      try {
        await this._doAuthenticateRefresh();
        --this._silentTokenRefreshInProgress;
      } catch (e) {
        --this._silentTokenRefreshInProgress;
        if (!this._silentTokenRefreshTimeout && this._tokenRefreshFailureRetryInterval) {
          this._logger.debug(`Silent token refresh - will retry in ${this._tokenRefreshFailureRetryInterval}s (operation ended with unexpected error).`, e);
          this._silentTokenRefreshTimeout = setTimeout(() => {
            delete this._silentTokenRefreshTimeout;
            doSilentRenew();
          }, this._tokenRefreshFailureRetryInterval * 1000);
        } else {
          if (this._silentTokenRefreshTimeout) this._logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", e);
          else this._logger.debug("Silent token refresh - ending with no-op (operation ended with unexpected error).", e);
        }
        if (invocationCount === 1) this._logger.warn("Token refresh failed with error:", e);
        else if (invocationCount === 2) this._logger.error("Suppressing further notifications of token refresh problem to prevent log cluttering (until success or logout).")
      }
    };

    await doSilentRenew();
  }

  _equalsArray(array1, array2) {
    return array1.length === array2.length && array1.every((it, i) => it === array2[i]);
  }

  _toFullAppUrl(path) {
    // relative & absolute paths are relative to app base
    var a = document.createElement("a");
    a.href = path && path.match(/^[a-z]+:/i) ? path : APP_BASE_URI + (path ? path.replace(/^\/+/, "") : "");
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }

  _toFullUrl(path) {
    // relative paths are relative to assets (document.baseURI); absolute paths are absolute against domain
    var a = document.createElement("a");
    a.href = path || "";
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }

  _toTimeString(date) {
    return (
      // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
      ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
    );
  }

  async _doAuthenticateRefresh() {
    try {
      if (!this._authnFlow) {
        await this._loadAuthnFlowPromise;
      };
      let authConstraints = this._currentSession ? this._currentSession._authConstraints : null;
      let scope = authConstraints ? authConstraints.scope : null;
      let acrValues = authConstraints ? authConstraints.acrValues : null;
      let maxAge = authConstraints ? authConstraints.maxAge : null;
      let result = await this._authnFlow.authenticate({ acrValues, maxAge, prompt: "none", usePopup: false }, scope);
      if (!this._currentSession || !this._currentSession.isAuthenticated()) {
        // no-op (we've become logged out and don't want to silently auto-login)
        this._logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
      } else {
        let supportedAcrValues;
        if (this._currentSession && this._currentSession._supportedAcrValues) {
          supportedAcrValues = this._currentSession._supportedAcrValues;
        } else {
          supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        }
        let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
        // if the user is different than the current one then perform logout
        let curSessIdentity = this._currentSession.getIdentity();
        let newSessIdentity = session.getIdentity();
        if (
          (curSessIdentity && newSessIdentity && curSessIdentity.getUuIdentity() !== newSessIdentity.getUuIdentity()) ||
          ((!curSessIdentity || !newSessIdentity) && curSessIdentity != newSessIdentity)
        ) {
          this._logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
          this._localLogout();
        } else {
          // everything is fine - use new session
          this._logger.debug("Silent token refresh - ending with token renewed.");
          session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
          session._authConstraints = authConstraints;
          this._currentSession = session;
          if (session) {
            session._onCloseListener = this._onSessionClose.bind(this);
            session.storeToCache(result.clientId);
          }
          this._triggerEvent("sessionChanged", session);
        }
      }
    } catch (e) {
      if (e && ((e.code && e.code.match(/(interaction|login|account_selection|consent)_required/i)) || (e.message && e.message.match(/interaction required/i)))) {
        this._logger.debug(`Silent token refresh ending with local logout, user interaction is required (${e.code}).`);
      } else {
        this._logger.error("Silent token refresh failed, ending with local logout.", e);
      }
      this._localLogout();
      return;
    }
  }
}

AuthenticationService._providers = {};
AuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
AuthenticationService.load(false);

module.exports = AuthenticationService;
