const CallbackHandler = require("./callback-handler.js");

const DEFAULT_POPUP_WIDTH = 599;
const DEFAULT_POPUP_HEIGHT = 600;

/**
 * Default visual component for presenting login/logout prompt to the user. It displays the
 * URL in a popup window and waits until the user logs in / closes the window. After that
 * initAttrs.onResult(authResultUrl) is called as callback.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
 *   contains the authentication response in fragment).
 */
const PopupComponent = function (initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    loginWindow: null,
    closeCheckInterval: null
  };

  // add self to the list of opened loginWindows
  CallbackHandler.registerForCallback(this, state);

  this.finalize = function (result) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(result);
  }.bind(this);

  var closeCheck = function () {
    if (!state.loginWindow || !state.loginWindow.closed) return;
    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
  }.bind(this);

  this.render = function () {
    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
    if (!state.loginWindow) {
      var rect = { width: attrs.width || DEFAULT_POPUP_WIDTH, height: attrs.height || DEFAULT_POPUP_HEIGHT };
      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);
      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);
      state.loginWindow = window.open(attrs.url, "_blank", `toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=${rect.width},height=${rect.height},top=${rect.top},left=${rect.left}`);
      if (!state.loginWindow) { // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
        Promise.resolve().then(() => this.finalize(PopupComponent.ERROR_POPUP_BLOCKED)); // finalize in async way
      } else {
        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
      }
    }
  };

  this.focus = function () {
    if (state.loginWindow) state.loginWindow.focus();
  };

  this.destroy = function () {
    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
    this.destroy = function () {};
    CallbackHandler.unregisterForCallback(this);
  };
};

PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";

module.exports = PopupComponent;
