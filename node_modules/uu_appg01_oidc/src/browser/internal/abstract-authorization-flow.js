"use strict";

const Dom = require("../ui/dom.js");
const PopupComponent = require("../ui/popup-component.js");
const IframeComponent = require("../ui/iframe-component.js");
const MainWindowComponent = require("../ui/main-window-component.js");
const SyncCallNotPossible = require("../../internal/sync-call-not-possible.js");
const ClientCredentialsProvider = require("./client-credentials-provider.js");
const { AuthenticationError } = require("uu_appg01_core-authentication");
const { Config, BaseError } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const Base64 = require("../../internal/base64.js");

const CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
const CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const LOGIN_POPUP_ENABLED_CONFIG = "_login_popup_enabled";
const LOGIN_POPUP_WIDTH_CONFIG = "_login_popup_width";
const LOGIN_POPUP_HEIGHT_CONFIG = "_login_popup_height";
const CONFIG_POST_LOGOUT_REDIRECT_URI_KEY = "uu_app_oidc_post_logout_redirect_uri";
const LOGOUT_TYPE_CONFIG = "_logout_type";
const LOGOUT_POPUP_WIDTH_CONFIG = "_logout_popup_width";
const LOGOUT_POPUP_HEIGHT_CONFIG = "_logout_popup_height";
const DEFAULT_SCOPE_MODE = "allUseCases";
const DEFAULT_POPUP_WIDTH = 655;
const DEFAULT_POPUP_HEIGHT = 875;
const LOGIN_POPUP_DEFAULTS = {
  enabled: {
    oidcg01: true,
    oidcg02: true
  },
  width: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  height: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};
const LOGOUT_DEFAULTS = {
  type: {
    oidcg01: "iframe",
    oidcg02: "iframe"
  },
  popupWidth: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  popupHeight: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};

const BASE_ELEMENT = document.querySelector("base");
const APP_BASE_URI = location.protocol + "//" + location.host + ((BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "") || "/");

class AbstractAuthorizationFlow {

  constructor(oauthClient, serviceName, defaultRedirectUri) {
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._defaultRedirectUri = defaultRedirectUri;
    let popupEnabled = Config.getBoolean(CONFIG_PREFIX + serviceName + LOGIN_POPUP_ENABLED_CONFIG);
    if (popupEnabled == null) {
      popupEnabled = LOGIN_POPUP_DEFAULTS.enabled[serviceName];
      this._popupEnabled = (popupEnabled == null) ? true : popupEnabled;
    } else {
      this._popupEnabled = popupEnabled;
    }
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false);
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._logger = LoggerFactory.get("uuapp.oidc.internal." + serviceName + "." + this.constructor.name);
    this._checkSessionIframe = null;
    this._loadCheckSessionIframePromise = null;
    this._runningCheckSessionPromise = null;
    this._runningCheckSessionResolve = null;
  }

  getAuthResponseFromCallback(loginCallbackResult) {
    throw new Error("AbstractFlow.getAuthResponseFromCallback must be implemented on child class.");
  }

  createAuthState(authCtx = null, usePopup = null) {
    let state = {
      r: Math.random().toString(32).substr(2),
      // Remember URI of UVE we are leaving (needed in case callback is done in main window - we have to redirect)
      appUri: location.pathname + location.search + (location.hash.length > 1 ? location.hash : ""),
      authCtx,
      usePopup
    };
    return state;
  }

  authenticate(options, responseType, scope = null) {
    let uiComponent;
    let resultPromise = new Promise(async (resolve, reject) => {
      try {
        let { acrValues, maxAge, prompt, language, usePopup, authenticationContext, loginHint} = options || {};

        if (acrValues == null) acrValues = this._defaultAcrValues;
        if (maxAge == null) maxAge = this._defaultMaxAge;
        if (usePopup == null) usePopup = true; // use login popup by default...
        usePopup = usePopup && this._popupEnabled; // ...unless globally disabled

        // NOTE Using synchronous variant (when prompt != "none") because typically this call is made after
        // clicking a button and we're going to show a popup window. Browsers will block the popup window unless
        // we open it within click event's lifetime or within single Promise (but not Promise chain because
        // that doesn't work on iPhones / Chrome). The sync variant works only if there already has been
        // async variant call, but that's sufficient for us, because we perform session initialization
        // with prompt == "none" (async) during this library's initialization.
        let authUri;
        let clientCredentials;
        if (prompt === "none") {
          clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          authUri = await this._oauthClient.getAuthorizationUri(responseType, this._defaultRedirectUri, clientCredentials, acrValues, scope);
        } else {
          try {
            clientCredentials = ClientCredentialsProvider.getClientCredentialsSync(this._serviceName);
          } catch (e) {
            if (e instanceof SyncCallNotPossible) {
              this._logger.debug("Trying to reload client credentials on background.");
              ClientCredentialsProvider.getClientCredentials(this._serviceName);
            }
            throw new BaseError(`Unable to get client credentials for service ${this._serviceName}: ${e.message}`, e);
          }
          try {
            authUri = this._oauthClient.getAuthorizationUriSync(responseType, this._defaultRedirectUri, clientCredentials, acrValues, scope);
          } catch (e) {
            if (e instanceof SyncCallNotPossible) {
              this._logger.debug("Trying to reload service metadata on background.");
              this._oauthClient.getMetadata();
            }
            throw new BaseError(`Unable to get metadata of service ${this._serviceName}: ${e.message}`, e);
          }
        }

        let nonce = Math.random().toString(32).substr(2);
        let state = Base64.urlSafeEncode(JSON.stringify(this.createAuthState(authenticationContext, usePopup)));
        let authFinalUri = this._addUriParams(authUri, {
          max_age: maxAge,
          login_hint: loginHint,
          prompt,
          state,
          nonce,
          language
        });
        let LoginVisualComponent = prompt !== "none" ? (usePopup ? PopupComponent : MainWindowComponent) : IframeComponent;

        this._logger.debug(`Invoking authorization request: ${authFinalUri}`);
        let requestPromise = this.sendRequest(authFinalUri, LoginVisualComponent);
        if (resultPromise) resultPromise.uiComponent = requestPromise.uiComponent;
        else uiComponent = requestPromise.uiComponent;
        let authResponse = await requestPromise;
        let clientId = clientCredentials.client_id;
        resolve({ authResponse, state, nonce, scope, acrValues, maxAge, clientId });
      } catch (e) {
        reject(e);
      }
    });
    if (uiComponent) resultPromise.uiComponent = uiComponent;
    return resultPromise;
  }

  async isCheckSessionSupported() {
    if (this._loadCheckSessionIframePromise == null) {
      this._loadCheckSessionIframePromise = this._loadCheckSessionIframe();
    }
    await this._loadCheckSessionIframePromise;
    return !!this._checkSessionIframe;
  }

  checkSession(query) {
    if (this._runningCheckSessionPromise) {
      return this._runningCheckSessionPromise;
    } else {
      let resultResolve = null;
      let resultPromise = new Promise(async (resolve, reject) => {
        resultResolve = resolve;
        if (!(await this.isCheckSessionSupported())) {
          this._runningCheckSessionResolve = null;
          this._runningCheckSessionPromise = null;
          return reject(new BaseError("Check session is not supported."));
        }
        this._logger.debug(`Querying session state change from check session iframe. Query: ${query}`);
        this._checkSessionIframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);
      });
      this._runningCheckSessionResolve = resultResolve;
      this._runningCheckSessionPromise = resultPromise;
      return resultPromise;
    }
  }

  getEndSessionUri() {
    throw new Error("AbstractFlow.getEndSessionUri must be implemented on child class.");
  }

  endSession(session) {
    let resultPromise = new Promise(async (resolve, reject) => {
      let endSessionUri = this.getEndSessionUri();
      let idTokenHint = null;
      let useIdTokenHint = Config.getBoolean(CONFIG_PREFIX + session.getServiceName() + "_logout_token_hint_enabled");
      useIdTokenHint = useIdTokenHint != null ? useIdTokenHint : true;
      if (useIdTokenHint) {
        let cfgKey = `${CONFIG_PREFIX}${session.getServiceName()}_default_call_token_scope_mode`;
        let scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE;
        if (scopeMode === "none") {
          idTokenHint = session._idToken;
        } else {
          try {
            this._logger.debug("Obtaining token to be used as id_token_hint for end session request.");
            let opts = {callTokenType: "idToken", excludeAuthenticationType: true};
            idTokenHint = await session.getCallToken(endSessionUri, opts);
          } catch (e) {
            this._logger.warn("Unable to provide id_token_hint for end session request, using standard token.", e);
            idTokenHint = session._idToken;
          }
        }
      }
      if (idTokenHint) {
        endSessionUri += "?id_token_hint=" + encodeURIComponent(idTokenHint);
        // Parameter "post_logout_redirect_uri" can be sent only if token hint is given.
        // (without token hint, redirect uri cannot be verified)
        let postLogoutRedirectUri = Config.getString(CONFIG_POST_LOGOUT_REDIRECT_URI_KEY);
        if (postLogoutRedirectUri) {
          postLogoutRedirectUri = this._toFullAppUrl(postLogoutRedirectUri);
        } else {
          postLogoutRedirectUri = this._defaultRedirectUri;
        }
        endSessionUri += "&post_logout_redirect_uri=" + encodeURIComponent(postLogoutRedirectUri);
      }
      let logoutType = Config.getString(CONFIG_PREFIX + this._serviceName + LOGOUT_TYPE_CONFIG) || LOGOUT_DEFAULTS.type[this._serviceName];
      let width = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGOUT_POPUP_WIDTH_CONFIG) || LOGOUT_DEFAULTS.popupWidth[this._serviceName] || DEFAULT_POPUP_WIDTH;
      let height = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGOUT_POPUP_HEIGHT_CONFIG) || LOGOUT_DEFAULTS.popupHeight[this._serviceName] || DEFAULT_POPUP_HEIGHT;
      let LogoutVisualComponent = logoutType === "main" ? MainWindowComponent : logoutType === "popup" ? PopupComponent : IframeComponent;
      this._logger.debug(`Invoking end session request: ${endSessionUri}`);
      new LogoutVisualComponent({
        width: width,
        height: height,
        url: endSessionUri,
        onResult: result => {
          if (result instanceof Error) {
            reject(result);
          } else {
            resolve();
          }
        }
      }).render();
    });
    return resultPromise;
  }

  sendRequest(uri, LoginVisualComponent = IframeComponent, getAuthResponseFromCallback = this.getAuthResponseFromCallback.bind(this)) {
    let uiComponent;
    let result = new Promise((resolve, reject) => {
      let width = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGIN_POPUP_WIDTH_CONFIG) || LOGIN_POPUP_DEFAULTS.width[this._serviceName] || DEFAULT_POPUP_WIDTH;
      let height = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGIN_POPUP_HEIGHT_CONFIG) || LOGIN_POPUP_DEFAULTS.height[this._serviceName] || DEFAULT_POPUP_HEIGHT;
      uiComponent = new LoginVisualComponent({
        width: width,
        height: height,
        url: uri,
        onResult: aLoginResult => {
          if (aLoginResult instanceof Error) return reject(aLoginResult);
          if (aLoginResult === false) return reject(new AuthenticationError("User refused to log in."));
          if (aLoginResult === PopupComponent.ERROR_POPUP_BLOCKED) return reject(new AuthenticationError("Login failed due to popup blocking."));

          let authResponse = getAuthResponseFromCallback(aLoginResult);

          // resolve the promise successfully with the token (iff there's no "error" field)
          if (authResponse.error) {
            let { error, error_description, uu_oidc_error_id, uu_oidc_error_code, ...rest } = authResponse;
            let authnError = new AuthenticationError(error_description || "Authentication error: " + error);
            if (uu_oidc_error_id) authnError.id = uu_oidc_error_id;
            authnError.code = uu_oidc_error_code || error;
            Object.assign(authnError, rest);
            reject(authnError);
          } else {
            resolve(authResponse);
          }
        }
      });
      uiComponent.render();
    });
    result.uiComponent = uiComponent;
    return result;
  }

  async _loadCheckSessionIframe() {
    // add iframe with check_session_iframe URL
    return new Promise(async resolve => {
      await Dom.domReady;
      let iframeUrl = await this._oauthClient.getCheckSessionIframeUri();
      if (!iframeUrl) {
        this._logger.warn(`The OpenID Connect server ${this._oauthClient.getServiceUri()} doesn't support check_session_iframe endpoint.`);
        resolve();
      } else {
        this._logger.debug(`Creating iframe with check_session_iframe endpoint URL: ${iframeUrl}`);
        let iframe = document.createElement("iframe");
        iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
        iframe.tabIndex = "-1";
        iframe.onload = () => {
          this._iframeTrustedOrigin = iframeUrl.match(/^(https?:\/\/[^\/]+).*$/)[1] || null;
          this._checkSessionIframe = iframe;
          // add message handler for processing messages from the iframe
          window.addEventListener("message", this._onMessage.bind(this));
          resolve();
        };
        iframe.src = iframeUrl;
        document.body.appendChild(iframe);
      }
    });
  }

  _onMessage(message) {
    this._logger.debug(`Received message from ${message.origin}: ${message.data}`);
    if (!this._checkSessionIframe || message.source !== this._checkSessionIframe.contentWindow || message.origin !== this._iframeTrustedOrigin) {
      this._logger.debug(`Message "${message.data}" from ${message.origin} is not from check session iframe, ignoring.`);
    } else {
      this._logger.debug(`Propagating session state "${message.data}" to listeners.`);
      if (this._runningCheckSessionResolve) {
        this._runningCheckSessionResolve(message.data);
      }
      this._runningCheckSessionResolve = null;
      this._runningCheckSessionPromise = null;
    }
  }

  _toFullAppUrl(path) {
    // relative & absolute paths are relative to app base
    var a = document.createElement("a");
    a.href = path && path.match(/^[a-z]+:/i) ? path : APP_BASE_URI + (path ? path.replace(/^\/+/, "") : "");
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }

  _addUriParams(uri, params) {
    let paramParts = [];
    for (let k in params) {
      let v = params[k];
      if (v == null) continue;
      paramParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
    }
    return uri + "&" + paramParts.join("&");
  }

}

module.exports = AbstractAuthorizationFlow;
