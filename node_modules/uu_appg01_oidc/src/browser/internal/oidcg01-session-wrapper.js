// TODO Remove when compatibility with uu_oidcg01 is no longer needed.

class SessionWrapper {
  /**
   * Modifies Session class (API) to be compatible with uu_oidcg01's Session.
   * @param {*} session
   */
  static wrapClass(Session, AuthenticationService) {
    let oidcg01Session;

    Object.defineProperty(Session, "currentSession", {
      get() {
        if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
        return oidcg01Session;
      }
    });
    Object.defineProperty(Session, "initComplete", {
      get() {
        return AuthenticationService._onPageLoadFinished;
      }
    });
    Object.defineProperty(Session, "initPromise", {
      get() {
        return AuthenticationService._onPageLoad().then(session => {
          if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
          return oidcg01Session;
        });
      }
    });

    return Session;
  }

  static initG01Session(Session, AuthenticationService) {
    let session = Session._createEmptySession(); // in case user of legacy API uses "obj instanceof Session" expression

    Object.defineProperty(session, "initComplete", {
      get() {
        return AuthenticationService._onPageLoadFinished;
      }
    });
    Object.defineProperty(session, "initPromise", {
      get() {
        return AuthenticationService._onPageLoad().then(() => session);
      }
    });

    // NOTE In optimal case this wrapper would always use AuthenticationService.getCurrentSession().
    // However that's not possible if we're finishing session restore because the "sessionChanged" event
    // is triggerred sooner than AuthnService._primaryProvider gets updated. So if an app uses
    // e.g. getIdentity() inside of the sessionChanged event handler, we would forward it to AS.getCurrentSession()
    // which would return empty session / session from not-yet-updated _primaryProvider.
    // => during events use the g02 session instance which was sent to the event, otherwise use getCurrentSession()
    let runningG02Session = null;
    const getG02Session = () => runningG02Session || AuthenticationService.getCurrentSession();

    session.getIdentity = function() {
      let g02Session = getG02Session();
      let identity = g02Session.getIdentity();
      if (!identity) return identity;
      identity.id = g02Session.getAttribute("sub");
      identity.name = identity.getName();
      identity.email = g02Session.getAttribute("email");
      identity.uuIdentity = identity.getUuIdentity();
      identity.levelOfAssurance = identity.getLevelOfAssurance();
      identity.loginLevelOfAssurance = g02Session.getAuthenticationLevelOfAssurance();
      return identity;
    };

    session.getClaims = function() {
      return getG02Session()._attributes;
    };

    session.getCallToken = function(scope = null, opts = {}) {
      if (typeof scope === "string" || Array.isArray(scope)) {
        return getG02Session().getCallToken(scope, opts);
      } else {
        // If scope was not defined, return legacy value
        let session = getG02Session();
        return {
          token: session._idToken || session._accessToken,
          tokenType: session._idToken ? "Bearer" : null
        };
      }
    };

    session.isExpiring = function() {
      return AuthenticationService.isSessionExpiring();
    };

    session.isAuthenticated = function() {
      return getG02Session().isAuthenticated();
    };

    session.login = function(options) {
      let opts = { ...options };
      let authnSvcOpts = {};
      if (opts.access_token && opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
        authnSvcOpts = { os8Token: opts.access_token };
        delete opts.access_token;
        delete opts.token_type_hint;
      }
      Object.assign(authnSvcOpts, opts);
      return AuthenticationService.authenticate(authnSvcOpts).then(() => session);
    };

    session.logout = function() {
      return getG02Session().close();
    };

    let _legacyListeners = {};
    session.addListener = function(eventType, listenerFn) {
      if (eventType === "identityChange") eventType = "sessionChanged";
      let unregFn = AuthenticationService.addListener(eventType, ({ type, data }) => {
        let origRunningG02Session = runningG02Session;
        if (data instanceof Session) runningG02Session = data;
        try {
          let g01Type = type;
          let g01Data = data instanceof Session ? session : data;
          if (type === "sessionChanged") {
            g01Type = "identityChange";
            g01Data = session.getIdentity();
          }
          let legacyEvent = { type: g01Type, data: g01Data };
          return listenerFn(legacyEvent);
        } finally {
          runningG02Session = origRunningG02Session;
        }
      });
      let map = _legacyListeners[eventType];
      if (!map) map = _legacyListeners[eventType] = new Map();
      map.set(listenerFn, unregFn);
      return unregFn;
    };

    session.removeListener = function(eventType, listenerFn) {
      if (eventType === "identityChange") eventType = "sessionChanged";
      let map = _legacyListeners[eventType];
      let unregFn = map ? map.get(listenerFn) : null;
      if (!unregFn) return false;
      map.delete(listenerFn);
      return unregFn();
    };

    let _legacyIdentityChangeListeners = new Map();
    session.addIdentityChangeListener = function(listenerFn) {
      let unregFn = session.addListener("identityChange", e => listenerFn(e.data));
      _legacyIdentityChangeListeners.set(listenerFn, unregFn);
      return unregFn;
    };
    session.removeIdentityChangeListener = function(listenerFn) {
      let unregFn = _legacyIdentityChangeListeners.get(listenerFn);
      if (!unregFn) return false;
      _legacyIdentityChangeListeners.delete(listenerFn);
      return unregFn();
    };

    session.getAuthenticationContext = function() {
      return getG02Session().getAuthenticationContext();
    };

    session._unwrap = function() {
      return getG02Session();
    };

    return session;
  }
}

module.exports = SessionWrapper;
