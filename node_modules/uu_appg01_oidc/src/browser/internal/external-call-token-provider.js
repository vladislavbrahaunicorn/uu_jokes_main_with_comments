"use strict";

const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const ImplicitFlow = require("./implicit-flow.js");
const CodeFlow = require("./code-flow.js");

const CONFIG_PREFIX = "uu_app_oidc_providers_";
const CONFIG_REDIRECT_URI_KEY = "uu_app_oidc_redirect_uri";
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;

const BASE_ELEMENT = document.querySelector("base");
const APP_BASE_URI = location.protocol + "//" + location.host + ((BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "") || "/");

/**
 * Component providing tokens for external calls
 * (call to URLs outside of current application scope)
 */
class ExternalCallTokenProvider {
  // TODO Add support for code based flow
  // Now relies only on implicit flow (which is working even if application
  // itself uses code based flow). In order to support code based flow, it
  // will be necessary to:
  // 1) Call auth request with external app client_id and redirect_uri
  // 2) Be able to check authentication result (requires access to iframe
  //    renderend on another address)
  // 3) Logout must trigger logout for all components separately

  /**
   * Returns token to be used by client to call functionality provided by other application server.
   * @param {Session} initSession Instance of current session in which scope we are requesting token.
   * @param {String|URI} callUri URI of called functionality.
   * @param {Object} opts Call token options.
   * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
   * @returns {Promise<String>} Call token
   */
  static async getCallToken(initSession, callUri, opts) {
    let serviceName = initSession.getServiceName();
    if (!serviceName || !initSession._oauthClient) {
      return null;
    }
    callUri = callUri ? callUri.toString() : "";
    let providerKey = `${serviceName}|${callUri}`;
    let provider = this._providers[providerKey];
    if (!provider) {
      provider = new this(initSession, callUri);
      this._providers[providerKey] = provider;
    }
    return provider._getCallToken(opts);
  }

  /**
   * Creates new external call token provider.
   * @param {Session} initSession Instance of current session in which scope we are requesting token.
   * @param {String} callUri Call URI for which to provide token
   */
  constructor(initSession, callUri) {
    this._serviceName = initSession.getServiceName();
    this._callUri = callUri;
    let redirectUri = Config.getString(CONFIG_REDIRECT_URI_KEY);
    if (!redirectUri) {
      let legacyRedirectUri = Config.getString("uuoidc.redirectUri");
      if (!legacyRedirectUri && !Config.getBoolean("uu_app_oidc_backend_available")) legacyRedirectUri = "callbacks/oidc-callback.html";
      if (legacyRedirectUri) redirectUri = this._toFullUrl(legacyRedirectUri); // relative to assets base
      else redirectUri = this._toFullAppUrl("/oidc/callback"); // relative to app base
    } else {
      redirectUri = this._toFullAppUrl(redirectUri);
    }
    this._configPrefix = `${CONFIG_PREFIX}${this._serviceName}_`;
    this._tokenTimeLeeway = Config.getNumber(`${this._configPrefix}token_time_leeway`, false) || DEFAULT_TOKEN_TIME_LEEWAY;
    this._logger = LoggerFactory.get("uuapp.oidc.ExternalCallTokenProvider");
    // Primarily use flow from Authentication Service
    this._authnFlow = initSession._authnService._authnFlow;
    if (this._authnFlow instanceof CodeFlow) {
      // In case primary flow is code based flow, we have to replace it with implicit
      // (else we will be not able to receive tokens for external calls)
      this._authnFlow = new ImplicitFlow(initSession._oauthClient, this._serviceName, redirectUri, APP_BASE_URI);
    }
    this._runningPromise = null;
    this._idToken = null;
    this._accessToken = null;
    this._expireAt = null;

    initSession._authnService.addListener("sessionChanged", () => {
      this._refreshCallToken();
    });
  }

  async _getCallToken(opts = {}) {
    if (this._isExpired()) {
      if (!this._runningPromise) {
        this._logger.debug(`Requesting new call token for ${this._callUri}`);
        let authOpts = {prompt: "none", usePopup: false};
        this._runningPromise = this._authnFlow.authenticate(authOpts, this._callUri);
      }
      try {
        let {idToken, accessToken, claims} = await this._runningPromise;
        this._idToken = idToken;
        this._accessToken = accessToken;
        this._expireAt = claims.exp * 1000;
        this._logger.debug(`Call token for ${this._callUri} received`);
      } catch (e) {
        this._logger.error(`Unable to get call token for ${this._callUri}`, e);
        return null;
      } finally {
        this._runningPromise = null;
      }
    }
    let token = null;
    let callTokenType = opts ? opts.callTokenType : null;
    if (!callTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      callTokenType = Config.getString(cfgKey);
    }
    if (callTokenType === "idToken") {
      token = this._idToken;
    } else if (callTokenType === "accessToken") {
      token = this._accessToken;
    } else if (!callTokenType) {
      token = this._idToken || this._accessToken;
    }
    return token;
  }

  async _refreshCallToken() {
    if (!this._runningPromise) {
      // Drop old data (user might be switched)
      this._idToken = null;
      this._accessToken = null;
      this._expireAt = null;
      this._logger.debug(`Refreshing call token for ${this._callUri} invoked by session change`);
      let authOpts = {prompt: "none", usePopup: false};
      this._runningPromise = this._authnFlow.authenticate(authOpts, this._callUri);
    }
    try {
      let {idToken, accessToken, claims} = await this._runningPromise;
      this._idToken = idToken;
      this._accessToken = accessToken;
      this._expireAt = claims.exp * 1000;
      this._logger.debug(`Call token for ${this._callUri} refreshed`);
    } catch (e) {
      if (e && ((e.code && e.code.match(/(interaction|login|account_selection|consent)_required/i)) || (e.message && e.message.match(/interaction required/i)))) {
        this._logger.debug(`Refresh of call token for ${this._callUri} failed, due to user interaction is required (${e.code}).`)
      } else {
        this._logger.error(`Unable to refresh call token for ${this._callUri}`, e);
      }
      this._idToken = null;
      this._accessToken = null;
      this._expireAt = null;
    } finally {
      this._runningPromise = null;
    }
  }

  _isExpired() {
    if (!this._expireAt) {
      return true;
    }
    return Date.now() >= (this._expireAt - this._tokenTimeLeeway * 2);
  }

  _toFullAppUrl(path) {
    // relative & absolute paths are relative to app base
    let a = document.createElement("a");
    a.href = path && path.match(/^[a-z]+:/i) ? path : APP_BASE_URI + (path ? path.replace(/^\/+/, "") : "");
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }

  _toFullUrl(path) {
    // relative paths are relative to assets (document.baseURI); absolute paths are absolute against domain
    var a = document.createElement("a");
    a.href = path || "";
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }

}

ExternalCallTokenProvider._providers = {};

module.exports = ExternalCallTokenProvider;
