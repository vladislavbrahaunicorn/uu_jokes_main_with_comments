"use strict";

const Os = require("os");
const Fs = require("fs");
const Util = require("util");
const fsReadFile = Util.promisify(Fs.readFile);
const fsExists = Util.promisify(Fs.exists);
const Path = require("path");
const {BaseError} = require("uu_appg01_core-utils");
const CoreAuthenticationService = require("uu_appg01_core-authentication").AuthenticationService;
const {InvalidCredentials, AuthenticationError} = require("uu_appg01_core-authentication");
const {LoggerFactory, LoggerMDC} = require("uu_appg01_core-logging");
const DefaultServiceLoader = require("./internal/default-service-loader.js");
const OAuthClient = require("./internal/oauth-client.js");
const OAuthCode = require("./internal/oauth-code.js");
const ClientCredentialsProvider = require("./internal/client-credentials-provider.js");
const OidcSession = require("./session.js");
const Base64 = require("./internal/base64.js");
const Digest = require("./internal/digest.js");
const {ContextStore} = require("uu_appg01_core-utils");
let UseCaseContext = null;
try {
  UseCaseContext = require("uu_appg01_core-appserver").UseCaseContext;
} catch (e) {
  UseCaseContext = null;
}

const DEFAULT_ACCESS_TOKEN_PATTERN = ".*";
const DEFAULT_REFRESH_TOKEN_PATTERN = ".*";
const DEFAULT_VERIFY_AUDIENCE = false;
const UU_CLOUD_ENV_VARIABLE = "UU_CLOUD_HOST_NAME";

const DEFAULT_LEGACY_SERVICE_NAME = "uu_oidcg01_main";
const DEFAULT_SERVICE_NAME = "oidcg01";
const META_SERVICE_NAME = "uu_appg01_oidc";

const OAUTH_CODE = "code";
const OAUTH_REDIRECT_URI = "redirect_uri";
const ID_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

/**
 * Implementation of authentication service based on uuOIDC.
 */
class OidcAuthenticationService {

  /**
   * Load and initialize authentication service(s)
   * @param reconfigure
   */
  static load(reconfigure = false) {
    DefaultServiceLoader.load(OidcAuthenticationService, reconfigure);
  }

  /**
   * Creates new instance of uuOIDC authentication service and registers it
   * as authentication service with given name.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  static create(name, opts = {}) {
    // Do not allow reinitialization of already registered services
    let force = opts.force || false;
    if (!force && this._providers[name]) {
      return;
    }

    let authService = new this(name, opts);
    // Register service in global authentication service component
    if (name === DEFAULT_SERVICE_NAME || name === DEFAULT_LEGACY_SERVICE_NAME) {
      CoreAuthenticationService._register(DEFAULT_SERVICE_NAME, authService);
      CoreAuthenticationService._register(DEFAULT_LEGACY_SERVICE_NAME, authService);
    } else {
      CoreAuthenticationService._register(name, authService);
    }
    // Register oidc meta-service to be able to use multiple oidc providers via generic API
    CoreAuthenticationService._register(META_SERVICE_NAME, this);
    // Store service localy
    // (to be able to choose service based on tokens)
    // In local store, use only new name
    if (name === DEFAULT_LEGACY_SERVICE_NAME) {
      name = DEFAULT_SERVICE_NAME;
    }
    this._providers[name] = authService;
    if (!this._primaryProvider) {
      this._primaryProvider = name;
    }
  }

  /**
   * Authenticates user.
   * @param {Object|String} credentials User credentials to be verified (data object or token string)
   * @param {String} credentials.access_code1 User access code 1
   * @param {String} credentials.access_code2 User access code 2
   * @param {String} credentials.code Value for OAuth code flow
   * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
   * @returns {Promise<Session>} User session for passed user credentials.
   * @throws {InvalidCredentials} In case credentials are not valid.
   * @throws {AuthenticationError} In case authentication fails.
   */
  static async authenticate(credentials, scope = null) {
    credentials = await this._resolvePasswordFileCredentials(credentials);
    let supportedServices = [];
    if (!credentials) {
      // In case of interactive login, we just have to use primary service
      // (we cannot try multiple services due to required browser interaction)
      supportedServices.push(this._providers[this._primaryProvider]);
    } else if (typeof credentials === "string") {
      if (credentials.match(ID_TOKEN_REGEX)) {
        // In case of ID token, find exact service via issuer_uri
        // (There must be one, else token is not supported at all)
        let issuerUri = null;
        try {
          issuerUri = JSON.parse(Base64.urlSafeDecode(credentials.split(".")[1])).iss;
        } catch (e) {
          throw new InvalidCredentials("Token is not trusted (unknown token issuer).", e);
        }
        for (let provider of Object.values(this._providers)) {
          if (issuerUri === (await provider.getServiceUri())) {
            supportedServices.push(provider);
            break;
          }
        }
        if (supportedServices.length === 0) {
          throw new InvalidCredentials("Token is not trusted (unknown token issuer).");
        }
      } else {
        // In case of access token, find all services supporting it
        let primaryProvider = this._providers[this._primaryProvider];
        if (credentials.match(primaryProvider.getAccessTokenPattern())) {
          supportedServices.push(primaryProvider);
        }
        for (let provider of Object.values(this._providers)) {
          if (provider.getServiceName() !== this._primaryProvider && credentials.match(provider.getAccessTokenPattern())) {
            supportedServices.push(provider);
          }
        }
      }
    } else if (typeof credentials === "object") {
      // In case of authorization code or basic credentals we have to try all configured services
      let primaryProvider = this._providers[this._primaryProvider];
      supportedServices.push(primaryProvider);
      for (let provider of Object.values(this._providers)) {
        if (provider.getServiceName() !== this._primaryProvider) {
          supportedServices.push(provider);
        }
      }
    } else {
      throw new InvalidCredentials("Unsupported credentials.");
    }
    if (supportedServices.length === 0) {
      throw new InvalidCredentials("Unsupported credentials.");
    }
    // Iterate throuth each service supporting credentials and try to authenticate
    let authenticationErrors = [];
    for (let service of supportedServices) {
      try {
        //In case of successful authentication return immediately
        return await service.authenticate(credentials, scope);
      } catch (e) {
        // Remember service name and authentication error
        authenticationErrors.push([service.getServiceName(), e]);
      }
    }
    let logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
    for (let [serviceName, error] of authenticationErrors.slice(0, -1)) {
      logger.error(`Authentication with ${serviceName} failed.`, error);
    }
    //In case authentication did not succeed, throw last error
    throw authenticationErrors.pop()[1];
  }

  /**
   * Returns name of primary authentication service.
   * @returns {String} Name of primary authentication service
   */
  static getServiceName() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getServiceName() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   */
  static async getServiceUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? (await primaryProvider.getServiceUri()) : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   * @deprecated
   */
  static getProviderUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getProviderUri() : null;
  }

  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  constructor(name, opts = {}) {
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    // Allow configuration via legacy parameters but do not allow creation
    // without any options (only using defaults).
    this._serviceUri = opts.serviceUri || opts.uu_oidc_server_uri;
    if (!this._serviceUri && opts.uu_oidc_server_tenant_id) {
      let tenant = opts.uu_oidc_server_tenant_id;
      this._serviceUri = `https://oidc.plus4u.net/uu-oidcg01-main/${tenant}`;
    }
    if (!this._serviceUri) {
      throw new BaseError(`There is no service URI defined for service ${this._serviceName}`);
    }
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
    this._doVerifyAudience = (typeof opts.verifyAudience === "boolean") ? opts.verifyAudience : DEFAULT_VERIFY_AUDIENCE;
    // Allow audience alias by default in uuCloud environment (checked by presence of specific uuCloud environment variable)
    this._allowAudienceAlias = (typeof opts.allowAudienceAlias === "boolean") ? opts.allowAudienceAlias : !!process.env[UU_CLOUD_ENV_VARIABLE];
    this._oauthClient = new OAuthClient(this._serviceUri, opts);
    this._oauthCode = new OAuthCode(this._serviceUri, opts);
  }

  /**
   * Returns Returns name of authentication service.
   * @returns {String} Name of authentication service
   */
  getServiceName() {
    return this._serviceName;
  }

  /**
   * Returns URI of authentication service.
   * @returns {String} URI of authentication service
   */
  async getServiceUri() {
    return await this._oauthClient.getIssuer();
  }

  /**
   * Returns URI of authentication service.
   * @returns {String|Uri|*} URI of authentication service
   * @deprecated
   */
  getProviderUri() {
    return this._serviceUri;
  }

  /**
   * Returns pattern of access token supported by service.
   * @returns {String} Supported access token pattern
   */
  getAccessTokenPattern() {
    return this._accessTokenPattern;
  }

  /**
   * Returns pattern of refresh token supported by service.
   * @returns {String} Supported refresh token pattern
   */
  getRefreshTokenPattern() {
    return this._refreshTokenPattern;
  }

  async authenticate(credentials, scope = null) {
    credentials = await OidcAuthenticationService._resolvePasswordFileCredentials(credentials);
    let session = null;
    if (!credentials) {
      if (!this._oauthCode.isSupported()) {
        throw new InvalidCredentials("Missing credentials.");
      }
      let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      try {
        credentials = await this._oauthCode.get(clientCredentials.client_id, scope);
      } catch (e) {
        throw new AuthenticationError("Authentication failed.", e);
      }
      session = await this.authenticate(credentials, scope);
    } else if (typeof credentials === "string") {
      if (ID_TOKEN_REGEX.test(credentials)) {
        let claims = await this._oauthClient.parseToken(credentials, true, null);
        if (this._doVerifyAudience) {
          await this._verifyAudience(claims);
        }
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, credentials, null);
      } else {
        let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
        let tokenKey = Digest.sha1(credentials);
        let claims = await this._oauthClient.getToken(tokenKey);
        if (!claims) {
          claims = await this._oauthClient.parseToken(credentials, true, clientCredentials);
          if (this._doVerifyAudience) {
            await this._verifyAudience(claims);
          }
          this._oauthClient.cacheToken(tokenKey, claims.exp, claims);
        }
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, null, credentials);
      }
    } else {
      let clientCredentials = credentials.clientCredentials;
      if (!clientCredentials) {
        clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      }
      if (credentials[OAUTH_CODE]) {
        let authorizationCode = credentials[OAUTH_CODE];
        let redirectUri = credentials[OAUTH_REDIRECT_URI];
        let token = await this._oauthClient.grantAuthorizationCodeToken(authorizationCode, clientCredentials, redirectUri, scope);
        let claims = await this._oauthClient.parseToken(token.id_token);
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, token.id_token, token.access_token);
      } else {
        let username = credentials.username || credentials.accessCode1 || credentials.access_code1;
        let password = credentials.password || credentials.accessCode2 || credentials.access_code2;
        if (!username || !password) {
          throw new InvalidCredentials("Unsupported credentials.");
        }
        let tokenKey;
        if (Array.isArray(scope)) {
          tokenKey = Digest.sha1(`${username}:${clientCredentials.client_id}:${scope.sort().join("|")}`);
        } else {
          tokenKey = Digest.sha1(`${username}:${clientCredentials.client_id}:${scope}`);
        }
        let token = this._oauthClient.getToken(tokenKey);
        if (!token) {
          token = await this._oauthClient.grantResourceOwnerPasswordCredentialsToken(username, password, clientCredentials, scope);
          let expiresAt = token.expires_at || Number((Date.now() / 1000) + token.expires_in);
          this._oauthClient.cacheToken(tokenKey, expiresAt, token);
        }
        let claims = await this._oauthClient.parseToken(token.id_token);
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, token.id_token, token.access_token);
      }
    }
    return session;
  }

  async _verifyAudience(claims) {
    let serviceUri = null;
    let serviceUriAlias = null;
    if (UseCaseContext && ContextStore.get("uuapp.server.endpoint")) {
      serviceUri = UseCaseContext.getUri().toString();
      if (this._allowAudienceAlias) {
        // TODO Should be read via UseCaseContext once supported by uuAppServer
        let baseUriAlias = LoggerMDC.get("baseUriAlias");
        if (baseUriAlias) {
          serviceUriAlias = `${baseUriAlias.replace(/\/$/, "")}/${UseCaseContext.getUri().getUseCase()}`;
        }
      }
    }
    let audienceClaim = claims.aud ? (Array.isArray(claims.aud) ? claims.aud : [claims.aud]) : [];
    let checkServiceUri = serviceUri && audienceClaim.length > 1;
    let clientId = null;
    if (!checkServiceUri) {
      clientId = (await ClientCredentialsProvider.getClientCredentials(this._serviceName)).client_id;
    }
    for (let audience of (audienceClaim)) {
      if (checkServiceUri) {
        if (serviceUri.startsWith(audience) || (serviceUriAlias && serviceUriAlias.startsWith(audience))) {
          return true;
        }
      } else {
        if (clientId === audience) {
          return true;
        }
      }
    }
    throw new InvalidCredentials("Token scope does not match.");
  }

  static async _resolvePasswordFileCredentials(credentials) {
    if (typeof credentials !== "string") {
      return credentials;
    }
    let passwdFilePath = credentials;
    if (!Path.isAbsolute(passwdFilePath)) {
      passwdFilePath = Path.join(Os.homedir(), ".uu", passwdFilePath);
    }
    if (!(await fsExists(passwdFilePath))) {
      return credentials;
    }
    credentials = {};
    let passwdFileContent = await fsReadFile(passwdFilePath, "utf8");
    passwdFileContent = passwdFileContent.replace(/\r\n?/g, "\n");
    passwdFileContent.split("\n").forEach(function(line) {
      line = line.trim();
      if (/^[#!]/.test(line)) {
        return;
      }
      let [name, value] = line.split(/[=:](.*)/, 2);
      name = name ? name.trim() : null;
      if (name) {
        value = value ? value.trimLeft() : null;
        credentials[name] = value ? value : null;
      }
    });
    return credentials;
  }

}

OidcAuthenticationService._providers = {};
OidcAuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
OidcAuthenticationService.load(false);

module.exports = OidcAuthenticationService;
