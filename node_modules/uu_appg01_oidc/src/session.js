"use strict";

const {Config, BaseError} = require("uu_appg01_core-utils");
const {UriBuilder} = require("uu_appg01_core-uri");
const {LoggerFactory} = require("uu_appg01_core-logging");
const CoreAuthenticationService = require("uu_appg01_core-authentication").AuthenticationService;
const CoreSession = require("uu_appg01_core-authentication").Session;
const {Identity, ClientIdentity, ApplicationIdentity} = require("uu_appg01_core-authentication");
const EmptySession = require("./internal/empty-session.js");
const ClientCredentialsProvider = require("./internal/client-credentials-provider.js");
const Digest = require("./internal/digest.js");

const JWT_CLAIM_UU_IDENTITY = "uuidentity";
const JWT_CLAIM_UU_IDENTITY_G01 = "uu_identity";
const JWT_CLAIM_NAME = "name";
const JWT_CLAIM_TOKEN_ID = "jti";
const JWT_CLAIM_SESSION_ID = "auth_id";
const JWT_CLAIM_SESSION_ID_G01 = "sid";
const JWT_CLAIM_AUTH_TIME = "auth_time";
const JWT_CLAIM_ISSUED_AT = "iat";
const JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE = "acr";
const JWT_CLAIM_LEVEL_OF_ASSURANCE = "loa";
const JWT_CLAIM_CLIENT_APP_ID = "client_app_id";
const JWT_CLAIM_CLIENT_APP_CODE = "client_app_code";
const JWT_CLAIM_CLIENT_UU_IDENTITY = "client_uuidentity";
const JWT_CLAIM_CLIENT_APP_NAME = "client_app_name";
const JWT_CLAIM_CLIENT_URI = "client_uri";
const JWT_CLAIM_IDENTITY_TYPE = "uuidentity_type";
const JWT_CLAIM_IDENTITY_TYPE_G01 = "identity_type";

const OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
const OAUTH_TOKEN_TYPE_ACCESS_TOKEN = "access_token";

const OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_ID_TOKEN}`;

const CLIENT_URI_URN = "urn:uuoidcclient:";

const ANONYMOUS_UUIDENTITY = "0-0";

const CONFIG_PREFIX = "uu_app_oidc_providers_";
const DEFAULT_SCOPE_MODE = "allUseCases";
const DEFAULT_USE_TOKEN_EXCHANGE = true;
const DEFAULT_AUTH_LEVEL_OF_ASSURANCE = 1;

class Session extends CoreSession {

  constructor(serviceName, oauthClient, supportedAcrValues, claims = null, idToken = null, accessToken = null) {
    let id = null;
    let authenticationId = null;
    let authenticationTime = null;
    let authenticationLevelOfAssurance = null;
    let identity = null;
    let clientIdentity = null;
    let applicationIdentity = null;
    let attributes = claims;
    let configPrefix = `${CONFIG_PREFIX}${serviceName}_`;
    if (attributes) {
      id = attributes[JWT_CLAIM_TOKEN_ID];
      authenticationId = attributes[JWT_CLAIM_SESSION_ID] || attributes[JWT_CLAIM_SESSION_ID_G01];
      let epochAuthTime = attributes[JWT_CLAIM_AUTH_TIME] || attributes[JWT_CLAIM_ISSUED_AT];
      if (epochAuthTime) {
        authenticationTime = new Date(epochAuthTime * 1000);
      }
      let loa = attributes[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
      if (loa == null) {
        authenticationLevelOfAssurance = DEFAULT_AUTH_LEVEL_OF_ASSURANCE;
      } else {
        if (supportedAcrValues.indexOf(loa) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa);
        } else if (supportedAcrValues.indexOf(loa.toString()) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa.toString());
        } else if (supportedAcrValues.indexOf(Number(loa.toString())) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(Number(loa.toString()));
        } else {
          // TODO Fallback because oidcg02 now returns supported values as word but acr_value as number
          authenticationLevelOfAssurance = Number(loa.toString());
        }
      }
      let uuIdentity;
      let uuIdentityClaim = Config.getString(`${configPrefix}uu_identity_claim`);
      if (uuIdentityClaim) {
        uuIdentity = attributes[uuIdentityClaim];
      } else {
        uuIdentity = attributes[JWT_CLAIM_UU_IDENTITY] || attributes[JWT_CLAIM_UU_IDENTITY_G01];
      }
      if (uuIdentity) {
        let levelOfAssurance = attributes[JWT_CLAIM_LEVEL_OF_ASSURANCE];
        let name = attributes[JWT_CLAIM_NAME];
        if (uuIdentity === ANONYMOUS_UUIDENTITY) {
          authenticationLevelOfAssurance = 0;
        }
        let type = attributes[JWT_CLAIM_IDENTITY_TYPE] || attributes[JWT_CLAIM_IDENTITY_TYPE_G01];
        let identityData = {name, levelOfAssurance, type};
        identity = new Identity(uuIdentity, identityData);
      }
      let appCode = attributes[JWT_CLAIM_CLIENT_APP_CODE];
      let appIdentity = attributes[JWT_CLAIM_CLIENT_UU_IDENTITY];
      if (appCode || appIdentity) {
        let appData = {};
        appData.id = attributes[JWT_CLAIM_CLIENT_APP_ID];
        appData.code = appCode;
        appData.name = attributes[JWT_CLAIM_CLIENT_APP_NAME];
        let clientUri = attributes[JWT_CLAIM_CLIENT_URI];
        if (clientUri) {
          appData.clientUri = attributes[JWT_CLAIM_CLIENT_URI];
          if (appData.clientUri && appData.clientUri.startsWith(CLIENT_URI_URN)) {
            let [product, asidawid] = appData.clientUri.replace(CLIENT_URI_URN, "").split(/[:\/](.*)/);
            let [asid, awid] = asidawid.split(/[:\-]/);
            if (!appData.code) {
              appData.code = product.toUpperCase().replace(/-/g, ".");
            }
            if (!appData.name) {
              appData.name = product.replace(/(-\w)/g, function (match) {
                return match[1].toUpperCase();
              });
            }
            let [vendor, app, subApp] = product.split("-");
            appData.product = product;
            appData.vendor = vendor;
            appData.app = app;
            appData.subApp = subApp;
            appData.asid = asid;
            appData.awid = awid;
          }
        } else if (appData.code) {
          let [vendor, app, subApp] = appData.code.toLowerCase().split(/[\.\-_]/);
          let product = `${vendor}-${app}-${subApp}`;
          appData.vendor = vendor;
          appData.app = app;
          appData.subApp = subApp;
          appData.product = product;
          appData.clientUri = `${CLIENT_URI_URN}${product}`;
        }
        clientIdentity = new ClientIdentity(appIdentity, appData);
        applicationIdentity = new ApplicationIdentity(appIdentity, appData);
      }
    }
    super({
      id,
      authenticationId,
      authenticationTime,
      authenticationLevelOfAssurance,
      identity,
      clientIdentity,
      applicationIdentity,
      attributes
    });
    this._configPrefix = configPrefix;
    this._serviceName = serviceName;
    this._oauthClient = oauthClient;
    this._supportedAcrValues = supportedAcrValues;
    this._idToken = idToken;
    this._accessToken = accessToken;
    this._logger = LoggerFactory.get("uuapp.oidc.Session");
    // TODO Workaround for providers not providing acr value (should be moved to core session)
    if (!this._authenticated && !this._authenticationLevelOfAssurance) {
      // Session should return isAuthenticated as true as long as there is some identity other than anonymous
      this._authenticated = this._identity && this._identity.getUuIdentity() && this._identity.getUuIdentity() !== ANONYMOUS_UUIDENTITY;
    }
  }

  getServiceName() {
    return this._serviceName;
  }

  async getServiceUri() {
    let service = CoreAuthenticationService.get(this._serviceName);
    return typeof service.getServiceUri === "function" ? (await service.getServiceUri()) : null;
  }

  getProviderUri() {
    let service = CoreAuthenticationService.get(this._serviceName);
    return typeof service.getProviderUri === "function" ? (service.getProviderUri()) : null;
  }

  async getCallTokenScope(uri, opts = {}) {
    let scopeMode = opts ? opts.scopeMode : null;
    if (!scopeMode) {
      let cfgKey = `${this._configPrefix}default_call_token_scope_mode`;
      scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE
    }
    if (scopeMode === "none") {
      return null;
    }
    let scope;
    try {
      let uriBuilder = UriBuilder.parse(uri);
      uriBuilder.clearParameters();
      if (scopeMode === "useCase") {
        scope = uriBuilder.toUri().toString();
      } else if (scopeMode === "allUseCases") {
        uriBuilder.setUseCase(null);
        scope = uriBuilder.toUri().toString();
      } else {
        throw new BaseError(`Unsupported scope mode: ${scopeMode}`);
      }
    } catch (e) {
      scope = uri.toString().split("?")[0];
    }
    return scope;
  }

  async getCallToken(scope, opts = {}) {
    let useTokenExchange = opts ? opts.useTokenExchange : null;
    if (typeof useTokenExchange !== "boolean") {
      let cfgKey = `${this._configPrefix}use_token_exchange`;
      useTokenExchange = Config.hasKey(cfgKey) ? Config.getBoolean(cfgKey) : DEFAULT_USE_TOKEN_EXCHANGE;
    }
    let callTokenType = opts ? opts.callTokenType : null;
    if (!callTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      callTokenType = Config.getString(cfgKey);
    }
    let excludeAuthType = opts ? opts.excludeAuthenticationType : false;

    let token = null;
    if (!useTokenExchange) {
      if (callTokenType === "idToken") {
        token = this._idToken;
      } else if (callTokenType === "accessToken") {
        token = this._accessToken;
      } else if (!callTokenType) {
        token = this._idToken || this._accessToken;
      }
    } else {
      let credentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
      let tokenKey;
      if (Array.isArray(scope)) {
        tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${credentials.client_id}:${scope.sort().join("|")}`);
      } else {
        tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${credentials.client_id}:${scope}`);
      }
      let grantedToken = await this._oauthClient.getToken(tokenKey);
      if (!grantedToken) {
        grantedToken = await this._oauthClient.exchangeToken(this._idToken || this._accessToken, credentials, scope);
        let expiresAt = grantedToken.expires_at || Number((new Date() / 1000) + grantedToken.expires_in);
        this._oauthClient.cacheToken(tokenKey, expiresAt, grantedToken);
      }
      if (callTokenType === "idToken") {
        token = grantedToken.id_token;
      } else if (callTokenType === "accessToken") {
        token = grantedToken.access_token;
      } else if (!callTokenType) {
        token = grantedToken.id_token || grantedToken.access_token;
      }
    }

    if (!token) {
      throw new BaseError(`Call token of type "${tokenType || "idToken"}" is not available.`);
    }
    if (excludeAuthType === true) {
      return token;
    } else {
      return `Bearer ${token}`;
    }
  }

  async close() {
    super.close();
    let credentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
    if (this._idToken || this._accessToken) {
      try {
        await this._oauthClient.revokeToken(this._idToken || this._accessToken, credentials);
      } catch (e) {
        this._logger.error("Token revocation failed.", e);
      }
    }
    this._oauthClient.listTokens((tokenKey, grantedToken) => {
      if (grantedToken.id_token == this._idToken || grantedToken.access_token == this._accessToken) {
        this._oauthClient.deleteToken(tokenKey);
        return false;
      }
    });
    this._idToken = null;
    this._accessToken = null;
  }

  static _createEmptySession() {
    return new EmptySession();
  }

}

module.exports = Session;
