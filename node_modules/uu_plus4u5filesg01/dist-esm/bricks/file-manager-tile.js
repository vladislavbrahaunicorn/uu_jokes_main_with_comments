import Config from "../config/config.js";
import * as UU5 from "uu5g04";
import "uu5imagingg01";

import Calls from "../calls.js";
import LsiHelper from "../helpers/lsi-helper.js";
import Css from "../helpers/css.js";
import TagList from "./tag-list.js";
import ImageFromCall from "./image-from-call.js";

import "./file-manager-tile.less";

const LIGHTBOX_PLACEHOLDER_DATA = [
  {
    id: "image",
    src: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
    authenticate: true
  }
];
const MemoizedLightbox = UU5.Common.Component.memo(props => <UU5.Imaging.Lightbox {...props} />);

const FileManagerTile = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.PureRenderMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Config.TAG + "FileManagerTile",
    classNames: {
      main: Config.CSS + "file-manager-tile",
      mainSelected: Config.CSS + "file-manager-tile-selected",
      selectableOnly: Config.CSS + "file-manager-selectable-only",
      innerTile: Config.CSS + "file-manager-inner-tile",
      smallTile: "small-tile",
      previewField: "preview-field",
      image: "image",
      previewContentWrapper: "preview-content-wrapper",
      infoField: "info-field",
      tileCard: "tile-card",
      infoBox: "info-box",
      infoFieldRow: "info-field-row",
      infoFieldCol: "info-field-col",
      primaryAttribute: "primary-attribute",
      secondaryAttribute: "secondary-attribute",
      buttonPanel: "button-panel",
      selectButton: "select-button",
      flex: props =>
        props.tileType === "small"
          ? ""
          : Css.css(`
              display: flex;
              align-items: stretch;

              & > .plus4u5-files-file-manager-tile {
                display: flex;
                flex-direction: column;
                align-items: stretch;

                & > .tile-card {
                  flex: 1 0 auto;
                  display: flex;
                  flex-direction: column;
                  align-items: stretch;

                  & > .info-box {
                    flex: 1 0 auto;
                    display: flex;
                    flex-direction: column;
                    align-items: stretch;

                    & > .info-field {
                      flex: 1 0 auto;
                      display: flex;
                      flex-direction: column;
                      align-items: stretch;
                    }
                  }
                }
              }
            `)
    },
    defaults: {
      maxButtons: 3
    },
    opt: {
      nestingLevelWrapper: true,
      pureRender: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    fileManager: UU5.PropTypes.object,
    tileType: UU5.PropTypes.string,
    getThumbnail: UU5.PropTypes.func,
    isS: UU5.PropTypes.bool,
    uuCmdGetBinaryData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetBinaryDataUri: UU5.PropTypes.func,
    uuCmdGetThumbnailData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetThumbnailDataUri: UU5.PropTypes.func,
    onFileClick: UU5.PropTypes.func,
    shouldShowThumbnail: UU5.PropTypes.bool,
    fileButtons: UU5.PropTypes.object,

    customSelectable: UU5.PropTypes.string,
    selectableOnly: UU5.PropTypes.bool,

    onFilenameSet: UU5.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      selectableOnly: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    return {
      loadError: false,
      renderButtons: this.props.isS,
      src: undefined,
      srcMeta: this._updateSrc(this.props.uuCmdGetBinaryData, this.props.uuCmdGetBinaryDataUri),
      thumbSrc: undefined,
      thumbThumbSrc: undefined,
      ...this._updateThumbnails(),
      icon: this.props.data.icon || "mdi-file",
      thumbnailType: this.props.data.thumbnailType || "icon",
      binaryType: this.props.data.type || "other"
    };
  },

  componentDidMount() {
    this._updateLightbox();
  },

  componentDidUpdate(prevProps, prevState) {
    this.setState(prevState => {
      if (!prevState.renderButtons && this.props.isS) {
        return { renderButtons: true };
      }
    });

    this._updateLightbox(prevState.src);
  },

  componentWillReceiveProps(nextProps) {
    let newState = {};

    if (
      nextProps.baseUri !== this.props.baseUri ||
      nextProps.uuCmdGetBinaryData !== this.props.uuCmdGetBinaryData ||
      nextProps.code !== this.props.code
    ) {
      newState.srcMeta = this._updateSrc(nextProps.uuCmdGetBinaryData, nextProps.uuCmdGetBinaryDataUri, {
        baseUri: nextProps.baseUri,
        binary: nextProps.data.binary,
        data: { code: nextProps.code }
      });
    }

    let updatedThumbnailData = this._updateThumbnails(nextProps);
    if (!UU5.Common.Tools.deepEqual(updatedThumbnailData.thumbSrcMeta, this.state.thumbSrcMeta)) {
      newState.thumbSrcMeta = updatedThumbnailData.thumbSrcMeta;
    }
    if (!UU5.Common.Tools.deepEqual(updatedThumbnailData.thumbThumbSrcMeta, this.state.thumbThumbSrcMeta)) {
      newState.thumbThumbSrcMeta = updatedThumbnailData.thumbThumbSrcMeta;
    }

    if (
      nextProps.data.icon !== this.props.data.icon ||
      nextProps.data.thumbnailType !== this.props.data.thumbnailType ||
      nextProps.data.binaryType !== this.props.data.binaryType
    ) {
      newState = {
        ...newState,
        icon: nextProps.data.icon || "mdi-file",
        thumbnailType: nextProps.data.thumbnailType || "icon",
        binaryType: nextProps.data.type || "other"
      };
    }

    if (Object.keys(newState).length) {
      this.setState(newState);
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  _updateLightbox(prevSrc) {
    if (this._lightbox && prevSrc !== this.state.src) {
      if (this.state.src !== undefined) {
        this._lightbox.replaceImage(this.state.src || LIGHTBOX_PLACEHOLDER_DATA[0].src, "image");
      }
    }
    // NOTE Currently it's not possible to change data while lightbox is opened => that's why
    // we waited for new "src" and we'll open the lightbox now.
    if (this._lightbox && this._lastOpenId !== this.state.lightboxOpenId && this.state.src !== undefined) {
      this._lastOpenId = this.state.lightboxOpenId;
      this._lightbox.open();
    }
  },

  _updateSrc(uuCmd, uuCmdUri, { baseUri, binary, stringParams, data, download = false } = {}, callback) {
    data = data || { code: this.props.data.binary.code };
    baseUri = baseUri || this.props.baseUri;
    let stringSrc;
    if (typeof uuCmdUri === "function") {
      stringSrc = uuCmdUri(binary || this.props.data.binary, download);
    } else if (typeof uuCmd !== "function") {
      stringSrc = Calls.getCommandUri(baseUri, uuCmd, data);
      if (stringParams) {
        stringSrc += "&" + stringParams;
      }
      if (download) stringSrc += "&contentDisposition=attachment";
    }
    if (download && stringSrc && UU5.Environment.isTrustedDomain(stringSrc)) {
      let session = UU5.Environment.getSession();
      stringSrc += "&access_token=" + (session ? (session.getCallToken() || {}).token : "");
    }
    return { data, uuCmd, stringSrc, callback };
  },

  _updateThumbnails(props = this.props) {
    let code = props.data.binary.code;
    let thumbCode = code.length > 61 ? code.substr(0, 61) : code;
    thumbCode = thumbCode + "_th";
    let thumbnail = props.getThumbnail(thumbCode);
    let thumbSrcMeta;
    let thumbThumbSrcMeta;
    if (thumbnail) {
      let stringParams = thumbnail.sys.mts;
      stringParams = stringParams.replace(/[:.-]/g, "");
      // TODO ??? Why using uuCmdGetThumbnailData for getting props.data.binary?
      thumbSrcMeta = this._updateSrc(props.uuCmdGetThumbnailData, props.uuCmdGetThumbnailDataUri, {
        data: { code: code },
        binary: props.data.binary,
        stringParams
      });
      thumbThumbSrcMeta = this._updateSrc(props.uuCmdGetThumbnailData, props.uuCmdGetThumbnailDataUri, {
        data: { code: thumbCode },
        binary: thumbnail,
        stringParams
      });
    }

    return { thumbSrcMeta, thumbThumbSrcMeta };
  },

  _buildPreview(renderImages) {
    let preview;

    if (this.state.thumbnailType === "original") {
      // no thumbnails, show original images
      if (renderImages) {
        let mainPropsToPass = this.getMainPropsToPass();
        if (this.props.customSelectable !== "none" && this.props.selectableOnly) {
          preview = (
            <ImageFromCall
              srcMeta={this.state.srcMeta}
              onSrcReady={({ src }) => this.setState({ src })}
              style={{
                maxWidth: mainPropsToPass.style && mainPropsToPass.style.width ? mainPropsToPass.style.width - 4 : 200
              }}
              authenticate
            />
          );
        } else {
          preview = (
            <ImageFromCall
              srcMeta={this.state.srcMeta}
              onSrcReady={({ src }) => this.setState({ src })}
              imageComponent={UU5.Imaging.Image}
              fit="coverNoScaleUp"
              authenticate
              onClick={this.props.onFileClick ? () => this.props.onFileClick(this.props.data.binary) : undefined}
            />
          );
        }
      } else {
        preview = <UU5.Bricks.Icon icon={this.state.icon} />;
      }
    } else if (this.state.thumbnailType === "thumbnail") {
      // show thumbnails
      if (this.state.thumbSrcMeta && renderImages && !this.state.loadError) {
        let mainPropsToPass = this.getMainPropsToPass();
        if (this.props.customSelectable !== "none" && this.props.selectableOnly) {
          preview = (
            <ImageFromCall
              srcMeta={this.state.thumbThumbSrcMeta}
              onSrcReady={({ src }) => this.setState({ thumbThumbSrc: src })}
              style={{
                maxWidth: mainPropsToPass.style && mainPropsToPass.style.width ? mainPropsToPass.style.width - 4 : 200
              }}
              authenticate
            />
          );
        } else {
          preview = (
            <ImageFromCall
              srcMeta={this.state.thumbSrcMeta}
              thumbSrcMeta={this.state.thumbThumbSrcMeta}
              imageComponent={UU5.Imaging.Image}
              onSrcReady={({ src, thumbSrc }) => this.setState({ thumbSrc: src, thumbThumbSrc: thumbSrc })}
              lightbox={this.props.data.id}
              fit="coverNoScaleUp"
              authenticate
              onClick={this.props.onFileClick ? () => this.props.onFileClick(this.props.data.binary) : undefined}
            />
          );
        }
      } else {
        preview = <UU5.Bricks.Icon icon={this.state.icon} />;
      }
    } else {
      // show icons
      preview = <UU5.Bricks.Icon icon={this.state.icon} />;
    }

    // TODO :-( Currently we need this.state.src because of Lightbox so we download both thumbnail & full image
    // right away.
    if (this.state.lightboxSrcMeta) {
      preview = (
        <>
          {preview}
          <ImageFromCall
            style={{ display: "none" }}
            srcMeta={this.state.lightboxSrcMeta}
            onSrcReady={({ src }) => this.setState({ src })}
            srcReadyKey={this.state.lightboxOpenId + ""}
            authenticate
          />
        </>
      );
    }

    return preview;
  },

  _openPreviewForm(binaryCode, type, event) {
    event.preventDefault();
    event.stopPropagation();
    this.props.onFileClick(binaryCode, type);
  },

  _getMainAttrValue() {
    return this.props.onFilenameSet
      ? LsiHelper.getLsiComponent(this.props.onFilenameSet(this.props.data.binary))
      : this.props.data.binary.filename;
  },

  _toggleSelected() {
    if (this.props.selected) {
      this.props.fileManager.customRemoveSelectedItem(this.props.id);
    } else {
      this.props.fileManager.customAddSelectedItem(this.props.id);
    }
  },

  _onDownloadLinkClick() {
    let { data, stringSrc, uuCmd } = this._updateSrc(this.props.uuCmdGetBinaryData, this.props.uuCmdGetBinaryDataUri, {
      download: true
    });
    if (!stringSrc && typeof this.props.uuCmdGetBinaryData === "function") {
      // blob cannot be downloaded directly - we must download manually and change content type to octet/stream
      let filename = this.props.binary.filename;
      uuCmd(data).then(dtoOut => {
        let fileBlob = new Blob([dtoOut], { type: "octet/stream" });
        // save blob in IE and Edge - standard click on a link doesn't work in this browsers
        if (typeof navigator.msSaveBlob === "function") {
          navigator.msSaveBlob(fileBlob, filename);
          return;
        }
        let url = window.URL.createObjectURL(fileBlob);
        // to set name for the file we need to create link element and set name into download attribute
        let link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.style = "display: none;";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => {
          window.URL.revokeObjectURL(url);
        }, 60000);
      });
    } else {
      window.open(stringSrc, "_self");
    }
  },

  _getDownloadLink(opt, i) {
    return (
      <UU5.Bricks.Link
        key={"dropdownItem" + i}
        className="uu5-bricks-dropdown-item-link"
        content={LsiHelper.getLsiComponent(opt.label)}
        onClick={this._onDownloadLinkClick}
        download
      />
    );
  },

  _renderButtonPanel() {
    let buttons = [];
    let dropdownItems = [];
    let { itemList, hideDropdown } = this.props.fileButtons;

    if (this.props.customSelectable !== "none" && this.props.selectableOnly && this.props.data.clickable) {
      buttons.push(
        <UU5.Bricks.Button
          key={"magnifyButton"}
          onClick={(opt, event) => {
            event.preventDefault();
            event.stopPropagation();
            if (this.props.onFileClick) {
              this.props.onFileClick(this.props.data.binary);
            } else if (this._lightbox) {
              this.setState(state => ({
                lightboxSrcMeta: state.srcMeta,
                lightboxOpenId: (state.lightboxOpenId || 0) + 1
              }));
            }
          }}
          colorSchema="primary"
        >
          <UU5.Bricks.Icon icon={"mdi-magnify-plus"} />
        </UU5.Bricks.Button>
      );
    }

    itemList = itemList.filter(Boolean);
    let dropdownItemsAreDuplicitOnly = true;
    for (let i = 0; i < itemList.length; i++) {
      let item = itemList[i];
      let alsoAsButton = false;
      if (
        item.active &&
        ((this.props.customSelectable === "none" || !this.props.selectableOnly) &&
          !(this.props.tileType === "small" && this.props.isS))
      ) {
        alsoAsButton = true;
      }
      if (alsoAsButton) {
        buttons.push(
          <UU5.Bricks.Button
            key={"button" + i}
            onClick={(opt, event) => {
              event.preventDefault();
              event.stopPropagation();
              if (typeof item.onClick === "function") item.onClick(this.props.data.binary, this.state.binaryType);
            }}
            colorSchema="primary"
            tooltip={item.label ? this.getLsiItem(item.label) : undefined}
          >
            <UU5.Bricks.Icon icon={item.icon} />
          </UU5.Bricks.Button>
        );
      }
      if (
        (!hideDropdown || (this.props.tileType === "small" && this.props.isS)) &&
        (this.props.customSelectable === "none" || !this.props.selectableOnly)
      ) {
        if (item.isDownload) {
          if (dropdownItemsAreDuplicitOnly) dropdownItemsAreDuplicitOnly = alsoAsButton;
          dropdownItems.push(this._getDownloadLink(item, i));
        } else {
          if (item.icon !== "mdi-magnify-plus" || (item.icon === "mdi-magnify-plus" && this.props.data.clickable)) {
            if (dropdownItemsAreDuplicitOnly) dropdownItemsAreDuplicitOnly = alsoAsButton;
            dropdownItems.push(
              <UU5.Bricks.Dropdown.Item
                label={LsiHelper.getLsiComponent(item.label)}
                onClick={() => item.onClick(this.props.data.binary, this.state.binaryType)}
                key={"dropdownItem" + i}
              />
            );
          }
        }
      }
    }
    if (dropdownItemsAreDuplicitOnly) dropdownItems = [];
    let remainingButtons = this.getDefault("maxButtons") - (dropdownItems.length > 0 ? 1 : 0);
    if (buttons.length > remainingButtons) buttons.splice(remainingButtons);

    return (
      this.state.renderButtons && (
        <UU5.Bricks.Div className={this.getClassName("buttonPanel")}>
          {buttons}
          {dropdownItems.length > 0 && (
            <UU5.Bricks.Dropdown
              label=""
              ref_={opt => (this._dropdown = opt)}
              iconOpen="mdi-dots-vertical"
              iconClosed="mdi-dots-vertical"
              pullRight
              colorSchema="primary"
              allowTags={["UU5.Bricks.Link"]}
            >
              {dropdownItems}
            </UU5.Bricks.Dropdown>
          )}
        </UU5.Bricks.Div>
      )
    );
  },

  _renderSelectButton() {
    return (
      this.props.customSelectable !== "none" && (
        <UU5.Bricks.Button
          key="selectButton"
          className={
            this.getClassName("selectButton") +
            " " +
            (this.props.selected ? this.getClassName("selectButtonSelected") : "")
          }
          tooltip={this.getLsiItem({ cs: "Vybrat soubor", en: "Select File" })}
          onClick={(opt, event) => this._toggleSelected(event)}
          colorSchema={this.props.isS ? (this.props.selected ? "orange" : "blue") : "orange"}
        >
          <UU5.Bricks.Icon
            icon="mdi-checkbox-marked-circle"
            style={{ color: "#ffffff", fontSize: this.props.isS ? null : "32px" }}
          />
        </UU5.Bricks.Button>
      )
    );
  },

  _getFullInfoBox() {
    return (
      <div className={this.getClassName("infoBox")}>
        <div
          className={
            this.getClassName("previewField") + (this.props.data.clickable ? " " + this.getClassName("image") : "")
          }
        >
          <div className={this.getClassName("previewContentWrapper")}>
            {this._buildPreview(this.props.shouldShowThumbnail)}
          </div>
        </div>
        <div className={this.getClassName("infoField")}>
          <div className={this.getClassName("primaryAttribute")} title={this.props.data.binary.filename}>
            {this._getMainAttrValue()}
          </div>
          <div className={this.getClassName("secondaryAttribute")} title={this.props.data.binary.code}>
            {this.props.data.binary.code}
          </div>
          <UU5.Bricks.Resize>
            {size => (
              <TagList
                key="tagList"
                items={this.props.data.binary.tagList}
                onTagExpand={this.props.handleMeasure}
                className="tag-list"
                width={size.width}
                height={size.height}
              />
            )}
          </UU5.Bricks.Resize>
          <div className={this.getClassName("secondaryAttribute")}>
            {new Date(this.props.data.binary.sys.mts)
              .toLocaleString()
              .slice(0, -3)
              .replace(/:$/, "")}
          </div>
        </div>
        {this._renderSelectButton()}
        {!this.props.isS && this._renderButtonPanel()}
      </div>
    );
  },

  _getSmallInfoBox() {
    return (
      <div>
        <div
          className={
            this.getClassName("previewField") + (this.props.data.clickable ? " " + this.getClassName("image") : "")
          }
        >
          {this._buildPreview(false)}
        </div>
        <div className={this.getClassName("infoField")}>
          <div className={this.getClassName("infoFieldRow")}>
            <div className={this.getClassName("infoFieldCol")} title={this.props.data.binary.filename}>
              {this._getMainAttrValue()}
            </div>
            <div className={this.getClassName("infoFieldCol")}>
              {new Date(this.props.data.binary.sys.mts).toLocaleString().slice(0, -3)}
            </div>
          </div>
          <div className={this.getClassName("infoFieldRow")}>
            <div className={this.getClassName("infoFieldCol")} title={this.props.data.binary.code}>
              {this.props.data.binary.code}
            </div>
          </div>
        </div>
        {this._renderSelectButton()}
        {!this.props.isS && this._renderButtonPanel()}
      </div>
    );
  },

  _setLightboxRef(ref) {
    this._lightbox = ref;
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let mainPropsToPass = this.getMainPropsToPass();
    if (this.props.selected) mainPropsToPass.className += " " + this.getClassName("mainSelected");
    if (this.props.customSelectable !== "none" && this.props.selectableOnly)
      mainPropsToPass.className += " " + this.getClassName("selectableOnly");
    if (this.props.tileType === "small") mainPropsToPass.className += " " + this.getClassName("smallTile");
    return (
      <UU5.Bricks.Div style={this.props.wrapperStyle} className={this.getClassName("flex")}>
        <UU5.Bricks.Div
          {...mainPropsToPass}
          mainAttrs={{
            onMouseOver: () => this.setState({ renderButtons: true }),
            onClick: event => {
              event.preventDefault();
              event.stopPropagation();
              this.props.customSelectable !== "none" && this.props.selectableOnly ? this._toggleSelected() : null;
            }
          }}
        >
          <UU5.Bricks.Card
            className={this.getClassName("tileCard")}
            elevation={1}
            elevationHover={2}
            colorSchema={this.props.selected ? "orange" : null}
            bgStyle="outline"
            style={{
              borderWidth: this.props.selected ? "2px" : "1px",
              margin: "0"
            }}
          >
            {this.props.isS && this._renderButtonPanel()}
            {this.props.tileType === "small" ? this._getSmallInfoBox() : this._getFullInfoBox()}
          </UU5.Bricks.Card>
          <div onClick={e => e.stopPropagation()}>
            {this.props.selectableOnly ? (
              // our re-render always causes the lightbox to close => use memo-ized component so that it doesn't re-render at all
              // (we'll control it using API methods)
              <MemoizedLightbox
                name={this.props.data.id}
                ref_={this._setLightboxRef}
                data={LIGHTBOX_PLACEHOLDER_DATA}
              />
            ) : null}
          </div>
        </UU5.Bricks.Div>
      </UU5.Bricks.Div>
    );
  }
  //@@viewOff:render
});

export default FileManagerTile;
