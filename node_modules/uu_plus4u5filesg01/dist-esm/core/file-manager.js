//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import "uu5tilesg01";

import Lsi from "../config/lsi.js";
import LsiHelper from "../helpers/lsi-helper.js";

import FileManagerTile from "../bricks/file-manager-tile.js";
import FileManagerTypeFilter from "../bricks/file-manager-type-filter.js";
import FileUploader from "./file-uploader.js";
import FormController from "../forms/form-controller.js";
import FilePasteHandlerMixin from "./internal/file-paste-handler-mixin.js";
import ListWrapper from "./internal/list-wrapper.js";

import { parseScreenSizeProp } from "./internal/tools.js";
import { adjustFile, getMaxFileSize } from "../helpers/file.js";
import Config from "../config/config.js";
import Calls from "../calls";
import "./file-manager.less";
//@@viewOff:imports

function detectMobileBrowser() {
  let check = false;

  (function(a) {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
        a
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        a.substr(0, 4)
      )
    )
      check = true;
  })(navigator.userAgent || navigator.vendor || window.opera);

  return check;
}

const FileManager = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ScreenSizeMixin, FilePasteHandlerMixin],

  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Config.TAG + "FileManager",
    classNames: {
      main: Config.CSS + "file-manager",
      dndWrapper: Config.CSS + "file-manager-dnd-wrapper"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    baseUri: UU5.PropTypes.string,

    uuCmdListBinaries: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdCreateBinary: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdUpdateBinary: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdUpdateBinaryData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdDeleteBinary: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetBinaryData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetBinaryDataUri: UU5.PropTypes.func,
    uuCmdListThumbnails: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdCreateThumbnail: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdUpdateThumbnailData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdDeleteThumbnail: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetThumbnailData: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.string]),
    uuCmdGetThumbnailDataUri: UU5.PropTypes.func,

    fileList: UU5.PropTypes.array,
    thumbnailList: UU5.PropTypes.array,

    onFileCreate: UU5.PropTypes.func,
    onFileUpdate: UU5.PropTypes.func,
    onFileDelete: UU5.PropTypes.func,
    onFileShare: UU5.PropTypes.func,
    onFileClick: UU5.PropTypes.func,
    onSelect: UU5.PropTypes.func,

    thumbnailStrategy: UU5.PropTypes.string,
    sortItems: UU5.PropTypes.array,
    sortValues: UU5.PropTypes.array,
    onSetFileType: UU5.PropTypes.func,
    fileTypeFilters: UU5.PropTypes.object,
    dndEnabled: UU5.PropTypes.bool,
    sharingOptions: UU5.PropTypes.object,
    fileButtons: UU5.PropTypes.shape({
      hideDropdown: UU5.PropTypes.bool,
      itemList: UU5.PropTypes.arrayOf(
        UU5.PropTypes.oneOfType([
          UU5.PropTypes.string,
          UU5.PropTypes.shape({
            active: UU5.PropTypes.bool,
            onClick: UU5.PropTypes.func,
            icon: UU5.PropTypes.string,
            label: UU5.PropTypes.oneOfType([UU5.PropTypes.string, UU5.PropTypes.object])
          })
        ])
      )
    }),
    lsiLabels: UU5.PropTypes.object,
    onFilenameSet: UU5.PropTypes.string,
    searchKeyList: UU5.PropTypes.array,
    selectable: UU5.PropTypes.oneOf(["none", "single", "multi"]),
    selectableOnly: UU5.PropTypes.bool,
    displayCreateButton: UU5.PropTypes.oneOfType([UU5.PropTypes.bool, UU5.PropTypes.string, UU5.PropTypes.object]),

    outputMaxHeight: UU5.PropTypes.number,
    outputMaxWidth: UU5.PropTypes.number,
    outputQuality: UU5.PropTypes.number,

    headerHidden: UU5.PropTypes.bool,

    allowCustomTags: UU5.PropTypes.bool,
    ignoreTags: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    availableTags: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    onTagCreate: UU5.PropTypes.func,
    readOnly: UU5.PropTypes.bool,
    sizeLimit: UU5.PropTypes.number,

    createButtonFileCodeRule: UU5.PropTypes.oneOf(["none", "required", "notRequired"]),
    dndFileCodeRule: UU5.PropTypes.oneOf(["none", "required", "notRequired"]),
    bulkActions: UU5.PropTypes.arrayOf(
      UU5.PropTypes.shape({
        content: UU5.PropTypes.any, // UU5 content
        onClick: UU5.PropTypes.func,
        active: UU5.PropTypes.bool
      })
    ),
    displayInfoBar: UU5.PropTypes.bool,
    displayFilterBar: UU5.PropTypes.bool,
    displayFilterByTags: UU5.PropTypes.bool,

    initialCollapseBars: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    let sortItems = [
      {
        key: "code",
        name: { cs: "Kód", en: "Code" }
      },
      {
        key: "filename",
        name: { cs: "Název souboru", en: "Filename" }
      },
      {
        key: "sys.mts",
        name: { cs: "Datum změny", en: "Modification Time" }
      }
    ];

    return {
      uuCmdListBinaries: "uu-app-binarystore/listBinaries",
      uuCmdCreateBinary: "uu-app-binarystore/createBinary",
      uuCmdUpdateBinary: "uu-app-binarystore/updateBinary",
      uuCmdUpdateBinaryData: "uu-app-binarystore/updateBinaryData",
      uuCmdDeleteBinary: "uu-app-binarystore/deleteBinary",
      uuCmdGetBinaryData: "uu-app-binarystore/getBinaryData",
      uuCmdGetBinaryDataUri: undefined,

      thumbnailStrategy: "createAll",

      sortItems: sortItems,
      sortValues: [{ key: "sys.mts", descending: true }],
      dndEnabled: true,
      searchKeyList: ["code", "filename", "sys.mts", "tagList"],

      selectable: "none",
      selectableOnly: false,

      displayCreateButton: true,

      outputMaxHeight: undefined,
      outputMaxWidth: undefined,
      outputQuality: undefined,

      headerHidden: false,

      allowCustomTags: false,
      ignoreTags: undefined,
      onTagCreate: undefined,
      availableTags: undefined,
      readOnly: false,
      sizeLimit: undefined,

      createButtonFileCodeRule: undefined,
      dndFileCodeRule: undefined,
      bulkActions: undefined,

      displayInfoBar: true,
      displayFilterBar: true,
      displayFilterByTags: true,

      initialCollapseBars: undefined
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._sharingOptions = {
      default: [
        {
          label: Lsi.LSI_LABEL_FILE_MANAGER_SHARE_TYPE_CODE,
          value: "${code}",
          codeStyle: "text"
        },
        {
          label: Lsi.LSI_LABEL_FILE_MANAGER_SHARE_TYPE_URI,
          value: Calls.getCommandUri(this.props.baseUri, "uu-app-binarystore/getBinaryData") + "?code=${code}",
          codeStyle: "text"
        }
      ]
    };

    let strategies = this._getCodeStrategies(this.props);

    this._settings = {
      baseUri: this.props.baseUri,
      uuCmdCreateBinary: this.props.uuCmdCreateBinary,
      uuCmdUpdateBinary: this.props.uuCmdUpdateBinary,
      uuCmdUpdateBinaryData: this.props.uuCmdUpdateBinaryData,
      uuCmdDeleteBinary: this.props.uuCmdDeleteBinary,
      uuCmdGetBinaryData: this.props.uuCmdGetBinaryData,
      uuCmdGetBinaryDataUri: this.props.uuCmdGetBinaryDataUri,
      uuCmdListThumbnails: this.props.uuCmdListThumbnails,
      uuCmdCreateThumbnail: this.props.uuCmdCreateThumbnail || this.props.uuCmdCreateBinary,
      uuCmdUpdateThumbnailData: this.props.uuCmdUpdateThumbnailData || this.props.uuCmdUpdateBinaryData,
      uuCmdDeleteThumbnail: this.props.uuCmdDeleteThumbnail || this.props.uuCmdDeleteBinary,
      uuCmdGetThumbnailData: this.props.uuCmdGetThumbnailData || this.props.uuCmdGetBinaryData,
      uuCmdGetThumbnailDataUri: this.props.uuCmdGetThumbnailDataUri || this.props.uuCmdGetBinaryDataUri,
      thumbnailStrategy: this.props.thumbnailStrategy,

      ...strategies,

      outputMaxHeight: this.props.outputMaxHeight,
      outputMaxWidth: this.props.outputMaxWidth,
      outputQuality: this.props.outputQuality,

      sharingOptions: this.props.sharingOptions ? this.props.sharingOptions : this._sharingOptions
    };

    this._lsiLabels = {
      header: Lsi.LSI_LABEL_FILE_MANAGER,
      barHeader: Lsi.LSI_LABEL_FILE_MANAGER_HEADER,
      searchPlaceholder: Lsi.LSI_LABEL_FILE_MANAGER_SEARCH_PLACEHOLDER,
      noBinariesWarning: Lsi.LSI_LABEL_FILE_MANAGER_EMPTY_WARNING,
      addBinaryFormHeader: Lsi.LSI_LABEL_ADD_BINARY,
      addBinariesFormHeader: Lsi.LSI_LABEL_ADD_BINARIES,
      updateBinaryFormHeader: Lsi.LSI_LABEL_UPDATE_BINARY,
      deleteBinaryFormHeader: Lsi.LSI_LABEL_DELETE_BINARY,
      shareBinaryFormHeader: Lsi.LSI_LABEL_FILE_MANAGER_SHARE_HEADER,
      dndAreaPlaceholder: Lsi.LSI_LABEL_FILE_MANAGER_DROP_BAR_CONTENT,
      dndAreaUploadSuccessMsg: Lsi.LSI_LABEL_FILE_MANAGER_UPLOAD_RESULT_SUCCESS,
      dndAreaUploadFailedMsg: Lsi.LSI_LABEL_FILE_MANAGER_UPLOAD_RESULT_FAILED,
      deleteBinaryConfirmMsg: Lsi.LSI_LABEL_DELETE_BINARY_SUCCESS_CONFIRM_MSG,
      previewFormError: Lsi.LSI_LABEL_FILE_MANAGER_PREVIEW_ERROR,
      fileSizeExceededError: Lsi.LSI_LABEL_ADD_BINARY_FILE_SIZE_EXCEEDED,
      addBinaryFormFile: Lsi.LSI_LABEL_ADD_BINARY_FILE,
      addBinaryFormFileRequired: Lsi.LSI_LABEL_ADD_BINARY_FILE_REQUIRED,
      deleteBinaryFormContent: Lsi.LSI_LABEL_DELETE_BINARY_MSG,
      updateBinaryMetaDataFormHeader: Lsi.LSI_UPDATE_BINARY_META_DATA_FORM_HEADER
    };
    if (this.props.lsiLabels) {
      for (let key in this.props.lsiLabels) {
        this._lsiLabels[key] = this.props.lsiLabels[key];
      }
    }

    this._fileButtons = this._computeFileButtons();

    this._thumbnailMap = {};

    this._noThumbnailImageList = [];

    this._isDndAllowed = this.props.dndEnabled && !this.props.readOnly && !detectMobileBrowser();
    this._onDragEnterCounter = 0;

    let binaries = [];
    let thumbnailMap = {};
    let state = "loading";

    if (this.props.fileList) {
      if (this.props.thumbnailList) {
        for (let i = 0; i < this.props.fileList.length; i++) {
          if (!this.props.fileList[i].code.match(/_th$/)) {
            binaries.push(this._buildBinaryJson(this.props.fileList[i]));
          }
        }
        for (let i = 0; i < this.props.thumbnailList.length; i++) {
          if (this.props.thumbnailList[i].code.match(/_th$/)) {
            thumbnailMap[this.props.thumbnailList[i].code] = this.props.thumbnailList[i];
          }
        }
      } else {
        for (let i = 0; i < this.props.fileList.length; i++) {
          if (!this.props.fileList[i].code.match(/_th$/)) {
            binaries.push(this._buildBinaryJson(this.props.fileList[i]));
          } else {
            thumbnailMap[this.props.fileList[i].code] = this.props.fileList[i];
          }
        }
      }
      state = "ready";
    }

    return {
      state: state,
      type: "full",
      binaries: binaries,
      thumbnailMap: thumbnailMap,
      displayCreateButton: this._processDisplayCreateButton(),
      dndHover: false,
      collapseBars: this.props.initialCollapseBars
    };
  },

  componentWillMount() {
    if (this.props.customCodeStrategy) {
      UU5.Common.Tools.warning(
        'Property "customCodeStrategy" is deprecated! Use properties "createButtonFileCodeRule" and "dndFileCodeRule" instead.'
      );
    }
  },

  componentDidMount() {
    if (!this.props.fileList) {
      this._listBinaries(0);
    }

    if (this.props.fileList && this.props.thumbnailStrategy === "createAll") {
      this._migrateImagesWithoutThumbnail();
    }
  },

  componentWillReceiveProps(nextProps) {
    let strategies = this._getCodeStrategies(nextProps);

    this._settings = {
      baseUri: nextProps.baseUri,
      uuCmdCreateBinary: nextProps.uuCmdCreateBinary,
      uuCmdUpdateBinary: nextProps.uuCmdUpdateBinary,
      uuCmdUpdateBinaryData: nextProps.uuCmdUpdateBinaryData,
      uuCmdDeleteBinary: nextProps.uuCmdDeleteBinary,
      uuCmdGetBinaryData: nextProps.uuCmdGetBinaryData,
      uuCmdGetBinaryDataUri: nextProps.uuCmdGetBinaryDataUri,
      uuCmdListThumbnails: nextProps.uuCmdListThumbnails,
      uuCmdCreateThumbnail: nextProps.uuCmdCreateThumbnail || nextProps.uuCmdCreateBinary,
      uuCmdUpdateThumbnailData: nextProps.uuCmdUpdateThumbnailData || nextProps.uuCmdUpdateBinaryData,
      uuCmdDeleteThumbnail: nextProps.uuCmdDeleteThumbnail || nextProps.uuCmdDeleteBinary,
      uuCmdGetThumbnailData: nextProps.uuCmdGetThumbnailData || nextProps.uuCmdGetBinaryData,
      uuCmdGetThumbnailDataUri: nextProps.uuCmdGetThumbnailDataUri || nextProps.uuCmdGetBinaryDataUri,
      thumbnailStrategy: nextProps.thumbnailStrategy,

      ...strategies,

      outputMaxHeight: nextProps.outputMaxHeight,
      outputMaxWidth: nextProps.outputMaxWidth,
      outputQuality: nextProps.outputQuality,

      sharingOptions: nextProps.sharingOptions ? nextProps.sharingOptions : this._sharingOptions
    };

    this._isDndAllowed = nextProps.dndEnabled && !detectMobileBrowser();

    if (
      this.props.fileButtons !== nextProps.fileButtons ||
      this.props.customFileButtons !== nextProps.customFileButtons ||
      this.props.readOnly !== nextProps.readOnly
    ) {
      this._fileButtons = this._computeFileButtons(nextProps);
    }

    if (this.props.displayCreateButton !== nextProps.displayCreateButton) {
      this.setState({ displayCreateButton: this._processDisplayCreateButton(nextProps) });
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  addFile(binary) {
    let binaryToPush = this._buildBinaryJson(binary);
    this.setState(prevState => {
      let binaries = [...prevState.binaries];
      binaries.push(binaryToPush);
      return { binaries: binaries };
    });
  },

  getFile(binaryCode) {
    let binary = null;
    for (let i = 0; i < this.state.binaries.length; i++) {
      if (binaryCode === this.state.binaries[i].binary.code) {
        binary = this.state.binaries[i].binary;
        break;
      }
    }
    return binary;
  },

  updateFile(binary) {
    let selectedItemList = this._listController.getSelectedItemList();

    let inMethodSetState = () =>
      this.setState(prevState => {
        let binaries = prevState.binaries;
        for (let i = 0; i < binaries.length; i++) {
          if (binaries[i].code === binary.code) {
            binaries = [...binaries];
            binaries[i] = this._buildBinaryJson({ ...binary });
            break;
          }
        }
        return { binaries: binaries };
      });

    let isSelected = false;
    selectedItemList.forEach(selectedItem => {
      if (selectedItem.code === binary.code) {
        isSelected = true;
        selectedItem = this._buildBinaryJson({ ...binary });
        this._listController.addSelectedItem(selectedItem, inMethodSetState());
      }
    });

    if (!isSelected) {
      inMethodSetState();
    }
  },

  deleteFile(binaryCode) {
    this._listController.removeSelectedItem(binaryCode, () =>
      this.setState(prevState => {
        let binaries = prevState.binaries;
        for (let i = 0; i < binaries.length; i++) {
          if (binaries[i].binary.code === binaryCode) {
            binaries = [...binaries];
            binaries.splice(i, 1);
            break;
          }
        }
        return { binaries: binaries };
      })
    );
  },

  setThumbnail(thumbnail) {
    this.setState(prevState => {
      let thumbnailMap = { ...prevState.thumbnailMap };
      thumbnailMap[thumbnail.code] = thumbnail;
      return { thumbnailMap: thumbnailMap };
    });
  },

  unsetThumbnail(thumbnail) {
    this.setState(prevState => {
      let thumbnailMap = { ...prevState.thumbnailMap };
      delete thumbnailMap[thumbnail];
      return { thumbnailMap: thumbnailMap };
    });
  },

  getThumbnail(thumbnailCode) {
    return this.state.thumbnailMap[thumbnailCode];
  },

  customAddSelectedItem(tileId) {
    if (this.props.selectable === "single") {
      this._listController.clearSelected();
    }
    this._listController.addSelectedItem(tileId);
  },

  customRemoveSelectedItem(tileId) {
    this._listController.removeSelectedItem(tileId);
  },

  getSelectedFiles() {
    return this._listController.getSelectedItemList();
  },
  //@@viewOff:interface

  //@@viewOn:overriding
  pasteFiles_(blobs) {
    if (!this.props.readOnly) {
      blobs = blobs.slice(-1);
      if (blobs.length > 0) {
        this._addFiles(blobs[0]);
      }
    }
  },
  //@@viewOff:overriding

  //@@viewOn:private
  _processDisplayCreateButton(props = this.props) {
    let result = props.displayCreateButton;
    if (result === true) {
      result = { xs: "texticon" };
    }
    if (result) {
      result = parseScreenSizeProp(result, "texticon", value => {
        return {
          displayText: !!value.match("text"),
          displayIcon: !!value.match("icon")
        };
      });
    }

    return result;
  },

  _getCodeStrategies(props = this.props) {
    let createButtonFileCodeRule = props.createButtonFileCodeRule;
    let dndFileCodeRule = props.dndFileCodeRule;

    if (props.customCodeStrategy) {
      if (!createButtonFileCodeRule) {
        if (props.customCodeStrategy === "none") {
          createButtonFileCodeRule = "none";
        } else if (props.customCodeStrategy === "single" || props.customCodeStrategy === "multi") {
          createButtonFileCodeRule = "notRequired";
        } else if (props.customCodeStrategy === "singleRequired" || props.customCodeStrategy === "multiRequired") {
          createButtonFileCodeRule = "required";
        }
      }

      if (!dndFileCodeRule) {
        if (
          props.customCodeStrategy === "none" ||
          props.customCodeStrategy === "single" ||
          props.customCodeStrategy === "singleRequired"
        ) {
          dndFileCodeRule = "none";
        } else if (props.customCodeStrategy === "multi") {
          dndFileCodeRule = "notRequired";
        } else if (props.customCodeStrategy === "multiRequired") {
          dndFileCodeRule = "required";
        }
      }
    }

    return {
      createButtonFileCodeRule: createButtonFileCodeRule || "notRequired",
      dndFileCodeRule: dndFileCodeRule || "none"
    };
  },

  _getType(binary) {
    let type;
    let icon;
    let thumbnail = "icon";
    let clickable = false;

    if (binary.contentType.match(/\/svg/)) {
      type = "svg";
      icon = "mdi-file-image";
      thumbnail = "original";
      clickable = true;
    } else if (binary.contentType.match(/image\//)) {
      type = "image";
      icon = "mdi-file-image";
      thumbnail = "thumbnail";
      clickable = true;
    } else if (binary.contentType.match(/\/pdf/)) {
      type = "pdf";
      icon = "mdi-file-pdf";
      clickable = true;
    } else if (binary.contentType.match(/(\/html)|(\/xml)/)) {
      type = "xml";
      icon = "mdi-file-xml";
    } else if (binary.contentType.match(/(\/text$)|(^text\/)/)) {
      type = "text";
      icon = "mdi-file-document";
    } else if (binary.contentType.match(/\/json/)) {
      type = "json";
      icon = "mdi-json";
    } else if (binary.filename && binary.filename.match(/(\.rar$)|(\.zip$)|(\.7z$)|(\.tgz$)|(\.tar$)|(\.tar\.gz$)/)) {
      type = "archive";
      icon = "mdi-package";
    } else {
      type = "other";
      icon = "mdi-file";
    }

    return {
      type: type,
      icon: icon,
      thumbnail: thumbnail,
      clickable: clickable
    };
  },

  _buildBinaryJson(dtoOut) {
    let type = this.props.onSetFileType ? this.props.onSetFileType(dtoOut) : this._getType(dtoOut);
    let binaryObj = {};
    for (let i = 0; i < this.props.sortItems.length; i++) {
      // this method allows to read "a.b.c" of dtoOut as dtoOut[a][b][c] - in case of sys.mts or other
      binaryObj[this.props.sortItems[i].key] = this.props.sortItems[i].key.split(".").reduce(this._getVarOnKey, dtoOut);
    }
    binaryObj.id = dtoOut.code;
    binaryObj.binary = dtoOut;
    binaryObj.type = type.type;
    binaryObj.icon = type.icon;
    binaryObj.thumbnailType = type.thumbnail;
    binaryObj.clickable = type.clickable;
    return binaryObj;
  },

  _filterBinariesByTags(binaries, ignoreTags) {
    if (!ignoreTags || ignoreTags.length === 0) {
      return binaries;
    }

    return binaries.filter(
      binary => !binary.binary.tagList || binary.binary.tagList.every(tag => ignoreTags.indexOf(tag) === -1)
    );
  },

  _getBinaries() {
    return this._filterBinariesByTags(this.state.binaries, this.props.ignoreTags);
  },

  _computeFileButtons(
    { fileButtons, deprecatedCustomFileButtons, readOnly, availableTags, allowCustomTags } = this.props
  ) {
    let result;
    let usingDeprecatedProp = false;
    if (fileButtons) {
      result = { ...fileButtons };
    } else if (deprecatedCustomFileButtons) {
      usingDeprecatedProp = true;
      result = { ...deprecatedCustomFileButtons };
    } else {
      result = {
        hideDropdown: false,
        itemList: ["share", "download", "update", "updateTags", "delete"]
      };
    }

    // filter updateTags if tags are not used
    if (result.itemList && !availableTags && !allowCustomTags) {
      result.itemList = result.itemList.filter(item => item !== "updateTags");
    }

    // filter active items
    if (result.itemList && readOnly) {
      result.itemList = result.itemList.filter(item => item !== "update" && item !== "updateTags" && item !== "delete");
    }

    // filter items for sharing if share is not available
    if (result.itemList && typeof this.props.uuCmdGetBinaryData === "function" && !this.props.onFileShare) {
      // cannot show file URL in share form because we dont know what uuCmd getBinaryData does and what is shape of server request if is any
      // => filter share button if component does not have its own share form
      result.itemList = result.itemList.filter(item => item !== "share");
    }

    if (Array.isArray(result.itemList)) {
      if (usingDeprecatedProp) {
        result.itemList.forEach(item => {
          if (item.icon) item.active = true;
        });
      }
      result.itemList = result.itemList.map(item => {
        let result = null;
        if (typeof item === "string") {
          switch (item) {
            case "share":
              result = {
                label: Lsi.LSI_LABEL_FILE_MANAGER_TILE_DROPDOWN_SHARE,
                isDownload: false,
                onClick: this._openShareBinaryForm,
                icon: "mdi-content-copy",
                active: true
              };
              break;
            case "download":
              result = {
                label: Lsi.LSI_LABEL_FILE_MANAGER_TILE_DROPDOWN_DOWNLOAD,
                isDownload: true
              };
              break;
            case "update":
              result = {
                label: Lsi.LSI_LABEL_FILE_MANAGER_TILE_DROPDOWN_UPDATE,
                isDownload: false,
                onClick: this._openUpdateBinaryFileDialog,
                icon: "mdi-pencil",
                active: true
              };
              break;
            case "updateTags":
              result = {
                label: Lsi.LSI_LABEL_FILE_MANAGER_TILE_DROPDOWN_UPDATE_TAGS,
                isDownload: false,
                onClick: this._openUpdateBinaryDialog,
                icon: "mdi-tag",
                active: true
              };
              break;
            case "delete":
              result = {
                label: Lsi.LSI_LABEL_FILE_MANAGER_TILE_DROPDOWN_DELETE,
                isDownload: false,
                onClick: this._deleteBinary
              };
              break;
          }
        } else {
          result = item;
        }
        return result;
      });
    }

    return result;
  },

  _shouldListNext(pageInfo) {
    // pageIndex is 0-based
    return (pageInfo.pageIndex + 1) * pageInfo.pageSize < pageInfo.total;
  },

  _listBinariesDone(dtoOut, pageIndex) {
    this.setState(prevState => {
      let filteredBinaries = [];
      let thumbnailMap = { ...prevState.thumbnailMap };
      for (let i = 0; i < dtoOut.itemList.length; i++) {
        if (!dtoOut.itemList[i].code.match(/_th$/)) {
          filteredBinaries.push(this._buildBinaryJson(dtoOut.itemList[i]));
        } else {
          thumbnailMap[dtoOut.itemList[i].code] = dtoOut.itemList[i];
        }
      }
      return {
        binaries: prevState.binaries.concat(filteredBinaries),
        thumbnailMap: thumbnailMap
      };
    });
    this._shouldListNext(dtoOut.pageInfo)
      ? this._listBinaries(pageIndex + 1)
      : this.props.uuCmdListThumbnails
      ? this._listThumbnails(0)
      : this._finishListBinaries();
  },

  _listBinariesFail(dtoOut) {
    this.setState({ state: "error" });
  },

  _listBinaries(pageIndex) {
    // create data object
    const data = { pageInfo: JSON.stringify({ pageSize: 1000, pageIndex: pageIndex }) };
    const done = dtoOut => this._listBinariesDone(dtoOut, pageIndex);
    const fail = this._listBinariesFail;

    if (typeof this.props.uuCmdListBinaries === "function") {
      this.props.uuCmdListBinaries(data).then(done, fail);
    } else {
      let myDtoIn = { data, done, fail };
      Calls.customGetCmd(this.props.baseUri, this.props.uuCmdListBinaries, myDtoIn);
    }
  },

  _listThumbnailsDone(dtoOut, pageIndex) {
    this.setState(
      prevState => {
        let thumbnailMap = { ...prevState.thumbnailMap };
        for (let i = 0; i < dtoOut.itemList.length; i++) {
          if (dtoOut.itemList[i].code.match(/_th$/)) {
            thumbnailMap[dtoOut.itemList[i].code] = dtoOut.itemList[i];
          }
        }
        return { thumbnailMap: thumbnailMap };
      },
      () => (this._shouldListNext(dtoOut.pageInfo) ? this._listThumbnails(pageIndex + 1) : this._finishListBinaries())
    );
  },
  _listThumbnailsFail(dtoOut) {
    this.setState({ state: "error" });
  },

  _listThumbnails(pageIndex) {
    if (this.props.thumbnailStrategy !== "none") {
      const data = { pageInfo: JSON.stringify({ pageSize: 1000, pageIndex: pageIndex }) };
      const done = dtoOut => this._listThumbnailsDone(dtoOut, pageIndex);
      const fail = this._listThumbnailsFail;
      const cmd = this.props.uuCmdListThumbnails || this.props.uuCmdListBinaries;

      if (typeof cmd === "function") {
        cmd(data).then(done, fail);
      } else {
        const myDtoIn = { data, done, fail };
        Calls.customGetCmd(this.props.baseUri, cmd, myDtoIn);
      }
    } else {
      this._finishListBinaries();
    }
  },

  _finishListBinaries() {
    this.setState({ state: "ready" });
    if (this.props.thumbnailStrategy === "createAll") {
      this._migrateImagesWithoutThumbnail();
    }
  },

  _migrateImagesWithoutThumbnail() {
    let binaries = this.state.binaries;

    for (let i = 0; i < binaries.length; i++) {
      let code = binaries[i].binary.code.length > 61 ? binaries[i].binary.code.substr(0, 61) : binaries[i].binary.code;
      if (binaries[i].thumbnailType === "thumbnail" && !this.state.thumbnailMap[code + "_th"]) {
        this._noThumbnailImageList.push(binaries[i].code);
      }
    }

    this._migrateImage(0);
  },

  _migrateImageDone(data, header, index) {
    let blob = new Blob([data], { type: header });
    this._saveThumbnail(
      this._noThumbnailImageList[index],
      blob,
      index,
      () => {
        this._migrateImage(index + 1);
        this._saveOriginalAsThumbnail(this._noThumbnailImageList[index], blob);
      },
      thumbnailDtoOut => {
        this.setThumbnail(thumbnailDtoOut);
        this._migrateImage(index + 1);
      },
      true
    );
  },

  _migrateImageFail(dtoOut, index) {
    this._migrateImage(index + 1);
  },

  _migrateImage(index) {
    if (this._noThumbnailImageList[index]) {
      const data = { code: this._noThumbnailImageList[index] };
      const done = (data, header) => this._migrateImageDone(data, header, index);
      const fail = dtoOut => this._migrateImageFail(dtoOut, index);
      if (typeof this._settings.uuCmdGetBinaryData === "function") {
        this._settings.uuCmdGetBinaryData(data).then(done, fail);
      } else {
        let dtoIn = {
          data,
          done,
          fail
        };
        Calls.customGetNotTransformedCmd(this.props.baseUri, this._settings.uuCmdGetBinaryData, dtoIn);
      }
    }
  },

  _saveThumbnail(code, file, index, onFail, onSuccess, isMigration) {
    let imageEncoding = "image/jpeg";
    let imageQuality = 0.85;

    let fileLoader = new FileReader();
    let canvas = document.createElement("canvas");
    let context = null;
    let imageObj = new Image();

    if (
      (isMigration && this.props.thumbnailStrategy === "createAll") ||
      (!isMigration && (this.props.thumbnailStrategy === "createAll" || this.props.thumbnailStrategy === "createNew"))
    ) {
      fileLoader.readAsDataURL(file);
    } else {
      onFail();
    }

    fileLoader.onload = () => {
      let data = fileLoader.result;
      imageObj.src = data;
    };

    imageObj.onerror = e => {
      onFail();
    };

    imageObj.onload = () => {
      // Check for empty images
      if (imageObj.width === 0 || imageObj.height === 0) {
        UU5.Common.Tools.warning("Image is empty");
        onFail();
      } else {
        let canvasProps = this._calculateCanvasSize(imageObj.width, imageObj.height);

        canvas.id = "file-manager-hidden-canvas";
        canvas.width = canvasProps.canvasWidth;
        canvas.height = canvasProps.canvasHeight;
        canvas.style.visibility = "hidden";
        document.body.appendChild(canvas);

        context = canvas.getContext("2d");

        context.fillStyle = "white";
        context.fillRect(0, 0, canvasProps.canvasWidth, canvasProps.canvasHeight);
        context.drawImage(imageObj, 0, 0, canvasProps.canvasWidth, canvasProps.canvasHeight);

        let dataURI = canvas.toDataURL(imageEncoding, imageQuality);

        let byteString = atob(dataURI.split(",")[1]);

        let mimeString = dataURI
          .split(",")[0]
          .split(":")[1]
          .split(";")[0];

        let ab = new ArrayBuffer(byteString.length);
        let ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
        }

        let blob = new Blob([ab], { type: mimeString });
        document.body.removeChild(canvas);

        let dtoIn = {
          done: thumbnailDtoOut => {
            onSuccess(thumbnailDtoOut);
          },
          fail: () => {
            onFail();
          },
          data: {
            code: (code.length > 61 ? code.substr(0, 61) : code) + "_th",
            data: blob
          }
        };
        if (typeof this._settings.uuCmdCreateThumbnail === "function") {
          this._settings.uuCmdCreateThumbnail(dtoIn.data).then(dtoIn.done, dtoIn.fail);
        } else {
          Calls.customPostMultipartCmd(this.props.baseUri, this._settings.uuCmdCreateThumbnail, dtoIn);
        }
      }
    };
  },

  _saveOriginalAsThumbnail(code, data) {
    code = code.length > 61 ? code.substr(0, 61) : code;
    let dtoIn = {
      done: () => {},
      fail: () => {},
      data: {
        code: code + "_th",
        data: data
      }
    };
    if (typeof this._settings.uuCmdCreateThumbnail === "function") {
      this._settings.uuCmdCreateThumbnail(dtoIn.data).then(dtoIn.done, dtoIn.fail);
    } else {
      Calls.customPostMultipartCmd(this.props.baseUri, this._settings.uuCmdCreateThumbnail, dtoIn);
    }
  },

  _calculateCanvasSize(imgWidth, imgHeight) {
    let canvasWidth = 512;
    let canvasHeight = 512;

    // Shrink to fit the whole rectangle, if any side is bigger than canvas side
    if (imgHeight > canvasHeight || imgWidth > canvasWidth) {
      if (imgHeight / canvasHeight > imgWidth / canvasWidth) {
        // scale by height
        imgWidth = imgWidth / (imgHeight / canvasHeight);
        imgHeight = canvasHeight;
      } else {
        // scale by width
        imgHeight = imgHeight / (imgWidth / canvasWidth);
        imgWidth = canvasWidth;
      }
    }

    // Recalculate canvas size, if img is too small
    canvasHeight = Math.min(canvasHeight, imgHeight);
    canvasWidth = Math.min(canvasWidth, imgWidth);

    return {
      canvasWidth: Math.ceil(canvasWidth),
      canvasHeight: Math.ceil(canvasHeight)
    };
  },

  _openFileDialogue(type) {
    let inputComp = type === "add" ? this._fileFormAdd : this._fileFormUpdate;

    // empty the File's value because if not emptied, choosing the same file twice will not trigger onChange
    let input = UU5.Common.DOM.findNode(inputComp);
    if (input) {
      input = input.querySelector("input");
      if (input) input.value = "";
    }

    inputComp._open();
  },

  _addFiles(files) {
    files = Array.isArray(files) ? files : [files];

    this._dropBar.setFiles(files, {
      customCodesEnabled: this._settings.createButtonFileCodeRule !== "none",
      customCodesRequired: this._settings.createButtonFileCodeRule === "required"
    });
  },

  _deleteBinary(binary, type) {
    if (this.props.onFileDelete) {
      this.props.onFileDelete(binary, type);
    } else {
      let thumbnail = (binary.code.length > 61 ? binary.code.substr(0, 61) : binary.code) + "_th";
      this._formController.openDeleteBinaryForm(
        binary,
        this.state.thumbnailMap[thumbnail],
        this.unsetThumbnail,
        this.deleteFile
      );
    }
  },

  _openUpdateBinaryFileDialog(binary, type) {
    if (this.props.onFileUpdate) {
      this.props.onFileUpdate(binary, type);
    } else {
      this._binaryToUpdate = binary;
      this._openFileDialogue("update");
    }
  },

  _openUpdateBinaryDialog(binary, type) {
    if (this.props.onFileInfoUpdate) {
      this.props.onFileInfoUpdate(binary, type);
    } else {
      this._formController.openUpdateBinaryMetaDataForm(binary, this.updateFile);
    }
  },

  _updateBinary(binary) {
    let thumbnailCode =
      (this._binaryToUpdate.code.length > 61 ? this._binaryToUpdate.code.substr(0, 61) : this._binaryToUpdate.code) +
      "_th";
    this._formController.openUpdateBinaryForm(
      binary,
      this._binaryToUpdate,
      this.state.thumbnailMap[thumbnailCode],
      this.setThumbnail,
      this.unsetThumbnail,
      this.updateFile
    );
  },

  _openDnDForm(fileList, onSave, formProps) {
    this._formController.openDnDForm(fileList, onSave, formProps);
  },

  _openShareBinaryForm(file, type) {
    if (this.props.onFileShare) {
      this.props.onFileShare(file, type);
    } else {
      this._formController.openShareBinaryForm(file, type);
    }
  },

  _getActions(screenSize) {
    let actions = [];

    // displayCreateButton is false or object with screen size keys
    if (this.state.displayCreateButton) {
      actions.push({
        content: this.state.displayCreateButton[screenSize].displayText
          ? this._lsiLabels.addBinaryFormHeader
          : undefined,
        icon: this.state.displayCreateButton[screenSize].displayIcon ? "mdi-upload" : null,
        onClick: () => (this.props.onFileCreate ? this.props.onFileCreate() : this._openFileDialogue("add")),
        active: true,
        controlledContent: true
      });
    }

    this.state.type !== "full" &&
      actions.push({
        content: "",
        onClick: () => this._setType("full"),
        icon: "mdi-view-grid",
        active: true
      });

    this.state.type !== "small" &&
      actions.push({
        content: "",
        onClick: () => this._setType("small"),
        icon: "mdi-view-headline",
        active: true
      });

    return actions;
  },

  _setType(type) {
    this.state.type !== type && this.setState({ type: type });
  },

  _getVarOnKey(obj, i) {
    return obj[i];
  },

  _getAttrValue(obj, attr) {
    return attr.split(".").reduce(this._getVarOnKey, obj);
  },

  _attrContainsValue(attrValue, value) {
    if (!attrValue || !value) return false;

    let result;
    if (Array.isArray(attrValue)) {
      result = attrValue.some(item => item && item.toLowerCase().indexOf(value) !== -1);
    } else {
      result = attrValue.toLowerCase().indexOf(value) !== -1;
    }

    return result;
  },

  _matchSearch(item, value) {
    let fragments = value.toLowerCase().split(/[\s]/);
    let match = false;

    for (let i = 0; i < this.props.searchKeyList.length; i++) {
      let attrVal = this._getAttrValue(item.binary, this.props.searchKeyList[i]);

      if (fragments.some(frag => this._attrContainsValue(attrVal, frag))) {
        match = true;
        break;
      }
    }

    return match;
  },

  _uploadFiles(fileList, codeList, tagList, shouldAdjustFile) {
    if (!this._dndStats || this._dndStats.finished) {
      let fileStats = [];
      for (let i = 0; i < fileList.length; i++) {
        fileStats.push({ name: fileList[i].name, state: i === 0 ? "started" : "waiting" });
      }
      this._dndStats = { index: 0, fileStats, fileList, codeList, tagList };
      this._dropBar.setProgress(this._dndStats.fileStats);
      this._uploadFile(shouldAdjustFile);
    } else {
      for (let i = 0; i < fileList.length; i++) {
        this._dndStats.fileStats.push({
          name: fileList[i].name,
          state: "waiting"
        });
      }
      this._dndStats.fileList = this._dndStats.fileList.concat(fileList);
      this._dndStats.codeList && (this._dndStats.codeList = this._dndStats.codeList.concat(codeList));
      this._dndStats.tagList && (this._dndStats.tagList = this._dndStats.tagList.concat(tagList));
      this._dropBar.setProgress(this._dndStats.fileStats);
    }
  },

  _callUploadFileDone(dtoOut, index, shouldAdjustFile) {
    this._saveThumbnail(
      dtoOut.code,
      this._dndStats.fileList[index],
      index,
      () => {
        this._dndStats.fileStats[index].state = "success";
        this._dndStats.fileStats[index + 1] && (this._dndStats.fileStats[index + 1].state = "started");
        this._dropBar.setProgress(this._dndStats.fileStats);
        this.addFile(dtoOut);
        this._dndStats.index++;
        this._uploadFile(shouldAdjustFile);
      },
      thumbnailDtoOut => {
        this._dndStats.fileStats[index].state = "success";
        this._dndStats.fileStats[index + 1] && (this._dndStats.fileStats[index + 1].state = "started");
        this._dropBar.setProgress(this._dndStats.fileStats);
        this.setThumbnail(thumbnailDtoOut);
        this.addFile(dtoOut);
        this._dndStats.index++;
        this._uploadFile(shouldAdjustFile);
      },
      false
    );
  },

  _callUploadFileFail(shouldAdjustFile, message) {
    this._dndStats.fileStats[this._dndStats.index].state = "failed";
    this._dndStats.fileStats[this._dndStats.index].message = message;
    this._dropBar.setProgress(this._dndStats.fileStats);
    this._dndStats.index++;
    this._uploadFile(shouldAdjustFile);
  },

  _callUploadFile(file, index, shouldAdjustFile) {
    if (file) {
      // validate maximal size of image
      if (file.size && file.size > getMaxFileSize(this.props.sizeLimit) * 1024) {
        return this._callUploadFileFail(
          shouldAdjustFile,
          <UU5.Bricks.Lsi
            lsi={Lsi.LSI_LABEL_ADD_BINARY_FILE_SIZE_EXCEEDED}
            params={{ maxSize: this.props.sizeLimit }}
          />
        );
      }
      const data = { data: file };
      const done = dtoOut => this._callUploadFileDone(dtoOut, index, shouldAdjustFile);
      const fail = this._callUploadFileFail;

      if (this._dndStats.codeList && this._dndStats.codeList[index]) {
        data.code = this._dndStats.codeList[index];
      }

      if (this._dndStats.tagList && this._dndStats.tagList[index]) {
        data.tagList = this._dndStats.tagList[index];
      }

      if (typeof this._settings.uuCmdCreateBinary === "function") {
        this._settings.uuCmdCreateBinary(data).then(done, () => fail(shouldAdjustFile));
      } else {
        let dtoIn = {
          data,
          done,
          fail: response => {
            let message;

            if (response && response.code) {
              let code = response.code.split("/");
              code = code[code.length - 1];
              if (code === "duplicateCode") {
                message = <UU5.Bricks.Lsi lsi={Lsi.LSI_DUPLICATE_CODE} />;
              }
            }

            if (!message) {
              message = <UU5.Bricks.Lsi lsi={Lsi.LSI_DEFAULT_ERROR_MESSAGE} />;
            }

            fail(shouldAdjustFile, message);
          }
        };
        Calls.customPostMultipartCmd(this.props.baseUri, this._settings.uuCmdCreateBinary, dtoIn);
      }
    } else {
      this._dndStats.finished = true;
    }
  },

  _uploadFile(shouldAdjustFile) {
    let index = this._dndStats.index;
    if (index >= this._dndStats.fileList.length) {
      // all files uploaded => ends processing of uploading files
      this._dndStats.finished = true;
      return;
    }
    let file = this._dndStats.fileList[index];

    if (shouldAdjustFile) {
      adjustFile(file, this.props).then(
        file => this._callUploadFile(file, index, shouldAdjustFile),
        response => {
          let message;

          if (response && response.code) {
            let code = response.code.split("/");
            code = code[code.length - 1];
            if (code === "duplicateCode") {
              message = <UU5.Bricks.Lsi lsi={Lsi.LSI_DUPLICATE_CODE} />;
            }
          }

          if (!message) {
            message = <UU5.Bricks.Lsi lsi={Lsi.LSI_DEFAULT_ERROR_MESSAGE} />;
          }

          this._callUploadFileFail(shouldAdjustFile, message);
        }
      );
    } else {
      this._callUploadFile(file, index, shouldAdjustFile);
    }
  },

  _onSetFiles(fileList, opt) {
    // opt is only present if setFiles is explicitly called which only happens when uploading files using the upload button
    let customCodesEnabled = opt ? opt.customCodesEnabled : this._settings.dndFileCodeRule !== "none";
    let customCodesRequired = opt ? opt.customCodesRequired : this._settings.dndFileCodeRule === "required";

    if (customCodesEnabled || this.props.availableTags || this.props.allowCustomTags) {
      this._openDnDForm(
        fileList,
        (codeList, tagList) => {
          this._uploadFiles(fileList, codeList, tagList, false);
        },
        { customCodesEnabled, customCodesRequired }
      );
    } else {
      this._uploadFiles(fileList, undefined, undefined, true);
    }
  },

  _onTagCreate(value) {
    this.props.onTagCreate({ component: this, value });
  },

  _onDropHandler(e) {
    this._onDragEnterCounter = 0;
    this.setState({ dndHover: false });
    e.preventDefault();
    e.stopPropagation();
    let files = [];

    if (e.dataTransfer.items) {
      // Use DataTransfer interface to access the file(s)
      for (let i = 0; i < e.dataTransfer.files.length; i++) {
        if (e.dataTransfer.files[i].type || e.dataTransfer.files[i].size % 4096 !== 0) {
          let file = e.dataTransfer.files[i];
          files.push(file);
        }
      }
    }

    this._onSetFiles(files);
  },

  _onDragOverHandler(e) {
    e.preventDefault();
    e.stopPropagation();
  },

  _onDragEnterHandler(e) {
    this._onDragEnterCounter++;
    !this.state.dndHover && this.setState({ dndHover: true });
    e.preventDefault();
    e.stopPropagation();
  },

  _onDragEndHandler(e) {
    this._onDragEnterCounter = 0;
    this.setState({ dndHover: false });
    e.preventDefault();
    e.stopPropagation();
  },

  _onDragLeaveHandler(e) {
    this._onDragEnterCounter--;
    this._onDragEnterCounter <= 0 && this.setState({ dndHover: false });
    e.preventDefault();
    e.stopPropagation();
  },

  _getFilterableTags() {
    // returns only tags of non ignored files
    let binaries = this._getBinaries();
    if (!binaries) return null;

    // fill set by tags from binaries
    let binariesTags = new Set();
    binaries.forEach(file => {
      if (file.binary.tagList) {
        file.binary.tagList.forEach(tag => binariesTags.add(tag));
      }
    });

    // sort all tags
    let result = [...binariesTags];
    return result.sort();
  },

  _getBulkActions() {
    let result = [];

    let { bulkActions } = this.props;
    if (Array.isArray(bulkActions)) {
      result = result.concat(bulkActions);
    }

    return result;
  },

  _registerListController(controller) {
    this._listController = controller;
  },

  _onSelect(opt){
    if(typeof this.props.onSelect === "function"){
      this.props.onSelect({ ...opt, component: this })
    }
  },

  _getChild() {
    // let tileHeight;
    let tileMinWidth;
    let tileMaxWidth;
    if (this.state.type === "full") {
      // tileHeight = this.isXs() || this.isS() ? 278 : 205;
      tileMinWidth = this.isXs() || this.isS() ? 232 : 192;
      tileMaxWidth = this.isXs() || this.isS() ? 540 : 280;
    } else {
      // tileHeight = this.isXs() || this.isS() ? 118 : 70;
      tileMinWidth = 400;
      tileMaxWidth = 800;
    }

    return [
      <FormController
        ref_={r => (this._formController = r)}
        id={UU5.Common.Tools.generateUUID()}
        settings={this._settings}
        lsiLabels={this._lsiLabels}
        key="formController"
        ignoreTags={this.props.ignoreTags}
        availableTags={this.props.availableTags}
        allowCustomTags={this.props.allowCustomTags}
        onTagCreate={typeof this.props.onTagCreate === "function" ? this._onTagCreate : undefined}
        sizeLimit={this.props.sizeLimit}
      />,
      <UU5.Forms.File
        ref_={r => (this._fileFormAdd = r)}
        key="fileFormAdd"
        hidden={true}
        multiple={true}
        onChange={e => {
          this._addFiles(e.value);
        }}
      />,
      <UU5.Forms.File
        ref_={r => (this._fileFormUpdate = r)}
        key="fileFormUpdate"
        hidden={true}
        multiple={false}
        onChange={e => {
          this._updateBinary(e.value);
        }}
      />,
      <UU5.Tiles.ListController
        ref_={this._registerListController}
        data={this._getBinaries()}
        selectable={this.props.selectable !== "none"}
        padding="none"
        onSelect={this._onSelect}
        key="tiles"
        outputMaxHeight={this.props.outputMaxHeight}
        outputMaxWidth={this.props.outputMaxWidth}
        outputQuality={this.props.outputQuality}
      >
        <UU5.Tiles.ActionBar
          title={this.getLsiItem(this._lsiLabels.barHeader)}
          actions={this._getActions(this.state.screenSize)}
          onItemSearch={this._matchSearch}
          searchPlaceHolder={this.getLsiItem(this._lsiLabels.searchPlaceholder)}
          collapsed={
            this.state.collapseBars === undefined ? this.props.selectable === "single" : this.state.collapseBars
          }
        />
        {this.props.displayFilterBar && (
          <FileManagerTypeFilter displayFilterByTags={this.props.displayFilterByTags} fileTypeFilters={this.props.fileTypeFilters} tags={this._getFilterableTags()} />
        )}
        {this.props.selectable === "multi" && !this.props.readOnly && (
          <UU5.Tiles.BulkActionBar key="bulkBar" actions={this._getBulkActions()} />
        )}
        {this.props.displayInfoBar && (
          <UU5.Tiles.InfoBar
            controller={this._listController}
            sortItems={this.props.sortItems}
            sortValues={this.props.sortValues}
            selectable={this.props.selectable === "multi" && !this.props.readOnly}
          />
        )}
        <ListWrapper
          ref_={r => (this._list = r)}
          tileHeight={"auto"}
          tileMinWidth={tileMinWidth}
          tileMaxWidth={tileMaxWidth}
          tileSpacing={8}
          rowSpacing={8}
          tileElevation={0}
          tileJustify="space-between"
          skipInnerTile={true}
          isEmpty={this.state.binaries.length === 0}
          isEmptyMessage={LsiHelper.getLsiComponent(this._lsiLabels.noBinariesWarning)}
          tile={
            <FileManagerTile
              isS={this.isXs() || this.isS()}
              fileManager={this}
              tileType={this.state.type}
              onFileClick={this.props.onFileClick ? this.props.onFileClick : null}
              uuCmdGetBinaryData={this._settings.uuCmdGetBinaryData}
              uuCmdGetBinaryDataUri={this._settings.uuCmdGetBinaryDataUri}
              uuCmdGetThumbnailData={this._settings.uuCmdGetThumbnailData}
              uuCmdGetThumbnailDataUri={this._settings.uuCmdGetThumbnailDataUri}
              getThumbnail={this.getThumbnail}
              shouldShowThumbnail={this.props.thumbnailStrategy !== "none"}
              fileButtons={this._fileButtons}
              customSelectable={this.props.readOnly ? "none" : this.props.selectable}
              selectableOnly={this.props.selectableOnly}
              onFilenameSet={this.props.onFilenameSet}
              baseUri={this.props.baseUri}
            />
          }
          wrapperAttrs={
            this._isDndAllowed
              ? {
                  onDragOver: this._onDragOverHandler,
                  onDragEnter: this._onDragEnterHandler,
                  onDrop: this._onDropHandler,
                  onDragEnd: this._onDragEndHandler,
                  onDragLeave: this._onDragLeaveHandler
                }
              : null
          }
          isHovered={this.state.dndHover}
        >
          {!this.props.readOnly && (
            <UU5.Bricks.Div className={this.getClassName("dndWrapper")}>
              <FileUploader
                ref_={r => (this._dropBar = r)}
                onSetFiles={this._onSetFiles}
                lsiLabels={{
                  placeholder: this._lsiLabels.dndAreaPlaceholder,
                  uploadSuccessMsg: this._lsiLabels.dndAreaUploadSuccessMsg,
                  uploadFailedMsg: this._lsiLabels.dndAreaUploadFailedMsg
                }}
                sizeLimit={this.props.sizeLimit}
                customCodesEnabled={this._settings.dndFileCodeRule !== "none"}
                customCodesRequired={this._settings.dndFileCodeRule === "required"}
                dndEnabled={false}
              />
            </UU5.Bricks.Div>
          )}
        </ListWrapper>
      </UU5.Tiles.ListController>
    ];
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let child;
    if (this.state.state === "loading") {
      child = <UU5.Bricks.Loading />;
    } else if (this.state.state === "ready") {
      child = this._getChild();
    } else if (this.state.state === "error") {
      child = <UU5.Bricks.Div content={LsiHelper.getLsiComponent(Lsi.LSI_LABEL_COPY_FILE_MANAGER_LIST_FAILED)} />;
    }
    return (
      <UU5.Bricks.Section
        {...this.getMainPropsToPass()}
        header={this.props.headerHidden ? null : LsiHelper.getLsiComponent(this._lsiLabels.header)}
        level={1}
      >
        {child}
      </UU5.Bricks.Section>
    );
  }
  //@@viewOff:render
});

export default FileManager;
