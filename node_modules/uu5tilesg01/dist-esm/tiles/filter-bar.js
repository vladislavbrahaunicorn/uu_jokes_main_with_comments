//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import "uu5g04-forms";
import Cfg from "../config/config.js";
import Lsi from "../config/lsi.js";

import SimpleFilterPanel from "./simple-filter-panel.js";
import { mergeButtonProps } from "./util.js";

import "./filter-bar.less";
//@@viewOff:imports

export const FilterBar = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [
    UU5.Common.BaseMixin,
    UU5.Common.ElementaryMixin,
    UU5.Common.PureRenderMixin,
    UU5.Common.ColorSchemaMixin,
    UU5.Common.ScreenSizeMixin,
    UU5.Common.NestingLevelMixin,
    UU5.Common.LsiMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "FilterBar",
    classNames: {
      main: Cfg.CSS + "filter-bar",
      panelBody: Cfg.CSS + "filter-bar-panel-body",
      titleBox: Cfg.CSS + "filter-bar-title-box",
      title: Cfg.CSS + "filter-bar-title",
      filterBadge: Cfg.CSS + "filter-bar-badge",
      addButton: Cfg.CSS + "filter-bar-add-button",
      buttons: Cfg.CSS + "filter-bar-buttons",
      filterButton: Cfg.CSS + "filter-bar-filter-button",
      cancelBox: Cfg.CSS + "filter-bar-cancel-box",
      cancelButton: Cfg.CSS + "filter-bar-cancel-button",
      collapsed: Cfg.CSS + "filter-bar-collapsed",
      chevron: Cfg.CSS + "filter-bar-chevron"
    },
    lsi: Lsi.filterBar,
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "boxCollection"),
    opt: {
      pureRender: true // avoid re-render from parent
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    controller: UU5.PropTypes.object,
    title: UU5.PropTypes.any,
    children: UU5.PropTypes.oneOfType([UU5.PropTypes.element, UU5.PropTypes.func]),
    filters: UU5.PropTypes.arrayOf(
      UU5.PropTypes.shape({
        key: UU5.PropTypes.string,
        label: UU5.PropTypes.oneOfType([UU5.PropTypes.string, UU5.PropTypes.object]),
        filterFn: UU5.PropTypes.func
      })
    ),
    simpleFilterPanel: UU5.PropTypes.bool,
    bgStyle: UU5.PropTypes.oneOf(["outline", "underline"]),
    borderRadius: UU5.PropTypes.string,
    elevation: UU5.PropTypes.oneOf(["0", "1", "2", "3", "4", "5", 0, 1, 2, 3, 4, 5]),
    filterValues: UU5.PropTypes.arrayOf(
      UU5.PropTypes.shape({ key: UU5.PropTypes.string, value: UU5.PropTypes.string })
    ),
    buttonProps: UU5.PropTypes.oneOfType([UU5.PropTypes.object, UU5.PropTypes.func])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      controller: null,
      title: <UU5.Bricks.Lsi lsi={Lsi.filterBar.title} />,
      filters: {},
      simpleFilterPanel: false,
      bgStyle: "underline",
      borderRadius: null,
      elevation: null,
      filterValues: [],
      buttonProps: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    if (!this.props.controller) {
      UU5.Common.Tools.error(
        `The prop \`controller\` cannot be empty for ${this.getTagName()}. Either provide the prop or nest the component into UU5.Tiles.ListController.`
      );
    }
    return {
      applied: {}
    };
  },

  componentWillMount() {
    this.props.controller.registerBar("filterBar", this);
    this.props.filterValues.forEach(filterValue => {
      let { label, filterFn } = this.props.filters.find(filter => filter.key === filterValue.key);
      this.addFilter(filterValue.key, label, filterValue.value, filterFn);
    });
  },

  componentWillUnmount() {
    this.props.controller.unregisterBar("filterBar");
  },

  componentWillReceiveProps(nextProps) {
    if (!UU5.Common.Tools.deepEqual(nextProps.filterValues, this.props.filterValues)) {
      let toAdd = [],
        toRemove = [];
      this.props.filterValues.forEach(filterValue => {
        let foundExisting = nextProps.filterValues.find(nextFilterValue => nextFilterValue.key === filterValue.key);
        if (!foundExisting) {
          toRemove.push(filterValue);
        } else if (foundExisting && foundExisting.value !== filterValue.value) {
          toRemove.push(filterValue);
          toAdd.push(filterValue);
        } else {
          toAdd.push(filterValue);
        }
      });

      nextProps.filterValues.forEach(filterValue => {
        let foundExisting = this.props.filterValues.find(
          existingFilterValue => existingFilterValue.key === filterValue.key
        );
        if (!foundExisting) {
          toAdd.push(filterValue);
        }
      });

      toRemove.forEach(filterValue => {
        this.removeFilter(filterValue.key);
      });

      toAdd.forEach(filterValue => {
        let { label, filterFn } = nextProps.filters.find(filter => filter.key === filterValue.key);
        this.addFilter(filterValue.key, label, filterValue.value, filterFn);
      });
    }
  },

  componentDidUpdate(prevProps, prevState) {
    if (this.state.screenSize !== prevState.screenSize && this._panel.isExpanded()) {
      this._panel.collapse();
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  addFilter(key, label, value, filterFn, removeFilterFn, setStateCallback) {
    let { controller } = this.props;
    if (controller.isFilterUsable("addFilter")) {
      this.setState(
        prevState => {
          let applied = { ...prevState.applied };
          applied[key] = { label, value };
          return { applied };
        },
        () => {
          let valueOrFilterFn;
          if (typeof controller.props.onLoad === "function") {
            valueOrFilterFn = value;
          } else {
            let filterFunction = filterFn || this._buildGenericOnFilter(key);
            valueOrFilterFn = item => {
              return filterFunction(item, value);
            };
          }
          controller.addFilter(key, valueOrFilterFn, removeFilterFn, setStateCallback);
        }
      );

      return this;
    } else {
      return false;
    }
  },

  removeFilter(key, setStateCallback) {
    if (this.props.controller.isFilterUsable("removeFilter")) {
      this.setState(
        prevState => {
          let applied = { ...prevState.applied };
          delete applied[key];
          return { applied };
        },
        () => this.props.controller.removeFilter(key, setStateCallback)
      );

      return this;
    } else {
      return false;
    }
  },

  update(setStateCallback) {
    let status = this.props.controller.getStatus();
    status.showSelected ? this.hide(setStateCallback) : this.show(setStateCallback);
  },

  collapse() {
    this._panel.collapse();
  },

  clearFilters(setStateCallback) {
    if (this.props.controller.isFilterUsable("clearFilters")) {
      this.setState({ applied: {} }, () => this._panel.collapse(setStateCallback));
      return this;
    } else {
      return false;
    }
  },
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private
  _buildGenericOnFilter(itemKey) {
    return (item, filterValue) => {
      return item[itemKey] && item[itemKey] === filterValue;
    };
  },

  _clearFilters() {
    this.props.controller.clearFilters();
  },

  _addFilter() {
    this._panel.toggle();
  },

  _hideJustSelected() {
    this.props.controller.hideJustSelected();
  },

  _getFilterBadge() {
    let value = Object.keys(this.state.applied).length;
    return (
      value > 0 && (
        <UU5.Bricks.Button
          colorSchema={this.props.colorSchema || "blue"}
          className={this.getClassName().filterBadge}
          content={value}
        />
      )
    );
  },

  _getButtons(justTags) {
    let buttons = [];
    for (let key in this.state.applied) {
      let item = this.state.applied[key];

      let content;
      if (UU5.Common.Element.isValid(item.label)) {
        content = item.label;
      } else if (item.label) {
        content = [
          this.getLsiItem(item.label),
          "\xA0",
          <UU5.Bricks.Strong key="value">{this.getLsiItem(item.value)}</UU5.Bricks.Strong>
        ];
      } else content = this.getLsiItem(item.value);

      let props = mergeButtonProps(
        {
          key,
          className: this.getClassName().filterButton,
          onClick: () => this.removeFilter(key),
          colorSchema: this.props.colorSchema || "blue",
          borderRadius: "16px"
        },
        this.props.buttonProps,
        key,
        item
      );
      buttons.push(
        <UU5.Bricks.Button {...props}>
          {content}
          <UU5.Bricks.Icon icon="mdi-close" />
        </UU5.Bricks.Button>
      );
    }

    if (!justTags) {
      let props = mergeButtonProps(
        {
          key: "addButton",
          className: this.getClassName().addButton,
          onClick: () => this._addFilter(),
          colorSchema: this.props.colorSchema || "blue",
          bgStyle: "outline",
          borderRadius: "16px"
        },
        this.props.buttonProps,
        "addFilter"
      );
      buttons.push(
        <UU5.Bricks.Button {...props}>
          <UU5.Bricks.Icon icon="mdi-plus-circle" />
          {this.getLsiValue("addFilter")}
        </UU5.Bricks.Button>
      );
    }

    return buttons;
  },

  _isApplied() {
    return Object.keys(this.state.applied).length > 0;
  },

  _getCancelButton() {
    return (
      this._isApplied() && (
        <UU5.Bricks.Div className={this.getClassName("cancelBox")} key="cancel" parent={this}>
          <UU5.Bricks.Button
            bgStyle="transparent"
            onClick={this._clearFilters}
            className={this.getClassName().cancelButton}
            colorSchema="custom"
          >
            {this.getLsiValue("cancelFilters")}
          </UU5.Bricks.Button>
        </UU5.Bricks.Div>
      )
    );
  },

  _isLsi(value) {
    return value && typeof value === "object" && ("en" in value || "cs" in value); // good-enough detection for backward compatibility
  },

  _buildHeader() {
    let status = this.props.controller.getStatus();
    let title = this._isLsi(this.props.title) ? this.getLsiItem(this.props.title) : this.props.title;

    let result = [
      <UU5.Bricks.Div key="left" className={this.getClassName("titleBox")}>
        <UU5.Bricks.Span className={this.getClassName().title} content={title} />
        {this.isXs() ? this._getFilterBadge(status) : this._getButtons()}
      </UU5.Bricks.Div>
    ];

    if (!this.isXs()) {
      this._isApplied() && result.push(this._getCancelButton());
    }

    return result;
  },

  _registerPanel(panel) {
    this._panel = panel;
  },

  _buildChildren() {
    let r = [];
    if (this.props.children && typeof this.props.children === "function") {
      this.props.children(
        this.props.controller,
        this.state.applied,
        this.addFilter,
        this.removeFilter,
        this.props.filters,
        this
      );
    } else {
      let props = {
        controller: this.props.controller,
        appliedFilters: this.state.applied,
        addFilter: this.addFilter,
        removeFilter: this.removeFilter,
        filters: this.props.filters,
        filterBar: this
      };
      UU5.Common.Children.forEach(this.props.children, element => {
        if (UU5.Common.Element.isValid(element)) {
          let p = { ...element.props, ...props };
          r.push(UU5.Common.Element.clone(element, p));
        } else r.push(element);
      });
    }
    return UU5.Common.Children.toArray(r);
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    // todo header
    let mainProps = this.getMainPropsToPass();
    delete mainProps.nestingLevel;
    if (this.isXs() && !this.state.expanded) {
      mainProps.className = mainProps.className ? `${mainProps.className} ${this.getClassName().collapsed}` : null;
    }
    mainProps.colorSchema = "custom";
    if (mainProps.className) mainProps.className = mainProps.className.replace(/\bcolor-schema-\S+/g, "");

    let xs = this.isXs();

    return this.getNestingLevel() ? (
      <UU5.Bricks.Panel
        {...mainProps}
        openClick={!xs ? "none" : "header"}
        iconExpanded={xs ? "mdi-chevron-up" : undefined}
        iconCollapsed={xs ? "mdi-chevron-down" : undefined}
        ref_={this._registerPanel}
        header={this._buildHeader()}
        colorSchemaHeader="custom"
        bgStyle={this.props.bgStyle}
        borderRadius={this.props.borderRadius}
        elevation={this.props.elevation}
      >
        {/* TODO ContentMixin doesn't preserve "key" settings on direct children which causes
            re-mount of Well on XS because cancel button gets shown/hidden based on number of filters.
            If the FilterPanel then sets default filter in its componentDidMount, it'll behave erratically.
            => For now wrap into another <div> and inside we can then use "key"s. */}
        <div>
          {xs && (
            <UU5.Bricks.Div key="buttons" className={this.getClassName("buttons")} parent={this}>
              {this._getButtons(true)}
            </UU5.Bricks.Div>
          )}
          {xs && this._getCancelButton()}
          <UU5.Bricks.Well
            key="body"
            className={this.getClassName("panelBody")}
            colorSchema={(this.getColorSchema() || "blue").replace(/-rich/, "")}
            borderRadius={this.props.borderRadius}
            parent={this}
          >
            {this.props.simpleFilterPanel ? (
              <SimpleFilterPanel
                controller={this.props.controller}
                appliedFilters={this.state.applied}
                addFilter={this.addFilter}
                removeFilter={this.removeFilter}
                filters={this.props.filters}
                filterBar={this}
                colorSchema={this.props.colorSchema}
                buttonProps={this.props.buttonProps}
              />
            ) : (
              this._buildChildren()
            )}
          </UU5.Bricks.Well>
        </div>
      </UU5.Bricks.Panel>
    ) : null;
  }
  //@@viewOff:render
});

export default FilterBar;
