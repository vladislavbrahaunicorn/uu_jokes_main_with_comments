import Cfg from "../config/config.js";
import UU5 from "uu5g04";
import "uu5g04-bricks";
import { List as VirtualizedList, InfiniteLoader, CellMeasurer, CellMeasurerCache, defaultCellRangeRenderer } from "react-virtualized";
import memoizeOne from "memoize-one";
import WindowScroller from "./window-scroller/window-scroller.js"; // NOTE We're using react-virtualized WindowScroller with bugfix - https://github.com/bvaughn/react-virtualized/pull/1349

import Tile from "./tile.js";
import ListCache from "./list-cache.js";
import { getRelativeTop } from "./util.js";
const ListDropZone = UU5.Common.Component.lazy(async () => {
  let {
    default: DropZone
  } = await import("./list-drop-zone.js");
  let ReactDnD = await SystemJS.import("react-dnd");
  let Component = ReactDnD.DropTarget([Tile.DRAG_ITEM_TYPE], DropZone.dropTarget, Tile.dropPropsExpander)(DropZone);
  return {
    default: Component
  };
});
import "./list.less";
import DndScrollEnhancer from "./dnd-scroll-enhancer.js";
import PassNearestScrollElement from "./pass-nearest-scroll-element.js";

function shallowEqualObject(a, b) {
  if (a == null || b == null) return a === b;
  return !Object.keys(a).some(k => a[k] !== b[k]);
}

let Row = ({
  columnCount,
  elevationMargins,
  itemRendererProps,
  rowClassName,
  rowSpacing,
  tileMinWidth,
  tileSpacing,
  tileWidth,
  ...row
}) => {
  row.style = { ...row.style,
    marginLeft: 0 //margin- ugly correction, works but needs some research

  };
  let items = [];

  for (let i = 0; i < columnCount; i++) {
    let item = { ...row
    };
    item.key = item.key + "-" + i;
    item.index = columnCount * row.index + i;
    item.rowIndex = row.index;
    item.columnIndex = i;

    if (tileMinWidth) {
      item.style = {
        width: tileWidth
      };
      item.wrapperStyle = {};
    } else {
      item.style = {
        flex: "1 1 auto"
      };
      item.wrapperStyle = {
        flex: "1 1 auto"
      };
    }

    if (rowSpacing) {
      // 1. Card height inside Tile is CH and it should be this.props.tileHeight.
      //    Note that it has elevation margins and is nested in a wrapper (see Tile).
      // 2. Row height is CH + RS (row spacing).
      // 3. Tile (wrapper) contains Card + elevation margins, but height is sized according to the row height, i.e. it's CH.
      //    => Card must have zero margins (when using RS)
      item.wrapperStyle.paddingBottom = rowSpacing;
      item.style.marginTop = 0;
      item.style.marginBottom = 0;
    }

    if (tileMinWidth && tileSpacing && i < columnCount - 1) {
      item.wrapperStyle.marginRight = tileSpacing - 2 * elevationMargins.horizontalHalf;
    }

    items.push(item);
  }

  return <div className={rowClassName} style={row.style} key={row.key}>
      {items.map((item, i) => <Item key={item.key} {...item} rowPosition={i} elevationMargins={elevationMargins} listProps={itemRendererProps} handleMeasure={itemRendererProps.handleMeasure} />)}
    </div>;
};

Row.propTypes = {
  columnCount: UU5.PropTypes.number,
  elevationMargins: UU5.PropTypes.any,
  itemRenderer: UU5.PropTypes.func,
  itemRendererProps: UU5.PropTypes.object,
  rowClassName: UU5.PropTypes.any,
  rowSpacing: UU5.PropTypes.any,
  tileMinWidth: UU5.PropTypes.any,
  tileSpacing: UU5.PropTypes.any,
  tileWidth: UU5.PropTypes.any
};
if (UU5.Common.Component.memo) Row = UU5.Common.Component.memo(Row);
let warnedDraggableItemWithoutId = false;

let Item = ({
  rowPosition,
  listProps,
  elevationMargins,
  ...tile
}) => {
  let {
    controller,
    data,
    draggable,
    estimatedTileHeight,
    handleMeasure,
    onDrop,
    onLoad,
    skipInnerTile,
    tile: propsTile,
    tileBorder,
    tileCount,
    tileElevation,
    tileElevationHover,
    tileStyle
  } = listProps;
  let tileData = data ? data[tile.index] : undefined;
  let tileDataLoading = onLoad && data && !tileData;

  if (tile.index >= tileCount || tileDataLoading) {
    // NOTE When rendering placeholder in the last row, the element must have min-height 1px so that
    // it's actually rendered - if it had 0 then the last row could have wrong tile widths due to flexing.
    // At the same time, tiles that are being dynamically loaded should have some "estimated" height because
    // if we used 1px, the dynamic-row-height estimation would try to mount ~1024 rows each being 1px high...
    let requiredMinHeight = tile.index >= tileCount && tile.index - tile.columnIndex < tileCount ? 1 : estimatedTileHeight;
    return <Placeholder wrapperStyle={tile.wrapperStyle} style={tile.style} requiredMinHeight={requiredMinHeight} elevationMargins={elevationMargins} />;
  }

  if (draggable && (!tileData || !tileData.id)) {
    draggable = false;

    if (!warnedDraggableItemWithoutId) {
      warnedDraggableItemWithoutId = true;
      UU5.Common.Tools.warning("The tile list is draggable={true} but it contains item(s) which don't have 'id'. Only item(s) with 'id' can be dragged.", {
        context: {
          item: tileData
        }
      });
    }
  }

  let result;
  let tileProps = {
    style: { ...tileStyle,
      ...tile.style
    },
    elevation: tileElevation,
    elevationHover: tileElevationHover,
    border: tileBorder,
    draggable: draggable,
    onDrop: draggable ? onDrop : null,
    wrapperStyle: tile.wrapperStyle,
    data: tileData,
    handleMeasure
  };
  delete tile.style;

  if (controller && tileData && tileData.id) {
    let ctrlTileProps = controller.getTileProps(tileData.id);
    Object.assign(tile, {
      selected: ctrlTileProps.selected
    });
    tileProps = { ...tileProps,
      ...ctrlTileProps
    };
    tileProps.key = tileData.id;
  }

  if (propsTile) {
    let newProps = { ...tile,
      ...tileData,
      data: tileData,
      id: tileData ? tileData.id : undefined,
      ...(skipInnerTile ? tileProps : null),
      parent: this
    };

    if (typeof propsTile === "function") {
      result = propsTile(newProps);
    } else if (UU5.Common.Element.isValid(propsTile)) {
      propsTile.props.border !== undefined && delete newProps.border;
      result = UU5.Common.Element.clone(propsTile, newProps);
    } else if (typeof propsTile === "string") {
      result = UU5.Common.Tools.findComponent(propsTile, newProps);
    }
  } else {
    skipInnerTile = false;

    if (tileData) {
      let style = { ...tileProps.style,
        ...tileData.style
      };
      tileProps = { ...tileProps,
        ...tileData,
        data: tileData
      };
      tileProps.style = style;
    }
  }

  return skipInnerTile ? result : <Tile {...tileProps} id={tileData ? tileData.id : undefined}>
      {result}
    </Tile>;
};

if (UU5.Common.Component.memo) Item = UU5.Common.Component.memo(Item);

let Placeholder = ({
  wrapperStyle,
  style,
  elevationMargins,
  requiredMinHeight
}) => {
  // eslint-disable-line
  let elevationHorizontal = elevationMargins.horizontalHalf;
  return <div style={wrapperStyle}>
      <div style={{ ...style,
      marginLeft: elevationHorizontal,
      marginRight: elevationHorizontal,
      minHeight: requiredMinHeight
    }} />
    </div>;
};

if (UU5.Common.Component.memo) Placeholder = UU5.Common.Component.memo(Placeholder);
const ListBase = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.NestingLevelMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "List",
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "box"),
    classNames: {
      main: Cfg.CSS + "list",
      row: Cfg.CSS + "list-row",
      item: Cfg.CSS + "list-item",
      justify: Cfg.CSS + "list-row-justify-",
      list: Cfg.CSS + "list-virtualized",
      loading: Cfg.CSS + "list-loading",
      reloading: Cfg.CSS + "list-reloading"
    },
    defaults: {
      // TODO: number depends on uu5g04 UU5.Bricks.Card styles!
      elevation: {
        0: {
          vertical: 0,
          verticalBottom: 0,
          horizontalHalf: 0
        },
        1: {
          vertical: 6,
          verticalBottom: 4,
          horizontalHalf: 3
        },
        2: {
          vertical: 11,
          verticalBottom: 7,
          horizontalHalf: 5
        },
        3: {
          vertical: 18,
          verticalBottom: 11,
          horizontalHalf: 9
        },
        4: {
          vertical: 23,
          verticalBottom: 15,
          horizontalHalf: 12
        },
        5: {
          vertical: 55,
          verticalBottom: 35,
          horizontalHalf: 27
        }
      },
      debouncedLoadDelay: 200,
      estimatedTileHeightAuto: 100 // NOTE The smaller the value, the more rows will be mounted ahead (e.g. having it at 100 on 1920x1024 means there'll be 11 rows + overscan rows).

    },
    warnings: {
      draggableItemWithoutId: "The tile list is draggable={true} but it contains item(s) which don't have 'id'. Only item(s) with 'id' can be dragged.",
      scrollToTileHeightAuto: 'Methods scrollToIndex/scrollToTile with tileHeight="auto" does not always scroll exactly to where you wanted because not all row heights are known. Use exact tileHeight if you need to rely on them.'
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    width: UU5.PropTypes.number.isRequired,
    tileHeight: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.oneOf(["auto"])]).isRequired,
    estimatedTileHeight: UU5.PropTypes.number,
    height: UU5.PropTypes.number,
    rowSpacing: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    overscanRowCount: UU5.PropTypes.number,
    overscanRowCountBackward: UU5.PropTypes.number,
    tileCount: UU5.PropTypes.number,
    // or data
    data: UU5.PropTypes.arrayOf(UU5.PropTypes.shape),
    controller: UU5.PropTypes.object,
    tile: UU5.PropTypes.oneOfType([UU5.PropTypes.func, UU5.PropTypes.element, UU5.PropTypes.string]),
    tileMinWidth: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    // px || "xs-12 s-6 m-4 ..."
    tileMaxWidth: UU5.PropTypes.number,
    tileSpacing: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    tileJustify: UU5.PropTypes.oneOf(["full", "left", "right", "center", "space-between", "space-around", "space-evenly"]),
    tileElevation: UU5.PropTypes.number,
    tileElevationHover: UU5.PropTypes.number,
    tileStyle: UU5.PropTypes.object,
    tileStretch: UU5.PropTypes.oneOf(["grow", "shrink"]),
    tileBorder: UU5.PropTypes.bool,
    skipInnerTile: UU5.PropTypes.bool,
    scrollToAlignment: UU5.PropTypes.oneOf(["auto", "start", "center", "end"]),
    onScroll: UU5.PropTypes.func,
    scrollElement: UU5.PropTypes.any,
    virtualizedListProps: UU5.PropTypes.object,
    draggable: UU5.PropTypes.bool,
    onChange: UU5.PropTypes.func,
    onLoad: UU5.PropTypes.func,
    onLoadPageSize: UU5.PropTypes.number,
    onMount: UU5.PropTypes.func
  },

  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      width: 400,
      height: process.env.NODE_ENV === "test" ? 500 : undefined,
      tileHeight: 32,
      estimatedTileHeight: undefined,
      rowSpacing: 0,
      overscanRowCount: 3,
      overscanRowCountBackward: 0,
      tileCount: undefined,
      data: null,
      controller: undefined,
      tile: null,
      tileMinWidth: null,
      tileMaxWidth: null,
      tileSpacing: 0,
      tileJustify: "full",
      tileElevation: undefined,
      tileElevationHover: undefined,
      tileStyle: null,
      tileStretch: "grow",
      tileBorder: undefined,
      skipInnerTile: false,
      scrollToAlignment: "start",
      onScroll: null,
      scrollElement: null,
      virtualizedListProps: {},
      draggable: false,
      onLoadPageSize: undefined
    };
  },

  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._warnedDraggableItemWithoutId = false;
    this._scrollTopFixPending = false; // see scrollToPosition()

    this._cachedData = []; // NOTE Loaded data is cached - developer must call invalidateData() or change component "key" to reset cache.

    if (this.props.onLoad) this._markAsLoaded(this.props.data);
    this._debouncedExecuteLoadCall = UU5.Common.Tools.debounce(this._executeLoadCall, this.getDefault("debouncedLoadDelay"));
    this._cellMeasurerCache = new CellMeasurerCache({
      defaultHeight: this.getDefault("estimatedTileHeightAuto"),
      fixedWidth: true
    });
    this._computeItemRenderer = memoizeOne(this._computeItemRenderer);
    this._computeItemRendererPropsRows = {};
    this._computeOverscanIndicesGetter = memoizeOne(this._computeOverscanIndicesGetter);
    this._computeWindowScrollerChildDivRef = memoizeOne(this._computeWindowScrollerChildDivRef);
    this._rowStyleMemoizers = {};
    return {
      scrollTopFix: undefined,
      // see scrollToPosition()
      loadTotalTileCount: undefined,
      // total tile count when being loaded via onLoad call without controller
      isReloading: !!this.props.onLoad,
      pendingInitialLoad: !!this.props.onLoad
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.onLoad !== this.props.onLoad) {
      this._cachedData = [];
      if (nextProps.onLoad) this._markAsLoaded(nextProps.data);
      this.setState({
        isReloading: !!nextProps.onLoad,
        pendingInitialLoad: true
      });
    }

    if (this._cellMeasurerCache && (nextProps.width !== this.props.width || nextProps.tileMinWidth !== this.props.tileMinWidth || nextProps.tileMaxWidth !== this.props.tileMaxWidth || nextProps.tileSpacing !== this.props.tileSpacing || nextProps.tileBorder !== this.props.tileBorder || nextProps.tileStyle !== this.props.tileStyle || nextProps.tileHeight !== this.props.tileHeight || nextProps.rowSpacing !== this.props.rowSpacing)) {
      this._cellMeasurerCache.clearAll();
    }
  },

  componentDidMount() {
    this._mounted = true;
    if (this.props.controller) this.props.controller.registerList(this);

    this._tryOnMount();
  },

  componentDidUpdate(prevProps) {
    this._scrollTopFixPending = false; // NOTE Cannot be in componentWillReceiveProps because InfiniteLoader / VirtualizedList will call us and our props would still be the old ones.

    if (prevProps.width !== this.props.width || prevProps.tileMinWidth !== this.props.tileMinWidth || prevProps.tileMaxWidth !== this.props.tileMaxWidth || prevProps.tileSpacing !== this.props.tileSpacing || prevProps.tileStretch !== this.props.tileStretch || prevProps.onLoad !== this.props.onLoad) {
      if (this._infiniteLoader && prevProps.onLoad) this._infiniteLoader.resetLoadMoreRowsCache(true);
    }

    this._tryOnMount();
  },

  componentWillUnmount() {
    this._unmounted = true;
    if (this._cumulatedLoad && this._cumulatedLoad.timeoutId) clearTimeout(this._cumulatedLoad.timeoutId);
    this._rowStyleMemoizers = {};
    if (this._windowScrollerCheckInterval) clearInterval(this._windowScrollerCheckInterval);
  },

  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  scrollToIndex(tileIndex) {
    if (this.props.tileHeight === "auto") {
      this.showWarning("scrollToTileHeightAuto");
    }

    let rowIndex = this._getRowIndex(tileIndex); // NOTE Commented out because it's not working properly with React 16.4.0+ because of
    // https://github.com/bvaughn/react-virtualized/issues/1179#issuecomment-411063935
    // this._list && this._list.scrollToRow(rowIndex);
    // temporary hack for the issue above


    let grid = this._list && this._list.Grid;

    if (grid && grid.constructor && grid.constructor._getScrollTopForScrollToRowStateUpdate) {
      let gridStateUpdate = grid.constructor._getScrollTopForScrollToRowStateUpdate({ ...grid.props,
        scrollToRow: rowIndex
      }, grid.state);

      if (gridStateUpdate && typeof gridStateUpdate.scrollTop === "number") {
        this._scrollTopFixPending = true;
        this.setState({
          scrollTopFix: gridStateUpdate.scrollTop
        });
      }
    }

    return this;
  },

  scrollToPosition(scrollTop) {
    // NOTE Commented out because it's not working properly with React 16.4.0+ because of
    // https://github.com/bvaughn/react-virtualized/issues/1179#issuecomment-411063935
    // this._list && this._list.scrollToPosition(scrollTop);
    // temporary hack for the issue above - pass scrollTop via props on virtualized list
    // (but we have to pass it only next render; afterwards we must use the value provided
    // by WindowScroller so that the scroll position isn't freezed)
    let grid = this._list && this._list.Grid;

    if (grid && grid.constructor && grid.constructor._getScrollToPositionStateUpdate) {
      let gridStateUpdate = grid.constructor._getScrollToPositionStateUpdate({
        prevState: grid.state,
        scrollTop: scrollTop
      });

      if (gridStateUpdate && typeof gridStateUpdate.scrollTop === "number") {
        this._scrollTopFixPending = true;
        this.setState({
          scrollTopFix: gridStateUpdate.scrollTop
        });
      }
    }

    return this;
  },

  scrollToTile(findFn) {
    let {
      data
    } = this.props;

    if (data) {
      let index = data.findIndex((item, index) => item ? findFn(item, index) : false);
      if (index !== -1) this.scrollToIndex(index);
    }

    return this;
  },

  reloadData() {
    this._cachedData = [];

    if (this._infiniteLoader) {
      this.setState({
        isReloading: true
      }, () => this._infiniteLoader.resetLoadMoreRowsCache(true));
    }
  },

  invalidateData() {
    this._cachedData = [];

    if (this._infiniteLoader) {
      // NOTE If using controller, data invalidation means that the controller might be missing
      // only some data (e.g. it invalidated selected items by a bulk action). Missing data thus
      // can be in inconsecutive ranges and react-virtualized InfiniteLoader will call loadMoreRows
      // fn multiple times. And because we use debouncing we'll execute only the last call and ignore
      // the others (which might still be necessary / on-screen).
      //   => use flag for skipping the debounce (there's no way to pass a flag via react-virtualized API)
      this._skipDebounce = true;

      this._infiniteLoader.resetLoadMoreRowsCache(true);
    }
  },

  //@@viewOff:interface
  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods
  //@@viewOn:private
  _tryOnMount() {
    if (!this._onMountDone) {
      // when we're in UU5.Bricks.Resize component, we'll initially get width=0 which
      // is unusable because we won't be able to find out number of our columns and
      // if user performs scrollToTile during onMount fn it'll scroll to wrong position
      // => postpone onMount until we get proper width in such case
      if (this.props.width !== 0 && this._list) {
        this._onMountDone = true;
        if (typeof this.props.onMount === "function") this.props.onMount({
          component: this
        });
      }
    }
  },

  _setListRef(ref) {
    this._list = ref;
    if (ref && this._mounted) this._tryOnMount();
  },

  _setWindowScrollerRef(ref) {
    this._windowScroller = ref; // if using scrollElement/BODY and something above us changes its height we need to
    // let WindowScroller know about that (otherwise it'll compute scroll positions incorrectly
    // resulting in tiles being rendered too late / unmounted too soon so white empty spaces would be shown
    // at the start/end of the currently rendered viewport rectangle)

    if (this._windowScrollerCheckInterval) clearInterval(this._windowScrollerCheckInterval);

    if (this._windowScroller) {
      let lastUpdatedTop = getRelativeTop(this._windowScrollerChildDiv, this._usedScrollElement);
      this._windowScrollerCheckInterval = setInterval(() => {
        let top = getRelativeTop(this._windowScrollerChildDiv, this._usedScrollElement);

        if (Math.abs(top - lastUpdatedTop) >= 10) {
          this._windowScroller.updatePosition();

          lastUpdatedTop = top;
        }
      }, 200);
    }
  },

  _getTileCount() {
    // return tiles count; if using onLoad (on-demand loading) and load wasn't performed yet then return an estimation of tile count
    let result = typeof this.props.tileCount === "number" ? this.props.tileCount : this.state.loadTotalTileCount;

    if (result == null) {
      result = this.props.data && this.props.data.length || 0;
    } // if we're reloading then use "some" non-zero number so that react-virtualized InfiniteLoader
    // knows there's non-zero rows and triggers _isRowLoaded() method


    if (this.state.isReloading) result = Math.max(result + 1, (this._estimateVisibleRowCount() + this._getLoadRowThreshold()) * this._countColumns());
    return result;
  },

  _countRows() {
    let count = this._getTileCount();

    if (this.props.tileMinWidth && (typeof this.props.tileMinWidth !== "number" || this.props.tileMinWidth <= this._getWidthWithoutElevation())) {
      count = Math.ceil(count / this._countColumns());
    }

    return count;
  },

  // returns width decreased by left & right elevation margins
  _getWidthWithoutElevation() {
    return this.props.width - (this.props.controller ? 0 : 2 * this.getDefault("elevation")[this._getMaxElevation()].horizontalHalf);
  },

  _countColumns() {
    let count = 1;

    if (this.props.tileMinWidth) {
      if (typeof this.props.tileMinWidth === "number") {
        let tileSpacing = this._getTileSpacing();

        let w1 = Math.floor((this._getWidthWithoutElevation() + tileSpacing) / (this.props.tileMinWidth + tileSpacing));
        let w2 = Math.floor((this._getWidthWithoutElevation() + tileSpacing) / (this.props.tileMaxWidth + tileSpacing));
        w2 = w1 - w2 > 1 ? w2 + 1 : w1;
        count = Math.max(this.props.tileStretch === "shrink" ? w1 : w2, 1);
      } else {
        // actual screen size, not rerender if screen size is changed, so it is working only with Resizing component
        let screenSize = UU5.Common.Tools.getScreenSize();
        UU5.Common.Tools.buildColWidthClassName(this.props.tileMinWidth).split(" ").forEach(className => {
          let values = className.match(/([a-z]+)(\d+)$/);

          if (values[1] === screenSize) {
            count = 12 / +values[2];
          }
        });
      }
    }

    return count;
  },

  _onTileDrop({
    item,
    component,
    before
  }) {
    if (typeof this.props.onChange === "function") {
      let dropComponentId = component.getId();
      let {
        onLoad,
        controller
      } = this.props;
      let data = onLoad && !controller ? this._cachedData : this.props.data;
      if (!data) data = [];
      let toIndex = data.length ? data.findIndex(dispItem => dispItem.id === dropComponentId) : 0;

      if (toIndex !== -1) {
        let newData = [...data];
        let dataItem;
        let fromIndex = data.findIndex(dispItem => dispItem.id === item.id);
        if (fromIndex !== -1) dataItem = newData.splice(fromIndex, 1)[0];else dataItem = item;
        newData.splice((toIndex > fromIndex && fromIndex !== -1 ? toIndex - 1 : toIndex) + !before, 0, dataItem);
        let opt = {
          data: newData,
          component: this
        };
        Promise.resolve().then(() => this.props.onChange(opt)); // postponed so that native event gets processed in full
      }
    }
  },

  _getMaxElevation() {
    let elevation = this.props.tileElevation && this.props.tileElevation < 5 && this.props.tileElevation > -5 ? this.props.tileElevation : 0;
    let elevationHover = this.props.tileElevationHover && this.props.tileElevationHover < 5 && this.props.tileElevationHover > -5 ? this.props.tileElevationHover : 0;
    return Math.max(elevation, elevationHover);
  },

  _getRowSpacing() {
    return this.props.rowSpacing || this.getDefault("elevation")[this._getMaxElevation()].vertical;
  },

  _getTileSpacing() {
    return this.props.tileSpacing || 2 * this.getDefault("elevation")[this._getMaxElevation()].horizontalHalf;
  },

  _computeItemRenderer(handleMeasure) {
    // NOTE This method is memoized. Use only parameters, no props/state.
    return (item, index) => this._renderItem(item, index, handleMeasure);
  },

  _computeItemRendererProps(rowIndex, props) {
    // each row needs its own memoization fn as the fn remembers only result of single call
    // (if all rows were using the same memoized fn then getting 2nd row would return new result
    // as it would have different props than the 1st row and memoization would be useless)
    let memoizedRowFn = this._computeItemRendererPropsRows[rowIndex];

    if (!memoizedRowFn) {
      memoizedRowFn = this._computeItemRendererPropsRows[rowIndex] = memoizeOne(props => props, (newArgs, oldArgs) => shallowEqualObject(newArgs[0], oldArgs[0]));
    }

    return memoizedRowFn(props);
  },

  _getSimplifiedRow(row) {
    let result = row;

    if (typeof this.props.tile !== "function") {
      // props isVisible, isScrolling are passed only to "tile" rendering realized using function (as a performance optimization)
      let {
        isScrolling,
        isVisible,
        style,
        ...simplifiedRow
      } = row; // eslint-disable-line

      if (!this._rowStyleMemoizers[row.index]) {
        this._rowStyleMemoizers[row.index] = memoizeOne(style => style, (newArgs, oldArgs) => shallowEqualObject(newArgs[0], oldArgs[0]));
      }

      simplifiedRow.style = this._rowStyleMemoizers[row.index](style);
      result = simplifiedRow;
    }

    return result;
  },

  _onScroll(scrollInfo) {
    let c = this._countColumns();

    scrollInfo.rowCount = this._countRows();
    scrollInfo.columnCount = this._countColumns();

    let tileHeight = this._getEstimatedTileHeight(); // TODO Compute indices precisely for case when using dynamic row height.


    scrollInfo.firstTileIndex = Math.ceil(scrollInfo.scrollTop / (tileHeight + this._getRowSpacing())) * c;
    scrollInfo.lastTileIndex = Math.floor((scrollInfo.scrollTop + scrollInfo.clientHeight) / (tileHeight + this._getRowSpacing())) * c - 1;
    scrollInfo.rowIndex = this._getRowIndex(scrollInfo.firstTileIndex);
    this.props.onScroll(scrollInfo);
  },

  _getEstimatedTileHeight() {
    return this.props.tileHeight === "auto" ? this.props.estimatedTileHeight || this.getDefault("estimatedTileHeightAuto") : this.props.tileHeight;
  },

  _getRowIndex(tileIndex) {
    let rowIndex = -1;

    let count = this._getTileCount();

    if (tileIndex <= 0) {
      rowIndex = 0;
    } else if (tileIndex >= count) {
      rowIndex = count;
    } else {
      rowIndex = Math.floor(tileIndex / this._countColumns());
    }

    return rowIndex;
  },

  _estimateRowHeight({
    index
  }) {
    // NOTE When using draggable tiles, react-dnd (DropTarget/DragSource) renders "null" during 1st render which
    // means that the row has height 0 and Grid will try to render next row (same result), ..., effectively mounting all remaining
    // rows (reeeeally slow) => guard against this by using estimated height instead of 0 and then the Tile component in its
    // componentDidMount will trigger row height re-computation.
    return this._cellMeasurerCache.rowHeight({
      index
    }) || this.getDefault("estimatedTileHeightAuto") + this._getRowSpacing();
  },

  _getList(scrollProps) {
    let rowCount = this._countRows();

    let rowHeight = this._getEstimatedTileHeight() + this._getRowSpacing();

    let listHeight = this.props.height == null ? rowCount * rowHeight : this.props.height;

    let elevationMargins = this.getDefault("elevation")[this._getMaxElevation()];

    let widthWithoutElevation = this._getWidthWithoutElevation();

    let listProps = { ...this.props.virtualizedListProps,
      key: "list",
      className: this.getClassName("list"),
      width: widthWithoutElevation + 2 * elevationMargins.horizontalHalf,
      height: listHeight,
      rowHeight: this.props.tileHeight === "auto" ? this._estimateRowHeight : rowHeight,
      estimatedRowSize: rowHeight,
      deferredMeasurementCache: this.props.tileHeight === "auto" ? this._cellMeasurerCache : undefined,
      rowCount: rowCount,
      rowRenderer: this._renderRow,
      scrollToAlignment: this.props.scrollToAlignment,
      overscanRowCount: this.props.overscanRowCount,
      overscanIndicesGetter: this.props.overscanRowCountBackward ? this._computeOverscanIndicesGetter(this.props.overscanRowCount, this.props.overscanRowCountBackward) : undefined,
      cellRangeRenderer: this._cellRangeRenderer,
      style: {
        marginTop: elevationMargins.vertical - elevationMargins.verticalBottom,
        marginBottom: elevationMargins.verticalBottom - this._getRowSpacing(),
        // last row has rowSpacing too
        marginLeft: this.props.controller ? -elevationMargins.horizontalHalf : 0,
        // TODO Not nice - controller should pass bigger width and use negative marginLeft normally via style prop.
        marginRight: this.props.controller ? -elevationMargins.horizontalHalf : 0
      }
    };
    let onScroll;

    if (typeof this.props.onScroll === "function") {
      onScroll = (...args) => {
        this._onScroll(...args);

        scrollProps && typeof scrollProps.onScroll === "function" && scrollProps.onScroll(...args);
      };
    }

    let result;
    let listAllProps = { ...listProps,
      ...scrollProps,
      ref: this._setListRef,
      scrollTop: this._scrollTopFixPending ? this.state.scrollTopFix : scrollProps ? scrollProps.scrollTop : undefined,
      height: scrollProps && scrollProps.height || listProps.height
    };

    if (!listAllProps.autoHeight) {
      // NOTE This fixes https://github.com/bvaughn/react-virtualized/issues/1179 - happens with scrollElement={null}
      // when user scrolls via API, e.g. scrollToTile, and then scrolls via mouse (Grid resets position to the position
      // made by API because they migrated componentWillReceiveProps to getDerviedStateFromProps and the latter one gets
      // called more often than the former one and rewrites new scroll position by old one).
      let onScrollOrig = onScroll;

      onScroll = (...args) => {
        this._scrollTopFixPending = true;
        this.setState({
          scrollTopFix: args.scrollTop
        });
        if (typeof onScrollOrig === "function") onScrollOrig(...args);
      };
    }

    Object.assign(listAllProps, {
      onScroll
    });

    if (typeof this.props.tile !== "function") {
      delete listAllProps.isScrolling;
    }

    if (typeof this.props.onLoad === "function") {
      result = <InfiniteLoader isRowLoaded={this._isRowLoaded} loadMoreRows={this._loadMoreRows} rowCount={rowCount} threshold={this._getLoadRowThreshold()} ref={comp => this._infiniteLoader = comp} key="il">
          {({
          onRowsRendered,
          registerChild
        }) => <VirtualizedList {...listAllProps} onRowsRendered={onRowsRendered} ref={list => {
          listAllProps.ref(list);
          return registerChild(list);
        }} />}
        </InfiniteLoader>;
      let isLoading = this.state.pendingInitialLoad || this.state.isReloading;

      if (isLoading) {
        let classNames = [this.getClassName("loading")];
        if (!this.state.pendingInitialLoad) classNames.push(this.getClassName("reloading"));
        result = [<div key="loading" className={classNames.join(" ")}>
            <UU5.Bricks.Loading className={!this.state.pendingInitialLoad ? "uu5-common-elevation-2" : undefined} />
          </div>, result];
      }
    } else {
      result = <VirtualizedList {...listAllProps} />;
    }

    return result;
  },

  _renderRow(row) {
    let {
      tileMinWidth,
      tileMaxWidth
    } = this.props;

    let rowSpacing = this._getRowSpacing();

    let tileSpacing = this._getTileSpacing();

    let elevationMargins = this.getDefault("elevation")[this._getMaxElevation()];

    let columnCount = this._countColumns(); // NOTE
    // 1. If we're in controller, virtualized list has extra negative margins, i.e.
    //    the list width W = this.props.width (=== this._getWidthWithoutElevation()) and row width is
    //    W + 2 * EMHH (EMHH = elevationMargins.horizontalHalf).
    // 2. Tile's left margin edge should be aligned with left edge of virtualized list
    //    and because Card inside Tile has EMHH, Card's left border is visually aligned
    //    with List left content edge.
    //    When we're outside of controller, the left edge alignment is still against
    //    virtualized list (which has no longer negative margins) and therefore Card's left
    //    border is now shifted against List left content edge.
    // 3. Card (inside Tile) border-box height should be (row height - row spacing).


    let tileWidth;

    if (tileMinWidth) {
      tileWidth = columnCount === 1 ? this._getWidthWithoutElevation() : Math.floor((this._getWidthWithoutElevation() - (columnCount - 1) * tileSpacing) / columnCount);
      tileMaxWidth && (tileWidth = Math.min(tileWidth, tileMaxWidth));
    }

    let rowClassName = this.getClassName("row");

    if (tileMinWidth) {
      let justify = columnCount === 1 ? "center" : this.props.tileJustify;
      rowClassName += ` ${this.getClassName("justify")}${justify}`;
    }

    let result;

    let doRender = handleMeasure => // NOTE <Row> is pure, i.e. it'll be re-rendered only if props change (shallowly).
    // It must also pass all necessary rendering props for row & items. TODO maybe change
    // to using Context instead?
    <Row {...this._getSimplifiedRow(row)} columnCount={columnCount} elevationMargins={elevationMargins} rowClassName={rowClassName} rowSpacing={rowSpacing} tileMinWidth={tileMinWidth} tileSpacing={tileSpacing} tileWidth={tileWidth} itemRendererProps={this._computeItemRendererProps(row.index, {
      controller: this.props.controller,
      data: this.props.onLoad && !this.props.controller ? this._cachedData : this.props.data,
      draggable: this.props.draggable,
      estimatedTileHeight: this._getEstimatedTileHeight(),
      handleMeasure,
      onDrop: this.props.draggable ? this._onTileDrop : undefined,
      onLoad: this.props.onLoad,
      skipInnerTile: this.props.skipInnerTile,
      tile: this.props.tile,
      tileBorder: this.props.tileBorder,
      tileCount: this._getTileCount(),
      tileElevation: this.props.tileElevation,
      tileElevationHover: this.props.tileElevationHover,
      tileStyle: this.props.tileStyle
    })} />;

    if (this.props.tileHeight === "auto") {
      result = <CellMeasurer cache={this._cellMeasurerCache} columnIndex={0} key={row.key} parent={row.parent} rowIndex={row.index}>
          {({
          measure
        }) => doRender(measure)}
        </CellMeasurer>;
    } else {
      result = doRender();
    }

    return result;
  },

  _getLoadRowThreshold() {
    // how many rows to load ahead of time
    return this.props.overscanRowCount + this._estimateVisibleRowCount();
  },

  _estimateVisibleRowCount() {
    let height = window.innerHeight;
    if (this._listNode) height = Math.min(height, this._listNode.getBoundingClientRect().height);
    return Math.ceil(height / (this._getEstimatedTileHeight() + this._getRowSpacing()));
  },

  _isRowLoaded({
    index
  }) {
    let result = false;

    if (!this.state.isReloading) {
      // check load status of all tiles in the row
      let {
        controller,
        onLoad
      } = this.props;
      let data = onLoad && !controller ? this._cachedData : this.props.data;

      let colCount = this._countColumns();

      let tileIndex = index * colCount;
      colCount = Math.min(colCount, this._getTileCount() - tileIndex);
      result = true;

      for (let i = 0; i < colCount && result; ++i) {
        result = controller ? controller.isTileLoaded(tileIndex + i) : data[tileIndex + i] !== undefined;
      }
    }

    return result;
  },

  _loadMoreRows({
    startIndex,
    stopIndex
  }) {
    // console.log("_loadMoreRows", { startIndex, stopIndex });
    // trigger load immediately if it's initial/reloading load
    let result;
    if (this.state.isReloading || this._skipDebounce) result = this._executeLoadCall({
      startIndex,
      stopIndex,
      skipIfAlreadyLoadingSame: this.state.pendingInitialLoad
    });else result = this._debouncedExecuteLoadCall({
      startIndex,
      stopIndex,
      skipIfAlreadyLoadingSame: true
    });
    if (this._skipDebounce) Promise.resolve().then(() => this._skipDebounce = false);
    return result;
  },

  _executeLoadCall({
    startIndex,
    stopIndex,
    skipIfAlreadyLoadingSame
  }) {
    let {
      onLoadPageSize: pageSize,
      controller,
      onLoad
    } = this.props; // compute tile-based indices for the call (because startIndex & stopIndex are row-based)
    // and then convert them to page-based

    let colCount = this._countColumns();

    let tileStartIndex = startIndex * colCount;
    let tileEndIndex = (stopIndex + 1) * colCount; // stopIndex is inclusive, we want exclusive => +1
    // commands use pageIndex + pageSize so if we need tiles 30..49 with pageSize=20 then
    // we have to perform 2 calls (pageIndex=1 loads 20..39, pageIndex=2 loads 40..59)

    let pageInfos;

    if (typeof pageSize === "number" && pageSize > 0) {
      let pageStartIndex = Math.floor(tileStartIndex / pageSize);
      let pageEndIndexInclusive = Math.floor((tileEndIndex - 1) / pageSize);
      pageInfos = [];

      for (let pageIndex = pageStartIndex; pageIndex <= pageEndIndexInclusive; ++pageIndex) {
        pageInfos.push({
          pageIndex,
          pageSize
        });
      }
    } else {
      pageInfos = [this._computePageInfo(tileStartIndex, tileEndIndex)];
    } // skip call if already laoding same set / superset


    let skip = false;

    if (skipIfAlreadyLoadingSame && this._lastLoadInfo) {
      let loadTileStartIndex = this._lastLoadInfo.tileStartIndex;
      let loadTileEndIndex = this._lastLoadInfo.tileEndIndex;

      if (loadTileStartIndex <= pageInfos[0].pageIndex * pageInfos[0].pageSize && loadTileEndIndex >= (pageInfos[pageInfos.length - 1].pageIndex + 1) * pageInfos[pageInfos.length - 1].pageSize) {
        skip = true;
      }
    }

    let result;

    if (!skip) {
      let loads = pageInfos.map(pageInfo => {
        return new Promise((resolve, reject) => {
          let dtoIn = {
            data: {
              pageInfo,
              ...(controller ? controller.getLoadParams() : undefined)
            },
            done: data => resolve({
              dtoIn,
              data
            }),
            fail: reject
          };
          onLoad(dtoIn);
        });
      });
      result = Promise.all(loads).then(results => {
        if (!this._unmounted) {
          if (this._cellMeasurerCache) this._cellMeasurerCache.clearAll();
          if (this._lastLoadInfo === lastLoadInfo) this._lastLoadInfo = null;
          let newState = {
            isReloading: false,
            pendingInitialLoad: false
          };

          for (let i = 0; i < results.length; ++i) {
            let {
              dtoIn,
              data
            } = results[i];

            if (data) {
              let {
                pageInfo: pageInfoOut,
                itemList
              } = data;

              if (controller) {
                controller.setData(itemList, pageInfoOut, dtoIn.data);
              } else {
                this._markAsLoaded(itemList, pageInfoOut);

                if (pageInfoOut && pageInfoOut.total != null) newState.loadTotalTileCount = pageInfoOut.total;
              }
            }
          }

          this.setState(state => {
            let resultState;

            for (let k in newState) {
              if (newState[k] !== state[k]) {
                resultState = newState;
                break;
              }
            }

            return resultState;
          });
        }
      }, error => {
        if (this._lastLoadInfo === lastLoadInfo) this._lastLoadInfo = null;
        this.setState(state => state.isReloading || state.pendingInitialLoad ? {
          isReloading: false,
          pendingInitialLoad: false
        } : undefined);
        return Promise.reject(error);
      });
      let lastLoadInfo = this._lastLoadInfo = {
        tileStartIndex: pageInfos[0].pageIndex * pageInfos[0].pageSize,
        tileEndIndex: (pageInfos[pageInfos.length - 1].pageIndex + 1) * pageInfos[pageInfos.length - 1].pageSize,
        // exclusive
        promise: result
      };
    } else {
      result = this._lastLoadInfo.promise;
    }

    return result;
  },

  _markAsLoaded(data, pageInfo = null) {
    if (Array.isArray(data)) {
      let oldData = this._cachedData;
      let from = pageInfo ? pageInfo.pageIndex * pageInfo.pageSize : 0;
      let to = from + data.length;
      let newData = new Array(pageInfo && typeof pageInfo.total === "number" ? pageInfo.total : Math.max(to, oldData.length));

      for (let i = 0, len = newData.length; i < len; ++i) newData[i] = from <= i && i < to ? data[i - from] : oldData[i];

      ListCache.evictItems(newData, from, to);
      this._cachedData = newData;
    }
  },

  _computePageInfo(tileStartIndex, tileEndIndex) {
    // compute page info with minimal pageSize to load tiles in range <tileStartIndex, tileEndIndex-1>
    let pageSize = 1;

    if (tileStartIndex < tileEndIndex) {
      let from = tileEndIndex - tileStartIndex;
      let to = tileEndIndex - tileStartIndex > tileStartIndex ? tileEndIndex : tileStartIndex;

      for (let i = from; i <= to; ++i) {
        if (Math.floor(tileStartIndex / i) === Math.floor((tileEndIndex - 1) / i)) {
          pageSize = i;
          break;
        }
      }
    }

    return {
      pageSize,
      pageIndex: Math.floor(tileStartIndex / pageSize)
    };
  },

  _computeOverscanIndicesGetter(rowCountAhead, rowCountBehind) {
    // NOTE This method is memoized. Use only parameters, no props/state.
    // https://github.com/bvaughn/react-virtualized/blob/master/docs/Grid.md#overscanindicesgetter
    return ({
      direction,
      cellCount,
      scrollDirection,
      overscanCellsCount,
      startIndex,
      stopIndex
    }) => {
      return {
        overscanStartIndex: Math.max(0, startIndex - (scrollDirection === 1 ? rowCountBehind : rowCountAhead)),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + (scrollDirection === 1 ? rowCountAhead : rowCountBehind))
      };
    };
  },

  _computeWindowScrollerChildDivRef(anotherRef) {
    return refValue => {
      if (typeof anotherRef === "function") anotherRef(refValue);else if (anotherRef) anotherRef.current = refValue;
      this._windowScrollerChildDiv = refValue;
    };
  },

  _cellRangeRenderer(props) {
    const children = defaultCellRangeRenderer(props);
    if (!this._usedScrollElement && this.props.draggable) children.push(<DndScrollEnhancer key="dse" />);
    return children;
  },

  _renderEmptyDropZone() {
    // render zone for dropping tiles from other lists (when this list is empty)
    return <ListDropZone key="dropZone" onDrop={this._onTileDrop} style={{
      height: this._getEstimatedTileHeight() + this._getRowSpacing() || undefined
    }} />;
  },

  _renderWithScrollElement({
    scrollElement
  }) {
    this._usedScrollElement = scrollElement;
    let result;

    if (!scrollElement) {
      result = [this._getList(), this.props.draggable && this._getTileCount() === 0 ? this._renderEmptyDropZone() : null];
    } else {
      result = <WindowScroller scrollElement={scrollElement} ref={this._setWindowScrollerRef}>
          {({
          height,
          isScrolling,
          registerChild,
          onChildScroll,
          scrollTop
        }) => {
          let childRef = this._computeWindowScrollerChildDivRef(registerChild);

          return <div ref={childRef}>
                {this._getList({
              autoHeight: true,
              height,
              isScrolling,
              scrollTop: this._getTileCount() > 0 ? scrollTop : 0,
              // condition prevents weird scroll resetting when tiles are filtered to 0 items and user tries to scroll below the tile container
              onScroll: onChildScroll
            })}
                {this.props.draggable && this._getTileCount() === 0 ? this._renderEmptyDropZone() : null}
                {this.props.draggable ? <DndScrollEnhancer scrollElement={scrollElement} /> : null}
              </div>;
        }}
        </WindowScroller>;
    }

    return result;
  },

  //@@viewOff:private
  //@@viewOn:render
  render() {
    let result;

    if (this.props.scrollElement) {
      result = this._renderWithScrollElement({
        scrollElement: this.props.scrollElement
      });
    } else if (!this.props.height) {
      result = <PassNearestScrollElement defaultValue={window}>{this._renderWithScrollElement}</PassNearestScrollElement>;
    } else {
      result = this._renderWithScrollElement({
        scrollElement: null
      });
    }

    let mainProps = this.getMainPropsToPass();
    delete mainProps.nestingLevel;
    return <UU5.Bricks.Div {...mainProps}>{result}</UU5.Bricks.Div>;
  } //@@viewOff:render


});
let ListWithDnD;
const LazyListWithDnD = UU5.Common.Component.lazy(async () => {
  if (typeof SystemJS !== "undefined") {
    /* eslint-disable no-undef */
    Tile._reactDnD = await SystemJS.import("react-dnd");
    await SystemJS.import("react-dnd-html5-backend");
    await SystemJS.import("react-dnd-touch-backend");
    /* eslint-enable no-undef */
  }

  if (!ListWithDnD) ListWithDnD = UU5.Common.DnD.withContext(ListBase);
  return {
    default: ListWithDnD
  };
});
export const List = UU5.Common.VisualComponent.create({
  statics: {
    getDerivedStateFromError(error) {
      return {
        error
      };
    }

  },

  getInitialState() {
    return {};
  },

  render() {
    let {
      error
    } = this.state;

    if (error) {
      return <UU5.Common.Error error={error} moreInfo />;
    } else if (this.props.draggable) {
      return <UU5.Common.Suspense fallback="">
          <LazyListWithDnD {...this.props} />
        </UU5.Common.Suspense>;
    } else {
      return <ListBase {...this.props} />;
    }
  }

});
List.isUu5PureComponent = true;
List.displayName = `withLazyDnD(${ListBase.displayName || ListBase.name || "Component"})`;
List.hocFor = ListBase;
export default List;