//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../config/config.js";

import "./tile.less";
//@@viewOff:imports

const TileBase = UU5.Common.VisualComponent.create({
  displayName: "Tile",

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.PureRenderMixin, UU5.Common.SectionMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "Tile",
    classNames: {
      main: Cfg.CSS + "tile",
      wrapper: Cfg.CSS + "tile-wrapper",
      buttons: Cfg.CSS + "tile-buttons",
      buttonSelected: Cfg.CSS + "tile-button-selected",
      buttonSelectedIcon: Cfg.CSS + "tile-button-selected-icon",
      buttonDrag: Cfg.CSS + "tile-button-drag",
      buttonDragIcon: Cfg.CSS + "tile-button-drag-icon",
      buttonDragWrapper: Cfg.CSS + "tile-button-drag-wrapper",
      content: Cfg.CSS + "tile-content",
      border: Cfg.CSS + "tile-border",
      dragging: Cfg.CSS + "tile-dragging",
      dragOver: Cfg.CSS + "tile-drag-over",
      dropIndicator: Cfg.CSS + "tile-drop-indicator",
      dropBefore: Cfg.CSS + "tile-drop-before",
      dropAfter: Cfg.CSS + "tile-drop-after"
    },
    opt: {
      pureRender: true,
      dummyLevel: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    id: UU5.PropTypes.any,
    tile: UU5.PropTypes.object,
    data: UU5.PropTypes.object,
    onSelect: UU5.PropTypes.func,
    selectable: UU5.PropTypes.bool,
    elevation: UU5.PropTypes.number,
    elevationHover: UU5.PropTypes.number,
    border: UU5.PropTypes.bool,
    draggable: UU5.PropTypes.bool,
    onDrop: UU5.PropTypes.func,
    wrapperStyle: UU5.PropTypes.object,
    skipCloneChildren: UU5.PropTypes.bool,

    // internal props passed by/for react-dnd
    _connectDropTarget: UU5.PropTypes.func,
    _connectDragSource: UU5.PropTypes.func,
    _connectDragPreview: UU5.PropTypes.func,
    _isDragging: UU5.PropTypes.bool,
    _onDraggingChange: UU5.PropTypes.func,
    _isDragOver: UU5.PropTypes.bool,
    _onDragOverChange: UU5.PropTypes.func,
    _canDrop: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      selectable: false,
      elevation: 0,
      elevationHover: null,
      border: false,
      draggable: false,
      skipCloneChildren: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    return {
      dropIndicatorBefore: null,
      dropIndicatorOffset: 0,
      isOverDroppable: false
    };
  },

  componentDidMount() {
    // we're firing drag*Change events even during mount because that seems to be the only way to get
    // reference to this component instance when using react-dnd and component gets re-mounted due to
    // scroll in react-virtualized list (during drag operation)
    this._fireDragOverChange();
    this._fireDraggingChange();

    // we have to re-measure the tile row when using react-dnd because DropTarget/DragSource HOCs
    // render initially null (therefore VirtualizedList's CellMeasurer will initially think we have height 0
    // and we need to let it know that that's not the case)
    if (this.props.draggable && typeof this.props.handleMeasure === "function") {
      this.props.handleMeasure();
    }
  },

  componentWillUnmount() {
    if (this.props._isDragOver) this._fireDragOverChange({ ...this.props, _isDragOver: false, _canDrop: false });
    if (this.props._isDragging) this._fireDraggingChange({ ...this.props, _isDragging: false });
  },

  componentDidUpdate(prevProps) {
    if (prevProps._isDragOver !== this.props._isDragOver) this._fireDragOverChange();
    if (prevProps._isDragging !== this.props._isDragging) this._fireDraggingChange();
    if (this._dropIndicator && this._card) {
      let rootNode = UU5.Common.DOM.findNode(this._rootNode);
      let rootNodeRect = rootNode.getBoundingClientRect();
      let cardNode = UU5.Common.DOM.findNode(this._card);
      let cardNodeRect = cardNode.getBoundingClientRect();
      let dropIndicatorNode = UU5.Common.DOM.findNode(this._dropIndicator);
      dropIndicatorNode.style.top = rootNodeRect.top - cardNodeRect.top + "px";
      dropIndicatorNode.style.bottom = rootNodeRect.bottom - cardNodeRect.bottom + "px";
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  setDropIndicator(before, offset) {
    this.setState(state => {
      let result;
      if (state.dropIndicatorBefore !== before || Math.abs(offset - state.dropIndicatorOffset) > 0.5) {
        result = { dropIndicatorBefore: before, dropIndicatorOffset: offset };
      }
      return result;
    });
  },

  getDropIndicator() {
    return {
      before: this.state.dropIndicatorBefore,
      offset: this.state.dropIndicatorOffset
    };
  },

  setDragIsOverDroppableTarget(isOverDroppable) {
    this.setState(state => {
      let result;
      if (state.isOverDroppable !== isOverDroppable) result = { isOverDroppable };
      return result;
    });
  },
  //@@viewOff:interface

  //@@viewOn:overriding
  toggleSelected_() {
    this.toggleSelectedDefault(() => {
      let fn = undefined;
      let id = this.props.id;

      if (typeof this.props.onSelect === "function") {
        fn = this.props.onSelect;
      } else if (this.props.tile && typeof this.props.tile.onSelect === "function") {
        fn = this.props.tile.onSelect;
      }
      id && fn && fn(id, this.isSelected());
    });
  },
  //@@viewOff:overriding

  //@@viewOn:private
  _fireDragOverChange(props = this.props) {
    if (typeof props._onDragOverChange === "function") {
      let opt = { isDragOver: props._isDragOver, canDrop: props._canDrop, component: this };
      props._onDragOverChange(opt);
    }
  },

  _fireDraggingChange(props = this.props) {
    if (typeof props._onDraggingChange === "function") {
      let opt = { isDragging: props._isDragging, component: this };
      props._onDraggingChange(opt);
    }
  },

  _buildChildren() {
    let r;
    let tileProps = { tileFrame: this, id: this.props.id };
    this.props.data && (tileProps.data = this.props.data);
    this.props.tile && (tileProps.tile = this.props.tile);
    if (typeof this.props.children === "function") {
      r = this.props.children(tileProps);
    } else if (!this.props.skipCloneChildren) {
      r = UU5.Common.Children.map(this.props.children, element => {
        let el;
        if (UU5.Common.Element.isValid(element)) {
          el = UU5.Common.Element.clone(element, tileProps);
        } else {
          el = element;
        }
        return el;
      });
    } else r = this.props.children;
    return r;
  },

  _getMainProps() {
    let mainProps = this.getMainPropsToPass();
    let { border } = this.props;

    if (border) {
      mainProps.className = mainProps.className + " " + this.getClassName("border");
    }

    return mainProps;
  },

  _renderButtons() {
    let { _connectDragSource } = this.props;
    return (
      <UU5.Common.Fragment>
        {_connectDragSource(
          // NOTE <span> is required by react-dnd.
          <span className={this.getClassName().buttonDragWrapper} key="btn-drag">
            {this.props.draggable && (
              <UU5.Bricks.Button bgStyle="transparent" className={this.getClassName().buttonDrag}>
                <UU5.Bricks.Icon icon="mdi-cursor-move" className={this.getClassName().buttonDragIcon} />
              </UU5.Bricks.Button>
            )}
          </span>
        )}
        {this.props.selectable && !this.isDisabled() && (
          <UU5.Bricks.Button
            bgStyle="transparent"
            className={this.getClassName().buttonSelected}
            onClick={this.toggleSelected}
            key="btn-selected"
          >
            <UU5.Bricks.Icon icon="mdi-check-circle" className={this.getClassName().buttonSelectedIcon} />
          </UU5.Bricks.Button>
        )}
      </UU5.Common.Fragment>
    );
  },

  _setCardRef(comp) {
    this._card = comp;
  },

  _setDropIndicatorRef(comp) {
    this._dropIndicator = comp;
  },

  _setRootNodeRef(comp) {
    this._rootNode = comp;
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let elevationHover = this.props.elevationHover === null ? this.props.elevation : this.props.elevationHover;
    let { _connectDragPreview, _connectDropTarget, _isDragging, _isDragOver, draggable } = this.props;
    let { dropIndicatorBefore, dropIndicatorOffset, isOverDroppable } = this.state;

    let rootClassNames = [this.getClassName().wrapper];
    let dropIndicator;
    if (draggable) {
      if (_isDragging) {
        rootClassNames.push(this.getClassName().dragging);
      }
      if (_isDragOver || (_isDragging && !isOverDroppable)) {
        // show drag-over indicator on dragSource instance also in case that we're not over a component that we can drop the item to
        if (!_isDragOver) dropIndicatorBefore = true;
        rootClassNames.push(this.getClassName().dragOver);
        rootClassNames.push(dropIndicatorBefore ? this.getClassName().dropBefore : this.getClassName().dropAfter);
      }
      dropIndicator = (
        <div
          ref={this._setDropIndicatorRef}
          className={this.getClassName().dropIndicator}
          style={{
            [dropIndicatorBefore ? "marginLeft" : "marginRight"]: dropIndicatorOffset
          }}
        />
      );
    }

    return _connectDropTarget(
      _connectDragPreview(
        // NOTE Native <div> is required by react-dnd.
        <div className={rootClassNames.join(" ")} style={this.props.wrapperStyle} ref={this._setRootNodeRef}>
          {dropIndicator}
          <UU5.Bricks.Card
            {...this._getMainProps()}
            elevation={this.props.elevation}
            elevationHover={elevationHover}
            ref_={this._setCardRef}
          >
            {!_isDragging ? this._renderButtons() : null}
            {!_isDragging ? this._buildChildren() : null}
          </UU5.Bricks.Card>
        </div>
      )
    );
  }
});

const DRAG_ITEM_TYPE = "UU5.Tiles.Tile";

// handling of drop indicator (for dragSource component instance) for case that we're NOT over droppable
// target - react-dnd don't notify us about that on dragSource so we have to handle state transitions
// on dropTarget instances and notify dragSource instance on our own
let dragOpExtraState = {
  dropAllowedOn: {},
  dragSourceComponent: null
};
const handleDragOverChange = function({ isDragOver, canDrop, component }) {
  let { dropAllowedOn, dragSourceComponent } = dragOpExtraState;
  if (!isDragOver || !canDrop) delete dropAllowedOn[component.props.id];
  else dropAllowedOn[component.props.id] = true;
  if (dragSourceComponent) dragSourceComponent.setDragIsOverDroppableTarget(Object.keys(dropAllowedOn).length > 0);
};
const handleDraggingChange = function({ isDragging, component }) {
  // NOTE "isDragging" can change due to unmount and re-mount (we're in virtualized-list so if we scroll down
  // while drag operation is being done then the source component might be unmounted and if we scroll back up
  // a new component should become the drag source).
  if (isDragging) {
    dragOpExtraState.dragSourceComponent = component;
    dragOpExtraState.dragSourceComponent.setDragIsOverDroppableTarget(
      Object.keys(dragOpExtraState.dropAllowedOn).length > 0
    );
  } else if (component === dragOpExtraState.dragSourceComponent) {
    dragOpExtraState.dragSourceComponent = null;
  }
};

const tileDragSource = {
  canDrag(props) {
    return props.draggable;
  },
  beginDrag(props, monitor, component) {
    dragOpExtraState.dragSourceComponent = component.getDecoratedComponentInstance();
    // return the data describing the dragged item
    return { id: props.id, ...props.data };
  },
  endDrag() {
    dragOpExtraState = {
      dropAllowedOn: {},
      dragSourceComponent: null
    };
  },
  isDragging(props, monitor) {
    // our Tile-s are in react-virtualized, i.e. they might be unmounted during drag & sufficient scroll
    // => if user scrolls back (during drag operation) match the newly mounted component by ID
    return props.id === monitor.getItem().id;
  }
};

const dragPropsExpander = function(connect, monitor) {
  // which extra props to inject into component which can be dragged (Tile)
  return {
    _connectDragSource: connect.dragSource(),
    _connectDragPreview: connect.dragPreview(),
    _isDragging: monitor.isDragging(),
    _onDraggingChange: handleDraggingChange
  };
};

const tileDropTarget = {
  canDrop(props, monitor) {
    let item = monitor.getItem();
    return item.id !== props.id; // don't allow dropping onto the same component which is being dragged
  },
  hover(props, monitor, component) {
    if (!component) return;

    let domNode = UU5.Common.DOM.findNode(component);
    let cardNode = domNode ? domNode.lastChild : null;
    if (cardNode) {
      let cardNodeRect = cardNode.getBoundingClientRect();
      let hoverMiddleX = (cardNodeRect.right + cardNodeRect.left) / 2;
      let mouseXY = monitor.getClientOffset();
      let indicateBefore = mouseXY.x < hoverMiddleX;

      let indicatorOffset = 0;
      if (indicateBefore) {
        let prevCardNode = (domNode.previousSibling || {}).lastChild;
        if (prevCardNode) indicatorOffset = (prevCardNode.getBoundingClientRect().right - cardNodeRect.left) / 2;
        else indicatorOffset = (domNode.parentNode.getBoundingClientRect().left - cardNodeRect.left) / 2;
        indicatorOffset += cardNodeRect.left - domNode.getBoundingClientRect().left;
      } else {
        let nextCardNode = (domNode.nextSibling || {}).lastChild;
        if (nextCardNode) {
          indicatorOffset = (cardNodeRect.right - nextCardNode.getBoundingClientRect().left) / 2;
          indicatorOffset += domNode.getBoundingClientRect().right - cardNodeRect.right;
        }
      }
      component.setDropIndicator(indicateBefore, indicatorOffset);
    }
  },
  drop(props, monitor, component) {
    if (!monitor.didDrop()) {
      const item = monitor.getItem();
      if (typeof props.onDrop === "function")
        props.onDrop({
          item,
          component,
          before: component.getDropIndicator().before
        });
    }
  }
};

const dropPropsExpander = function(connect, monitor) {
  // which extra props to inject into component which can be dropped to (Tile)
  return {
    _connectDropTarget: connect.dropTarget(),
    _isDragOver: monitor.isOver(),
    _onDragOverChange: handleDragOverChange,
    _canDrop: monitor.isOver() && monitor.canDrop() // using "monitor.isOver() && ..." because it has much better performance this way
  };
};

// TODO The whole draggable/non-draggable (DragDropContext) should be handled differently, e.g. by having
// DraggableContext in UU5.Common and using that one (instead of prop "draggable"
// because the change in the prop causes unmount & mount due to using wrapped/unwrapped component).
const nonDraggable = function(Component) {
  let identityFn = value => value;
  let result = props => (
    <Component
      {...props}
      _connectDragSource={identityFn}
      _connectDragPreview={identityFn}
      _isDragging={false}
      _onDraggingChange={null}
      _connectDropTarget={identityFn}
      _isDragOver={false}
      _onDragOverChange={null}
      _canDrop={false}
    />
  );
  result.displayName = "nonDraggable(" + Component.displayName + ")";
  return result;
};

const NonDraggableTile = nonDraggable(TileBase);
let DraggableTile;

export const Tile = props => {
  if (props.draggable && Tile._reactDnD) {
    if (!DraggableTile)
      DraggableTile = Tile._reactDnD.DragSource(DRAG_ITEM_TYPE, tileDragSource, dragPropsExpander)(
        Tile._reactDnD.DropTarget([DRAG_ITEM_TYPE], tileDropTarget, dropPropsExpander)(TileBase)
      );
    return <DraggableTile {...props} />;
  } else {
    return <NonDraggableTile {...props} />;
  }
};
Tile.dragSource = tileDragSource;
Tile.dragPropsExpander = dragPropsExpander;
Tile.dropTarget = tileDropTarget;
Tile.dropPropsExpander = dropPropsExpander;
Tile.DRAG_ITEM_TYPE = DRAG_ITEM_TYPE;
export default Tile;
