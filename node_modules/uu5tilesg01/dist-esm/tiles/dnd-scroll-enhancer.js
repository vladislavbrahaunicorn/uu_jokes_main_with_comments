//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../config/config.js";
import "./dnd-scroll-enhancer.less";
//@@viewOff:imports

const DndScrollEnhancerBase = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "DndScrollEnhancer",
    classNames: {
      main: Cfg.CSS + "dnd-scroll-enhancer"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    scrollElement: UU5.PropTypes.oneOfType([UU5.PropTypes.string, UU5.PropTypes.object]),
    horizontalOffset: UU5.PropTypes.number,
    verticalOffset: UU5.PropTypes.number,
    dragDropManager: UU5.PropTypes.any
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      scrollElement: undefined,
      horizontalOffset: 150,
      verticalOffset: 150,
      dragDropManager: undefined
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._enhancerRegistration = null;
    this._domNode = null;
    return {};
  },

  componentDidMount() {
    this._updateEnhancer();
  },

  componentDidUpdate() {
    this._updateEnhancer();
  },

  componentWillUnmount() {
    if (this._enhancerRegistration) this._enhancerRegistration.detach();
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private
  _updateEnhancer() {
    let usedScrollElement;
    if (this.props.scrollElement) {
      usedScrollElement = this.props.scrollElement;
    } else if (this._domNode) {
      let node = this._domNode.parentNode;
      while (node && node.tagName) {
        let computedStyle = getComputedStyle(node);
        if (computedStyle.overflowY !== "visible" && computedStyle.overflowY !== "hidden") {
          usedScrollElement = node;
          break;
        }
        node = node.parentNode;
      }
    }

    let { horizontalOffset, verticalOffset, dragDropManager } = this.props;
    let params = { horizontalOffset, verticalOffset };
    if (!this._enhancerRegistration) {
      if (usedScrollElement)
        this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);
    } else if (usedScrollElement !== this._enhancerRegistration.getScrollElement()) {
      this._enhancerRegistration.detach();
      if (usedScrollElement)
        this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);
      else this._enhancerRegistration = null;
    } else {
      this._enhancerRegistration.setParams(params);
    }
  },

  _setDomNodeRef(ref) {
    this._domNode = ref;
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    return this.props.scrollElement ? null : (
      <span className={UU5.Common.ClassNames.hidden} ref={this._setDomNodeRef} />
    );
  }
  //@@viewOff:render
});

// NOTE Heavily inspired by react-dnd-scrollzone but works for "window" scroll too
// (https://github.com/azuqua/react-dnd-scrollzone/issues/5).
class ScrollEnhancer {
  static instances = new Map();

  /**
   * Initializes / updates scroll enhancer for specified DOM element. This method is safe to be called multiple times for
   * the same element - each such call receives different "registration" that can be used for manipulating
   * the scroll enhancer. Each "registration" must call "registration.detach()" after it no longer wants the DOM element
   * to be enhanced.
   *
   * The parameters that scroll enhancer uses are always taken from the last "registration". After "registration.detach()",
   * if there were multiple "registrations", scroll enhancer will still be active and will use parameters from previous
   * "registration". Scroll enhancer will be detached from the DOM element after all "registrations" are detached.
   *
   * @param {*} scrollElement
   * @param {*} params Parameters for scroll enhancer - horizontalOffset, verticalOffset.
   * @return Scroll enhancer's "registration".
   */
  static attachEnhancer(scrollElement, dragDropManager = null, params = {}) {
    let instanceInfo = ScrollEnhancer.instances.get(scrollElement);
    if (!instanceInfo) {
      let instance = new ScrollEnhancer(scrollElement, dragDropManager, params);
      instanceInfo = { instance, registrations: [] };
      ScrollEnhancer.instances.set(scrollElement, instanceInfo);
    }
    let { instance, registrations } = instanceInfo;
    const registration = {
      getScrollElement: () => scrollElement,
      getParams: () => params,
      detach: () => {
        let idx = registrations.indexOf(registration);
        if (idx === -1) return;
        registrations.pop();
        if (registrations.length === 0) {
          // no active registrations => detach completely
          instance.destroy();
          ScrollEnhancer.instances.delete(scrollElement);
        } else if (idx === registrations.length) {
          // detached registration that was active => change params to previous
          instance.setParams(registrations[idx - 1].getParams());
        }
      },
      setParams: newParams => {
        params = newParams;
        if (registrations[registrations.length - 1] === registration) instance.setParams(params);
      }
    };
    instanceInfo.registrations.push(registration);
    return registration;
  }

  constructor(scrollElement, dragDropManager, params) {
    this.scrollElement = scrollElement;
    this.dragDropManager = dragDropManager;
    this.setParams(params);
    this._isDragging = dragDropManager ? dragDropManager.getMonitor().isDragging() : false;
    this._isTrackingDrag = false;
    this._destroyed = false;
    this._listeners = [];
    this._scrollDeltaX = 30;
    this._scrollDeltaY = 30;

    this._updateScrolling = UU5.Common.Tools.throttle(this._updateScrolling.bind(this), 100, { trailing: false });
    this._startTrackingDrag = this._startTrackingDrag.bind(this);
    this._handleTouchStart = this._handleTouchStart.bind(this);
    this._handleTouchEnd = this._handleTouchEnd.bind(this);
    this._handleTouchCancel = this._handleTouchCancel.bind(this);
    this._handleTouchMove = this._handleTouchMove.bind(this);
    this._onDdmChange = this._onDdmChange.bind(this);
    this._addListener(
      scrollElement === window ? document.scrollingElement || document.body : scrollElement,
      "dragover",
      this._startTrackingDrag
    );
    // "touch" events needs to be on root
    this._addListener(document.scrollingElement || document.body, "touchstart", this._handleTouchStart);
    this._addListener(document.scrollingElement || document.body, "touchend", this._handleTouchEnd);
    this._addListener(document.scrollingElement || document.body, "touchcancel", this._handleTouchCancel);
    this._addListener(document.scrollingElement || document.body, "touchmove", this._handleTouchMove);
    if (dragDropManager) {
      this._clearDdmSubscription = dragDropManager.getMonitor().subscribeToStateChange(this._onDdmChange);
    }
  }

  setParams({ horizontalOffset, verticalOffset }) {
    this.horizontalOffset = horizontalOffset;
    this.verticalOffset = verticalOffset;
  }

  destroy() {
    this._destroyed = true;
    this._listeners.forEach(fn => fn());
    this._stopScrolling();
    this._clearDdmSubscription();
    this._touchCleanup();
    document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
    clearTimeout(this._dragCancelTimeout);
  }

  _addListener(obj, type, fn) {
    obj.addEventListener(type, fn);
    this._listeners.push(() => obj.removeEventListener(type, fn));
  }

  _onDdmChange() {
    let isDragging = this.dragDropManager.getMonitor().isDragging();
    if (isDragging && !this._isDragging) {
      this._isDragging = true;
    } else if (!isDragging && this._isDragging) {
      this._isDragging = false;
      this._stopScrolling();
      document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
    }
  }

  _handleTouchStart(e) {
    // NOTE If the element where touch started gets unmounted (which react-virtualized tends to do...),
    // browser stops sending any touch events. This was happening on Android devices on e12.html demo.
    //   =>
    // Guard the element and if during scrolling we detect that the element got unmounted, we'll
    // re-mount it to the BODY as hidden, which luckily makes touch events work again.
    if (!this._guardedTouchNode) {
      this._guardedTouchNode = e.target;
    }
  }

  _handleTouchEnd(e) {
    this._touchCleanup();
  }

  _handleTouchCancel(e) {
    this._touchCleanup();
  }

  _touchCleanup() {
    if (this._guardedTouchNode) {
      if (this._guardedTouchNodeRemounted && this._guardedTouchNode.parentNode) {
        this._guardedTouchNode.parentNode.removeChild(this._guardedTouchNode);
      }
      this._guardedTouchNode = null;
      this._guardedTouchNodeRemounted = false;
    }
  }

  _handleTouchMove(e) {
    // only start tracking if touchstart has been triggerred on our scrollingElement (i.e. we have a guarded node)
    if (this._guardedTouchNode) this._startTrackingDrag(e);
  }

  _startTrackingDrag(e) {
    if (!this._isTrackingDrag && (!this.dragDropManager || this._isDragging)) {
      this._isTrackingDrag = true;
      (document.scrollingElement || document.body).addEventListener("dragover", this._updateScrolling);
      (document.scrollingElement || document.body).addEventListener("touchmove", this._updateScrolling);
    }
  }

  _stopTrackingDrag() {
    this._isTrackingDrag = false;
    (document.scrollingElement || document.body).removeEventListener("dragover", this._updateScrolling);
    (document.scrollingElement || document.body).removeEventListener("touchmove", this._updateScrolling);
    clearTimeout(this._dragCancelTimeout);
  }

  _updateScrolling(e) {
    document.documentElement.classList.add("uu5-tiles-dnd-scroll-enhancer-scrolling");
    if (!this.dragDropManager) {
      this._isDragging = true;
      // if user drags e.g. .zip file over BODY and drops it then we don't get
      // any event about that => if no dragover happens within
      // some time then assume the user is no longer dragging
      clearTimeout(this._dragCancelTimeout);
      Promise.resolve().then(() => {
        if (this._destroyed) return;
        this._dragCancelTimeout = setTimeout(() => {
          if (this._isDragging) {
            this._isDragging = false;
            this._stopScrolling();
            document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
          }
        }, 500);
      });
    }

    let scrollElement = this.scrollElement;
    let scrollZoneRect =
      scrollElement === window
        ? {
            left: 0,
            top: 0,
            bottom: window.innerHeight,
            right: window.innerWidth,
            height: window.innerHeight,
            width: window.innerWidth
          }
        : scrollElement.getBoundingClientRect();
    let mousePos =
      e.type === "touchmove"
        ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }
        : { x: e.clientX, y: e.clientY };

    let animate = false;
    let insideScrollZone = false;
    if (
      scrollZoneRect.left <= mousePos.x &&
      mousePos.x <= scrollZoneRect.right &&
      scrollZoneRect.top <= mousePos.y &&
      mousePos.y <= scrollZoneRect.bottom
    ) {
      this._runningAdjust = this._computeScrollAdjust(scrollZoneRect, mousePos);
      animate = !!(this._runningAdjust.dx || this._runningAdjust.dy);
      insideScrollZone = true;
    }
    if (animate) {
      if (!this._runningRafId) this._startScrolling();
    } else if (!this.dragDropManager || !insideScrollZone) {
      this._runningAdjust = {};
      this._stopScrolling();
    }
  }

  _startScrolling() {
    let i = 0;
    let tick = () => {
      if (!this._guardedTouchNodeRemounted && this._guardedTouchNode && !document.contains(this._guardedTouchNode)) {
        this._guardedTouchNodeRemounted = true;
        this._guardedTouchNode.classList.add("uu5-common-hidden");
        document.body.appendChild(this._guardedTouchNode);
      }
      let { dx, dy } = this._runningAdjust;
      if (!dx && !dy) {
        this._stopScrolling();
      } else {
        i ^= 1; // on Android mobiles we cannot scroll on each paint because it somehow stops the page from dnd handling
        if (i) {
          let elem = this.scrollElement === window ? document.scrollingElement || document.body : this.scrollElement;
          let newScrollLeft = Math.max(0, Math.min(elem.scrollWidth - elem.clientWidth, elem.scrollLeft + dx));
          let newScrollTop = Math.max(0, Math.min(elem.scrollHeight - elem.clientHeight, elem.scrollTop + dy));
          if (newScrollLeft !== elem.scrollLeft) elem.scrollLeft = newScrollLeft;
          if (newScrollTop !== elem.scrollTop) elem.scrollTop = newScrollTop;
        }
        this._runningRafId = requestAnimationFrame(tick);
      }
    };
    tick();
  }

  _stopScrolling() {
    this._stopTrackingDrag();
    if (this._runningRafId) cancelAnimationFrame(this._runningRafId);
    this._runningRafId = null;
  }

  _computeScrollAdjust(scrollZoneRect, mousePos) {
    let horizontalOffset = Math.max(1, Math.min(this.horizontalOffset, scrollZoneRect.width / 2 - 64)); // 128x128 <=> reserved for central square which doesn't react to scroll (to be able to drop)
    let leftEdgeNorm = 1 - (mousePos.x - scrollZoneRect.left) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>
    let rightEdgeNorm = 1 - (scrollZoneRect.right - mousePos.x) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>
    let verticalOffset = Math.max(1, Math.min(this.verticalOffset, scrollZoneRect.height / 2 - 64));
    let topEdgeNorm = 1 - (mousePos.y - scrollZoneRect.top) / verticalOffset; // (-Inf, 1>, valid is <0, 1>
    let bottomEdgeNorm = 1 - (scrollZoneRect.bottom - mousePos.y) / verticalOffset; // (-Inf, 1>, valid is <0, 1>

    let ease = number => number; // linear easing
    let dx = leftEdgeNorm >= 0 ? -ease(leftEdgeNorm) : rightEdgeNorm >= 0 ? ease(rightEdgeNorm) : 0;
    let dy = topEdgeNorm >= 0 ? -ease(topEdgeNorm) : bottomEdgeNorm >= 0 ? ease(bottomEdgeNorm) : 0;
    dx = Math.round(dx * this._scrollDeltaX);
    dy = Math.round(dy * this._scrollDeltaY);
    return { dx, dy };
  }
}

export const DndScrollEnhancer = UU5.Common.DnD.withContext(DndScrollEnhancerBase);
export default DndScrollEnhancer;
