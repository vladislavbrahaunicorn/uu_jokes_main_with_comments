//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../config/config.js";
import Lsi from "../config/lsi.js";
import { mergeButtonProps } from "./util.js";
import "./action-bar.less";
//@@viewOff:imports

export const ActionBar = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [
    UU5.Common.BaseMixin,
    UU5.Common.ElementaryMixin,
    UU5.Common.ScreenSizeMixin,
    UU5.Common.ColorSchemaMixin,
    UU5.Common.PureRenderMixin,
    UU5.Common.NestingLevelMixin,
    UU5.Common.LsiMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ActionBar",
    classNames: {
      main: Cfg.CSS + "action-bar",
      searchInput: Cfg.CSS + "action-bar-search-input",
      titleBox: Cfg.CSS + "action-bar-titlebox",
      title: Cfg.CSS + "action-bar-title",
      titleSticky: Cfg.CSS + "action-bar-title-sticky",
      buttonsBox: Cfg.CSS + "action-bar-buttonsbox",
      controlledContentButton: Cfg.CSS + "action-bar-controlled-content-button",
      inputBox: Cfg.CSS + "action-bar-inputbox",
      selectedButton: Cfg.CSS + "action-bar-selected-button",
      selectedButtonActive: Cfg.CSS + "action-bar-selected-button-active",
      filteredButton: Cfg.CSS + "action-bar-filtered-button",
      dropdown: Cfg.CSS + "action-bar-dropdown",
      chevron: Cfg.CSS + "action-bar-chevron",
      searchButton: Cfg.CSS + "action-bar-search-button",
      searchButtonActive: Cfg.CSS + "action-bar-search-button-active"
    },
    defaults: {
      maxButtons: 3
    },
    lsi: Lsi.actionBar,
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "boxCollection"),
    opt: {
      pureRender: true // avoid re-render from parent
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    controller: UU5.PropTypes.object,
    title: UU5.PropTypes.any,
    searchable: UU5.PropTypes.bool,
    searchPlaceholder: UU5.PropTypes.any,
    searchEvents: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    onItemSearch: UU5.PropTypes.func,
    collapsible: UU5.PropTypes.bool,
    collapsed: UU5.PropTypes.bool,
    actions: UU5.PropTypes.arrayOf(
      UU5.PropTypes.shape({
        content: UU5.PropTypes.any, // UU5 content
        controlledContent: UU5.PropTypes.bool,
        icon: UU5.PropTypes.string,
        onClick: UU5.PropTypes.func,
        active: UU5.PropTypes.bool,
        bgStyle: UU5.PropTypes.string,
        borderRadius: UU5.PropTypes.string,
        disabled: UU5.PropTypes.bool
      })
    ),
    bgStyle: UU5.PropTypes.oneOf(["outline", "underline"]),
    borderRadius: UU5.PropTypes.string,
    elevation: UU5.PropTypes.oneOf(["0", "1", "2", "3", "4", "5", 0, 1, 2, 3, 4, 5]),
    buttonProps: UU5.PropTypes.oneOfType([UU5.PropTypes.object, UU5.PropTypes.func])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      controller: null,
      title: "Action Bar",
      searchable: true,
      searchEvents: ["onBlur", "onEnter"],
      actions: [],
      searchPlaceholder: Lsi.actionBar.searchPlaceholder,
      collapsible: true,
      collapsed: false,
      bgStyle: "underline",
      borderRadius: null,
      elevation: null,
      buttonProps: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    if (!this.props.controller) {
      UU5.Common.Tools.error(
        `The prop \`controller\` cannot be empty for ${this.getTagName()}. Either provide the prop or nest the component into UU5.Tiles.ListController.`
      );
    }
    return {
      searchText: "",
      toolbarExpanded: !this.props.collapsed
    };
  },

  componentDidMount() {
    this.props.controller.registerBar("actionBar", this);
  },

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.controlled &&
      ((this.props.collapsible &&
        this.props.collapsed !== prevProps.collapsed &&
        this.props.collapsed === this.state.toolbarExpanded) ||
        (this.props.collapsible !== prevProps.collapsible && !this.state.toolbarExpanded))
    ) {
      this._toggleToolbar();
    }
  },

  componentWillUnmount() {
    this.props.controller.unregisterBar("actionBar");
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  resetSearch() {
    this.setState({ searchText: "" }, () => this._search.setValue(""));
  },

  search(value) {
    if (value !== undefined && this._search) this._search.setValue(value || "");
    this._onSearch({ value: value === undefined && this._search ? this._search.getValue() : value || "" });
  },

  update(setStateCallback) {
    if (this._search && this.props.controller.getStatus().showSelected) {
      this._search.readOnly();
      this._search.setValue("");
    } else if (this._search && this._search.isReadOnly()) {
      this._search.editable();
      this._search.setValue(this.state.searchText);
    }
    this.forceUpdate(setStateCallback);
    return true;
  },
  //@@viewOff:interface

  //@@viewOn:overriding
  //@@viewOff:overriding

  //@@viewOn:private

  _buildGenericSearchFunc() {
    return (item, searchValue) => {
      let searchList = searchValue
        .toLowerCase()
        .split(/[.,;:!?\s]/g)
        .filter(Boolean);

      return Object.values(item).some(value => {
        let r;
        let v = this.getLsiItem(value);
        if (typeof v === "string" || typeof v === "number")
          r = Boolean(
            searchList.some(
              searchWord =>
                v
                  .toString()
                  .toLowerCase()
                  .indexOf(searchWord.toLowerCase()) !== -1
            )
          );
        else r = false;
        return r;
      });
    };
  },

  _onSearch(opt, eventName) {
    //TODO remove magic key
    let searchText = opt.value.trim();
    let searchTextLabel = searchText.length - 1 > 16 ? searchText.substr(0, 15) + "\u2026" : searchText;
    if (this.state.searchText !== searchText) {
      let searchFunc = this.props.onItemSearch || this._buildGenericSearchFunc(opt.value);
      this.setState({ searchText: searchText }, () => {
        if (searchText) {
          this.props.controller.addFilterExt(
            "search",
            this.getLsiValue("searchFilterLabel"),
            searchTextLabel,
            item => searchFunc(item, searchText),
            this.resetSearch
          );
        } else {
          this.props.controller.removeFilterExt("search");
        }
      });
    }
    if (eventName === "onChange") {
      // TODO: debounce & min 3 char?
      opt.component.setValue(opt.value);
    }
  },

  _toggleSearch() {
    if (this._searchPanel.isHidden()) {
      this.state.toolbarExpanded ? this._searchPanel.show() : this._toggleToolbar(() => this._searchPanel.show());
    } else {
      this._searchPanel.hide();
    }
  },

  _getInput() {
    let child = null;
    if (this.props.searchable) {
      let eventProps = {};
      let searchEvents = [...this.props.searchEvents, "onClick"];
      searchEvents.forEach(event => (eventProps[event] = opt => this._onSearch(opt, event)));
      child = (
        <UU5.Forms.TextIcon
          ref_={r => (this._search = r)}
          className={this.getClassName().searchInput}
          name="search"
          controlled={false}
          iconPosition="right"
          icon="mdi-magnify"
          placeholder={
            this.props.controller.getStatus().showSelected
              ? this.getLsiValue("searchInactive")
              : this.getLsiItem(this.props.searchPlaceHolder || this.props.searchPlaceholder)
          }
          {...eventProps}
        />
      );
    }
    return child;
  },

  _getButtons() {
    let maxItems = this.getDefault("maxButtons");

    let actions = [];
    if (this.props.searchable) {
      if (this.isXs()) {
        let colorSchema = this.state.searchText ? this.props.colorSchema || "blue" : "grey";
        actions.push(
          <UU5.Bricks.Button
            bgStyle="outline"
            ref_={r => (this._searchButton = r)}
            onClick={this._toggleSearch}
            colorSchema={colorSchema}
          >
            <UU5.Bricks.Icon icon="mdi-magnify" />
          </UU5.Bricks.Button>
        );
      }
      // search space
      maxItems--;
    }

    let isMoreButton = this.props.actions.length > maxItems;
    if (isMoreButton) {
      // other buttons space
      maxItems--;
    }

    let items = [];
    this.props.actions.forEach((item, i) => {
      if (item.active && maxItems > 0) {
        let { active, content, icon, controlledContent, ...restProps } = item; // eslint-disable-line
        let usedBtnProps = mergeButtonProps(
          {
            colorSchema: this.props.colorSchema || "blue"
          },
          this.props.buttonProps,
          item.key || "action-" + i
        );
        if (controlledContent) {
          content = content && this.getLsiItem(content);
          usedBtnProps.className = (usedBtnProps.className || "") + ` ${this.getClassName("controlledContentButton")}`; 
        } else {
          content = this.isXs() || this.isS() ? null : this.getLsiItem(content);
        }
        actions.push(
          <UU5.Bricks.Button {...usedBtnProps} {...restProps}>
            <UU5.Bricks.Icon icon={icon} />
            {content}
          </UU5.Bricks.Button>
        );
        // button space
        maxItems--;
      } else {
        // other buttons space
        !items.length && !isMoreButton && maxItems--;
        items.push({
          label: this.getLsiItem(item.content),
          onClick: item.onClick,
          disabled: item.disabled
        });
      }
    });

    if (items.length) {
      let props = mergeButtonProps(
        {
          bgStyle: "outline",
          label: <UU5.Bricks.Icon icon="mdi-dots-vertical" />,
          className: this.getClassName("dropdown"),
          colorSchema: "grey",
          iconHidden: true,
          items: items,
          pullRight: true
        },
        this.props.buttonProps,
        "menu"
      );
      actions.push(<UU5.Bricks.Dropdown {...props} />);
    }
    return UU5.Common.Children.toArray(actions);
  },

  _getButtonsWidth() {
    let width = 0;
    let buttonsLength = this.props.actions.length;
    let buttonWidth = 40;

    if (this.isXs()) {
      if (this.props.searchable) {
        buttonsLength++;
        width = 2;
      }
      buttonsLength = Math.min(buttonsLength, this.getDefault("maxButtons"));
      width = width + buttonsLength * buttonWidth;
    } else if (this.isS()) {
      let maxButtons = this.getDefault("maxButtons");
      if (this.props.searchable) {
        maxButtons--;
        width = 172;
      }
      buttonsLength = Math.min(buttonsLength, maxButtons);
      width = width + buttonsLength * buttonWidth;
    }
    return width;
  },

  _toggleToolbar(setStateCallback) {
    this.setState(
      prevState => {
        return { toolbarExpanded: !prevState.toolbarExpanded };
      },
      () => this.props.controller.toggleToolbar(setStateCallback)
    );
  },

  _getStatusButtons() {
    let actions = [<br key="br" />];
    let status = this.props.controller.getStatus();
    if (status.selected)
      actions.push(
        <UU5.Bricks.Button
          bgStyle="outline"
          className={
            status.showSelected ? this.getClassName().selectedButtonActive : this.getClassName().selectedButton
          }
          onClick={() => this._toggleToolbar()}
        >
          {`${status.selected}`}
        </UU5.Bricks.Button>
      );
    if (status.filterCount && !status.showSelected)
      actions.push(
        <UU5.Bricks.Button
          colorSchema="blue"
          className={this.getClassName().filteredButton}
          onClick={() => this._toggleToolbar()}
        >
          {`${status.filterCount}`}
        </UU5.Bricks.Button>
      );
    return actions.length > 1 && UU5.Common.Children.toArray(actions);
  },

  _getChevron() {
    return (
      <UU5.Bricks.Button
        bgStyle="transparent"
        onClick={() => this._toggleToolbar()}
        colorSchema="grey"
        className={this.getClassName().chevron}
      >
        <UU5.Bricks.Icon icon={this.state.toolbarExpanded ? "mdi-chevron-up" : "mdi-chevron-down"} />
      </UU5.Bricks.Button>
    );
  },

  _isLsi(value) {
    return value && typeof value === "object" && ("en" in value || "cs" in value); // good-enough detection for backward compatibility
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let buttonsWidth = this._getButtonsWidth();
    let titleClassName = this.getClassName("title");
    if (!this.props.collapsible) titleClassName += " " + this.getClassName("titleSticky");
    let title = this._isLsi(this.props.title) ? this.getLsiItem(this.props.title) : this.props.title;

    let mainProps = this.getMainPropsToPass();
    delete mainProps.nestingLevel;
    mainProps.colorSchema = "custom";
    if (mainProps.className) mainProps.className = mainProps.className.replace(/\bcolor-schema-\S+/g, "");
    if (this.props.borderRadius) {
      mainProps.style = { ...mainProps.style };
      mainProps.style.borderRadius = this.props.borderRadius;
    }
    if (this.props.bgStyle) mainProps.className += " uu5-common-bg-style-" + this.props.bgStyle;
    if (this.props.elevation) mainProps.className += " uu5-elevation-" + this.props.elevation;

    return this.getNestingLevel() ? (
      <UU5.Bricks.Div {...mainProps}>
        <UU5.Bricks.Div
          className={this.getClassName("titleBox")}
          style={{ maxWidth: buttonsWidth ? `calc(100% - ${buttonsWidth}px)` : undefined }}
        >
          <UU5.Bricks.Span className={titleClassName} content={title} />
          {this.props.collapsible && this._getChevron()}
          {/*{this.props.collapsible && !this.state.toolbarExpanded && this._getStatusButtons()}*/}
        </UU5.Bricks.Div>
        <UU5.Bricks.Div className={this.getClassName("buttonsBox")}>
          {!this.isXs() && this._getInput()}
          {this._getButtons()}
        </UU5.Bricks.Div>
        {this.isXs() && (
          <UU5.Bricks.Div className={this.getClassName("inputBox")} hidden ref_={r => (this._searchPanel = r)}>
            {this._getInput()}
          </UU5.Bricks.Div>
        )}
      </UU5.Bricks.Div>
    ) : null;
  }
  //@@viewOff:render
});

export default ActionBar;
