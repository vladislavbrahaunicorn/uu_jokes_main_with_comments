const MAX_ITEM_COUNT_IN_MEMORY = 1000;

export default {
  evictItems(list, exceptFrom, exceptTo) {
    let needsEvict = list.length > MAX_ITEM_COUNT_IN_MEMORY;
    if (needsEvict) {
      let inMemoryItems = [];
      for (let i = 0, len = list.length; i < len; ++i) {
        let item = list[i];
        if (item && (i < exceptFrom || i >= exceptTo)) {
          // the item is not in page and we've exceeded memory limit => compute its relevancy
          // (least relevant items will be then removed from memory); relevancy is based
          // on distance from current page and from start / end of the list to match
          // standard scroll patterns (PgUp, PgDn, arrows; Home; End)
          let distancePage = i < exceptFrom ? exceptFrom - i : i - exceptTo + 1;
          let distanceStart = i;
          let distanceEnd = len - i - 1;
          let relevancy = -distancePage;
          if (distanceStart <= 100) relevancy = Math.max(relevancy, -distanceStart);
          if (distanceEnd <= 100) relevancy = Math.max(relevancy, -distanceEnd);
          inMemoryItems.push({ index: i, item, relevancy });
        }
      }
      inMemoryItems.sort((a, b) => a.relevancy - b.relevancy); // less relevant are at the start of the array
      let itemsToForget = inMemoryItems.slice(0, -Math.max(0, MAX_ITEM_COUNT_IN_MEMORY - (exceptTo - exceptFrom)));
      itemsToForget.forEach(({ index }) => (list[index] = undefined));
    }
  }
};
