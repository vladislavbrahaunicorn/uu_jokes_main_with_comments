//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../config/config.js";
import "./list-controller.less";
import ListCache from "./list-cache.js"; //@@viewOff:imports

export const ListController = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin, UU5.Common.NestingLevelMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ListController",
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "bigBox"),
    classNames: {
      main: Cfg.CSS + "list-controller",
      list: Cfg.CSS + "list-controller-list",
      padding: Cfg.CSS + "list-controller-padding-",
      toolbarContainer: Cfg.CSS + "list-controller-toolbar-container",
      listContainer: Cfg.CSS + "list-controller-list-container",
      noItems: Cfg.CSS + "list-controller-no-items"
    },
    errors: {
      noIfcJustSelected: "Interface %s is not possible to call if just selected items are displayed.",
      wrongLocalFilterValue: "Cannot use filter '%s' with value %s. The value must be a function `item => includeItem ? true : false` or you must provide prop onLoad to turn on loading & filtering via remote call.",
      wrongRemoteFilterValue: "Cannot use filter '%s' with value of type '%s' because loading via remote call is turned on (prop onLoad is used). Only JSON-serializable values can be used.",
      wrongLocalSorterValue: "Cannot use sorter '%s' with value %s. The value must be a function `(item1, item2, opts) => number` or you must provide prop onLoad to turn on loading & sorting via remote call.",
      wrongRemoteSorterValue: "Cannot use sorter '%s' with value of type '%s' because loading via remote call is turned on (prop onLoad is used). Use value true for descending sort, false otherwise."
    },
    lsi: {
      noItems: {
        cs: "Nebyla nalezena žádná položka.",
        en: "No items was found."
      }
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.array,
    autoResize: UU5.PropTypes.bool,
    padding: UU5.PropTypes.oneOf(["all", "toolbar", "none"]),
    selectable: UU5.PropTypes.bool,
    draggable: UU5.PropTypes.bool,
    onChange: UU5.PropTypes.func,
    onLoad: UU5.PropTypes.func,
    onLoadPageSize: UU5.PropTypes.number,
    onSelect: UU5.PropTypes.func
  },

  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: [],
      autoResize: process.env.NODE_ENV === "test" ? false : true,
      padding: "all",
      selectable: true,
      onLoadPageSize: undefined,
      onSelect: undefined
    };
  },

  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._filterMap = {};
    this._sorterList = [];
    this._selected = {};
    this._scrollTo = 0;
    this._status = {
      total: 0,
      displayed: 0,
      selected: 0,
      showSelected: false
    };
    this._list = null;
    this._barMap = {};
    this._loadCallFilterMap = this._getLoadCallFilterMap();
    this._loadCallSorterList = this._getLoadCallSorterList();
    return {
      displayedData: this._getDisplayedData(this.props.data, null),
      toolbarExpanded: this._isToolbarExpanded(),
      data: this.props.data,
      invalidationMap: {},
      fullInvalidationCounter: 1,
      serverTotal: undefined
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      // eslint-disable-line react/prop-types
      let onLoadChanged = nextProps.onLoad !== this.props.onLoad;

      for (let id in this._selected) {
        let matchingItem = nextProps.data.find(dataItem => dataItem.id === id);

        if (matchingItem) {
          this._selected[id] = matchingItem;
        } else {
          delete this._selected[id];
        }
      }

      this.setState(state => ({
        data: nextProps.data,
        toolbarExpanded: this._isToolbarExpanded(nextProps),
        displayedData: this._getDisplayedData(nextProps.data, onLoadChanged ? null : state.serverTotal),
        serverTotal: onLoadChanged ? null : state.serverTotal,
        invalidationMap: {}
      }), this._updateBars);
    }
  },

  componentDidMount() {
    // NOTE If we ever add support for setting initial filters, it'll be necessary to perform
    // server-side call (onLoad) here to figure out total (unfiltered) count of items.
    if (navigator.userAgent.match(/Trident\/[.0-9]*|Edge\/[.0-9]*|Mac.*?Version\/.*?Safari\//)) {
      let domNode = this._toolbarContainerElem;

      if (domNode) {
        domNode.addEventListener("animationstart", this._animationFix);
        domNode.addEventListener("animationend", this._animationFix);
      }
    }
  },

  componentWillUnmount() {
    if (navigator.userAgent.match(/Trident\/[.0-9]*|Edge\/[.0-9]*|Mac.*?Version\/.*?Safari\//)) {
      let domNode = this._toolbarContainerElem;

      if (domNode) {
        domNode.removeEventListener("animationstart", this._animationFix);
        domNode.removeEventListener("animationend", this._animationFix);
      }
    }
  },

  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  toggleToolbar(setStateCallback) {
    this.setState(prevState => {
      return {
        toolbarExpanded: !prevState.toolbarExpanded
      };
    }, setStateCallback);
  },

  collapseToolbar(setStateCallback) {
    this.setState({
      toolbarExpanded: false
    }, setStateCallback);
  },

  expandToolbar(setStateCallback) {
    this.setState({
      toolbarExpanded: true
    }, setStateCallback);
  },

  isToolbarExpanded() {
    return this.state.toolbarExpanded;
  },

  getStatus() {
    return this._status;
  },

  findItem(func) {
    return this.state.data.find(func);
  },

  getSelectedItemList(data = this.state.data) {
    let selected = { ...this._selected
    };
    let result = []; // NOTE The result order must be same as in state.data. Additionally, prefer item data from state
    // instead of from selection as it might be "newer" when using server calls.

    for (let v of data) {
      if (v && v.id) {
        let selectedItem = selected[v.id];
        if (selectedItem) result.push(selectedItem);
        delete selected[v.id];
      }
    }

    for (let k in selected) result.push(selected[k]);

    return result;
  },

  addSelectedItem(id, setStateCallback) {
    // remember the data instead of just true/false - when using server calls (props.onLoad) the user
    // might select an item, use a filter after which the item is no longer visible and might have been removed
    // from this.state.data as well (if the total item count in memory exceeded threshold) therefore
    // we wouldn't be able to show all selected items
    let item = this.state.data.find(item => item && item.id === id);

    if (item) {
      this._selected[id] = item;

      let callback = () => {
        if (typeof this.props.onSelect === "function") {
          this.props.onSelect({
            component: this,
            selected: this.state.data.filter(item => item && this._selected[item.id])
          });
        }

        if (typeof setStateCallback === "function") setStateCallback();
      };

      this._setData(callback);
    }

    return this;
  },

  removeSelectedItem(id, setStateCallback) {
    delete this._selected[id];

    let callback = () => {
      if (typeof this.props.onSelect === "function") {
        this.props.onSelect({
          component: this,
          selected: this.state.data.filter(item => item && this._selected[item.id])
        });
      }

      if (typeof setStateCallback === "function") setStateCallback();
    };

    !this._status.showSelected || Object.keys(this._selected).length ? this._setData(callback) : this.hideJustSelected(callback);
    return this;
  },

  clearSelected(setStateCallback) {
    this._selected = {};

    let callback = () => {
      if (typeof this.props.onSelect === "function") {
        this.props.onSelect({
          component: this,
          selected: []
        });
      }

      if (typeof setStateCallback === "function") setStateCallback();
    };

    this._status.showSelected ? this.hideJustSelected(callback) : this._setData(callback);
    return this;
  },

  selectAll() {
    // selecting all is not allowed when using server calls
    if (!this.props.onLoad) {
      let itemsWithId = this.state.displayedData.filter(Boolean).filter(item => item.id);
      itemsWithId.forEach(item => {
        this._selected[item.id] = item;
      });

      this._setStatusNumbers();

      this._setData(() => {
        if (typeof this.props.onSelect === "function") {
          this.props.onSelect({
            component: this,
            selected: itemsWithId
          });
        }
      });
    }

    return this;
  },

  showJustSelected(setStateCallback) {
    this._status.showSelected = true;
    return this._setData(setStateCallback);
  },

  hideJustSelected(setStateCallback) {
    this._status.showSelected = false;
    return this._setData(setStateCallback);
  },

  isFilterUsable(msgKey) {
    if (this._status.showSelected) {
      this.showError("noIfcJustSelected", msgKey);
      return false;
    } else {
      return true;
    }
  },

  addFilter(key, valueOrFilterFunc, removeFilterFunc, setStateCallback) {
    let result = false;

    if (this.isFilterUsable("addFilter") && this._isFilterValueAllowed(key, valueOrFilterFunc)) {
      this._filterMap[key] = {};
      if (typeof valueOrFilterFunc === "function") this._filterMap[key].filterFunc = valueOrFilterFunc;else this._filterMap[key].value = valueOrFilterFunc;
      if (typeof removeFilterFunc === "function") this._filterMap[key].removeFilterFunc = removeFilterFunc;

      this._setData(setStateCallback);

      result = this;
    }

    return result;
  },

  removeFilter(key, setStateCallback) {
    if (this.isFilterUsable("removeFilter")) {
      if (this._filterMap[key]) {
        if (typeof this._filterMap[key].removeFilterFunc === "function") this._filterMap[key].removeFilterFunc(key);
        delete this._filterMap[key];

        this._setData(setStateCallback);
      }

      return this;
    } else {
      return false;
    }
  },

  addFilterExt(key, label, value, filterFunc, removeFilterFunc) {
    if (this.isFilterUsable("addFilterExt") && this._isFilterValueAllowed(key, typeof this.props.onLoad === "function" ? value : filterFunc)) {
      if (this._barMap.filterBar) this._barMap.filterBar.addFilter(key, label, value, filterFunc, removeFilterFunc);else this.addFilter(key, filterFunc || value, removeFilterFunc);
      return this;
    } else {
      return false;
    }
  },

  removeFilterExt(key) {
    if (this.isFilterUsable("removeFilterExt")) {
      if (this._barMap.filterBar) this._barMap.filterBar.removeFilter(key);else this.removeFilter(key);
      return this;
    } else {
      return false;
    }
  },

  clearFilters(setStateCallback) {
    if (this.isFilterUsable("clearFilters")) {
      Object.entries(this._filterMap).forEach(([key, filter]) => {
        if (typeof filter.removeFilterFunc === "function") filter.removeFilterFunc(key);
      });
      this._filterMap = {};
      return this._setData(() => {
        this._barMap.filterBar ? this._barMap.filterBar.clearFilters(setStateCallback) : typeof setStateCallback === "function" && setStateCallback();
      });
    } else {
      return false;
    }
  },

  setSorter(key, descendingOrSorterFunc, setStateCallback) {
    if (this._isSorterValueAllowed(key, descendingOrSorterFunc)) {
      let item = {
        key
      };
      if (typeof this.props.onLoad === "function") item.descending = descendingOrSorterFunc;else item.sorterFunc = descendingOrSorterFunc;
      this._sorterList = [item]; // remove previous and use just one

      this._setData(setStateCallback);
    }

    return this;
  },

  addSorter(key, descendingOrSorterFunc, setStateCallback) {
    if (this._isSorterValueAllowed(key, descendingOrSorterFunc)) {
      let item = {
        key
      };
      if (typeof this.props.onLoad === "function") item.descending = descendingOrSorterFunc;else item.sorterFunc = descendingOrSorterFunc;

      this._sorterList.push(item);

      this._setData(setStateCallback);
    }
  },

  removeSorter(key, setStateCallback) {
    this._sorterList = this._sorterList.filter(sorter => sorter.key !== key);
    return this._setData(setStateCallback);
  },

  clearSorters(setStateCallback) {
    this._sorterList = [];
    return this._setData(() => {
      this._barMap.infoBar ? this._barMap.infoBar.clearSorters(setStateCallback) : typeof setStateCallback === "function" && setStateCallback();
    });
  },

  registerBar(key, bar) {
    this._barMap[key] = bar;
  },

  unregisterBar(key) {
    delete this._barMap[key];
  },

  getBar(key) {
    return this._barMap[key];
  },

  registerList(list) {
    this._list = list;
  },

  getTileProps(tileId) {
    return {
      selected: !!this._selected[tileId],
      onSelect: this._setSelected,
      selectable: this.props.selectable,
      controller: this
    };
  },

  onChangeDefault(opt) {
    let {
      data
    } = opt;
    this.setData(data);
  },

  setData(data,
  /* pageInfo = null, dtoInData = null, setStateCallback*/
  ...args) {
    let setStateCallback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
    let pageInfo = args.shift();
    let dtoInData = args.shift();
    this.setState(state => {
      let {
        serverTotal
      } = state;
      let invalidationMap;
      let newData;
      let oldData = this._pendingReset ? [] : state.data || [];

      if (pageInfo) {
        // we got single page (partial data) => merge data into current
        // NOTE We also clear "old" items if there's too many of them in the memory but
        // the new page data is always stored in the memory entirely (even if it exceeds the max item count)
        // because we don't know which items are currently visible in the viewport and the assumption
        // is that the latest async load is for the currently visible items. TODO Ensure async load callbacks
        // are fired in order.
        // NOTE When clearing memory, if we try to compute which items are visible and it will not be sufficiently exact,
        // it might result in never-ending (async) re-rendering loop (depending on which items are cleared from memory).
        let from = pageInfo.pageIndex * pageInfo.pageSize || 0;
        let to = from + (data ? data.length : 0);
        invalidationMap = { ...state.invalidationMap
        };
        newData = new Array(typeof pageInfo.total === "number" ? pageInfo.total : Math.max(to, oldData.length));

        for (let i = 0, len = newData.length; i < len; ++i) {
          newData[i] = from <= i && i < to ? data[i - from] : oldData[i];
          if (from <= i && i < to && newData[i]) delete invalidationMap[newData[i].id];
        }

        ListCache.evictItems(newData, from, to);

        if (typeof pageInfo.total === "number") {
          if (!dtoInData || !dtoInData.filterMap || Object.keys(dtoInData.filterMap).length === 0) {
            serverTotal = pageInfo.total;
          }
        }

        this._syncSelectedWithData(newData, oldData, from, to);
      } else {
        newData = data;
        invalidationMap = {};

        if (newData) {
          for (let i = 0; i < newData.length; ++i) if (newData[i]) delete invalidationMap[newData[i].id];
        }

        this._syncSelectedWithData(newData, oldData);
      }

      delete this._pendingReset;
      return {
        data: newData,
        displayedData: this._getDisplayedData(newData, serverTotal),
        serverTotal,
        invalidationMap
      };
    }, () => {
      this._updateBars(setStateCallback);
    });
  },

  getData() {
    return this.state.data;
  },

  getTileCount() {
    return this.state.serverTotal != null ? this.state.serverTotal : (this.state.data || []).length;
  },

  invalidateData(data = this.state.data) {
    // NOTE There's special case when the current list has 0 items - in such case we need to perform
    // full reload, which we do by changing UU5.Tiles.List key (thanks to state.fullInvalidationCounter).
    this.setState(state => {
      let invalidationMap = { ...state.invalidationMap
      };
      let fullInvalidationCounter = state.fullInvalidationCounter + (!data || data.length === 0 ? 1 : 0);
      let length = data ? data.length : 0;

      for (let i = 0; i < length; ++i) {
        let value = data[i];
        if (typeof value === "string") invalidationMap[value] = true;else if (value && value.id) invalidationMap[value.id] = true;
      }

      return {
        invalidationMap,
        fullInvalidationCounter
      };
    }, () => this._list && this._list.invalidateData());
  },

  getLoadParams() {
    let result = {};
    if (Object.keys(this._loadCallFilterMap).length > 0) result.filterMap = this._loadCallFilterMap;
    if (this._loadCallSorterList.length > 0) result.sorterList = this._loadCallSorterList;
    return result;
  },

  isTileLoaded(tileIndex) {
    let result = false;

    if (!this._pendingReset) {
      let tileData = this.state.displayedData[tileIndex];
      if (tileData && !this.state.invalidationMap[tileData.id]) result = true;
    }

    return result;
  },

  //@@viewOff:interface
  //@@viewOn:overriding
  //@@viewOff:overriding
  //@@viewOn:private
  _animationFix(e) {
    // Edge & IE doesn't support changing of CSS "overflow" during animation in @keyframes
    if (e.type === "animationstart") e.target.style.overflow = "hidden";else e.target.style.overflow = "";
  },

  _isToolbarExpanded(props = this.props) {
    let toolbarExpanded = this.state ? this.state.toolbarExpanded : true;
    UU5.Common.Children.forEach(props.children, element => {
      if (UU5.Common.Element.isValid(element) && element.type.tagName === Cfg.TAG + "ActionBar" && element.props.collapsed !== undefined) {
        toolbarExpanded = !element.props.collapsed;
      }
    });
    return toolbarExpanded;
  },

  _isFilterValueAllowed(key, valueOrFilterFunc) {
    let result = true;

    if (typeof valueOrFilterFunc === "function") {
      if (typeof this.props.onLoad === "function") {
        this.showError("wrongRemoteFilterValue", [key, typeof valueOrFilterFunc]);
        result = false;
      }
    } else if (typeof this.props.onLoad !== "function") {
      this.showError("wrongLocalFilterValue", [key, valueOrFilterFunc]);
      result = false;
    }

    return result;
  },

  _isSorterValueAllowed(key, descendingOrSorterFunc) {
    let result = true;

    if (typeof descendingOrSorterFunc === "function") {
      if (typeof this.props.onLoad === "function") {
        this.showError("wrongRemoteSorterValue", [key, typeof descendingOrSorterFunc]);
        result = false;
      }
    } else if (typeof this.props.onLoad !== "function") {
      this.showError("wrongLocalSorterValue", [key, descendingOrSorterFunc]);
      result = false;
    }

    return result;
  },

  _setStatus(displayedData = this.state.displayedData, total = this.state.data.length) {
    this._status = {
      total,
      displayed: displayedData.length,
      selected: Object.keys(this._selected).length,
      showSelected: this._status.showSelected,
      filterCount: Object.keys(this._filterMap).length
    };
  },

  _updateBars(setStateCallback) {
    let bars = [];
    Object.values(this._barMap).forEach(bar => {
      if (typeof bar.update === "function") bars.push(bar);
    });
    let newSetStateCallback;

    if (setStateCallback) {
      newSetStateCallback = UU5.Common.Tools.buildCounterCallback(setStateCallback, bars.length);
    }

    bars.forEach(bar => bar.update(newSetStateCallback));
  },

  _setStatusNumbers(displayedData = this.state.displayedData) {
    this._setStatus(displayedData);

    this._updateBars();
  },

  _setData(setStateCallback) {
    let needsDataReload = false;
    this.setState(state => {
      let data = state.data;

      let filterMap = this._getLoadCallFilterMap();

      let orders = this._getLoadCallSorterList();

      if (!UU5.Common.Tools.deepEqual(filterMap, this._loadCallFilterMap) || !UU5.Common.Tools.deepEqual(orders, this._loadCallSorterList)) {
        this._loadCallFilterMap = filterMap;
        this._loadCallSorterList = orders;
        needsDataReload = true;
        this._pendingReset = true; // TODO This should probably be set from List.reloadData() so that user can reloadData via List as they wish.
      }

      let displayedData = this._getDisplayedData(data);

      return {
        displayedData
      };
    }, () => {
      if (needsDataReload && this._list) this._list.reloadData();

      this._updateBars(setStateCallback);
    });
    return this;
  },

  _getLoadCallFilterMap() {
    let result = {};

    if (this.props.onLoad) {
      for (let k in this._filterMap) {
        let {
          value,
          filterFunc
        } = this._filterMap[k] || {};
        if (!filterFunc && value != null && value !== "") result[k] = value;
      }
    }

    return result;
  },

  _getLoadCallSorterList() {
    let result = [];

    if (this.props.onLoad) {
      for (let {
        key,
        sorterFunc,
        descending
      } of this._sorterList) {
        if (!sorterFunc) result.push({
          key,
          descending
        });
      }
    }

    return result;
  },

  _getDisplayedData(data, serverTotal = this.state.serverTotal) {
    let displayedData;

    if (this._status.showSelected) {
      // NOTE When using server calls (onLoad) the selected items might not be in this.state.data
      // because of server-side filters (but they'll be in our this._selectedItems list because
      // we cache the data instead of just true/false flags), i.e. scenario: select items, add filter (server-side
      // load happens), show selected.
      displayedData = this.getSelectedItemList(data);
    } else {
      displayedData = data.filter(item => {
        return !Object.values(this._filterMap).some(filter => filter.filterFunc ? !filter.filterFunc(item) : false);
      });
    } // apply sort only when some sorter is set
    // Google Chrome resort collection even though result is 0


    let localSorterList = this._sorterList.filter(it => it.sorterFunc);

    if (localSorterList.length > 0) {
      // stable sort (preserve relative positions of equal items) => wrap (add index), sort, unwrap
      let displayedDataWithIndex = displayedData.map((item, i) => ({
        item,
        i
      }));
      displayedDataWithIndex.sort((a, b) => {
        let result = 0;

        for (let sorter of localSorterList) {
          let r = sorter.sorterFunc(a.item, b.item);

          if (r) {
            result = r;
            break;
          }
        }

        if (!result) result = a.i - b.i;
        return result;
      });
      displayedData = displayedDataWithIndex.map(it => it.item);
    }

    this._setStatus(displayedData, serverTotal != null ? serverTotal : data.length);

    return displayedData;
  },

  _setSelected(id, selectedState) {
    if (!selectedState && this._selected[id]) {
      this.removeSelectedItem(id);
    } else if (selectedState && !this._selected[id]) {
      this.addSelectedItem(id);
    }
  },

  _syncSelectedWithData(newData, oldData, from = 0, to = Infinity) {
    let newSelectedIds = {}; // new selected items inside <from, to) range

    if (newData) {
      for (let i = from, len = Math.min(newData.length, to); i < len; ++i) {
        if (newData[i] && this._selected[newData[i].id]) newSelectedIds[newData[i].id] = newData[i];
      }
    }

    let oldSelectedIds = {}; // old selected items inside <from, to) range

    if (oldData) {
      for (let i = from, len = Math.min(oldData.length, to); i < len; ++i) {
        if (oldData[i] && this._selected[oldData[i].id]) oldSelectedIds[oldData[i].id] = oldData[i];
      }
    }

    let mergedSelectedIds = { ...oldSelectedIds,
      ...newSelectedIds
    };

    for (let id in mergedSelectedIds) {
      if (newSelectedIds[id]) this._selected[id] = newSelectedIds[id];else delete this._selected[id];
    }
  },

  _onScroll(onScroll) {
    return scrollInfo => {
      //TODO
      if (typeof onScroll === "function") onScroll(scrollInfo);
    };
  },

  _onListChange(listOpt) {
    let {
      data: displayedData,
      ...opt
    } = listOpt;
    opt.component = this;
    opt.data = this._mergeDisplayedDataChanges(displayedData);
    if (typeof this.props.onChange === "function") this.props.onChange(opt);else this.onChangeDefault(opt);
  },

  _mergeDisplayedDataChanges(displayedData) {
    // NOTE Has to merge using item IDs as something is deep-cloning data so "===" doesn't work.
    let displayedDataCopy = displayedData.filter(it => it && it.id);
    let displayedItemIds = displayedDataCopy.reduce((set, it) => (set.add(it.id), set), new Set());
    let data = this.state.data.map(it => it && displayedItemIds.has(it.id) ? displayedDataCopy.shift() : it);
    return data;
  },

  _getListKey(props) {
    let result;

    if (props.onLoad) {
      // key must change when (remote) filter / order is changed so that all data / caches in List / react-virtualized components
      // is cleared
      result = "list" + JSON.stringify(this.getLoadParams()) + "_" + this.state.fullInvalidationCounter;
    } else {
      result = "list";
    }

    return result;
  },

  _buildChildren() {
    let children = {
      toolbar: [],
      list: null
    };
    let hasNoItems = false;
    let hasInfoBar = !!this._barMap.infobar; // inject connection props to access toolbar and list

    UU5.Common.Children.forEach(this.props.children, element => {
      if (UU5.Common.Element.isValid(element)) {
        let tagName = element.type.tagName || element.type.hocFor && element.type.hocFor.tagName;

        if (tagName === Cfg.TAG + "List") {
          let tileCount = this._list && !this._pendingReset && !this._status.showSelected && this.props.onLoad ? this.state.data.length : null; // tileCount might differ from displayedData.length in case that server-side loading is used; initially use null so that List estimates & loads first page

          hasNoItems = tileCount === 0 || tileCount === null && this.state.displayedData.length === 0 && (!this.props.onLoad || this._status.showSelected);
          let className = element.props.className ? `${element.props.className} ${this.getClassName().list}` : this.getClassName().list;
          let style = element.props.style || {};

          if (element.props.rowSpacing > 0) {
            style.marginTop = element.props.rowSpacing;
            style.marginBottom = element.props.rowSpacing;
          }

          let onScroll = this._onScroll(element.props.onScroll);

          children.list = UU5.Common.Element.clone(element, {
            controller: this,
            tileCount: tileCount,
            data: this.state.displayedData,
            className,
            onScroll,
            style,
            draggable: this.props.draggable && !(this.props.onLoad && this._sorterList.length > 0),
            onChange: this._onListChange,
            onLoad: this._status.showSelected ? null : this.props.onLoad,
            onLoadPageSize: this.props.onLoadPageSize,
            key: this._getListKey(this.props)
          });
        } else if (element.type.tagName) {
          let newElement = UU5.Common.Element.clone(element, {
            controller: this,
            key: element.type.tagName,
            // TODO This will be TagPlaceholder if Tiles are used via uu5string.
            getStatus: this.getStatus,
            hidden: element.type.tagName === Cfg.TAG + "FilterBar" && this._status.showSelected,
            selectable: element.type.tagName === Cfg.TAG + "InfoBar" ? element.props.selectable === undefined || !this.props.selectable ? this.props.selectable : element.props.selectable : undefined
          });

          if (element.type.tagName === Cfg.TAG + "ActionBar") {
            children.toolbarMain = newElement;
          } else if (element.type.tagName === Cfg.TAG + "InfoBar") {
            hasInfoBar = true;
            children.toolbar.push(newElement);
          } else {
            children.toolbar.push(newElement);
          }
        }
      }
    });

    if (hasNoItems && !hasInfoBar) {
      children.noItems = <div className={this.getClassName("noItems")}>{this.getLsiComponent("noItems")}</div>;
    }

    return children;
  },

  // smaller padding because of elevation to tile to be at same line as text in toolbar
  _getPaddings(list) {
    let listPadding, controllerPadding;

    if (this.props.padding !== "all") {
      let elevation = Math.max(list.props.tileElevation || 0, list.props.tileElevationHover || 0);
      let ListClass = list.type.hocFor || list.type;
      let padding = ListClass.defaults.elevation[elevation].horizontalHalf;

      if (this.props.padding === "toolbar") {
        listPadding = padding;
      } else {
        controllerPadding = padding;
      }
    }

    return {
      listPadding,
      controllerPadding
    };
  },

  _setToolbarContainerRef(comp) {
    this._toolbarContainerElem = comp ? comp.findDOMNode() : null;
  },

  //@@viewOff:private
  //@@viewOn:render
  render() {
    let r;
    if (this.props.children === "function") r = this.props.children(this);else {
      let mainProps = this.getMainPropsToPass();
      delete mainProps.nestingLevel;
      mainProps.className = mainProps.className + " " + this.getClassName("padding") + this.props.padding;
      let listContainerClassName = this.getClassName().listContainer;
      let toolbarContainerClassName = this.getClassName().toolbarContainer;

      let {
        toolbarMain,
        toolbar,
        list,
        noItems
      } = this._buildChildren(this.state.toolbarExpanded);

      let {
        listPadding,
        controllerPadding
      } = this._getPaddings(list);

      mainProps.style = mainProps.style || {};
      mainProps.style.paddingRight = controllerPadding;
      mainProps.style.paddingLeft = controllerPadding;
      toolbarContainerClassName += " " + this.getClassName().toolbarContainer + (this.state.toolbarExpanded ? "-expanded" : "-collapsed");

      if (this.props.autoResize) {
        let origList = list;
        list = <UU5.Bricks.Resize>
            {({
            width,
            height
          }) => UU5.Common.Children.toArray([noItems && width ? UU5.Common.Element.clone(noItems, {
            width
          }) : null, origList && width ? UU5.Common.Element.clone(origList, {
            width
          }) : null])}
          </UU5.Bricks.Resize>;
        noItems = null;
      }

      r = <UU5.Bricks.Div {...mainProps}>
          {toolbarMain}
          <UU5.Bricks.Div className={toolbarContainerClassName} ref_={this._setToolbarContainerRef}>
            {toolbar}
          </UU5.Bricks.Div>
          <UU5.Bricks.Div className={listContainerClassName} style={{
          paddingLeft: listPadding,
          paddingRight: listPadding
        }}>
            {noItems}
            {list}
          </UU5.Bricks.Div>
        </UU5.Bricks.Div>;
    }
    return r;
  } //@@viewOff:render


});
export default ListController;