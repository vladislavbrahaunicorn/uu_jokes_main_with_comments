"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ListController = void 0;

var _uu5g = _interopRequireDefault(require("uu5g04"));

require("uu5g04-bricks");

var _config = _interopRequireDefault(require("../config/config.js"));

require("./list-controller.less");

var _listCache = _interopRequireDefault(require("./list-cache.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//@@viewOff:imports
var ListController = _uu5g.default.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [_uu5g.default.Common.BaseMixin, _uu5g.default.Common.ElementaryMixin, _uu5g.default.Common.NestingLevelMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config.default.TAG + "ListController",
    nestingLevelList: _uu5g.default.Environment.getNestingLevelList("bigBoxCollection", "bigBox"),
    classNames: {
      main: _config.default.CSS + "list-controller",
      list: _config.default.CSS + "list-controller-list",
      padding: _config.default.CSS + "list-controller-padding-",
      toolbarContainer: _config.default.CSS + "list-controller-toolbar-container",
      listContainer: _config.default.CSS + "list-controller-list-container",
      noItems: _config.default.CSS + "list-controller-no-items"
    },
    errors: {
      noIfcJustSelected: "Interface %s is not possible to call if just selected items are displayed.",
      wrongLocalFilterValue: "Cannot use filter '%s' with value %s. The value must be a function `item => includeItem ? true : false` or you must provide prop onLoad to turn on loading & filtering via remote call.",
      wrongRemoteFilterValue: "Cannot use filter '%s' with value of type '%s' because loading via remote call is turned on (prop onLoad is used). Only JSON-serializable values can be used.",
      wrongLocalSorterValue: "Cannot use sorter '%s' with value %s. The value must be a function `(item1, item2, opts) => number` or you must provide prop onLoad to turn on loading & sorting via remote call.",
      wrongRemoteSorterValue: "Cannot use sorter '%s' with value of type '%s' because loading via remote call is turned on (prop onLoad is used). Use value true for descending sort, false otherwise."
    },
    lsi: {
      noItems: {
        cs: "Nebyla nalezena žádná položka.",
        en: "No items was found."
      }
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    data: _uu5g.default.PropTypes.array,
    autoResize: _uu5g.default.PropTypes.bool,
    padding: _uu5g.default.PropTypes.oneOf(["all", "toolbar", "none"]),
    selectable: _uu5g.default.PropTypes.bool,
    draggable: _uu5g.default.PropTypes.bool,
    onChange: _uu5g.default.PropTypes.func,
    onLoad: _uu5g.default.PropTypes.func,
    onLoadPageSize: _uu5g.default.PropTypes.number,
    onSelect: _uu5g.default.PropTypes.func
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      data: [],
      autoResize: process.env.NODE_ENV === "test" ? false : true,
      padding: "all",
      selectable: true,
      onLoadPageSize: undefined,
      onSelect: undefined
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    this._filterMap = {};
    this._sorterList = [];
    this._selected = {};
    this._scrollTo = 0;
    this._status = {
      total: 0,
      displayed: 0,
      selected: 0,
      showSelected: false
    };
    this._list = null;
    this._barMap = {};
    this._loadCallFilterMap = this._getLoadCallFilterMap();
    this._loadCallSorterList = this._getLoadCallSorterList();
    return {
      displayedData: this._getDisplayedData(this.props.data, null),
      toolbarExpanded: this._isToolbarExpanded(),
      data: this.props.data,
      invalidationMap: {},
      fullInvalidationCounter: 1,
      serverTotal: undefined
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var _this = this;

    if (nextProps.controlled) {
      // eslint-disable-line react/prop-types
      var onLoadChanged = nextProps.onLoad !== this.props.onLoad;

      var _loop = function _loop(id) {
        var matchingItem = nextProps.data.find(function (dataItem) {
          return dataItem.id === id;
        });

        if (matchingItem) {
          _this._selected[id] = matchingItem;
        } else {
          delete _this._selected[id];
        }
      };

      for (var id in this._selected) {
        _loop(id);
      }

      this.setState(function (state) {
        return {
          data: nextProps.data,
          toolbarExpanded: _this._isToolbarExpanded(nextProps),
          displayedData: _this._getDisplayedData(nextProps.data, onLoadChanged ? null : state.serverTotal),
          serverTotal: onLoadChanged ? null : state.serverTotal,
          invalidationMap: {}
        };
      }, this._updateBars);
    }
  },
  componentDidMount: function componentDidMount() {
    // NOTE If we ever add support for setting initial filters, it'll be necessary to perform
    // server-side call (onLoad) here to figure out total (unfiltered) count of items.
    if (navigator.userAgent.match(/Trident\/[.0-9]*|Edge\/[.0-9]*|Mac.*?Version\/.*?Safari\//)) {
      var domNode = this._toolbarContainerElem;

      if (domNode) {
        domNode.addEventListener("animationstart", this._animationFix);
        domNode.addEventListener("animationend", this._animationFix);
      }
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    if (navigator.userAgent.match(/Trident\/[.0-9]*|Edge\/[.0-9]*|Mac.*?Version\/.*?Safari\//)) {
      var domNode = this._toolbarContainerElem;

      if (domNode) {
        domNode.removeEventListener("animationstart", this._animationFix);
        domNode.removeEventListener("animationend", this._animationFix);
      }
    }
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  toggleToolbar: function toggleToolbar(setStateCallback) {
    this.setState(function (prevState) {
      return {
        toolbarExpanded: !prevState.toolbarExpanded
      };
    }, setStateCallback);
  },
  collapseToolbar: function collapseToolbar(setStateCallback) {
    this.setState({
      toolbarExpanded: false
    }, setStateCallback);
  },
  expandToolbar: function expandToolbar(setStateCallback) {
    this.setState({
      toolbarExpanded: true
    }, setStateCallback);
  },
  isToolbarExpanded: function isToolbarExpanded() {
    return this.state.toolbarExpanded;
  },
  getStatus: function getStatus() {
    return this._status;
  },
  findItem: function findItem(func) {
    return this.state.data.find(func);
  },
  getSelectedItemList: function getSelectedItemList() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.data;

    var selected = _objectSpread({}, this._selected);

    var result = []; // NOTE The result order must be same as in state.data. Additionally, prefer item data from state
    // instead of from selection as it might be "newer" when using server calls.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;

        if (v && v.id) {
          var selectedItem = selected[v.id];
          if (selectedItem) result.push(selectedItem);
          delete selected[v.id];
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    for (var k in selected) {
      result.push(selected[k]);
    }

    return result;
  },
  addSelectedItem: function addSelectedItem(id, setStateCallback) {
    var _this2 = this;

    // remember the data instead of just true/false - when using server calls (props.onLoad) the user
    // might select an item, use a filter after which the item is no longer visible and might have been removed
    // from this.state.data as well (if the total item count in memory exceeded threshold) therefore
    // we wouldn't be able to show all selected items
    var item = this.state.data.find(function (item) {
      return item && item.id === id;
    });

    if (item) {
      this._selected[id] = item;

      var callback = function callback() {
        if (typeof _this2.props.onSelect === "function") {
          _this2.props.onSelect({
            component: _this2,
            selected: _this2.state.data.filter(function (item) {
              return item && _this2._selected[item.id];
            })
          });
        }

        if (typeof setStateCallback === "function") setStateCallback();
      };

      this._setData(callback);
    }

    return this;
  },
  removeSelectedItem: function removeSelectedItem(id, setStateCallback) {
    var _this3 = this;

    delete this._selected[id];

    var callback = function callback() {
      if (typeof _this3.props.onSelect === "function") {
        _this3.props.onSelect({
          component: _this3,
          selected: _this3.state.data.filter(function (item) {
            return item && _this3._selected[item.id];
          })
        });
      }

      if (typeof setStateCallback === "function") setStateCallback();
    };

    !this._status.showSelected || Object.keys(this._selected).length ? this._setData(callback) : this.hideJustSelected(callback);
    return this;
  },
  clearSelected: function clearSelected(setStateCallback) {
    var _this4 = this;

    this._selected = {};

    var callback = function callback() {
      if (typeof _this4.props.onSelect === "function") {
        _this4.props.onSelect({
          component: _this4,
          selected: []
        });
      }

      if (typeof setStateCallback === "function") setStateCallback();
    };

    this._status.showSelected ? this.hideJustSelected(callback) : this._setData(callback);
    return this;
  },
  selectAll: function selectAll() {
    var _this5 = this;

    // selecting all is not allowed when using server calls
    if (!this.props.onLoad) {
      var itemsWithId = this.state.displayedData.filter(Boolean).filter(function (item) {
        return item.id;
      });
      itemsWithId.forEach(function (item) {
        _this5._selected[item.id] = item;
      });

      this._setStatusNumbers();

      this._setData(function () {
        if (typeof _this5.props.onSelect === "function") {
          _this5.props.onSelect({
            component: _this5,
            selected: itemsWithId
          });
        }
      });
    }

    return this;
  },
  showJustSelected: function showJustSelected(setStateCallback) {
    this._status.showSelected = true;
    return this._setData(setStateCallback);
  },
  hideJustSelected: function hideJustSelected(setStateCallback) {
    this._status.showSelected = false;
    return this._setData(setStateCallback);
  },
  isFilterUsable: function isFilterUsable(msgKey) {
    if (this._status.showSelected) {
      this.showError("noIfcJustSelected", msgKey);
      return false;
    } else {
      return true;
    }
  },
  addFilter: function addFilter(key, valueOrFilterFunc, removeFilterFunc, setStateCallback) {
    var result = false;

    if (this.isFilterUsable("addFilter") && this._isFilterValueAllowed(key, valueOrFilterFunc)) {
      this._filterMap[key] = {};
      if (typeof valueOrFilterFunc === "function") this._filterMap[key].filterFunc = valueOrFilterFunc;else this._filterMap[key].value = valueOrFilterFunc;
      if (typeof removeFilterFunc === "function") this._filterMap[key].removeFilterFunc = removeFilterFunc;

      this._setData(setStateCallback);

      result = this;
    }

    return result;
  },
  removeFilter: function removeFilter(key, setStateCallback) {
    if (this.isFilterUsable("removeFilter")) {
      if (this._filterMap[key]) {
        if (typeof this._filterMap[key].removeFilterFunc === "function") this._filterMap[key].removeFilterFunc(key);
        delete this._filterMap[key];

        this._setData(setStateCallback);
      }

      return this;
    } else {
      return false;
    }
  },
  addFilterExt: function addFilterExt(key, label, value, filterFunc, removeFilterFunc) {
    if (this.isFilterUsable("addFilterExt") && this._isFilterValueAllowed(key, typeof this.props.onLoad === "function" ? value : filterFunc)) {
      if (this._barMap.filterBar) this._barMap.filterBar.addFilter(key, label, value, filterFunc, removeFilterFunc);else this.addFilter(key, filterFunc || value, removeFilterFunc);
      return this;
    } else {
      return false;
    }
  },
  removeFilterExt: function removeFilterExt(key) {
    if (this.isFilterUsable("removeFilterExt")) {
      if (this._barMap.filterBar) this._barMap.filterBar.removeFilter(key);else this.removeFilter(key);
      return this;
    } else {
      return false;
    }
  },
  clearFilters: function clearFilters(setStateCallback) {
    var _this6 = this;

    if (this.isFilterUsable("clearFilters")) {
      Object.entries(this._filterMap).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            filter = _ref2[1];

        if (typeof filter.removeFilterFunc === "function") filter.removeFilterFunc(key);
      });
      this._filterMap = {};
      return this._setData(function () {
        _this6._barMap.filterBar ? _this6._barMap.filterBar.clearFilters(setStateCallback) : typeof setStateCallback === "function" && setStateCallback();
      });
    } else {
      return false;
    }
  },
  setSorter: function setSorter(key, descendingOrSorterFunc, setStateCallback) {
    if (this._isSorterValueAllowed(key, descendingOrSorterFunc)) {
      var item = {
        key: key
      };
      if (typeof this.props.onLoad === "function") item.descending = descendingOrSorterFunc;else item.sorterFunc = descendingOrSorterFunc;
      this._sorterList = [item]; // remove previous and use just one

      this._setData(setStateCallback);
    }

    return this;
  },
  addSorter: function addSorter(key, descendingOrSorterFunc, setStateCallback) {
    if (this._isSorterValueAllowed(key, descendingOrSorterFunc)) {
      var item = {
        key: key
      };
      if (typeof this.props.onLoad === "function") item.descending = descendingOrSorterFunc;else item.sorterFunc = descendingOrSorterFunc;

      this._sorterList.push(item);

      this._setData(setStateCallback);
    }
  },
  removeSorter: function removeSorter(key, setStateCallback) {
    this._sorterList = this._sorterList.filter(function (sorter) {
      return sorter.key !== key;
    });
    return this._setData(setStateCallback);
  },
  clearSorters: function clearSorters(setStateCallback) {
    var _this7 = this;

    this._sorterList = [];
    return this._setData(function () {
      _this7._barMap.infoBar ? _this7._barMap.infoBar.clearSorters(setStateCallback) : typeof setStateCallback === "function" && setStateCallback();
    });
  },
  registerBar: function registerBar(key, bar) {
    this._barMap[key] = bar;
  },
  unregisterBar: function unregisterBar(key) {
    delete this._barMap[key];
  },
  getBar: function getBar(key) {
    return this._barMap[key];
  },
  registerList: function registerList(list) {
    this._list = list;
  },
  getTileProps: function getTileProps(tileId) {
    return {
      selected: !!this._selected[tileId],
      onSelect: this._setSelected,
      selectable: this.props.selectable,
      controller: this
    };
  },
  onChangeDefault: function onChangeDefault(opt) {
    var data = opt.data;
    this.setData(data);
  },
  setData: function setData(data) {
    var _this8 = this;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var setStateCallback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
    var pageInfo = args.shift();
    var dtoInData = args.shift();
    this.setState(function (state) {
      var serverTotal = state.serverTotal;
      var invalidationMap;
      var newData;
      var oldData = _this8._pendingReset ? [] : state.data || [];

      if (pageInfo) {
        // we got single page (partial data) => merge data into current
        // NOTE We also clear "old" items if there's too many of them in the memory but
        // the new page data is always stored in the memory entirely (even if it exceeds the max item count)
        // because we don't know which items are currently visible in the viewport and the assumption
        // is that the latest async load is for the currently visible items. TODO Ensure async load callbacks
        // are fired in order.
        // NOTE When clearing memory, if we try to compute which items are visible and it will not be sufficiently exact,
        // it might result in never-ending (async) re-rendering loop (depending on which items are cleared from memory).
        var from = pageInfo.pageIndex * pageInfo.pageSize || 0;
        var to = from + (data ? data.length : 0);
        invalidationMap = _objectSpread({}, state.invalidationMap);
        newData = new Array(typeof pageInfo.total === "number" ? pageInfo.total : Math.max(to, oldData.length));

        for (var i = 0, len = newData.length; i < len; ++i) {
          newData[i] = from <= i && i < to ? data[i - from] : oldData[i];
          if (from <= i && i < to && newData[i]) delete invalidationMap[newData[i].id];
        }

        _listCache.default.evictItems(newData, from, to);

        if (typeof pageInfo.total === "number") {
          if (!dtoInData || !dtoInData.filterMap || Object.keys(dtoInData.filterMap).length === 0) {
            serverTotal = pageInfo.total;
          }
        }

        _this8._syncSelectedWithData(newData, oldData, from, to);
      } else {
        newData = data;
        invalidationMap = {};

        if (newData) {
          for (var _i2 = 0; _i2 < newData.length; ++_i2) {
            if (newData[_i2]) delete invalidationMap[newData[_i2].id];
          }
        }

        _this8._syncSelectedWithData(newData, oldData);
      }

      delete _this8._pendingReset;
      return {
        data: newData,
        displayedData: _this8._getDisplayedData(newData, serverTotal),
        serverTotal: serverTotal,
        invalidationMap: invalidationMap
      };
    }, function () {
      _this8._updateBars(setStateCallback);
    });
  },
  getData: function getData() {
    return this.state.data;
  },
  getTileCount: function getTileCount() {
    return this.state.serverTotal != null ? this.state.serverTotal : (this.state.data || []).length;
  },
  invalidateData: function invalidateData() {
    var _this9 = this;

    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.data;
    // NOTE There's special case when the current list has 0 items - in such case we need to perform
    // full reload, which we do by changing UU5.Tiles.List key (thanks to state.fullInvalidationCounter).
    this.setState(function (state) {
      var invalidationMap = _objectSpread({}, state.invalidationMap);

      var fullInvalidationCounter = state.fullInvalidationCounter + (!data || data.length === 0 ? 1 : 0);
      var length = data ? data.length : 0;

      for (var i = 0; i < length; ++i) {
        var value = data[i];
        if (typeof value === "string") invalidationMap[value] = true;else if (value && value.id) invalidationMap[value.id] = true;
      }

      return {
        invalidationMap: invalidationMap,
        fullInvalidationCounter: fullInvalidationCounter
      };
    }, function () {
      return _this9._list && _this9._list.invalidateData();
    });
  },
  getLoadParams: function getLoadParams() {
    var result = {};
    if (Object.keys(this._loadCallFilterMap).length > 0) result.filterMap = this._loadCallFilterMap;
    if (this._loadCallSorterList.length > 0) result.sorterList = this._loadCallSorterList;
    return result;
  },
  isTileLoaded: function isTileLoaded(tileIndex) {
    var result = false;

    if (!this._pendingReset) {
      var tileData = this.state.displayedData[tileIndex];
      if (tileData && !this.state.invalidationMap[tileData.id]) result = true;
    }

    return result;
  },
  //@@viewOff:interface
  //@@viewOn:overriding
  //@@viewOff:overriding
  //@@viewOn:private
  _animationFix: function _animationFix(e) {
    // Edge & IE doesn't support changing of CSS "overflow" during animation in @keyframes
    if (e.type === "animationstart") e.target.style.overflow = "hidden";else e.target.style.overflow = "";
  },
  _isToolbarExpanded: function _isToolbarExpanded() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
    var toolbarExpanded = this.state ? this.state.toolbarExpanded : true;

    _uu5g.default.Common.Children.forEach(props.children, function (element) {
      if (_uu5g.default.Common.Element.isValid(element) && element.type.tagName === _config.default.TAG + "ActionBar" && element.props.collapsed !== undefined) {
        toolbarExpanded = !element.props.collapsed;
      }
    });

    return toolbarExpanded;
  },
  _isFilterValueAllowed: function _isFilterValueAllowed(key, valueOrFilterFunc) {
    var result = true;

    if (typeof valueOrFilterFunc === "function") {
      if (typeof this.props.onLoad === "function") {
        this.showError("wrongRemoteFilterValue", [key, _typeof(valueOrFilterFunc)]);
        result = false;
      }
    } else if (typeof this.props.onLoad !== "function") {
      this.showError("wrongLocalFilterValue", [key, valueOrFilterFunc]);
      result = false;
    }

    return result;
  },
  _isSorterValueAllowed: function _isSorterValueAllowed(key, descendingOrSorterFunc) {
    var result = true;

    if (typeof descendingOrSorterFunc === "function") {
      if (typeof this.props.onLoad === "function") {
        this.showError("wrongRemoteSorterValue", [key, _typeof(descendingOrSorterFunc)]);
        result = false;
      }
    } else if (typeof this.props.onLoad !== "function") {
      this.showError("wrongLocalSorterValue", [key, descendingOrSorterFunc]);
      result = false;
    }

    return result;
  },
  _setStatus: function _setStatus() {
    var displayedData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.displayedData;
    var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.data.length;
    this._status = {
      total: total,
      displayed: displayedData.length,
      selected: Object.keys(this._selected).length,
      showSelected: this._status.showSelected,
      filterCount: Object.keys(this._filterMap).length
    };
  },
  _updateBars: function _updateBars(setStateCallback) {
    var bars = [];
    Object.values(this._barMap).forEach(function (bar) {
      if (typeof bar.update === "function") bars.push(bar);
    });
    var newSetStateCallback;

    if (setStateCallback) {
      newSetStateCallback = _uu5g.default.Common.Tools.buildCounterCallback(setStateCallback, bars.length);
    }

    bars.forEach(function (bar) {
      return bar.update(newSetStateCallback);
    });
  },
  _setStatusNumbers: function _setStatusNumbers() {
    var displayedData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.displayedData;

    this._setStatus(displayedData);

    this._updateBars();
  },
  _setData: function _setData(setStateCallback) {
    var _this10 = this;

    var needsDataReload = false;
    this.setState(function (state) {
      var data = state.data;

      var filterMap = _this10._getLoadCallFilterMap();

      var orders = _this10._getLoadCallSorterList();

      if (!_uu5g.default.Common.Tools.deepEqual(filterMap, _this10._loadCallFilterMap) || !_uu5g.default.Common.Tools.deepEqual(orders, _this10._loadCallSorterList)) {
        _this10._loadCallFilterMap = filterMap;
        _this10._loadCallSorterList = orders;
        needsDataReload = true;
        _this10._pendingReset = true; // TODO This should probably be set from List.reloadData() so that user can reloadData via List as they wish.
      }

      var displayedData = _this10._getDisplayedData(data);

      return {
        displayedData: displayedData
      };
    }, function () {
      if (needsDataReload && _this10._list) _this10._list.reloadData();

      _this10._updateBars(setStateCallback);
    });
    return this;
  },
  _getLoadCallFilterMap: function _getLoadCallFilterMap() {
    var result = {};

    if (this.props.onLoad) {
      for (var k in this._filterMap) {
        var _ref3 = this._filterMap[k] || {},
            value = _ref3.value,
            filterFunc = _ref3.filterFunc;

        if (!filterFunc && value != null && value !== "") result[k] = value;
      }
    }

    return result;
  },
  _getLoadCallSorterList: function _getLoadCallSorterList() {
    var result = [];

    if (this.props.onLoad) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._sorterList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref5 = _step2.value;
          var key = _ref5.key,
              sorterFunc = _ref5.sorterFunc,
              descending = _ref5.descending;
          if (!sorterFunc) result.push({
            key: key,
            descending: descending
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    return result;
  },
  _getDisplayedData: function _getDisplayedData(data) {
    var _this11 = this;

    var serverTotal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.serverTotal;
    var displayedData;

    if (this._status.showSelected) {
      // NOTE When using server calls (onLoad) the selected items might not be in this.state.data
      // because of server-side filters (but they'll be in our this._selectedItems list because
      // we cache the data instead of just true/false flags), i.e. scenario: select items, add filter (server-side
      // load happens), show selected.
      displayedData = this.getSelectedItemList(data);
    } else {
      displayedData = data.filter(function (item) {
        return !Object.values(_this11._filterMap).some(function (filter) {
          return filter.filterFunc ? !filter.filterFunc(item) : false;
        });
      });
    } // apply sort only when some sorter is set
    // Google Chrome resort collection even though result is 0


    var localSorterList = this._sorterList.filter(function (it) {
      return it.sorterFunc;
    });

    if (localSorterList.length > 0) {
      // stable sort (preserve relative positions of equal items) => wrap (add index), sort, unwrap
      var displayedDataWithIndex = displayedData.map(function (item, i) {
        return {
          item: item,
          i: i
        };
      });
      displayedDataWithIndex.sort(function (a, b) {
        var result = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = localSorterList[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var sorter = _step3.value;
            var r = sorter.sorterFunc(a.item, b.item);

            if (r) {
              result = r;
              break;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (!result) result = a.i - b.i;
        return result;
      });
      displayedData = displayedDataWithIndex.map(function (it) {
        return it.item;
      });
    }

    this._setStatus(displayedData, serverTotal != null ? serverTotal : data.length);

    return displayedData;
  },
  _setSelected: function _setSelected(id, selectedState) {
    if (!selectedState && this._selected[id]) {
      this.removeSelectedItem(id);
    } else if (selectedState && !this._selected[id]) {
      this.addSelectedItem(id);
    }
  },
  _syncSelectedWithData: function _syncSelectedWithData(newData, oldData) {
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
    var newSelectedIds = {}; // new selected items inside <from, to) range

    if (newData) {
      for (var i = from, len = Math.min(newData.length, to); i < len; ++i) {
        if (newData[i] && this._selected[newData[i].id]) newSelectedIds[newData[i].id] = newData[i];
      }
    }

    var oldSelectedIds = {}; // old selected items inside <from, to) range

    if (oldData) {
      for (var _i3 = from, _len2 = Math.min(oldData.length, to); _i3 < _len2; ++_i3) {
        if (oldData[_i3] && this._selected[oldData[_i3].id]) oldSelectedIds[oldData[_i3].id] = oldData[_i3];
      }
    }

    var mergedSelectedIds = _objectSpread({}, oldSelectedIds, newSelectedIds);

    for (var id in mergedSelectedIds) {
      if (newSelectedIds[id]) this._selected[id] = newSelectedIds[id];else delete this._selected[id];
    }
  },
  _onScroll: function _onScroll(onScroll) {
    return function (scrollInfo) {
      //TODO
      if (typeof onScroll === "function") onScroll(scrollInfo);
    };
  },
  _onListChange: function _onListChange(listOpt) {
    var displayedData = listOpt.data,
        opt = _objectWithoutProperties(listOpt, ["data"]);

    opt.component = this;
    opt.data = this._mergeDisplayedDataChanges(displayedData);
    if (typeof this.props.onChange === "function") this.props.onChange(opt);else this.onChangeDefault(opt);
  },
  _mergeDisplayedDataChanges: function _mergeDisplayedDataChanges(displayedData) {
    // NOTE Has to merge using item IDs as something is deep-cloning data so "===" doesn't work.
    var displayedDataCopy = displayedData.filter(function (it) {
      return it && it.id;
    });
    var displayedItemIds = displayedDataCopy.reduce(function (set, it) {
      return set.add(it.id), set;
    }, new Set());
    var data = this.state.data.map(function (it) {
      return it && displayedItemIds.has(it.id) ? displayedDataCopy.shift() : it;
    });
    return data;
  },
  _getListKey: function _getListKey(props) {
    var result;

    if (props.onLoad) {
      // key must change when (remote) filter / order is changed so that all data / caches in List / react-virtualized components
      // is cleared
      result = "list" + JSON.stringify(this.getLoadParams()) + "_" + this.state.fullInvalidationCounter;
    } else {
      result = "list";
    }

    return result;
  },
  _buildChildren: function _buildChildren() {
    var _this12 = this;

    var children = {
      toolbar: [],
      list: null
    };
    var hasNoItems = false;
    var hasInfoBar = !!this._barMap.infobar; // inject connection props to access toolbar and list

    _uu5g.default.Common.Children.forEach(this.props.children, function (element) {
      if (_uu5g.default.Common.Element.isValid(element)) {
        var tagName = element.type.tagName || element.type.hocFor && element.type.hocFor.tagName;

        if (tagName === _config.default.TAG + "List") {
          var tileCount = _this12._list && !_this12._pendingReset && !_this12._status.showSelected && _this12.props.onLoad ? _this12.state.data.length : null; // tileCount might differ from displayedData.length in case that server-side loading is used; initially use null so that List estimates & loads first page

          hasNoItems = tileCount === 0 || tileCount === null && _this12.state.displayedData.length === 0 && (!_this12.props.onLoad || _this12._status.showSelected);
          var className = element.props.className ? "".concat(element.props.className, " ").concat(_this12.getClassName().list) : _this12.getClassName().list;
          var style = element.props.style || {};

          if (element.props.rowSpacing > 0) {
            style.marginTop = element.props.rowSpacing;
            style.marginBottom = element.props.rowSpacing;
          }

          var onScroll = _this12._onScroll(element.props.onScroll);

          children.list = _uu5g.default.Common.Element.clone(element, {
            controller: _this12,
            tileCount: tileCount,
            data: _this12.state.displayedData,
            className: className,
            onScroll: onScroll,
            style: style,
            draggable: _this12.props.draggable && !(_this12.props.onLoad && _this12._sorterList.length > 0),
            onChange: _this12._onListChange,
            onLoad: _this12._status.showSelected ? null : _this12.props.onLoad,
            onLoadPageSize: _this12.props.onLoadPageSize,
            key: _this12._getListKey(_this12.props)
          });
        } else if (element.type.tagName) {
          var newElement = _uu5g.default.Common.Element.clone(element, {
            controller: _this12,
            key: element.type.tagName,
            // TODO This will be TagPlaceholder if Tiles are used via uu5string.
            getStatus: _this12.getStatus,
            hidden: element.type.tagName === _config.default.TAG + "FilterBar" && _this12._status.showSelected,
            selectable: element.type.tagName === _config.default.TAG + "InfoBar" ? element.props.selectable === undefined || !_this12.props.selectable ? _this12.props.selectable : element.props.selectable : undefined
          });

          if (element.type.tagName === _config.default.TAG + "ActionBar") {
            children.toolbarMain = newElement;
          } else if (element.type.tagName === _config.default.TAG + "InfoBar") {
            hasInfoBar = true;
            children.toolbar.push(newElement);
          } else {
            children.toolbar.push(newElement);
          }
        }
      }
    });

    if (hasNoItems && !hasInfoBar) {
      children.noItems = _uu5g.default.Common.Element.create("div", {
        className: this.getClassName("noItems")
      }, this.getLsiComponent("noItems"));
    }

    return children;
  },
  // smaller padding because of elevation to tile to be at same line as text in toolbar
  _getPaddings: function _getPaddings(list) {
    var listPadding, controllerPadding;

    if (this.props.padding !== "all") {
      var elevation = Math.max(list.props.tileElevation || 0, list.props.tileElevationHover || 0);
      var ListClass = list.type.hocFor || list.type;
      var padding = ListClass.defaults.elevation[elevation].horizontalHalf;

      if (this.props.padding === "toolbar") {
        listPadding = padding;
      } else {
        controllerPadding = padding;
      }
    }

    return {
      listPadding: listPadding,
      controllerPadding: controllerPadding
    };
  },
  _setToolbarContainerRef: function _setToolbarContainerRef(comp) {
    this._toolbarContainerElem = comp ? comp.findDOMNode() : null;
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    var r;
    if (this.props.children === "function") r = this.props.children(this);else {
      var mainProps = this.getMainPropsToPass();
      delete mainProps.nestingLevel;
      mainProps.className = mainProps.className + " " + this.getClassName("padding") + this.props.padding;
      var listContainerClassName = this.getClassName().listContainer;
      var toolbarContainerClassName = this.getClassName().toolbarContainer;

      var _this$_buildChildren = this._buildChildren(this.state.toolbarExpanded),
          toolbarMain = _this$_buildChildren.toolbarMain,
          toolbar = _this$_buildChildren.toolbar,
          list = _this$_buildChildren.list,
          noItems = _this$_buildChildren.noItems;

      var _this$_getPaddings = this._getPaddings(list),
          listPadding = _this$_getPaddings.listPadding,
          controllerPadding = _this$_getPaddings.controllerPadding;

      mainProps.style = mainProps.style || {};
      mainProps.style.paddingRight = controllerPadding;
      mainProps.style.paddingLeft = controllerPadding;
      toolbarContainerClassName += " " + this.getClassName().toolbarContainer + (this.state.toolbarExpanded ? "-expanded" : "-collapsed");

      if (this.props.autoResize) {
        var origList = list;
        list = _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Resize, null, function (_ref6) {
          var width = _ref6.width,
              height = _ref6.height;
          return _uu5g.default.Common.Children.toArray([noItems && width ? _uu5g.default.Common.Element.clone(noItems, {
            width: width
          }) : null, origList && width ? _uu5g.default.Common.Element.clone(origList, {
            width: width
          }) : null]);
        });
        noItems = null;
      }

      r = _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Div, mainProps, toolbarMain, _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Div, {
        className: toolbarContainerClassName,
        ref_: this._setToolbarContainerRef
      }, toolbar), _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Div, {
        className: listContainerClassName,
        style: {
          paddingLeft: listPadding,
          paddingRight: listPadding
        }
      }, noItems, list));
    }
    return r;
  } //@@viewOff:render

});

exports.ListController = ListController;
var _default = ListController;
exports.default = _default;