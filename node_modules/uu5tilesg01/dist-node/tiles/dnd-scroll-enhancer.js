"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DndScrollEnhancer = void 0;

var _uu5g = _interopRequireDefault(require("uu5g04"));

require("uu5g04-bricks");

var _config = _interopRequireDefault(require("../config/config.js"));

require("./dnd-scroll-enhancer.less");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//@@viewOff:imports
var DndScrollEnhancerBase = _uu5g.default.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [_uu5g.default.Common.BaseMixin, _uu5g.default.Common.ElementaryMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config.default.TAG + "DndScrollEnhancer",
    classNames: {
      main: _config.default.CSS + "dnd-scroll-enhancer"
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    scrollElement: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.string, _uu5g.default.PropTypes.object]),
    horizontalOffset: _uu5g.default.PropTypes.number,
    verticalOffset: _uu5g.default.PropTypes.number,
    dragDropManager: _uu5g.default.PropTypes.any
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      scrollElement: undefined,
      horizontalOffset: 150,
      verticalOffset: 150,
      dragDropManager: undefined
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    this._enhancerRegistration = null;
    this._domNode = null;
    return {};
  },
  componentDidMount: function componentDidMount() {
    this._updateEnhancer();
  },
  componentDidUpdate: function componentDidUpdate() {
    this._updateEnhancer();
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this._enhancerRegistration) this._enhancerRegistration.detach();
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  //@@viewOff:interface
  //@@viewOn:overriding
  //@@viewOff:overriding
  //@@viewOn:private
  _updateEnhancer: function _updateEnhancer() {
    var usedScrollElement;

    if (this.props.scrollElement) {
      usedScrollElement = this.props.scrollElement;
    } else if (this._domNode) {
      var node = this._domNode.parentNode;

      while (node && node.tagName) {
        var computedStyle = getComputedStyle(node);

        if (computedStyle.overflowY !== "visible" && computedStyle.overflowY !== "hidden") {
          usedScrollElement = node;
          break;
        }

        node = node.parentNode;
      }
    }

    var _this$props = this.props,
        horizontalOffset = _this$props.horizontalOffset,
        verticalOffset = _this$props.verticalOffset,
        dragDropManager = _this$props.dragDropManager;
    var params = {
      horizontalOffset: horizontalOffset,
      verticalOffset: verticalOffset
    };

    if (!this._enhancerRegistration) {
      if (usedScrollElement) this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);
    } else if (usedScrollElement !== this._enhancerRegistration.getScrollElement()) {
      this._enhancerRegistration.detach();

      if (usedScrollElement) this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);else this._enhancerRegistration = null;
    } else {
      this._enhancerRegistration.setParams(params);
    }
  },
  _setDomNodeRef: function _setDomNodeRef(ref) {
    this._domNode = ref;
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    return this.props.scrollElement ? null : _uu5g.default.Common.Element.create("span", {
      className: _uu5g.default.Common.ClassNames.hidden,
      ref: this._setDomNodeRef
    });
  } //@@viewOff:render

}); // NOTE Heavily inspired by react-dnd-scrollzone but works for "window" scroll too
// (https://github.com/azuqua/react-dnd-scrollzone/issues/5).


var ScrollEnhancer =
/*#__PURE__*/
function () {
  _createClass(ScrollEnhancer, null, [{
    key: "attachEnhancer",

    /**
     * Initializes / updates scroll enhancer for specified DOM element. This method is safe to be called multiple times for
     * the same element - each such call receives different "registration" that can be used for manipulating
     * the scroll enhancer. Each "registration" must call "registration.detach()" after it no longer wants the DOM element
     * to be enhanced.
     *
     * The parameters that scroll enhancer uses are always taken from the last "registration". After "registration.detach()",
     * if there were multiple "registrations", scroll enhancer will still be active and will use parameters from previous
     * "registration". Scroll enhancer will be detached from the DOM element after all "registrations" are detached.
     *
     * @param {*} scrollElement
     * @param {*} params Parameters for scroll enhancer - horizontalOffset, verticalOffset.
     * @return Scroll enhancer's "registration".
     */
    value: function attachEnhancer(scrollElement) {
      var dragDropManager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var instanceInfo = ScrollEnhancer.instances.get(scrollElement);

      if (!instanceInfo) {
        var _instance = new ScrollEnhancer(scrollElement, dragDropManager, params);

        instanceInfo = {
          instance: _instance,
          registrations: []
        };
        ScrollEnhancer.instances.set(scrollElement, instanceInfo);
      }

      var _instanceInfo = instanceInfo,
          instance = _instanceInfo.instance,
          registrations = _instanceInfo.registrations;
      var registration = {
        getScrollElement: function getScrollElement() {
          return scrollElement;
        },
        getParams: function getParams() {
          return params;
        },
        detach: function detach() {
          var idx = registrations.indexOf(registration);
          if (idx === -1) return;
          registrations.pop();

          if (registrations.length === 0) {
            // no active registrations => detach completely
            instance.destroy();
            ScrollEnhancer.instances.delete(scrollElement);
          } else if (idx === registrations.length) {
            // detached registration that was active => change params to previous
            instance.setParams(registrations[idx - 1].getParams());
          }
        },
        setParams: function setParams(newParams) {
          params = newParams;
          if (registrations[registrations.length - 1] === registration) instance.setParams(params);
        }
      };
      instanceInfo.registrations.push(registration);
      return registration;
    }
  }]);

  function ScrollEnhancer(scrollElement, dragDropManager, params) {
    _classCallCheck(this, ScrollEnhancer);

    this.scrollElement = scrollElement;
    this.dragDropManager = dragDropManager;
    this.setParams(params);
    this._isDragging = dragDropManager ? dragDropManager.getMonitor().isDragging() : false;
    this._isTrackingDrag = false;
    this._destroyed = false;
    this._listeners = [];
    this._scrollDeltaX = 30;
    this._scrollDeltaY = 30;
    this._updateScrolling = _uu5g.default.Common.Tools.throttle(this._updateScrolling.bind(this), 100, {
      trailing: false
    });
    this._startTrackingDrag = this._startTrackingDrag.bind(this);
    this._handleTouchStart = this._handleTouchStart.bind(this);
    this._handleTouchEnd = this._handleTouchEnd.bind(this);
    this._handleTouchCancel = this._handleTouchCancel.bind(this);
    this._handleTouchMove = this._handleTouchMove.bind(this);
    this._onDdmChange = this._onDdmChange.bind(this);

    this._addListener(scrollElement === window ? document.scrollingElement || document.body : scrollElement, "dragover", this._startTrackingDrag); // "touch" events needs to be on root


    this._addListener(document.scrollingElement || document.body, "touchstart", this._handleTouchStart);

    this._addListener(document.scrollingElement || document.body, "touchend", this._handleTouchEnd);

    this._addListener(document.scrollingElement || document.body, "touchcancel", this._handleTouchCancel);

    this._addListener(document.scrollingElement || document.body, "touchmove", this._handleTouchMove);

    if (dragDropManager) {
      this._clearDdmSubscription = dragDropManager.getMonitor().subscribeToStateChange(this._onDdmChange);
    }
  }

  _createClass(ScrollEnhancer, [{
    key: "setParams",
    value: function setParams(_ref) {
      var horizontalOffset = _ref.horizontalOffset,
          verticalOffset = _ref.verticalOffset;
      this.horizontalOffset = horizontalOffset;
      this.verticalOffset = verticalOffset;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._destroyed = true;

      this._listeners.forEach(function (fn) {
        return fn();
      });

      this._stopScrolling();

      this._clearDdmSubscription();

      this._touchCleanup();

      document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
      clearTimeout(this._dragCancelTimeout);
    }
  }, {
    key: "_addListener",
    value: function _addListener(obj, type, fn) {
      obj.addEventListener(type, fn);

      this._listeners.push(function () {
        return obj.removeEventListener(type, fn);
      });
    }
  }, {
    key: "_onDdmChange",
    value: function _onDdmChange() {
      var isDragging = this.dragDropManager.getMonitor().isDragging();

      if (isDragging && !this._isDragging) {
        this._isDragging = true;
      } else if (!isDragging && this._isDragging) {
        this._isDragging = false;

        this._stopScrolling();

        document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
      }
    }
  }, {
    key: "_handleTouchStart",
    value: function _handleTouchStart(e) {
      // NOTE If the element where touch started gets unmounted (which react-virtualized tends to do...),
      // browser stops sending any touch events. This was happening on Android devices on e12.html demo.
      //   =>
      // Guard the element and if during scrolling we detect that the element got unmounted, we'll
      // re-mount it to the BODY as hidden, which luckily makes touch events work again.
      if (!this._guardedTouchNode) {
        this._guardedTouchNode = e.target;
      }
    }
  }, {
    key: "_handleTouchEnd",
    value: function _handleTouchEnd(e) {
      this._touchCleanup();
    }
  }, {
    key: "_handleTouchCancel",
    value: function _handleTouchCancel(e) {
      this._touchCleanup();
    }
  }, {
    key: "_touchCleanup",
    value: function _touchCleanup() {
      if (this._guardedTouchNode) {
        if (this._guardedTouchNodeRemounted && this._guardedTouchNode.parentNode) {
          this._guardedTouchNode.parentNode.removeChild(this._guardedTouchNode);
        }

        this._guardedTouchNode = null;
        this._guardedTouchNodeRemounted = false;
      }
    }
  }, {
    key: "_handleTouchMove",
    value: function _handleTouchMove(e) {
      // only start tracking if touchstart has been triggerred on our scrollingElement (i.e. we have a guarded node)
      if (this._guardedTouchNode) this._startTrackingDrag(e);
    }
  }, {
    key: "_startTrackingDrag",
    value: function _startTrackingDrag(e) {
      if (!this._isTrackingDrag && (!this.dragDropManager || this._isDragging)) {
        this._isTrackingDrag = true;
        (document.scrollingElement || document.body).addEventListener("dragover", this._updateScrolling);
        (document.scrollingElement || document.body).addEventListener("touchmove", this._updateScrolling);
      }
    }
  }, {
    key: "_stopTrackingDrag",
    value: function _stopTrackingDrag() {
      this._isTrackingDrag = false;
      (document.scrollingElement || document.body).removeEventListener("dragover", this._updateScrolling);
      (document.scrollingElement || document.body).removeEventListener("touchmove", this._updateScrolling);
      clearTimeout(this._dragCancelTimeout);
    }
  }, {
    key: "_updateScrolling",
    value: function _updateScrolling(e) {
      var _this = this;

      document.documentElement.classList.add("uu5-tiles-dnd-scroll-enhancer-scrolling");

      if (!this.dragDropManager) {
        this._isDragging = true; // if user drags e.g. .zip file over BODY and drops it then we don't get
        // any event about that => if no dragover happens within
        // some time then assume the user is no longer dragging

        clearTimeout(this._dragCancelTimeout);
        Promise.resolve().then(function () {
          if (_this._destroyed) return;
          _this._dragCancelTimeout = setTimeout(function () {
            if (_this._isDragging) {
              _this._isDragging = false;

              _this._stopScrolling();

              document.documentElement.classList.remove("uu5-tiles-dnd-scroll-enhancer-scrolling");
            }
          }, 500);
        });
      }

      var scrollElement = this.scrollElement;
      var scrollZoneRect = scrollElement === window ? {
        left: 0,
        top: 0,
        bottom: window.innerHeight,
        right: window.innerWidth,
        height: window.innerHeight,
        width: window.innerWidth
      } : scrollElement.getBoundingClientRect();
      var mousePos = e.type === "touchmove" ? {
        x: e.changedTouches[0].clientX,
        y: e.changedTouches[0].clientY
      } : {
        x: e.clientX,
        y: e.clientY
      };
      var animate = false;
      var insideScrollZone = false;

      if (scrollZoneRect.left <= mousePos.x && mousePos.x <= scrollZoneRect.right && scrollZoneRect.top <= mousePos.y && mousePos.y <= scrollZoneRect.bottom) {
        this._runningAdjust = this._computeScrollAdjust(scrollZoneRect, mousePos);
        animate = !!(this._runningAdjust.dx || this._runningAdjust.dy);
        insideScrollZone = true;
      }

      if (animate) {
        if (!this._runningRafId) this._startScrolling();
      } else if (!this.dragDropManager || !insideScrollZone) {
        this._runningAdjust = {};

        this._stopScrolling();
      }
    }
  }, {
    key: "_startScrolling",
    value: function _startScrolling() {
      var _this2 = this;

      var i = 0;

      var tick = function tick() {
        if (!_this2._guardedTouchNodeRemounted && _this2._guardedTouchNode && !document.contains(_this2._guardedTouchNode)) {
          _this2._guardedTouchNodeRemounted = true;

          _this2._guardedTouchNode.classList.add("uu5-common-hidden");

          document.body.appendChild(_this2._guardedTouchNode);
        }

        var _this2$_runningAdjust = _this2._runningAdjust,
            dx = _this2$_runningAdjust.dx,
            dy = _this2$_runningAdjust.dy;

        if (!dx && !dy) {
          _this2._stopScrolling();
        } else {
          i ^= 1; // on Android mobiles we cannot scroll on each paint because it somehow stops the page from dnd handling

          if (i) {
            var elem = _this2.scrollElement === window ? document.scrollingElement || document.body : _this2.scrollElement;
            var newScrollLeft = Math.max(0, Math.min(elem.scrollWidth - elem.clientWidth, elem.scrollLeft + dx));
            var newScrollTop = Math.max(0, Math.min(elem.scrollHeight - elem.clientHeight, elem.scrollTop + dy));
            if (newScrollLeft !== elem.scrollLeft) elem.scrollLeft = newScrollLeft;
            if (newScrollTop !== elem.scrollTop) elem.scrollTop = newScrollTop;
          }

          _this2._runningRafId = requestAnimationFrame(tick);
        }
      };

      tick();
    }
  }, {
    key: "_stopScrolling",
    value: function _stopScrolling() {
      this._stopTrackingDrag();

      if (this._runningRafId) cancelAnimationFrame(this._runningRafId);
      this._runningRafId = null;
    }
  }, {
    key: "_computeScrollAdjust",
    value: function _computeScrollAdjust(scrollZoneRect, mousePos) {
      var horizontalOffset = Math.max(1, Math.min(this.horizontalOffset, scrollZoneRect.width / 2 - 64)); // 128x128 <=> reserved for central square which doesn't react to scroll (to be able to drop)

      var leftEdgeNorm = 1 - (mousePos.x - scrollZoneRect.left) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>

      var rightEdgeNorm = 1 - (scrollZoneRect.right - mousePos.x) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>

      var verticalOffset = Math.max(1, Math.min(this.verticalOffset, scrollZoneRect.height / 2 - 64));
      var topEdgeNorm = 1 - (mousePos.y - scrollZoneRect.top) / verticalOffset; // (-Inf, 1>, valid is <0, 1>

      var bottomEdgeNorm = 1 - (scrollZoneRect.bottom - mousePos.y) / verticalOffset; // (-Inf, 1>, valid is <0, 1>

      var ease = function ease(number) {
        return number;
      }; // linear easing


      var dx = leftEdgeNorm >= 0 ? -ease(leftEdgeNorm) : rightEdgeNorm >= 0 ? ease(rightEdgeNorm) : 0;
      var dy = topEdgeNorm >= 0 ? -ease(topEdgeNorm) : bottomEdgeNorm >= 0 ? ease(bottomEdgeNorm) : 0;
      dx = Math.round(dx * this._scrollDeltaX);
      dy = Math.round(dy * this._scrollDeltaY);
      return {
        dx: dx,
        dy: dy
      };
    }
  }]);

  return ScrollEnhancer;
}();

_defineProperty(ScrollEnhancer, "instances", new Map());

var DndScrollEnhancer = _uu5g.default.Common.DnD.withContext(DndScrollEnhancerBase);

exports.DndScrollEnhancer = DndScrollEnhancer;
var _default = DndScrollEnhancer;
exports.default = _default;