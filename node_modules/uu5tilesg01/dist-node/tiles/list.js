"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.List = void 0;

var _config = _interopRequireDefault(require("../config/config.js"));

var _uu5g = _interopRequireDefault(require("uu5g04"));

require("uu5g04-bricks");

var _reactVirtualized = require("react-virtualized");

var _memoizeOne = _interopRequireDefault(require("memoize-one"));

var _windowScroller = _interopRequireDefault(require("./window-scroller/window-scroller.js"));

var _tile = _interopRequireDefault(require("./tile.js"));

var _listCache = _interopRequireDefault(require("./list-cache.js"));

var _util = require("./util.js");

require("./list.less");

var _dndScrollEnhancer = _interopRequireDefault(require("./dnd-scroll-enhancer.js"));

var _passNearestScrollElement = _interopRequireDefault(require("./pass-nearest-scroll-element.js"));

var _this = void 0;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var ListDropZone = _uu5g.default.Common.Component.lazy(
/*#__PURE__*/
_asyncToGenerator(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee() {
  var _ref2, DropZone, ReactDnD, Component;

  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return import("./list-drop-zone.js");

        case 2:
          _ref2 = _context.sent;
          DropZone = _ref2.default;
          _context.next = 6;
          return SystemJS.import("react-dnd");

        case 6:
          ReactDnD = _context.sent;
          Component = ReactDnD.DropTarget([_tile.default.DRAG_ITEM_TYPE], DropZone.dropTarget, _tile.default.dropPropsExpander)(DropZone);
          return _context.abrupt("return", {
            default: Component
          });

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
})));

function shallowEqualObject(a, b) {
  if (a == null || b == null) return a === b;
  return !Object.keys(a).some(function (k) {
    return a[k] !== b[k];
  });
}

var Row = function Row(_ref3) {
  var columnCount = _ref3.columnCount,
      elevationMargins = _ref3.elevationMargins,
      itemRendererProps = _ref3.itemRendererProps,
      rowClassName = _ref3.rowClassName,
      rowSpacing = _ref3.rowSpacing,
      tileMinWidth = _ref3.tileMinWidth,
      tileSpacing = _ref3.tileSpacing,
      tileWidth = _ref3.tileWidth,
      row = _objectWithoutProperties(_ref3, ["columnCount", "elevationMargins", "itemRendererProps", "rowClassName", "rowSpacing", "tileMinWidth", "tileSpacing", "tileWidth"]);

  row.style = _objectSpread({}, row.style, {
    marginLeft: 0 //margin- ugly correction, works but needs some research

  });
  var items = [];

  for (var i = 0; i < columnCount; i++) {
    var item = _objectSpread({}, row);

    item.key = item.key + "-" + i;
    item.index = columnCount * row.index + i;
    item.rowIndex = row.index;
    item.columnIndex = i;

    if (tileMinWidth) {
      item.style = {
        width: tileWidth
      };
      item.wrapperStyle = {};
    } else {
      item.style = {
        flex: "1 1 auto"
      };
      item.wrapperStyle = {
        flex: "1 1 auto"
      };
    }

    if (rowSpacing) {
      // 1. Card height inside Tile is CH and it should be this.props.tileHeight.
      //    Note that it has elevation margins and is nested in a wrapper (see Tile).
      // 2. Row height is CH + RS (row spacing).
      // 3. Tile (wrapper) contains Card + elevation margins, but height is sized according to the row height, i.e. it's CH.
      //    => Card must have zero margins (when using RS)
      item.wrapperStyle.paddingBottom = rowSpacing;
      item.style.marginTop = 0;
      item.style.marginBottom = 0;
    }

    if (tileMinWidth && tileSpacing && i < columnCount - 1) {
      item.wrapperStyle.marginRight = tileSpacing - 2 * elevationMargins.horizontalHalf;
    }

    items.push(item);
  }

  return _uu5g.default.Common.Element.create("div", {
    className: rowClassName,
    style: row.style,
    key: row.key
  }, items.map(function (item, i) {
    return _uu5g.default.Common.Element.create(Item, _extends({
      key: item.key
    }, item, {
      rowPosition: i,
      elevationMargins: elevationMargins,
      listProps: itemRendererProps,
      handleMeasure: itemRendererProps.handleMeasure
    }));
  }));
};

Row.propTypes = {
  columnCount: _uu5g.default.PropTypes.number,
  elevationMargins: _uu5g.default.PropTypes.any,
  itemRenderer: _uu5g.default.PropTypes.func,
  itemRendererProps: _uu5g.default.PropTypes.object,
  rowClassName: _uu5g.default.PropTypes.any,
  rowSpacing: _uu5g.default.PropTypes.any,
  tileMinWidth: _uu5g.default.PropTypes.any,
  tileSpacing: _uu5g.default.PropTypes.any,
  tileWidth: _uu5g.default.PropTypes.any
};
if (_uu5g.default.Common.Component.memo) Row = _uu5g.default.Common.Component.memo(Row);
var warnedDraggableItemWithoutId = false;

var Item = function Item(_ref4) {
  var rowPosition = _ref4.rowPosition,
      listProps = _ref4.listProps,
      elevationMargins = _ref4.elevationMargins,
      tile = _objectWithoutProperties(_ref4, ["rowPosition", "listProps", "elevationMargins"]);

  var controller = listProps.controller,
      data = listProps.data,
      draggable = listProps.draggable,
      estimatedTileHeight = listProps.estimatedTileHeight,
      handleMeasure = listProps.handleMeasure,
      onDrop = listProps.onDrop,
      onLoad = listProps.onLoad,
      skipInnerTile = listProps.skipInnerTile,
      propsTile = listProps.tile,
      tileBorder = listProps.tileBorder,
      tileCount = listProps.tileCount,
      tileElevation = listProps.tileElevation,
      tileElevationHover = listProps.tileElevationHover,
      tileStyle = listProps.tileStyle;
  var tileData = data ? data[tile.index] : undefined;
  var tileDataLoading = onLoad && data && !tileData;

  if (tile.index >= tileCount || tileDataLoading) {
    // NOTE When rendering placeholder in the last row, the element must have min-height 1px so that
    // it's actually rendered - if it had 0 then the last row could have wrong tile widths due to flexing.
    // At the same time, tiles that are being dynamically loaded should have some "estimated" height because
    // if we used 1px, the dynamic-row-height estimation would try to mount ~1024 rows each being 1px high...
    var requiredMinHeight = tile.index >= tileCount && tile.index - tile.columnIndex < tileCount ? 1 : estimatedTileHeight;
    return _uu5g.default.Common.Element.create(Placeholder, {
      wrapperStyle: tile.wrapperStyle,
      style: tile.style,
      requiredMinHeight: requiredMinHeight,
      elevationMargins: elevationMargins
    });
  }

  if (draggable && (!tileData || !tileData.id)) {
    draggable = false;

    if (!warnedDraggableItemWithoutId) {
      warnedDraggableItemWithoutId = true;

      _uu5g.default.Common.Tools.warning("The tile list is draggable={true} but it contains item(s) which don't have 'id'. Only item(s) with 'id' can be dragged.", {
        context: {
          item: tileData
        }
      });
    }
  }

  var result;
  var tileProps = {
    style: _objectSpread({}, tileStyle, tile.style),
    elevation: tileElevation,
    elevationHover: tileElevationHover,
    border: tileBorder,
    draggable: draggable,
    onDrop: draggable ? onDrop : null,
    wrapperStyle: tile.wrapperStyle,
    data: tileData,
    handleMeasure: handleMeasure
  };
  delete tile.style;

  if (controller && tileData && tileData.id) {
    var ctrlTileProps = controller.getTileProps(tileData.id);
    Object.assign(tile, {
      selected: ctrlTileProps.selected
    });
    tileProps = _objectSpread({}, tileProps, ctrlTileProps);
    tileProps.key = tileData.id;
  }

  if (propsTile) {
    var newProps = _objectSpread({}, tile, tileData, {
      data: tileData,
      id: tileData ? tileData.id : undefined
    }, skipInnerTile ? tileProps : null, {
      parent: _this
    });

    if (typeof propsTile === "function") {
      result = propsTile(newProps);
    } else if (_uu5g.default.Common.Element.isValid(propsTile)) {
      propsTile.props.border !== undefined && delete newProps.border;
      result = _uu5g.default.Common.Element.clone(propsTile, newProps);
    } else if (typeof propsTile === "string") {
      result = _uu5g.default.Common.Tools.findComponent(propsTile, newProps);
    }
  } else {
    skipInnerTile = false;

    if (tileData) {
      var style = _objectSpread({}, tileProps.style, tileData.style);

      tileProps = _objectSpread({}, tileProps, tileData, {
        data: tileData
      });
      tileProps.style = style;
    }
  }

  return skipInnerTile ? result : _uu5g.default.Common.Element.create(_tile.default, _extends({}, tileProps, {
    id: tileData ? tileData.id : undefined
  }), result);
};

if (_uu5g.default.Common.Component.memo) Item = _uu5g.default.Common.Component.memo(Item);

var Placeholder = function Placeholder(_ref5) {
  var wrapperStyle = _ref5.wrapperStyle,
      style = _ref5.style,
      elevationMargins = _ref5.elevationMargins,
      requiredMinHeight = _ref5.requiredMinHeight;
  // eslint-disable-line
  var elevationHorizontal = elevationMargins.horizontalHalf;
  return _uu5g.default.Common.Element.create("div", {
    style: wrapperStyle
  }, _uu5g.default.Common.Element.create("div", {
    style: _objectSpread({}, style, {
      marginLeft: elevationHorizontal,
      marginRight: elevationHorizontal,
      minHeight: requiredMinHeight
    })
  }));
};

if (_uu5g.default.Common.Component.memo) Placeholder = _uu5g.default.Common.Component.memo(Placeholder);

var ListBase = _uu5g.default.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [_uu5g.default.Common.BaseMixin, _uu5g.default.Common.ElementaryMixin, _uu5g.default.Common.NestingLevelMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config.default.TAG + "List",
    nestingLevelList: _uu5g.default.Environment.getNestingLevelList("bigBoxCollection", "box"),
    classNames: {
      main: _config.default.CSS + "list",
      row: _config.default.CSS + "list-row",
      item: _config.default.CSS + "list-item",
      justify: _config.default.CSS + "list-row-justify-",
      list: _config.default.CSS + "list-virtualized",
      loading: _config.default.CSS + "list-loading",
      reloading: _config.default.CSS + "list-reloading"
    },
    defaults: {
      // TODO: number depends on uu5g04 UU5.Bricks.Card styles!
      elevation: {
        0: {
          vertical: 0,
          verticalBottom: 0,
          horizontalHalf: 0
        },
        1: {
          vertical: 6,
          verticalBottom: 4,
          horizontalHalf: 3
        },
        2: {
          vertical: 11,
          verticalBottom: 7,
          horizontalHalf: 5
        },
        3: {
          vertical: 18,
          verticalBottom: 11,
          horizontalHalf: 9
        },
        4: {
          vertical: 23,
          verticalBottom: 15,
          horizontalHalf: 12
        },
        5: {
          vertical: 55,
          verticalBottom: 35,
          horizontalHalf: 27
        }
      },
      debouncedLoadDelay: 200,
      estimatedTileHeightAuto: 100 // NOTE The smaller the value, the more rows will be mounted ahead (e.g. having it at 100 on 1920x1024 means there'll be 11 rows + overscan rows).

    },
    warnings: {
      draggableItemWithoutId: "The tile list is draggable={true} but it contains item(s) which don't have 'id'. Only item(s) with 'id' can be dragged.",
      scrollToTileHeightAuto: 'Methods scrollToIndex/scrollToTile with tileHeight="auto" does not always scroll exactly to where you wanted because not all row heights are known. Use exact tileHeight if you need to rely on them.'
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    width: _uu5g.default.PropTypes.number.isRequired,
    tileHeight: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.number, _uu5g.default.PropTypes.oneOf(["auto"])]).isRequired,
    estimatedTileHeight: _uu5g.default.PropTypes.number,
    height: _uu5g.default.PropTypes.number,
    rowSpacing: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.number, _uu5g.default.PropTypes.string]),
    overscanRowCount: _uu5g.default.PropTypes.number,
    overscanRowCountBackward: _uu5g.default.PropTypes.number,
    tileCount: _uu5g.default.PropTypes.number,
    // or data
    data: _uu5g.default.PropTypes.arrayOf(_uu5g.default.PropTypes.shape),
    controller: _uu5g.default.PropTypes.object,
    tile: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.func, _uu5g.default.PropTypes.element, _uu5g.default.PropTypes.string]),
    tileMinWidth: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.number, _uu5g.default.PropTypes.string]),
    // px || "xs-12 s-6 m-4 ..."
    tileMaxWidth: _uu5g.default.PropTypes.number,
    tileSpacing: _uu5g.default.PropTypes.oneOfType([_uu5g.default.PropTypes.number, _uu5g.default.PropTypes.string]),
    tileJustify: _uu5g.default.PropTypes.oneOf(["full", "left", "right", "center", "space-between", "space-around", "space-evenly"]),
    tileElevation: _uu5g.default.PropTypes.number,
    tileElevationHover: _uu5g.default.PropTypes.number,
    tileStyle: _uu5g.default.PropTypes.object,
    tileStretch: _uu5g.default.PropTypes.oneOf(["grow", "shrink"]),
    tileBorder: _uu5g.default.PropTypes.bool,
    skipInnerTile: _uu5g.default.PropTypes.bool,
    scrollToAlignment: _uu5g.default.PropTypes.oneOf(["auto", "start", "center", "end"]),
    onScroll: _uu5g.default.PropTypes.func,
    scrollElement: _uu5g.default.PropTypes.any,
    virtualizedListProps: _uu5g.default.PropTypes.object,
    draggable: _uu5g.default.PropTypes.bool,
    onChange: _uu5g.default.PropTypes.func,
    onLoad: _uu5g.default.PropTypes.func,
    onLoadPageSize: _uu5g.default.PropTypes.number,
    onMount: _uu5g.default.PropTypes.func
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      width: 400,
      height: process.env.NODE_ENV === "test" ? 500 : undefined,
      tileHeight: 32,
      estimatedTileHeight: undefined,
      rowSpacing: 0,
      overscanRowCount: 3,
      overscanRowCountBackward: 0,
      tileCount: undefined,
      data: null,
      controller: undefined,
      tile: null,
      tileMinWidth: null,
      tileMaxWidth: null,
      tileSpacing: 0,
      tileJustify: "full",
      tileElevation: undefined,
      tileElevationHover: undefined,
      tileStyle: null,
      tileStretch: "grow",
      tileBorder: undefined,
      skipInnerTile: false,
      scrollToAlignment: "start",
      onScroll: null,
      scrollElement: null,
      virtualizedListProps: {},
      draggable: false,
      onLoadPageSize: undefined
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    this._warnedDraggableItemWithoutId = false;
    this._scrollTopFixPending = false; // see scrollToPosition()

    this._cachedData = []; // NOTE Loaded data is cached - developer must call invalidateData() or change component "key" to reset cache.

    if (this.props.onLoad) this._markAsLoaded(this.props.data);
    this._debouncedExecuteLoadCall = _uu5g.default.Common.Tools.debounce(this._executeLoadCall, this.getDefault("debouncedLoadDelay"));
    this._cellMeasurerCache = new _reactVirtualized.CellMeasurerCache({
      defaultHeight: this.getDefault("estimatedTileHeightAuto"),
      fixedWidth: true
    });
    this._computeItemRenderer = (0, _memoizeOne.default)(this._computeItemRenderer);
    this._computeItemRendererPropsRows = {};
    this._computeOverscanIndicesGetter = (0, _memoizeOne.default)(this._computeOverscanIndicesGetter);
    this._computeWindowScrollerChildDivRef = (0, _memoizeOne.default)(this._computeWindowScrollerChildDivRef);
    this._rowStyleMemoizers = {};
    return {
      scrollTopFix: undefined,
      // see scrollToPosition()
      loadTotalTileCount: undefined,
      // total tile count when being loaded via onLoad call without controller
      isReloading: !!this.props.onLoad,
      pendingInitialLoad: !!this.props.onLoad
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.onLoad !== this.props.onLoad) {
      this._cachedData = [];
      if (nextProps.onLoad) this._markAsLoaded(nextProps.data);
      this.setState({
        isReloading: !!nextProps.onLoad,
        pendingInitialLoad: true
      });
    }

    if (this._cellMeasurerCache && (nextProps.width !== this.props.width || nextProps.tileMinWidth !== this.props.tileMinWidth || nextProps.tileMaxWidth !== this.props.tileMaxWidth || nextProps.tileSpacing !== this.props.tileSpacing || nextProps.tileBorder !== this.props.tileBorder || nextProps.tileStyle !== this.props.tileStyle || nextProps.tileHeight !== this.props.tileHeight || nextProps.rowSpacing !== this.props.rowSpacing)) {
      this._cellMeasurerCache.clearAll();
    }
  },
  componentDidMount: function componentDidMount() {
    this._mounted = true;
    if (this.props.controller) this.props.controller.registerList(this);

    this._tryOnMount();
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    this._scrollTopFixPending = false; // NOTE Cannot be in componentWillReceiveProps because InfiniteLoader / VirtualizedList will call us and our props would still be the old ones.

    if (prevProps.width !== this.props.width || prevProps.tileMinWidth !== this.props.tileMinWidth || prevProps.tileMaxWidth !== this.props.tileMaxWidth || prevProps.tileSpacing !== this.props.tileSpacing || prevProps.tileStretch !== this.props.tileStretch || prevProps.onLoad !== this.props.onLoad) {
      if (this._infiniteLoader && prevProps.onLoad) this._infiniteLoader.resetLoadMoreRowsCache(true);
    }

    this._tryOnMount();
  },
  componentWillUnmount: function componentWillUnmount() {
    this._unmounted = true;
    if (this._cumulatedLoad && this._cumulatedLoad.timeoutId) clearTimeout(this._cumulatedLoad.timeoutId);
    this._rowStyleMemoizers = {};
    if (this._windowScrollerCheckInterval) clearInterval(this._windowScrollerCheckInterval);
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  scrollToIndex: function scrollToIndex(tileIndex) {
    if (this.props.tileHeight === "auto") {
      this.showWarning("scrollToTileHeightAuto");
    }

    var rowIndex = this._getRowIndex(tileIndex); // NOTE Commented out because it's not working properly with React 16.4.0+ because of
    // https://github.com/bvaughn/react-virtualized/issues/1179#issuecomment-411063935
    // this._list && this._list.scrollToRow(rowIndex);
    // temporary hack for the issue above


    var grid = this._list && this._list.Grid;

    if (grid && grid.constructor && grid.constructor._getScrollTopForScrollToRowStateUpdate) {
      var gridStateUpdate = grid.constructor._getScrollTopForScrollToRowStateUpdate(_objectSpread({}, grid.props, {
        scrollToRow: rowIndex
      }), grid.state);

      if (gridStateUpdate && typeof gridStateUpdate.scrollTop === "number") {
        this._scrollTopFixPending = true;
        this.setState({
          scrollTopFix: gridStateUpdate.scrollTop
        });
      }
    }

    return this;
  },
  scrollToPosition: function scrollToPosition(scrollTop) {
    // NOTE Commented out because it's not working properly with React 16.4.0+ because of
    // https://github.com/bvaughn/react-virtualized/issues/1179#issuecomment-411063935
    // this._list && this._list.scrollToPosition(scrollTop);
    // temporary hack for the issue above - pass scrollTop via props on virtualized list
    // (but we have to pass it only next render; afterwards we must use the value provided
    // by WindowScroller so that the scroll position isn't freezed)
    var grid = this._list && this._list.Grid;

    if (grid && grid.constructor && grid.constructor._getScrollToPositionStateUpdate) {
      var gridStateUpdate = grid.constructor._getScrollToPositionStateUpdate({
        prevState: grid.state,
        scrollTop: scrollTop
      });

      if (gridStateUpdate && typeof gridStateUpdate.scrollTop === "number") {
        this._scrollTopFixPending = true;
        this.setState({
          scrollTopFix: gridStateUpdate.scrollTop
        });
      }
    }

    return this;
  },
  scrollToTile: function scrollToTile(findFn) {
    var data = this.props.data;

    if (data) {
      var index = data.findIndex(function (item, index) {
        return item ? findFn(item, index) : false;
      });
      if (index !== -1) this.scrollToIndex(index);
    }

    return this;
  },
  reloadData: function reloadData() {
    var _this2 = this;

    this._cachedData = [];

    if (this._infiniteLoader) {
      this.setState({
        isReloading: true
      }, function () {
        return _this2._infiniteLoader.resetLoadMoreRowsCache(true);
      });
    }
  },
  invalidateData: function invalidateData() {
    this._cachedData = [];

    if (this._infiniteLoader) {
      // NOTE If using controller, data invalidation means that the controller might be missing
      // only some data (e.g. it invalidated selected items by a bulk action). Missing data thus
      // can be in inconsecutive ranges and react-virtualized InfiniteLoader will call loadMoreRows
      // fn multiple times. And because we use debouncing we'll execute only the last call and ignore
      // the others (which might still be necessary / on-screen).
      //   => use flag for skipping the debounce (there's no way to pass a flag via react-virtualized API)
      this._skipDebounce = true;

      this._infiniteLoader.resetLoadMoreRowsCache(true);
    }
  },
  //@@viewOff:interface
  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods
  //@@viewOn:private
  _tryOnMount: function _tryOnMount() {
    if (!this._onMountDone) {
      // when we're in UU5.Bricks.Resize component, we'll initially get width=0 which
      // is unusable because we won't be able to find out number of our columns and
      // if user performs scrollToTile during onMount fn it'll scroll to wrong position
      // => postpone onMount until we get proper width in such case
      if (this.props.width !== 0 && this._list) {
        this._onMountDone = true;
        if (typeof this.props.onMount === "function") this.props.onMount({
          component: this
        });
      }
    }
  },
  _setListRef: function _setListRef(ref) {
    this._list = ref;
    if (ref && this._mounted) this._tryOnMount();
  },
  _setWindowScrollerRef: function _setWindowScrollerRef(ref) {
    var _this3 = this;

    this._windowScroller = ref; // if using scrollElement/BODY and something above us changes its height we need to
    // let WindowScroller know about that (otherwise it'll compute scroll positions incorrectly
    // resulting in tiles being rendered too late / unmounted too soon so white empty spaces would be shown
    // at the start/end of the currently rendered viewport rectangle)

    if (this._windowScrollerCheckInterval) clearInterval(this._windowScrollerCheckInterval);

    if (this._windowScroller) {
      var lastUpdatedTop = (0, _util.getRelativeTop)(this._windowScrollerChildDiv, this._usedScrollElement);
      this._windowScrollerCheckInterval = setInterval(function () {
        var top = (0, _util.getRelativeTop)(_this3._windowScrollerChildDiv, _this3._usedScrollElement);

        if (Math.abs(top - lastUpdatedTop) >= 10) {
          _this3._windowScroller.updatePosition();

          lastUpdatedTop = top;
        }
      }, 200);
    }
  },
  _getTileCount: function _getTileCount() {
    // return tiles count; if using onLoad (on-demand loading) and load wasn't performed yet then return an estimation of tile count
    var result = typeof this.props.tileCount === "number" ? this.props.tileCount : this.state.loadTotalTileCount;

    if (result == null) {
      result = this.props.data && this.props.data.length || 0;
    } // if we're reloading then use "some" non-zero number so that react-virtualized InfiniteLoader
    // knows there's non-zero rows and triggers _isRowLoaded() method


    if (this.state.isReloading) result = Math.max(result + 1, (this._estimateVisibleRowCount() + this._getLoadRowThreshold()) * this._countColumns());
    return result;
  },
  _countRows: function _countRows() {
    var count = this._getTileCount();

    if (this.props.tileMinWidth && (typeof this.props.tileMinWidth !== "number" || this.props.tileMinWidth <= this._getWidthWithoutElevation())) {
      count = Math.ceil(count / this._countColumns());
    }

    return count;
  },
  // returns width decreased by left & right elevation margins
  _getWidthWithoutElevation: function _getWidthWithoutElevation() {
    return this.props.width - (this.props.controller ? 0 : 2 * this.getDefault("elevation")[this._getMaxElevation()].horizontalHalf);
  },
  _countColumns: function _countColumns() {
    var count = 1;

    if (this.props.tileMinWidth) {
      if (typeof this.props.tileMinWidth === "number") {
        var tileSpacing = this._getTileSpacing();

        var w1 = Math.floor((this._getWidthWithoutElevation() + tileSpacing) / (this.props.tileMinWidth + tileSpacing));
        var w2 = Math.floor((this._getWidthWithoutElevation() + tileSpacing) / (this.props.tileMaxWidth + tileSpacing));
        w2 = w1 - w2 > 1 ? w2 + 1 : w1;
        count = Math.max(this.props.tileStretch === "shrink" ? w1 : w2, 1);
      } else {
        // actual screen size, not rerender if screen size is changed, so it is working only with Resizing component
        var screenSize = _uu5g.default.Common.Tools.getScreenSize();

        _uu5g.default.Common.Tools.buildColWidthClassName(this.props.tileMinWidth).split(" ").forEach(function (className) {
          var values = className.match(/([a-z]+)(\d+)$/);

          if (values[1] === screenSize) {
            count = 12 / +values[2];
          }
        });
      }
    }

    return count;
  },
  _onTileDrop: function _onTileDrop(_ref6) {
    var _this4 = this;

    var item = _ref6.item,
        component = _ref6.component,
        before = _ref6.before;

    if (typeof this.props.onChange === "function") {
      var dropComponentId = component.getId();
      var _this$props = this.props,
          onLoad = _this$props.onLoad,
          controller = _this$props.controller;
      var data = onLoad && !controller ? this._cachedData : this.props.data;
      if (!data) data = [];
      var toIndex = data.length ? data.findIndex(function (dispItem) {
        return dispItem.id === dropComponentId;
      }) : 0;

      if (toIndex !== -1) {
        var newData = _toConsumableArray(data);

        var dataItem;
        var fromIndex = data.findIndex(function (dispItem) {
          return dispItem.id === item.id;
        });
        if (fromIndex !== -1) dataItem = newData.splice(fromIndex, 1)[0];else dataItem = item;
        newData.splice((toIndex > fromIndex && fromIndex !== -1 ? toIndex - 1 : toIndex) + !before, 0, dataItem);
        var opt = {
          data: newData,
          component: this
        };
        Promise.resolve().then(function () {
          return _this4.props.onChange(opt);
        }); // postponed so that native event gets processed in full
      }
    }
  },
  _getMaxElevation: function _getMaxElevation() {
    var elevation = this.props.tileElevation && this.props.tileElevation < 5 && this.props.tileElevation > -5 ? this.props.tileElevation : 0;
    var elevationHover = this.props.tileElevationHover && this.props.tileElevationHover < 5 && this.props.tileElevationHover > -5 ? this.props.tileElevationHover : 0;
    return Math.max(elevation, elevationHover);
  },
  _getRowSpacing: function _getRowSpacing() {
    return this.props.rowSpacing || this.getDefault("elevation")[this._getMaxElevation()].vertical;
  },
  _getTileSpacing: function _getTileSpacing() {
    return this.props.tileSpacing || 2 * this.getDefault("elevation")[this._getMaxElevation()].horizontalHalf;
  },
  _computeItemRenderer: function _computeItemRenderer(handleMeasure) {
    var _this5 = this;

    // NOTE This method is memoized. Use only parameters, no props/state.
    return function (item, index) {
      return _this5._renderItem(item, index, handleMeasure);
    };
  },
  _computeItemRendererProps: function _computeItemRendererProps(rowIndex, props) {
    // each row needs its own memoization fn as the fn remembers only result of single call
    // (if all rows were using the same memoized fn then getting 2nd row would return new result
    // as it would have different props than the 1st row and memoization would be useless)
    var memoizedRowFn = this._computeItemRendererPropsRows[rowIndex];

    if (!memoizedRowFn) {
      memoizedRowFn = this._computeItemRendererPropsRows[rowIndex] = (0, _memoizeOne.default)(function (props) {
        return props;
      }, function (newArgs, oldArgs) {
        return shallowEqualObject(newArgs[0], oldArgs[0]);
      });
    }

    return memoizedRowFn(props);
  },
  _getSimplifiedRow: function _getSimplifiedRow(row) {
    var result = row;

    if (typeof this.props.tile !== "function") {
      // props isVisible, isScrolling are passed only to "tile" rendering realized using function (as a performance optimization)
      var isScrolling = row.isScrolling,
          isVisible = row.isVisible,
          style = row.style,
          simplifiedRow = _objectWithoutProperties(row, ["isScrolling", "isVisible", "style"]); // eslint-disable-line


      if (!this._rowStyleMemoizers[row.index]) {
        this._rowStyleMemoizers[row.index] = (0, _memoizeOne.default)(function (style) {
          return style;
        }, function (newArgs, oldArgs) {
          return shallowEqualObject(newArgs[0], oldArgs[0]);
        });
      }

      simplifiedRow.style = this._rowStyleMemoizers[row.index](style);
      result = simplifiedRow;
    }

    return result;
  },
  _onScroll: function _onScroll(scrollInfo) {
    var c = this._countColumns();

    scrollInfo.rowCount = this._countRows();
    scrollInfo.columnCount = this._countColumns();

    var tileHeight = this._getEstimatedTileHeight(); // TODO Compute indices precisely for case when using dynamic row height.


    scrollInfo.firstTileIndex = Math.ceil(scrollInfo.scrollTop / (tileHeight + this._getRowSpacing())) * c;
    scrollInfo.lastTileIndex = Math.floor((scrollInfo.scrollTop + scrollInfo.clientHeight) / (tileHeight + this._getRowSpacing())) * c - 1;
    scrollInfo.rowIndex = this._getRowIndex(scrollInfo.firstTileIndex);
    this.props.onScroll(scrollInfo);
  },
  _getEstimatedTileHeight: function _getEstimatedTileHeight() {
    return this.props.tileHeight === "auto" ? this.props.estimatedTileHeight || this.getDefault("estimatedTileHeightAuto") : this.props.tileHeight;
  },
  _getRowIndex: function _getRowIndex(tileIndex) {
    var rowIndex = -1;

    var count = this._getTileCount();

    if (tileIndex <= 0) {
      rowIndex = 0;
    } else if (tileIndex >= count) {
      rowIndex = count;
    } else {
      rowIndex = Math.floor(tileIndex / this._countColumns());
    }

    return rowIndex;
  },
  _estimateRowHeight: function _estimateRowHeight(_ref7) {
    var index = _ref7.index;
    // NOTE When using draggable tiles, react-dnd (DropTarget/DragSource) renders "null" during 1st render which
    // means that the row has height 0 and Grid will try to render next row (same result), ..., effectively mounting all remaining
    // rows (reeeeally slow) => guard against this by using estimated height instead of 0 and then the Tile component in its
    // componentDidMount will trigger row height re-computation.
    return this._cellMeasurerCache.rowHeight({
      index: index
    }) || this.getDefault("estimatedTileHeightAuto") + this._getRowSpacing();
  },
  _getList: function _getList(scrollProps) {
    var _this6 = this;

    var rowCount = this._countRows();

    var rowHeight = this._getEstimatedTileHeight() + this._getRowSpacing();

    var listHeight = this.props.height == null ? rowCount * rowHeight : this.props.height;

    var elevationMargins = this.getDefault("elevation")[this._getMaxElevation()];

    var widthWithoutElevation = this._getWidthWithoutElevation();

    var listProps = _objectSpread({}, this.props.virtualizedListProps, {
      key: "list",
      className: this.getClassName("list"),
      width: widthWithoutElevation + 2 * elevationMargins.horizontalHalf,
      height: listHeight,
      rowHeight: this.props.tileHeight === "auto" ? this._estimateRowHeight : rowHeight,
      estimatedRowSize: rowHeight,
      deferredMeasurementCache: this.props.tileHeight === "auto" ? this._cellMeasurerCache : undefined,
      rowCount: rowCount,
      rowRenderer: this._renderRow,
      scrollToAlignment: this.props.scrollToAlignment,
      overscanRowCount: this.props.overscanRowCount,
      overscanIndicesGetter: this.props.overscanRowCountBackward ? this._computeOverscanIndicesGetter(this.props.overscanRowCount, this.props.overscanRowCountBackward) : undefined,
      cellRangeRenderer: this._cellRangeRenderer,
      style: {
        marginTop: elevationMargins.vertical - elevationMargins.verticalBottom,
        marginBottom: elevationMargins.verticalBottom - this._getRowSpacing(),
        // last row has rowSpacing too
        marginLeft: this.props.controller ? -elevationMargins.horizontalHalf : 0,
        // TODO Not nice - controller should pass bigger width and use negative marginLeft normally via style prop.
        marginRight: this.props.controller ? -elevationMargins.horizontalHalf : 0
      }
    });

    var onScroll;

    if (typeof this.props.onScroll === "function") {
      onScroll = function onScroll() {
        _this6._onScroll.apply(_this6, arguments);

        scrollProps && typeof scrollProps.onScroll === "function" && scrollProps.onScroll.apply(scrollProps, arguments);
      };
    }

    var result;

    var listAllProps = _objectSpread({}, listProps, scrollProps, {
      ref: this._setListRef,
      scrollTop: this._scrollTopFixPending ? this.state.scrollTopFix : scrollProps ? scrollProps.scrollTop : undefined,
      height: scrollProps && scrollProps.height || listProps.height
    });

    if (!listAllProps.autoHeight) {
      // NOTE This fixes https://github.com/bvaughn/react-virtualized/issues/1179 - happens with scrollElement={null}
      // when user scrolls via API, e.g. scrollToTile, and then scrolls via mouse (Grid resets position to the position
      // made by API because they migrated componentWillReceiveProps to getDerviedStateFromProps and the latter one gets
      // called more often than the former one and rewrites new scroll position by old one).
      var onScrollOrig = onScroll;

      onScroll = function onScroll() {
        _this6._scrollTopFixPending = true;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this6.setState({
          scrollTopFix: args.scrollTop
        });

        if (typeof onScrollOrig === "function") onScrollOrig.apply(void 0, args);
      };
    }

    Object.assign(listAllProps, {
      onScroll: onScroll
    });

    if (typeof this.props.tile !== "function") {
      delete listAllProps.isScrolling;
    }

    if (typeof this.props.onLoad === "function") {
      result = _uu5g.default.Common.Element.create(_reactVirtualized.InfiniteLoader, {
        isRowLoaded: this._isRowLoaded,
        loadMoreRows: this._loadMoreRows,
        rowCount: rowCount,
        threshold: this._getLoadRowThreshold(),
        ref: function ref(comp) {
          return _this6._infiniteLoader = comp;
        },
        key: "il"
      }, function (_ref8) {
        var onRowsRendered = _ref8.onRowsRendered,
            registerChild = _ref8.registerChild;
        return _uu5g.default.Common.Element.create(_reactVirtualized.List, _extends({}, listAllProps, {
          onRowsRendered: onRowsRendered,
          ref: function ref(list) {
            listAllProps.ref(list);
            return registerChild(list);
          }
        }));
      });
      var isLoading = this.state.pendingInitialLoad || this.state.isReloading;

      if (isLoading) {
        var classNames = [this.getClassName("loading")];
        if (!this.state.pendingInitialLoad) classNames.push(this.getClassName("reloading"));
        result = [_uu5g.default.Common.Element.create("div", {
          key: "loading",
          className: classNames.join(" ")
        }, _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Loading, {
          className: !this.state.pendingInitialLoad ? "uu5-common-elevation-2" : undefined
        })), result];
      }
    } else {
      result = _uu5g.default.Common.Element.create(_reactVirtualized.List, listAllProps);
    }

    return result;
  },
  _renderRow: function _renderRow(row) {
    var _this7 = this;

    var _this$props2 = this.props,
        tileMinWidth = _this$props2.tileMinWidth,
        tileMaxWidth = _this$props2.tileMaxWidth;

    var rowSpacing = this._getRowSpacing();

    var tileSpacing = this._getTileSpacing();

    var elevationMargins = this.getDefault("elevation")[this._getMaxElevation()];

    var columnCount = this._countColumns(); // NOTE
    // 1. If we're in controller, virtualized list has extra negative margins, i.e.
    //    the list width W = this.props.width (=== this._getWidthWithoutElevation()) and row width is
    //    W + 2 * EMHH (EMHH = elevationMargins.horizontalHalf).
    // 2. Tile's left margin edge should be aligned with left edge of virtualized list
    //    and because Card inside Tile has EMHH, Card's left border is visually aligned
    //    with List left content edge.
    //    When we're outside of controller, the left edge alignment is still against
    //    virtualized list (which has no longer negative margins) and therefore Card's left
    //    border is now shifted against List left content edge.
    // 3. Card (inside Tile) border-box height should be (row height - row spacing).


    var tileWidth;

    if (tileMinWidth) {
      tileWidth = columnCount === 1 ? this._getWidthWithoutElevation() : Math.floor((this._getWidthWithoutElevation() - (columnCount - 1) * tileSpacing) / columnCount);
      tileMaxWidth && (tileWidth = Math.min(tileWidth, tileMaxWidth));
    }

    var rowClassName = this.getClassName("row");

    if (tileMinWidth) {
      var justify = columnCount === 1 ? "center" : this.props.tileJustify;
      rowClassName += " ".concat(this.getClassName("justify")).concat(justify);
    }

    var result;

    var doRender = function doRender(handleMeasure) {
      return (// NOTE <Row> is pure, i.e. it'll be re-rendered only if props change (shallowly).
        // It must also pass all necessary rendering props for row & items. TODO maybe change
        // to using Context instead?
        _uu5g.default.Common.Element.create(Row, _extends({}, _this7._getSimplifiedRow(row), {
          columnCount: columnCount,
          elevationMargins: elevationMargins,
          rowClassName: rowClassName,
          rowSpacing: rowSpacing,
          tileMinWidth: tileMinWidth,
          tileSpacing: tileSpacing,
          tileWidth: tileWidth,
          itemRendererProps: _this7._computeItemRendererProps(row.index, {
            controller: _this7.props.controller,
            data: _this7.props.onLoad && !_this7.props.controller ? _this7._cachedData : _this7.props.data,
            draggable: _this7.props.draggable,
            estimatedTileHeight: _this7._getEstimatedTileHeight(),
            handleMeasure: handleMeasure,
            onDrop: _this7.props.draggable ? _this7._onTileDrop : undefined,
            onLoad: _this7.props.onLoad,
            skipInnerTile: _this7.props.skipInnerTile,
            tile: _this7.props.tile,
            tileBorder: _this7.props.tileBorder,
            tileCount: _this7._getTileCount(),
            tileElevation: _this7.props.tileElevation,
            tileElevationHover: _this7.props.tileElevationHover,
            tileStyle: _this7.props.tileStyle
          })
        }))
      );
    };

    if (this.props.tileHeight === "auto") {
      result = _uu5g.default.Common.Element.create(_reactVirtualized.CellMeasurer, {
        cache: this._cellMeasurerCache,
        columnIndex: 0,
        key: row.key,
        parent: row.parent,
        rowIndex: row.index
      }, function (_ref9) {
        var measure = _ref9.measure;
        return doRender(measure);
      });
    } else {
      result = doRender();
    }

    return result;
  },
  _getLoadRowThreshold: function _getLoadRowThreshold() {
    // how many rows to load ahead of time
    return this.props.overscanRowCount + this._estimateVisibleRowCount();
  },
  _estimateVisibleRowCount: function _estimateVisibleRowCount() {
    var height = window.innerHeight;
    if (this._listNode) height = Math.min(height, this._listNode.getBoundingClientRect().height);
    return Math.ceil(height / (this._getEstimatedTileHeight() + this._getRowSpacing()));
  },
  _isRowLoaded: function _isRowLoaded(_ref10) {
    var index = _ref10.index;
    var result = false;

    if (!this.state.isReloading) {
      // check load status of all tiles in the row
      var _this$props3 = this.props,
          controller = _this$props3.controller,
          onLoad = _this$props3.onLoad;
      var data = onLoad && !controller ? this._cachedData : this.props.data;

      var colCount = this._countColumns();

      var tileIndex = index * colCount;
      colCount = Math.min(colCount, this._getTileCount() - tileIndex);
      result = true;

      for (var i = 0; i < colCount && result; ++i) {
        result = controller ? controller.isTileLoaded(tileIndex + i) : data[tileIndex + i] !== undefined;
      }
    }

    return result;
  },
  _loadMoreRows: function _loadMoreRows(_ref11) {
    var _this8 = this;

    var startIndex = _ref11.startIndex,
        stopIndex = _ref11.stopIndex;
    // console.log("_loadMoreRows", { startIndex, stopIndex });
    // trigger load immediately if it's initial/reloading load
    var result;
    if (this.state.isReloading || this._skipDebounce) result = this._executeLoadCall({
      startIndex: startIndex,
      stopIndex: stopIndex,
      skipIfAlreadyLoadingSame: this.state.pendingInitialLoad
    });else result = this._debouncedExecuteLoadCall({
      startIndex: startIndex,
      stopIndex: stopIndex,
      skipIfAlreadyLoadingSame: true
    });
    if (this._skipDebounce) Promise.resolve().then(function () {
      return _this8._skipDebounce = false;
    });
    return result;
  },
  _executeLoadCall: function _executeLoadCall(_ref12) {
    var _this9 = this;

    var startIndex = _ref12.startIndex,
        stopIndex = _ref12.stopIndex,
        skipIfAlreadyLoadingSame = _ref12.skipIfAlreadyLoadingSame;
    var _this$props4 = this.props,
        pageSize = _this$props4.onLoadPageSize,
        controller = _this$props4.controller,
        onLoad = _this$props4.onLoad; // compute tile-based indices for the call (because startIndex & stopIndex are row-based)
    // and then convert them to page-based

    var colCount = this._countColumns();

    var tileStartIndex = startIndex * colCount;
    var tileEndIndex = (stopIndex + 1) * colCount; // stopIndex is inclusive, we want exclusive => +1
    // commands use pageIndex + pageSize so if we need tiles 30..49 with pageSize=20 then
    // we have to perform 2 calls (pageIndex=1 loads 20..39, pageIndex=2 loads 40..59)

    var pageInfos;

    if (typeof pageSize === "number" && pageSize > 0) {
      var pageStartIndex = Math.floor(tileStartIndex / pageSize);
      var pageEndIndexInclusive = Math.floor((tileEndIndex - 1) / pageSize);
      pageInfos = [];

      for (var pageIndex = pageStartIndex; pageIndex <= pageEndIndexInclusive; ++pageIndex) {
        pageInfos.push({
          pageIndex: pageIndex,
          pageSize: pageSize
        });
      }
    } else {
      pageInfos = [this._computePageInfo(tileStartIndex, tileEndIndex)];
    } // skip call if already laoding same set / superset


    var skip = false;

    if (skipIfAlreadyLoadingSame && this._lastLoadInfo) {
      var loadTileStartIndex = this._lastLoadInfo.tileStartIndex;
      var loadTileEndIndex = this._lastLoadInfo.tileEndIndex;

      if (loadTileStartIndex <= pageInfos[0].pageIndex * pageInfos[0].pageSize && loadTileEndIndex >= (pageInfos[pageInfos.length - 1].pageIndex + 1) * pageInfos[pageInfos.length - 1].pageSize) {
        skip = true;
      }
    }

    var result;

    if (!skip) {
      var loads = pageInfos.map(function (pageInfo) {
        return new Promise(function (resolve, reject) {
          var dtoIn = {
            data: _objectSpread({
              pageInfo: pageInfo
            }, controller ? controller.getLoadParams() : undefined),
            done: function done(data) {
              return resolve({
                dtoIn: dtoIn,
                data: data
              });
            },
            fail: reject
          };
          onLoad(dtoIn);
        });
      });
      result = Promise.all(loads).then(function (results) {
        if (!_this9._unmounted) {
          if (_this9._cellMeasurerCache) _this9._cellMeasurerCache.clearAll();
          if (_this9._lastLoadInfo === lastLoadInfo) _this9._lastLoadInfo = null;
          var newState = {
            isReloading: false,
            pendingInitialLoad: false
          };

          for (var i = 0; i < results.length; ++i) {
            var _results$i = results[i],
                dtoIn = _results$i.dtoIn,
                data = _results$i.data;

            if (data) {
              var pageInfoOut = data.pageInfo,
                  itemList = data.itemList;

              if (controller) {
                controller.setData(itemList, pageInfoOut, dtoIn.data);
              } else {
                _this9._markAsLoaded(itemList, pageInfoOut);

                if (pageInfoOut && pageInfoOut.total != null) newState.loadTotalTileCount = pageInfoOut.total;
              }
            }
          }

          _this9.setState(function (state) {
            var resultState;

            for (var k in newState) {
              if (newState[k] !== state[k]) {
                resultState = newState;
                break;
              }
            }

            return resultState;
          });
        }
      }, function (error) {
        if (_this9._lastLoadInfo === lastLoadInfo) _this9._lastLoadInfo = null;

        _this9.setState(function (state) {
          return state.isReloading || state.pendingInitialLoad ? {
            isReloading: false,
            pendingInitialLoad: false
          } : undefined;
        });

        return Promise.reject(error);
      });
      var lastLoadInfo = this._lastLoadInfo = {
        tileStartIndex: pageInfos[0].pageIndex * pageInfos[0].pageSize,
        tileEndIndex: (pageInfos[pageInfos.length - 1].pageIndex + 1) * pageInfos[pageInfos.length - 1].pageSize,
        // exclusive
        promise: result
      };
    } else {
      result = this._lastLoadInfo.promise;
    }

    return result;
  },
  _markAsLoaded: function _markAsLoaded(data) {
    var pageInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (Array.isArray(data)) {
      var oldData = this._cachedData;
      var from = pageInfo ? pageInfo.pageIndex * pageInfo.pageSize : 0;
      var to = from + data.length;
      var newData = new Array(pageInfo && typeof pageInfo.total === "number" ? pageInfo.total : Math.max(to, oldData.length));

      for (var i = 0, len = newData.length; i < len; ++i) {
        newData[i] = from <= i && i < to ? data[i - from] : oldData[i];
      }

      _listCache.default.evictItems(newData, from, to);

      this._cachedData = newData;
    }
  },
  _computePageInfo: function _computePageInfo(tileStartIndex, tileEndIndex) {
    // compute page info with minimal pageSize to load tiles in range <tileStartIndex, tileEndIndex-1>
    var pageSize = 1;

    if (tileStartIndex < tileEndIndex) {
      var from = tileEndIndex - tileStartIndex;
      var to = tileEndIndex - tileStartIndex > tileStartIndex ? tileEndIndex : tileStartIndex;

      for (var i = from; i <= to; ++i) {
        if (Math.floor(tileStartIndex / i) === Math.floor((tileEndIndex - 1) / i)) {
          pageSize = i;
          break;
        }
      }
    }

    return {
      pageSize: pageSize,
      pageIndex: Math.floor(tileStartIndex / pageSize)
    };
  },
  _computeOverscanIndicesGetter: function _computeOverscanIndicesGetter(rowCountAhead, rowCountBehind) {
    // NOTE This method is memoized. Use only parameters, no props/state.
    // https://github.com/bvaughn/react-virtualized/blob/master/docs/Grid.md#overscanindicesgetter
    return function (_ref13) {
      var direction = _ref13.direction,
          cellCount = _ref13.cellCount,
          scrollDirection = _ref13.scrollDirection,
          overscanCellsCount = _ref13.overscanCellsCount,
          startIndex = _ref13.startIndex,
          stopIndex = _ref13.stopIndex;
      return {
        overscanStartIndex: Math.max(0, startIndex - (scrollDirection === 1 ? rowCountBehind : rowCountAhead)),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + (scrollDirection === 1 ? rowCountAhead : rowCountBehind))
      };
    };
  },
  _computeWindowScrollerChildDivRef: function _computeWindowScrollerChildDivRef(anotherRef) {
    var _this10 = this;

    return function (refValue) {
      if (typeof anotherRef === "function") anotherRef(refValue);else if (anotherRef) anotherRef.current = refValue;
      _this10._windowScrollerChildDiv = refValue;
    };
  },
  _cellRangeRenderer: function _cellRangeRenderer(props) {
    var children = (0, _reactVirtualized.defaultCellRangeRenderer)(props);
    if (!this._usedScrollElement && this.props.draggable) children.push(_uu5g.default.Common.Element.create(_dndScrollEnhancer.default, {
      key: "dse"
    }));
    return children;
  },
  _renderEmptyDropZone: function _renderEmptyDropZone() {
    // render zone for dropping tiles from other lists (when this list is empty)
    return _uu5g.default.Common.Element.create(ListDropZone, {
      key: "dropZone",
      onDrop: this._onTileDrop,
      style: {
        height: this._getEstimatedTileHeight() + this._getRowSpacing() || undefined
      }
    });
  },
  _renderWithScrollElement: function _renderWithScrollElement(_ref14) {
    var _this11 = this;

    var scrollElement = _ref14.scrollElement;
    this._usedScrollElement = scrollElement;
    var result;

    if (!scrollElement) {
      result = [this._getList(), this.props.draggable && this._getTileCount() === 0 ? this._renderEmptyDropZone() : null];
    } else {
      result = _uu5g.default.Common.Element.create(_windowScroller.default, {
        scrollElement: scrollElement,
        ref: this._setWindowScrollerRef
      }, function (_ref15) {
        var height = _ref15.height,
            isScrolling = _ref15.isScrolling,
            registerChild = _ref15.registerChild,
            onChildScroll = _ref15.onChildScroll,
            scrollTop = _ref15.scrollTop;

        var childRef = _this11._computeWindowScrollerChildDivRef(registerChild);

        return _uu5g.default.Common.Element.create("div", {
          ref: childRef
        }, _this11._getList({
          autoHeight: true,
          height: height,
          isScrolling: isScrolling,
          scrollTop: _this11._getTileCount() > 0 ? scrollTop : 0,
          // condition prevents weird scroll resetting when tiles are filtered to 0 items and user tries to scroll below the tile container
          onScroll: onChildScroll
        }), _this11.props.draggable && _this11._getTileCount() === 0 ? _this11._renderEmptyDropZone() : null, _this11.props.draggable ? _uu5g.default.Common.Element.create(_dndScrollEnhancer.default, {
          scrollElement: scrollElement
        }) : null);
      });
    }

    return result;
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    var result;

    if (this.props.scrollElement) {
      result = this._renderWithScrollElement({
        scrollElement: this.props.scrollElement
      });
    } else if (!this.props.height) {
      result = _uu5g.default.Common.Element.create(_passNearestScrollElement.default, {
        defaultValue: window
      }, this._renderWithScrollElement);
    } else {
      result = this._renderWithScrollElement({
        scrollElement: null
      });
    }

    var mainProps = this.getMainPropsToPass();
    delete mainProps.nestingLevel;
    return _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Div, mainProps, result);
  } //@@viewOff:render

});

var ListWithDnD;

var LazyListWithDnD = _uu5g.default.Common.Component.lazy(
/*#__PURE__*/
_asyncToGenerator(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee2() {
  return regeneratorRuntime.wrap(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof SystemJS !== "undefined")) {
            _context2.next = 8;
            break;
          }

          _context2.next = 3;
          return SystemJS.import("react-dnd");

        case 3:
          _tile.default._reactDnD = _context2.sent;
          _context2.next = 6;
          return SystemJS.import("react-dnd-html5-backend");

        case 6:
          _context2.next = 8;
          return SystemJS.import("react-dnd-touch-backend");

        case 8:
          if (!ListWithDnD) ListWithDnD = _uu5g.default.Common.DnD.withContext(ListBase);
          return _context2.abrupt("return", {
            default: ListWithDnD
          });

        case 10:
        case "end":
          return _context2.stop();
      }
    }
  }, _callee2);
})));

var List = _uu5g.default.Common.VisualComponent.create({
  statics: {
    getDerivedStateFromError: function getDerivedStateFromError(error) {
      return {
        error: error
      };
    }
  },
  getInitialState: function getInitialState() {
    return {};
  },
  render: function render() {
    var error = this.state.error;

    if (error) {
      return _uu5g.default.Common.Element.create(_uu5g.default.Common.Error, {
        error: error,
        moreInfo: true
      });
    } else if (this.props.draggable) {
      return _uu5g.default.Common.Element.create(_uu5g.default.Common.Suspense, {
        fallback: ""
      }, _uu5g.default.Common.Element.create(LazyListWithDnD, this.props));
    } else {
      return _uu5g.default.Common.Element.create(ListBase, this.props);
    }
  }
});

exports.List = List;
List.isUu5PureComponent = true;
List.displayName = "withLazyDnD(".concat(ListBase.displayName || ListBase.name || "Component", ")");
List.hocFor = ListBase;
var _default = List;
exports.default = _default;