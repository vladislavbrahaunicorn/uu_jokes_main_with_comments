"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Tile = void 0;

var _uu5g = _interopRequireDefault(require("uu5g04"));

require("uu5g04-bricks");

var _config = _interopRequireDefault(require("../config/config.js"));

require("./tile.less");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//@@viewOff:imports
var TileBase = _uu5g.default.Common.VisualComponent.create({
  displayName: "Tile",
  //@@viewOn:mixins
  mixins: [_uu5g.default.Common.BaseMixin, _uu5g.default.Common.ElementaryMixin, _uu5g.default.Common.PureRenderMixin, _uu5g.default.Common.SectionMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config.default.TAG + "Tile",
    classNames: {
      main: _config.default.CSS + "tile",
      wrapper: _config.default.CSS + "tile-wrapper",
      buttons: _config.default.CSS + "tile-buttons",
      buttonSelected: _config.default.CSS + "tile-button-selected",
      buttonSelectedIcon: _config.default.CSS + "tile-button-selected-icon",
      buttonDrag: _config.default.CSS + "tile-button-drag",
      buttonDragIcon: _config.default.CSS + "tile-button-drag-icon",
      buttonDragWrapper: _config.default.CSS + "tile-button-drag-wrapper",
      content: _config.default.CSS + "tile-content",
      border: _config.default.CSS + "tile-border",
      dragging: _config.default.CSS + "tile-dragging",
      dragOver: _config.default.CSS + "tile-drag-over",
      dropIndicator: _config.default.CSS + "tile-drop-indicator",
      dropBefore: _config.default.CSS + "tile-drop-before",
      dropAfter: _config.default.CSS + "tile-drop-after"
    },
    opt: {
      pureRender: true,
      dummyLevel: true
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    id: _uu5g.default.PropTypes.any,
    tile: _uu5g.default.PropTypes.object,
    data: _uu5g.default.PropTypes.object,
    onSelect: _uu5g.default.PropTypes.func,
    selectable: _uu5g.default.PropTypes.bool,
    elevation: _uu5g.default.PropTypes.number,
    elevationHover: _uu5g.default.PropTypes.number,
    border: _uu5g.default.PropTypes.bool,
    draggable: _uu5g.default.PropTypes.bool,
    onDrop: _uu5g.default.PropTypes.func,
    wrapperStyle: _uu5g.default.PropTypes.object,
    skipCloneChildren: _uu5g.default.PropTypes.bool,
    // internal props passed by/for react-dnd
    _connectDropTarget: _uu5g.default.PropTypes.func,
    _connectDragSource: _uu5g.default.PropTypes.func,
    _connectDragPreview: _uu5g.default.PropTypes.func,
    _isDragging: _uu5g.default.PropTypes.bool,
    _onDraggingChange: _uu5g.default.PropTypes.func,
    _isDragOver: _uu5g.default.PropTypes.bool,
    _onDragOverChange: _uu5g.default.PropTypes.func,
    _canDrop: _uu5g.default.PropTypes.bool
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      selectable: false,
      elevation: 0,
      elevationHover: null,
      border: false,
      draggable: false,
      skipCloneChildren: false
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    return {
      dropIndicatorBefore: null,
      dropIndicatorOffset: 0,
      isOverDroppable: false
    };
  },
  componentDidMount: function componentDidMount() {
    // we're firing drag*Change events even during mount because that seems to be the only way to get
    // reference to this component instance when using react-dnd and component gets re-mounted due to
    // scroll in react-virtualized list (during drag operation)
    this._fireDragOverChange();

    this._fireDraggingChange(); // we have to re-measure the tile row when using react-dnd because DropTarget/DragSource HOCs
    // render initially null (therefore VirtualizedList's CellMeasurer will initially think we have height 0
    // and we need to let it know that that's not the case)


    if (this.props.draggable && typeof this.props.handleMeasure === "function") {
      this.props.handleMeasure();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this.props._isDragOver) this._fireDragOverChange(_objectSpread({}, this.props, {
      _isDragOver: false,
      _canDrop: false
    }));
    if (this.props._isDragging) this._fireDraggingChange(_objectSpread({}, this.props, {
      _isDragging: false
    }));
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (prevProps._isDragOver !== this.props._isDragOver) this._fireDragOverChange();
    if (prevProps._isDragging !== this.props._isDragging) this._fireDraggingChange();

    if (this._dropIndicator && this._card) {
      var rootNode = _uu5g.default.Common.DOM.findNode(this._rootNode);

      var rootNodeRect = rootNode.getBoundingClientRect();

      var cardNode = _uu5g.default.Common.DOM.findNode(this._card);

      var cardNodeRect = cardNode.getBoundingClientRect();

      var dropIndicatorNode = _uu5g.default.Common.DOM.findNode(this._dropIndicator);

      dropIndicatorNode.style.top = rootNodeRect.top - cardNodeRect.top + "px";
      dropIndicatorNode.style.bottom = rootNodeRect.bottom - cardNodeRect.bottom + "px";
    }
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  setDropIndicator: function setDropIndicator(before, offset) {
    this.setState(function (state) {
      var result;

      if (state.dropIndicatorBefore !== before || Math.abs(offset - state.dropIndicatorOffset) > 0.5) {
        result = {
          dropIndicatorBefore: before,
          dropIndicatorOffset: offset
        };
      }

      return result;
    });
  },
  getDropIndicator: function getDropIndicator() {
    return {
      before: this.state.dropIndicatorBefore,
      offset: this.state.dropIndicatorOffset
    };
  },
  setDragIsOverDroppableTarget: function setDragIsOverDroppableTarget(isOverDroppable) {
    this.setState(function (state) {
      var result;
      if (state.isOverDroppable !== isOverDroppable) result = {
        isOverDroppable: isOverDroppable
      };
      return result;
    });
  },
  //@@viewOff:interface
  //@@viewOn:overriding
  toggleSelected_: function toggleSelected_() {
    var _this = this;

    this.toggleSelectedDefault(function () {
      var fn = undefined;
      var id = _this.props.id;

      if (typeof _this.props.onSelect === "function") {
        fn = _this.props.onSelect;
      } else if (_this.props.tile && typeof _this.props.tile.onSelect === "function") {
        fn = _this.props.tile.onSelect;
      }

      id && fn && fn(id, _this.isSelected());
    });
  },
  //@@viewOff:overriding
  //@@viewOn:private
  _fireDragOverChange: function _fireDragOverChange() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

    if (typeof props._onDragOverChange === "function") {
      var opt = {
        isDragOver: props._isDragOver,
        canDrop: props._canDrop,
        component: this
      };

      props._onDragOverChange(opt);
    }
  },
  _fireDraggingChange: function _fireDraggingChange() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

    if (typeof props._onDraggingChange === "function") {
      var opt = {
        isDragging: props._isDragging,
        component: this
      };

      props._onDraggingChange(opt);
    }
  },
  _buildChildren: function _buildChildren() {
    var r;
    var tileProps = {
      tileFrame: this,
      id: this.props.id
    };
    this.props.data && (tileProps.data = this.props.data);
    this.props.tile && (tileProps.tile = this.props.tile);

    if (typeof this.props.children === "function") {
      r = this.props.children(tileProps);
    } else if (!this.props.skipCloneChildren) {
      r = _uu5g.default.Common.Children.map(this.props.children, function (element) {
        var el;

        if (_uu5g.default.Common.Element.isValid(element)) {
          el = _uu5g.default.Common.Element.clone(element, tileProps);
        } else {
          el = element;
        }

        return el;
      });
    } else r = this.props.children;

    return r;
  },
  _getMainProps: function _getMainProps() {
    var mainProps = this.getMainPropsToPass();
    var border = this.props.border;

    if (border) {
      mainProps.className = mainProps.className + " " + this.getClassName("border");
    }

    return mainProps;
  },
  _renderButtons: function _renderButtons() {
    var _connectDragSource = this.props._connectDragSource;
    return _uu5g.default.Common.Element.create(_uu5g.default.Common.Fragment, null, _connectDragSource( // NOTE <span> is required by react-dnd.
    _uu5g.default.Common.Element.create("span", {
      className: this.getClassName().buttonDragWrapper,
      key: "btn-drag"
    }, this.props.draggable && _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Button, {
      bgStyle: "transparent",
      className: this.getClassName().buttonDrag
    }, _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Icon, {
      icon: "mdi-cursor-move",
      className: this.getClassName().buttonDragIcon
    })))), this.props.selectable && !this.isDisabled() && _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Button, {
      bgStyle: "transparent",
      className: this.getClassName().buttonSelected,
      onClick: this.toggleSelected,
      key: "btn-selected"
    }, _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Icon, {
      icon: "mdi-check-circle",
      className: this.getClassName().buttonSelectedIcon
    })));
  },
  _setCardRef: function _setCardRef(comp) {
    this._card = comp;
  },
  _setDropIndicatorRef: function _setDropIndicatorRef(comp) {
    this._dropIndicator = comp;
  },
  _setRootNodeRef: function _setRootNodeRef(comp) {
    this._rootNode = comp;
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    var elevationHover = this.props.elevationHover === null ? this.props.elevation : this.props.elevationHover;
    var _this$props = this.props,
        _connectDragPreview = _this$props._connectDragPreview,
        _connectDropTarget = _this$props._connectDropTarget,
        _isDragging = _this$props._isDragging,
        _isDragOver = _this$props._isDragOver,
        draggable = _this$props.draggable;
    var _this$state = this.state,
        dropIndicatorBefore = _this$state.dropIndicatorBefore,
        dropIndicatorOffset = _this$state.dropIndicatorOffset,
        isOverDroppable = _this$state.isOverDroppable;
    var rootClassNames = [this.getClassName().wrapper];
    var dropIndicator;

    if (draggable) {
      if (_isDragging) {
        rootClassNames.push(this.getClassName().dragging);
      }

      if (_isDragOver || _isDragging && !isOverDroppable) {
        // show drag-over indicator on dragSource instance also in case that we're not over a component that we can drop the item to
        if (!_isDragOver) dropIndicatorBefore = true;
        rootClassNames.push(this.getClassName().dragOver);
        rootClassNames.push(dropIndicatorBefore ? this.getClassName().dropBefore : this.getClassName().dropAfter);
      }

      dropIndicator = _uu5g.default.Common.Element.create("div", {
        ref: this._setDropIndicatorRef,
        className: this.getClassName().dropIndicator,
        style: _defineProperty({}, dropIndicatorBefore ? "marginLeft" : "marginRight", dropIndicatorOffset)
      });
    }

    return _connectDropTarget(_connectDragPreview( // NOTE Native <div> is required by react-dnd.
    _uu5g.default.Common.Element.create("div", {
      className: rootClassNames.join(" "),
      style: this.props.wrapperStyle,
      ref: this._setRootNodeRef
    }, dropIndicator, _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Card, _extends({}, this._getMainProps(), {
      elevation: this.props.elevation,
      elevationHover: elevationHover,
      ref_: this._setCardRef
    }), !_isDragging ? this._renderButtons() : null, !_isDragging ? this._buildChildren() : null))));
  }
});

var DRAG_ITEM_TYPE = "UU5.Tiles.Tile"; // handling of drop indicator (for dragSource component instance) for case that we're NOT over droppable
// target - react-dnd don't notify us about that on dragSource so we have to handle state transitions
// on dropTarget instances and notify dragSource instance on our own

var dragOpExtraState = {
  dropAllowedOn: {},
  dragSourceComponent: null
};

var handleDragOverChange = function handleDragOverChange(_ref2) {
  var isDragOver = _ref2.isDragOver,
      canDrop = _ref2.canDrop,
      component = _ref2.component;
  var _dragOpExtraState = dragOpExtraState,
      dropAllowedOn = _dragOpExtraState.dropAllowedOn,
      dragSourceComponent = _dragOpExtraState.dragSourceComponent;
  if (!isDragOver || !canDrop) delete dropAllowedOn[component.props.id];else dropAllowedOn[component.props.id] = true;
  if (dragSourceComponent) dragSourceComponent.setDragIsOverDroppableTarget(Object.keys(dropAllowedOn).length > 0);
};

var handleDraggingChange = function handleDraggingChange(_ref3) {
  var isDragging = _ref3.isDragging,
      component = _ref3.component;

  // NOTE "isDragging" can change due to unmount and re-mount (we're in virtualized-list so if we scroll down
  // while drag operation is being done then the source component might be unmounted and if we scroll back up
  // a new component should become the drag source).
  if (isDragging) {
    dragOpExtraState.dragSourceComponent = component;
    dragOpExtraState.dragSourceComponent.setDragIsOverDroppableTarget(Object.keys(dragOpExtraState.dropAllowedOn).length > 0);
  } else if (component === dragOpExtraState.dragSourceComponent) {
    dragOpExtraState.dragSourceComponent = null;
  }
};

var tileDragSource = {
  canDrag: function canDrag(props) {
    return props.draggable;
  },
  beginDrag: function beginDrag(props, monitor, component) {
    dragOpExtraState.dragSourceComponent = component.getDecoratedComponentInstance(); // return the data describing the dragged item

    return _objectSpread({
      id: props.id
    }, props.data);
  },
  endDrag: function endDrag() {
    dragOpExtraState = {
      dropAllowedOn: {},
      dragSourceComponent: null
    };
  },
  isDragging: function isDragging(props, monitor) {
    // our Tile-s are in react-virtualized, i.e. they might be unmounted during drag & sufficient scroll
    // => if user scrolls back (during drag operation) match the newly mounted component by ID
    return props.id === monitor.getItem().id;
  }
};

var dragPropsExpander = function dragPropsExpander(connect, monitor) {
  // which extra props to inject into component which can be dragged (Tile)
  return {
    _connectDragSource: connect.dragSource(),
    _connectDragPreview: connect.dragPreview(),
    _isDragging: monitor.isDragging(),
    _onDraggingChange: handleDraggingChange
  };
};

var tileDropTarget = {
  canDrop: function canDrop(props, monitor) {
    var item = monitor.getItem();
    return item.id !== props.id; // don't allow dropping onto the same component which is being dragged
  },
  hover: function hover(props, monitor, component) {
    if (!component) return;

    var domNode = _uu5g.default.Common.DOM.findNode(component);

    var cardNode = domNode ? domNode.lastChild : null;

    if (cardNode) {
      var cardNodeRect = cardNode.getBoundingClientRect();
      var hoverMiddleX = (cardNodeRect.right + cardNodeRect.left) / 2;
      var mouseXY = monitor.getClientOffset();
      var indicateBefore = mouseXY.x < hoverMiddleX;
      var indicatorOffset = 0;

      if (indicateBefore) {
        var prevCardNode = (domNode.previousSibling || {}).lastChild;
        if (prevCardNode) indicatorOffset = (prevCardNode.getBoundingClientRect().right - cardNodeRect.left) / 2;else indicatorOffset = (domNode.parentNode.getBoundingClientRect().left - cardNodeRect.left) / 2;
        indicatorOffset += cardNodeRect.left - domNode.getBoundingClientRect().left;
      } else {
        var nextCardNode = (domNode.nextSibling || {}).lastChild;

        if (nextCardNode) {
          indicatorOffset = (cardNodeRect.right - nextCardNode.getBoundingClientRect().left) / 2;
          indicatorOffset += domNode.getBoundingClientRect().right - cardNodeRect.right;
        }
      }

      component.setDropIndicator(indicateBefore, indicatorOffset);
    }
  },
  drop: function drop(props, monitor, component) {
    if (!monitor.didDrop()) {
      var item = monitor.getItem();
      if (typeof props.onDrop === "function") props.onDrop({
        item: item,
        component: component,
        before: component.getDropIndicator().before
      });
    }
  }
};

var dropPropsExpander = function dropPropsExpander(connect, monitor) {
  // which extra props to inject into component which can be dropped to (Tile)
  return {
    _connectDropTarget: connect.dropTarget(),
    _isDragOver: monitor.isOver(),
    _onDragOverChange: handleDragOverChange,
    _canDrop: monitor.isOver() && monitor.canDrop() // using "monitor.isOver() && ..." because it has much better performance this way

  };
}; // TODO The whole draggable/non-draggable (DragDropContext) should be handled differently, e.g. by having
// DraggableContext in UU5.Common and using that one (instead of prop "draggable"
// because the change in the prop causes unmount & mount due to using wrapped/unwrapped component).


var nonDraggable = function nonDraggable(Component) {
  var identityFn = function identityFn(value) {
    return value;
  };

  var result = function result(props) {
    return _uu5g.default.Common.Element.create(Component, _extends({}, props, {
      _connectDragSource: identityFn,
      _connectDragPreview: identityFn,
      _isDragging: false,
      _onDraggingChange: null,
      _connectDropTarget: identityFn,
      _isDragOver: false,
      _onDragOverChange: null,
      _canDrop: false
    }));
  };

  result.displayName = "nonDraggable(" + Component.displayName + ")";
  return result;
};

var NonDraggableTile = nonDraggable(TileBase);
var DraggableTile;

var Tile = function Tile(props) {
  if (props.draggable && Tile._reactDnD) {
    if (!DraggableTile) DraggableTile = Tile._reactDnD.DragSource(DRAG_ITEM_TYPE, tileDragSource, dragPropsExpander)(Tile._reactDnD.DropTarget([DRAG_ITEM_TYPE], tileDropTarget, dropPropsExpander)(TileBase));
    return _uu5g.default.Common.Element.create(DraggableTile, props);
  } else {
    return _uu5g.default.Common.Element.create(NonDraggableTile, props);
  }
};

exports.Tile = Tile;
Tile.dragSource = tileDragSource;
Tile.dragPropsExpander = dragPropsExpander;
Tile.dropTarget = tileDropTarget;
Tile.dropPropsExpander = dropPropsExpander;
Tile.DRAG_ITEM_TYPE = DRAG_ITEM_TYPE;
var _default = Tile;
exports.default = _default;