"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SortableTree = exports.SortableTreeBase = void 0;

var _react = _interopRequireDefault(require("react"));

var _createReactClass = _interopRequireDefault(require("create-react-class"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _uu5g = _interopRequireDefault(require("uu5g04"));

require("uu5g04-bricks");

require("uu5g04-forms");

var _reactSortableTree = require("react-sortable-tree");

require("react-sortable-tree/style.css");

var _config = _interopRequireDefault(require("../config/config.js"));

require("./sortable-tree.less");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var inspect = function inspect(object) {
  if (object && _typeof(object) === "object") {
    if (Array.isArray(object)) return object.map(inspect);

    if (object["$$typeof"]) {
      return {
        tagName: typeof object.type === "function" ? object.type.tagName : object.type,
        props: inspect(object.props)
      };
    } else {
      var newObject = {};

      for (var k in object) {
        newObject[k] = inspect(object[k]);
      }

      return newObject;
    }
  }

  return object;
};

var buildData = function buildData(data) {
  var expandAllNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var collapseAllNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return data.map(function (item) {
    item = _objectSpread({}, item);
    if (expandAllNodes) item.expanded = true;
    if (collapseAllNodes) item.expanded = false;
    item.id = item.id || _uu5g.default.Common.Tools.generateUUID();
    if (item.children) item.children = buildData(item.children, expandAllNodes, collapseAllNodes);
    return item;
  });
};

var getNodeKey = function getNodeKey(_ref) {
  var node = _ref.node,
      treeIndex = _ref.treeIndex;
  return node.id === undefined ? treeIndex : node.id;
};

function defaultSearch(opt) {
  if (!opt.searchQuery) return false;
  var searchList = opt.searchQuery.toLowerCase().split(/[.,;:!?\s]/g).filter(Boolean).map(function (it) {
    return it.toLowerCase();
  });
  var fields = opt.node ? [opt.node.title, opt.node.subtitle].filter(function (it) {
    return it != null;
  }) : [];
  return fields.some(function (value) {
    var r;
    var v = _typeof(value) === "object" ? _uu5g.default.Common.Tools.getLsiItemByLanguage(value) : value;
    if (typeof v === "string" && v.match(/^<uu5string\s*\/>/)) v = _uu5g.default.Common.UU5String.toPlainText(v);

    if (typeof v === "string" || typeof v === "number") {
      r = searchList.every(function (searchWord) {
        return v.toString().toLowerCase().indexOf(searchWord) !== -1;
      });
    }

    return r;
  });
}

var dataPropType = _propTypes.default.arrayOf(_propTypes.default.shape({
  id: _propTypes.default.string,
  title: _propTypes.default.any.isRequired,
  subtitle: _propTypes.default.any,
  expanded: _propTypes.default.bool,
  children: dataPropType,
  subItemsLoadable: _propTypes.default.bool
}));

var SortableTreeItem = (0, _createReactClass.default)({
  displayName: "SortableTreeItem",
  //@@viewOn:mixins
  mixins: [_uu5g.default.Common.BaseMixin, _uu5g.default.Common.ElementaryMixin, _uu5g.default.Common.NestingLevelMixin, _uu5g.default.Common.ColorSchemaMixin, _uu5g.default.Common.LsiMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config.default.TAG + "SortableTree",
    nestingLevel: "box",
    classNames: {
      main: _config.default.CSS + "sortabletree",
      noScroll: _config.default.CSS + "sortabletree-noscroll",
      treeStretch: _config.default.CSS + "sortabletree-stretch",
      input: _config.default.CSS + "sortabletree-input-",
      searchInput: _config.default.CSS + "sortabletree-search-input"
    },
    errors: {
      onLoadSubItemsError: "An error occured while loading data.",
      dataError: "Data are not valid"
    },
    lsi: {
      errorMessage: {
        cs: "Při načitaní dat došlo k chybě.",
        en: "An error occured while loading data."
      },
      searchInputPlaceholder: {
        cs: "Hledat ...",
        en: "Search ..."
      }
    },
    defaults: {
      loadingComponent: "<uu5string/><UU5.Bricks.Loading/>",
      expandedButtonClass: "rst__expandButton"
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    data: dataPropType.isRequired,
    height: _propTypes.default.number,
    onChange: _propTypes.default.func,
    nodeHeight: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.func]),
    generateNodeProps: _propTypes.default.func,
    stretchNodeWidth: _propTypes.default.bool,
    nodeElevation: _propTypes.default.number,
    bgStyle: _propTypes.default.string,
    editable: _propTypes.default.bool,
    editColorSchema: _propTypes.default.string,
    draggable: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
    dragColorSchema: _propTypes.default.string,
    searchable: _propTypes.default.bool,
    searchColorSchema: _propTypes.default.string,
    treeProps: _propTypes.default.object,
    controlled: _propTypes.default.bool,
    onLoadSubItems: _propTypes.default.func,
    expanded: _propTypes.default.oneOf(["default", "all", "none"])
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      data: [],
      height: null,
      onChange: null,
      nodeHeight: 62,
      generateNodeProps: null,
      stretchNodeWidth: false,
      nodeElevation: 1,
      bgStyle: "filled",
      editable: false,
      editColorSchema: null,
      draggable: false,
      dragColorSchema: null,
      searchable: false,
      searchColorSchema: "primary",
      treeProps: {},
      onLoadSubItems: null,
      expanded: "default"
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    var data;

    if (this.props.data && this.props.data.length !== 0) {
      data = this.props.data;
    } else if (this.props.children) {
      data = this._getDataAsChildren(this.props.children);
    }

    var expandAllNodes = this.props.expanded === "all";
    var collapseAllNodes = this.props.expanded === "none";
    return {
      data: buildData(data, expandAllNodes, collapseAllNodes),
      searchQuery: null,
      searchFocusIndex: 0,
      searchResultCount: 0
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      var stateObj = null;

      if (JSON.stringify(inspect(nextProps.data)) !== JSON.stringify(inspect(this.props.data))) {
        stateObj = nextProps.data;
      } else if ((!nextProps.data || nextProps.data.length === 0) && nextProps.children) {
        var nextChildren = this._getDataAsChildren(nextProps.children);

        var currentChildren = this._getDataAsChildren(this.props.children);

        if (JSON.stringify(currentChildren) !== JSON.stringify(nextChildren)) {
          stateObj = nextChildren;
        }
      }

      stateObj ? this.setState({
        data: buildData(stateObj)
      }) : null;
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (this.state.lastSearchStartId !== prevState.lastSearchStartId) this._setPendingScroll(null); // we have to scroll to the found node manually if the tree doesn't have explicit height
    // (because react-sortable-tree scrolls there only with explicit height)

    if (!this.props.height && this._searchFocusNode && this.state.searchQuery && this.state.lastSearchStartId === this.state.lastSearchEndId && ( // search is not in progress
    prevState.searchFocusIndex !== this.state.searchFocusIndex || // found index changed or a new search ended
    prevState.lastSearchEndId !== this.state.lastSearchEndId)) {
      var nodeId = this._searchFocusNode.id;

      var scrolled = this._scrollTo(nodeId);

      this._setPendingScroll(scrolled ? null : nodeId);
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this._setPendingScroll(null);
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  getVisibleNodeCount: function getVisibleNodeCount() {
    return (0, _reactSortableTree.getVisibleNodeCount)({
      treeData: this.state.data
    });
  },
  forEach: function forEach(callback) {
    var ignoreCollapsed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    (0, _reactSortableTree.walk)({
      treeData: this.state.data,
      getNodeKey: getNodeKey,
      callback: callback,
      ignoreCollapsed: ignoreCollapsed
    });
    return this;
  },
  map: function map(callback) {
    var ignoreCollapsed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var setStateCallback = arguments.length > 2 ? arguments[2] : undefined;

    if (typeof ignoreCollapsed === "function") {
      setStateCallback = ignoreCollapsed;
      ignoreCollapsed = false;
    }

    this.setState(function (state) {
      return {
        data: (0, _reactSortableTree.map)({
          treeData: state.data,
          getNodeKey: getNodeKey,
          callback: callback,
          ignoreCollapsed: ignoreCollapsed
        })
      };
    }, setStateCallback);
    return this;
  },
  insertNode: function insertNode(newNode) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var setStateCallback = arguments.length > 2 ? arguments[2] : undefined;

    if (typeof opt === "function") {
      setStateCallback = opt;
      opt = {};
    }

    this.setState(function (state) {
      var params = {
        treeData: state.data,
        newNode: newNode,
        getNodeKey: getNodeKey,
        ignoreCollapsed: opt.ignoreCollapsed === undefined ? true : opt.ignoreCollapsed,
        expandParent: opt.expandParent === undefined ? true : opt.expandParent
      };
      var changedDataObject;

      if (opt.parentKey === undefined) {
        params.depth = opt.depth || null;
        params.minimumTreeIndex = opt.minimumTreeIndex || null;
        changedDataObject = (0, _reactSortableTree.insertNode)(params);
      } else {
        params.parentKey = opt.parentKey;
        changedDataObject = (0, _reactSortableTree.addNodeUnderParent)(params);
      }

      return {
        data: changedDataObject.treeData
      };
    }, setStateCallback);
    return this;
  },
  getNode: function getNode(path) {
    return (0, _reactSortableTree.getNodeAtPath)({
      treeData: this.state.data,
      path: path,
      getNodeKey: getNodeKey
    });
  },
  changeNode: function changeNode(path, newNode, setStateCallback) {
    this.setState(function (state) {
      return {
        data: (0, _reactSortableTree.changeNodeAtPath)({
          treeData: state.data,
          newNode: newNode,
          path: path,
          getNodeKey: getNodeKey
        })
      };
    }, setStateCallback);
    return this;
  },
  removeNode: function removeNode(path, setStateCallback) {
    this.setState(function (state) {
      return {
        data: (0, _reactSortableTree.removeNodeAtPath)({
          treeData: state.data,
          path: path,
          getNodeKey: getNodeKey
        })
      };
    }, setStateCallback);
    return this;
  },
  find: function find(searchMethod) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (0, _reactSortableTree.find)({
      treeData: this.state.data,
      searchMethod: searchMethod,
      getNodeKey: getNodeKey,
      searchFocusOffset: opt.searchFocusOffset,
      searchQuery: opt.searchQuery,
      expandAllMatchPaths: opt.expandAllMatchPaths === undefined ? true : opt.expandAllMatchPaths,
      expandFocusMatchPaths: opt.expandFocusMatchPaths === undefined ? true : opt.expandFocusMatchPaths
    });
  },
  expandAll: function expandAll(setStateCallback) {
    this._toggleExpandedAll(true, setStateCallback);

    return this;
  },
  collapseAll: function collapseAll(setStateCallback) {
    this._toggleExpandedAll(false, setStateCallback);

    return this;
  },
  getFlatData: function getFlatData() {
    var ignoreCollapsed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return SortableTree.getFlatDataFromTree(this.state.data, {
      ignoreCollapsed: ignoreCollapsed
    }).map(function (_ref2) {
      var node = _ref2.node,
          path = _ref2.path,
          treeIndex = _ref2.treeIndex;

      var title = node.title,
          subtitle = node.subtitle,
          otherProps = _objectWithoutProperties(node, ["title", "subtitle"]);

      return _objectSpread({
        id: getNodeKey({
          node: node,
          treeIndex: treeIndex
        }),
        title: title,
        subtitle: subtitle === undefined ? null : subtitle,
        // The last entry in the path is this node's key
        // The second to last entry (accessed here) is the parent node's key
        parent: path.length > 1 ? path[path.length - 2] : null
      }, otherProps);
    });
  },
  getData: function getData() {
    return this.state.data;
  },
  setData: function setData(data, setStateCallback) {
    this.setState({
      data: buildData(data)
    }, setStateCallback);
    return this;
  },
  //@@viewOff:interface
  //@@viewOn:private
  _setPendingScroll: function _setPendingScroll(nodeId) {
    var _this = this;

    if (this._pendingScrollRaf) cancelAnimationFrame(this._pendingScrollRaf);
    this._pendingScrollRaf = null;

    if (nodeId) {
      var startTime = Date.now();

      var tryScroll = function tryScroll() {
        var scrolled = _this._scrollTo(nodeId);

        if (!scrolled && Date.now() - startTime < 10000) _this._pendingScrollRaf = requestAnimationFrame(tryScroll);else _this._pendingScrollRaf = null;
      };

      this._pendingScrollRaf = requestAnimationFrame(tryScroll);
    }
  },
  _scrollTo: function _scrollTo(nodeId) {
    var result = false;
    var rootNode = this.findDOMNode();

    if (rootNode) {
      var nodeToScrollTo = rootNode.querySelector('[id="' + nodeId + '"]');

      if (nodeToScrollTo) {
        var gridEl = rootNode.querySelector('[role="grid"]');
        var treeEl = rootNode.querySelector(".rst__tree"); // NOTE We're checking same height because when search finishes and some nodes gets expanded,
        // we will have nodeToScrollTo but due to styling of gridEl the scrollIntoView() would change
        // scrollTop on gridEl, not on window => wait until heights gets updated by react-sortable-tree
        // (which will force scrollTop on gridEl to 0 and will keep it that way)

        if (gridEl && treeEl && gridEl.style.height === treeEl.style.height) {
          nodeToScrollTo.scrollIntoView();
          result = true;
        }
      }
    }

    return result;
  },
  _getDataAsChildren: function _getDataAsChildren(children) {
    var json;

    if (Array.isArray(children)) {
      json = children.join(" ");
    } else {
      json = children;
    }

    if (json.trim()) {
      try {
        json = JSON.parse(json);
      } catch (err) {
        this.showError("dataError", null, err);
        json = [];
      }
    }

    return json;
  },
  _toggleExpandedAll: function _toggleExpandedAll(expanded, setStateCallback) {
    this.setState(function (state) {
      return {
        data: (0, _reactSortableTree.toggleExpandedForAll)({
          treeData: state.data,
          expanded: expanded
        })
      };
    }, setStateCallback);
  },
  _getChangeCallback: function _getChangeCallback() {
    var _this2 = this;

    var setStateCallback;

    if (typeof this.props.onChange === "function") {
      setStateCallback = function setStateCallback() {
        var opt = {
          data: _this2.state.data,
          component: _this2
        };

        _this2.props.onChange(opt);
      };
    }

    return setStateCallback;
  },
  _generateNodeProps: function _generateNodeProps(opt) {
    var _this3 = this;

    var node = opt.node,
        path = opt.path,
        isSearchMatch = opt.isSearchMatch,
        isSearchFocus = opt.isSearchFocus;
    var colorClassName = "";
    var nodeProps = typeof this.props.generateNodeProps === "function" ? this.props.generateNodeProps(_objectSpread({}, opt, {
      component: this
    })) : {};
    var classNames = [nodeProps.className];

    if (this.props.colorSchema) {
      colorClassName = "color-schema-" + _uu5g.default.Environment.getColorSchema(this.props.colorSchema);
    }

    if (this.props.editable) {
      var size = "m";

      if (this.props.editColorSchema) {
        colorClassName = "color-schema-" + _uu5g.default.Environment.getColorSchema(this.props.editColorSchema);
      }

      if (node.subtitle) {
        size = "s";
        nodeProps.subtitle = nodeProps.subtitle || _uu5g.default.Common.Element.create(_uu5g.default.Forms.Text, {
          className: this.getClassName("input") + size,
          size: size,
          value: node.subtitle,
          onBlur: function onBlur(opt) {
            var subtitle = opt.value;

            if (subtitle !== node.subtitle) {
              _this3.changeNode(path, _objectSpread({}, node, {
                subtitle: subtitle
              }), _this3._getChangeCallback());
            }
          }
        });
      }

      nodeProps.title = nodeProps.title || _uu5g.default.Common.Element.create(_uu5g.default.Forms.Text, {
        className: this.getClassName("input") + size,
        size: size,
        value: node.title,
        onBlur: function onBlur(opt) {
          var title = opt.value;

          if (title !== node.title) {
            _this3.changeNode(path, _objectSpread({}, node, {
              title: title
            }), _this3._getChangeCallback());
          }
        }
      });
    }

    if (isSearchFocus) this._searchFocusNode = node;

    if (this.props.searchColorSchema && isSearchMatch) {
      colorClassName = "color-schema-" + _uu5g.default.Environment.getColorSchema(this.props.searchColorSchema);
    } else if (this.props.dragColorSchema && (typeof this.props.draggable === "function" && this.props.draggable({
      node: node
    }) || this.props.draggable === true)) {
      colorClassName = "color-schema-" + _uu5g.default.Environment.getColorSchema(this.props.dragColorSchema);
    }

    classNames.push(colorClassName);
    classNames.push("uu5-common-bg-style-" + this.props.bgStyle);

    if (this.props.nodeElevation) {
      classNames.push("uu5-common-elevation-" + this.props.nodeElevation);
    }

    nodeProps.title = _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Span, {
      content: nodeProps.title || node.title
    });
    nodeProps.subtitle = _uu5g.default.Common.Element.create(_uu5g.default.Bricks.Span, {
      content: nodeProps.subtitle || node.subtitle
    });
    nodeProps.className = classNames.filter(function (v) {
      return v;
    }).join(" ");
    nodeProps.id = node.id;

    if (this.props.onLoadSubItems && typeof this.props.onLoadSubItems === "function") {
      if (node.subItemsLoadable !== false) {
        if (node.children && node.children.length === 0) {
          //sortable tree is checking children.length for rendering collapse button
          node.children = [{
            title: this.getDefault("loadingComponent")
          }];
        }

        nodeProps.onClick = function (e) {
          return _this3._handleOnLoadSubItems(e, nodeProps, node, path);
        };
      }
    }

    return nodeProps;
  },
  _handleOnLoadSubItems: function _handleOnLoadSubItems(e, nodeProps, node, path) {
    var _this4 = this;

    var loading = [{
      title: this.getDefault("loadingComponent")
    }];
    var errorMessage = this.getLsiValue("errorMessage");
    var errorCommon = [{
      title: "<uu5string/><UU5.Common.Error inline content=\"".concat(errorMessage, "\"/>")
    }];

    if (e.target.classList.contains(this.getDefault("expandedButtonClass"))) {
      var stateData = _toConsumableArray(this.state.data);

      stateData.forEach(function (item) {
        var nodeFromData = _this4._findNodeInDataById(item, nodeProps.id);

        if (nodeFromData === node) {
          nodeFromData.expanded = true;

          var currentNode = _objectSpread({}, node);

          var nodeWithRemovedChildren;

          if (currentNode.children) {
            delete currentNode.children;
            nodeWithRemovedChildren = currentNode;
          }

          var childrenBeforeLoad = nodeFromData.children;
          nodeFromData.children = loading;

          _this4.changeNode(path, nodeFromData, function () {
            nodeFromData.children = childrenBeforeLoad;

            _this4.props.onLoadSubItems(nodeWithRemovedChildren).then(function (data) {
              // add newly loaded children to current state node
              _this4._setNewNodeToState(path, data);
            }).catch(function (data) {
              node.children = errorCommon;

              _this4.changeNode(path, node, function () {
                _this4.showError("onLoadSubItemsError", null, {
                  data: data
                });
              });
            });
          });
        }
      });
    }
  },
  _setNewNodeToState: function _setNewNodeToState(path, data) {
    var _this5 = this;

    var stateData = this.state.data;
    stateData.forEach(function (item) {
      var nodeFromData = _this5._findNodeInDataById(item, data.id);

      if (nodeFromData) {
        _this5.setState(function (state) {
          return {
            data: (0, _reactSortableTree.changeNodeAtPath)({
              treeData: state.data,
              newNode: _objectSpread({}, nodeFromData, {
                children: data.children.length > 0 ? data.children : null,
                subItemsLoadable: data.subItemsLoadable
              }),
              path: path,
              getNodeKey: getNodeKey
            })
          };
        });
      }
    });
  },
  _findNodeInDataById: function _findNodeInDataById(obj, id) {
    if (!obj) return null;
    var out = null;
    if (obj.id === id) out = obj;else if (obj.children) {
      for (var i = 0; i < obj.children.length; ++i) {
        var tmp = this._findNodeInDataById(obj.children[i], id);

        if (tmp) {
          out = tmp;
          break;
        }
      }
    } else return null;
    return out;
  },
  _onChange: function _onChange(treeData) {
    this.setData(treeData, this._getChangeCallback());
  },
  _setInputSearchRef: function _setInputSearchRef(ref) {
    this._inputSearch = ref;
  },
  _onInputSearch: function _onInputSearch(opt) {
    var value = this._inputSearch.getValue();

    var isValueChanged = value != this.state.searchQuery;
    if (isValueChanged) this.collapseAll();
    var indexChange = opt && opt.event && opt.event.shiftKey ? -1 : 1;
    this.setState(function (state) {
      return {
        searchQuery: value || null,
        lastSearchStartId: isValueChanged ? Math.random() : state.lastSearchStartId,
        searchFocusIndex: isValueChanged ? state.searchFocusIndex : (state.searchFocusIndex + indexChange + (state.searchResultCount || 1)) % (state.searchResultCount || 1)
      };
    });
  },
  _onInputKeyPress: function _onInputKeyPress(event) {
    if ((event.keyCode || event.which) === 13 && !event.ctrlKey) {
      this._onInputSearch({
        event: event
      });
    }
  },
  _onSearchCallback: function _onSearchCallback(matches) {
    this.setState(function (state) {
      return {
        lastSearchEndId: state.lastSearchStartId,
        searchResultCount: matches.length,
        searchFocusIndex: matches.length > 0 ? state.searchFocusIndex % matches.length : 0
      };
    });
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    var _this6 = this;

    var props = this.getMainPropsToPass();
    !this.props.height && (props.className += " " + this.getClassName("noScroll"));
    this.props.stretchNodeWidth && (props.className += " " + this.getClassName("treeStretch"));
    var style = this.props.treeProps && this.props.treeProps.style ? this.props.treeProps.style : {};
    style.height = this.props.height || this.getVisibleNodeCount() * this.props.nodeHeight;
    return _uu5g.default.Common.Element.create(_uu5g.default.Common.Div, props, this.props.searchable ? _uu5g.default.Common.Element.create(_uu5g.default.Forms.TextButton, {
      ref_: this._setInputSearchRef,
      className: this.getClassName("searchInput"),
      buttons: [{
        icon: "mdi-magnify",
        onClick: this._onInputSearch
      }],
      inputAttrs: {
        onKeyPress: this._onInputKeyPress
      },
      controlled: false,
      placeholder: this.getLsiValue("searchInputPlaceholder"),
      colorSchema: "default"
    }) : null, _uu5g.default.Common.Element.create(_reactSortableTree.SortableTreeWithoutDndContext, _extends({}, this.props.treeProps, {
      treeData: this.state.data,
      rowHeight: this.props.nodeHeight,
      onChange: this._onChange,
      canDrag: this.props.draggable,
      generateNodeProps: function generateNodeProps(opt) {
        return _this6._generateNodeProps(opt);
      },
      getNodeKey: getNodeKey,
      style: style,
      searchMethod: defaultSearch,
      searchQuery: this.state.searchQuery,
      searchFocusOffset: this.state.searchFocusIndex,
      searchFinishCallback: this._onSearchCallback
    })));
  } //@@viewOff:render

});
var SortableTreeBase = SortableTreeItem;
exports.SortableTreeBase = SortableTreeBase;

var SortableTree = _uu5g.default.Common.DnD.withContext(SortableTreeItem);

exports.SortableTree = SortableTree;

SortableTree.getTreeFromFlatData = function (flatData) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0, _reactSortableTree.getTreeFromFlatData)({
    flatData: flatData,
    getKey: opt.getKey || function (node) {
      return node.id;
    },
    getParentKey: opt.getParentKey || function (node) {
      return node.parent || null;
    },
    rootKey: opt.rootKey === undefined ? null : opt.rootKey
  });
};

SortableTree.getFlatDataFromTree = function (treeData) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0, _reactSortableTree.getFlatDataFromTree)({
    treeData: treeData,
    getNodeKey: opt.getNodeKey || getNodeKey,
    ignoreCollapsed: opt.ignoreCollapsed || false
  });
};

var _default = SortableTree;
exports.default = _default;