import React from "react";
import createReactClass from "create-react-class";
import PropTypes from "prop-types";
import UU5 from "uu5g04";
import "uu5g04-bricks";
import "uu5g04-forms";
import {
  SortableTreeWithoutDndContext,
  getVisibleNodeCount,
  changeNodeAtPath,
  addNodeUnderParent,
  getTreeFromFlatData,
  getFlatDataFromTree,
  walk,
  map,
  insertNode,
  find,
  removeNodeAtPath,
  toggleExpandedForAll,
  getNodeAtPath
} from "react-sortable-tree";
import "react-sortable-tree/style.css";

import Config from "../config/config.js";
import "./sortable-tree.less";

const inspect = object => {
  if (object && typeof object === "object") {
    if (Array.isArray(object)) return object.map(inspect);

    if (object["$$typeof"]) {
      return {
        tagName: typeof object.type === "function" ? object.type.tagName : object.type,
        props: inspect(object.props)
      };
    } else {
      let newObject = {};
      for (let k in object) {
        newObject[k] = inspect(object[k]);
      }
      return newObject;
    }
  }
  return object;
};

const buildData = (data, expandAllNodes = false, collapseAllNodes = false) => {
  return data.map(item => {
    item = { ...item };
    if (expandAllNodes) item.expanded = true;
    if (collapseAllNodes) item.expanded = false;
    item.id = item.id || UU5.Common.Tools.generateUUID();
    if (item.children) item.children = buildData(item.children, expandAllNodes, collapseAllNodes);
    return item;
  });
};

const getNodeKey = ({ node, treeIndex }) => (node.id === undefined ? treeIndex : node.id);

function defaultSearch(opt) {
  if (!opt.searchQuery) return false;

  let searchList = opt.searchQuery
    .toLowerCase()
    .split(/[.,;:!?\s]/g)
    .filter(Boolean)
    .map(it => it.toLowerCase());
  let fields = opt.node ? [opt.node.title, opt.node.subtitle].filter(it => it != null) : [];
  return fields.some(value => {
    let r;
    let v = typeof value === "object" ? UU5.Common.Tools.getLsiItemByLanguage(value) : value;
    if (typeof v === "string" && v.match(/^<uu5string\s*\/>/)) v = UU5.Common.UU5String.toPlainText(v);
    if (typeof v === "string" || typeof v === "number") {
      r = searchList.every(
        searchWord =>
          v
            .toString()
            .toLowerCase()
            .indexOf(searchWord) !== -1
      );
    }
    return r;
  });
}

const dataPropType = PropTypes.arrayOf(
  PropTypes.shape({
    id: PropTypes.string,
    title: PropTypes.any.isRequired,
    subtitle: PropTypes.any,
    expanded: PropTypes.bool,
    children: dataPropType,
    subItemsLoadable: PropTypes.bool
  })
);

const SortableTreeItem = createReactClass({
  //@@viewOn:mixins
  mixins: [
    UU5.Common.BaseMixin,
    UU5.Common.ElementaryMixin,
    UU5.Common.NestingLevelMixin,
    UU5.Common.ColorSchemaMixin,
    UU5.Common.LsiMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Config.TAG + "SortableTree",
    nestingLevel: "box",
    classNames: {
      main: Config.CSS + "sortabletree",
      noScroll: Config.CSS + "sortabletree-noscroll",
      treeStretch: Config.CSS + "sortabletree-stretch",
      input: Config.CSS + "sortabletree-input-",
      searchInput: Config.CSS + "sortabletree-search-input"
    },
    errors: {
      onLoadSubItemsError: "An error occured while loading data.",
      dataError: "Data are not valid"
    },
    lsi: {
      errorMessage: {
        cs: "Při načitaní dat došlo k chybě.",
        en: "An error occured while loading data."
      },
      searchInputPlaceholder: {
        cs: "Hledat ...",
        en: "Search ..."
      }
    },
    defaults: {
      loadingComponent: "<uu5string/><UU5.Bricks.Loading/>",
      expandedButtonClass: "rst__expandButton"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: dataPropType.isRequired,
    height: PropTypes.number,
    onChange: PropTypes.func,
    nodeHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),
    generateNodeProps: PropTypes.func,
    stretchNodeWidth: PropTypes.bool,
    nodeElevation: PropTypes.number,
    bgStyle: PropTypes.string,
    editable: PropTypes.bool,
    editColorSchema: PropTypes.string,
    draggable: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
    dragColorSchema: PropTypes.string,
    searchable: PropTypes.bool,
    searchColorSchema: PropTypes.string,
    treeProps: PropTypes.object,
    controlled: PropTypes.bool,
    onLoadSubItems: PropTypes.func,
    expanded: PropTypes.oneOf(["default", "all", "none"])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: [],
      height: null,
      onChange: null,
      nodeHeight: 62,
      generateNodeProps: null,
      stretchNodeWidth: false,
      nodeElevation: 1,
      bgStyle: "filled",
      editable: false,
      editColorSchema: null,
      draggable: false,
      dragColorSchema: null,
      searchable: false,
      searchColorSchema: "primary",
      treeProps: {},
      onLoadSubItems: null,
      expanded: "default"
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    let data;
    if (this.props.data && this.props.data.length !== 0) {
      data = this.props.data;
    } else if (this.props.children) {
      data = this._getDataAsChildren(this.props.children);
    }
    const expandAllNodes = this.props.expanded === "all";
    const collapseAllNodes = this.props.expanded === "none";

    return {
      data: buildData(data, expandAllNodes, collapseAllNodes),
      searchQuery: null,
      searchFocusIndex: 0,
      searchResultCount: 0
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      let stateObj = null;
      if (JSON.stringify(inspect(nextProps.data)) !== JSON.stringify(inspect(this.props.data))) {
        stateObj = nextProps.data;
      } else if ((!nextProps.data || nextProps.data.length === 0) && nextProps.children) {
        let nextChildren = this._getDataAsChildren(nextProps.children);
        let currentChildren = this._getDataAsChildren(this.props.children);
        if (JSON.stringify(currentChildren) !== JSON.stringify(nextChildren)) {
          stateObj = nextChildren;
        }
      }
      stateObj ? this.setState({ data: buildData(stateObj) }) : null;
    }
  },

  componentDidUpdate(prevProps, prevState) {
    if (this.state.lastSearchStartId !== prevState.lastSearchStartId) this._setPendingScroll(null);

    // we have to scroll to the found node manually if the tree doesn't have explicit height
    // (because react-sortable-tree scrolls there only with explicit height)
    if (
      !this.props.height &&
      this._searchFocusNode &&
      this.state.searchQuery &&
      this.state.lastSearchStartId === this.state.lastSearchEndId && // search is not in progress
      (prevState.searchFocusIndex !== this.state.searchFocusIndex || // found index changed or a new search ended
        prevState.lastSearchEndId !== this.state.lastSearchEndId)
    ) {
      let nodeId = this._searchFocusNode.id;
      let scrolled = this._scrollTo(nodeId);
      this._setPendingScroll(scrolled ? null : nodeId);
    }
  },

  componentWillUnmount() {
    this._setPendingScroll(null);
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  getVisibleNodeCount() {
    return getVisibleNodeCount({ treeData: this.state.data });
  },

  forEach(callback, ignoreCollapsed = false) {
    walk({
      treeData: this.state.data,
      getNodeKey,
      callback,
      ignoreCollapsed
    });
    return this;
  },

  map(callback, ignoreCollapsed = false, setStateCallback) {
    if (typeof ignoreCollapsed === "function") {
      setStateCallback = ignoreCollapsed;
      ignoreCollapsed = false;
    }

    this.setState(
      state => ({
        data: map({
          treeData: state.data,
          getNodeKey,
          callback,
          ignoreCollapsed
        })
      }),
      setStateCallback
    );

    return this;
  },

  insertNode(newNode, opt = {}, setStateCallback) {
    if (typeof opt === "function") {
      setStateCallback = opt;
      opt = {};
    }

    this.setState(state => {
      let params = {
        treeData: state.data,
        newNode,
        getNodeKey,
        ignoreCollapsed: opt.ignoreCollapsed === undefined ? true : opt.ignoreCollapsed,
        expandParent: opt.expandParent === undefined ? true : opt.expandParent
      };

      let changedDataObject;
      if (opt.parentKey === undefined) {
        params.depth = opt.depth || null;
        params.minimumTreeIndex = opt.minimumTreeIndex || null;
        changedDataObject = insertNode(params);
      } else {
        params.parentKey = opt.parentKey;
        changedDataObject = addNodeUnderParent(params);
      }

      return { data: changedDataObject.treeData };
    }, setStateCallback);

    return this;
  },

  getNode(path) {
    return getNodeAtPath({
      treeData: this.state.data,
      path,
      getNodeKey
    });
  },

  changeNode(path, newNode, setStateCallback) {
    this.setState(
      state => ({
        data: changeNodeAtPath({
          treeData: state.data,
          newNode,
          path,
          getNodeKey
        })
      }),
      setStateCallback
    );

    return this;
  },

  removeNode(path, setStateCallback) {
    this.setState(
      state => ({
        data: removeNodeAtPath({
          treeData: state.data,
          path,
          getNodeKey
        })
      }),
      setStateCallback
    );

    return this;
  },

  find(searchMethod, opt = {}) {
    return find({
      treeData: this.state.data,
      searchMethod,
      getNodeKey,
      searchFocusOffset: opt.searchFocusOffset,
      searchQuery: opt.searchQuery,
      expandAllMatchPaths: opt.expandAllMatchPaths === undefined ? true : opt.expandAllMatchPaths,
      expandFocusMatchPaths: opt.expandFocusMatchPaths === undefined ? true : opt.expandFocusMatchPaths
    });
  },

  expandAll(setStateCallback) {
    this._toggleExpandedAll(true, setStateCallback);
    return this;
  },

  collapseAll(setStateCallback) {
    this._toggleExpandedAll(false, setStateCallback);
    return this;
  },

  getFlatData(ignoreCollapsed = false) {
    return SortableTree.getFlatDataFromTree(this.state.data, { ignoreCollapsed }).map(({ node, path, treeIndex }) => {
      let { title, subtitle, ...otherProps } = node;
      return {
        id: getNodeKey({ node, treeIndex }),
        title: title,
        subtitle: subtitle === undefined ? null : subtitle,

        // The last entry in the path is this node's key
        // The second to last entry (accessed here) is the parent node's key
        parent: path.length > 1 ? path[path.length - 2] : null,

        ...otherProps
      };
    });
  },

  getData() {
    return this.state.data;
  },

  setData(data, setStateCallback) {
    this.setState({ data: buildData(data) }, setStateCallback);
    return this;
  },
  //@@viewOff:interface

  //@@viewOn:private
  _setPendingScroll(nodeId) {
    if (this._pendingScrollRaf) cancelAnimationFrame(this._pendingScrollRaf);
    this._pendingScrollRaf = null;
    if (nodeId) {
      let startTime = Date.now();
      let tryScroll = () => {
        let scrolled = this._scrollTo(nodeId);
        if (!scrolled && Date.now() - startTime < 10000) this._pendingScrollRaf = requestAnimationFrame(tryScroll);
        else this._pendingScrollRaf = null;
      };
      this._pendingScrollRaf = requestAnimationFrame(tryScroll);
    }
  },

  _scrollTo(nodeId) {
    let result = false;
    let rootNode = this.findDOMNode();
    if (rootNode) {
      let nodeToScrollTo = rootNode.querySelector('[id="' + nodeId + '"]');
      if (nodeToScrollTo) {
        let gridEl = rootNode.querySelector('[role="grid"]');
        let treeEl = rootNode.querySelector(".rst__tree");
        // NOTE We're checking same height because when search finishes and some nodes gets expanded,
        // we will have nodeToScrollTo but due to styling of gridEl the scrollIntoView() would change
        // scrollTop on gridEl, not on window => wait until heights gets updated by react-sortable-tree
        // (which will force scrollTop on gridEl to 0 and will keep it that way)
        if (gridEl && treeEl && gridEl.style.height === treeEl.style.height) {
          nodeToScrollTo.scrollIntoView();
          result = true;
        }
      }
    }
    return result;
  },

  _getDataAsChildren(children) {
    let json;
    if (Array.isArray(children)) {
      json = children.join(" ");
    } else {
      json = children;
    }
    if (json.trim()) {
      try {
        json = JSON.parse(json);
      } catch (err) {
        this.showError("dataError", null, err);
        json = [];
      }
    }
    return json;
  },

  _toggleExpandedAll(expanded, setStateCallback) {
    this.setState(state => ({ data: toggleExpandedForAll({ treeData: state.data, expanded }) }), setStateCallback);
  },

  _getChangeCallback() {
    let setStateCallback;

    if (typeof this.props.onChange === "function") {
      setStateCallback = () => {
        let opt = { data: this.state.data, component: this };
        this.props.onChange(opt);
      };
    }

    return setStateCallback;
  },

  _generateNodeProps(opt) {
    let { node, path, isSearchMatch, isSearchFocus } = opt;
    let colorClassName = "";
    let nodeProps =
      typeof this.props.generateNodeProps === "function"
        ? this.props.generateNodeProps({ ...opt, component: this })
        : {};

    let classNames = [nodeProps.className];

    if (this.props.colorSchema) {
      colorClassName = "color-schema-" + UU5.Environment.getColorSchema(this.props.colorSchema);
    }

    if (this.props.editable) {
      let size = "m";
      if (this.props.editColorSchema) {
        colorClassName = "color-schema-" + UU5.Environment.getColorSchema(this.props.editColorSchema);
      }

      if (node.subtitle) {
        size = "s";
        nodeProps.subtitle = nodeProps.subtitle || (
          <UU5.Forms.Text
            className={this.getClassName("input") + size}
            size={size}
            value={node.subtitle}
            onBlur={opt => {
              const subtitle = opt.value;
              if (subtitle !== node.subtitle) {
                this.changeNode(path, { ...node, subtitle }, this._getChangeCallback());
              }
            }}
          />
        );
      }

      nodeProps.title = nodeProps.title || (
        <UU5.Forms.Text
          className={this.getClassName("input") + size}
          size={size}
          value={node.title}
          onBlur={opt => {
            const title = opt.value;
            if (title !== node.title) {
              this.changeNode(path, { ...node, title }, this._getChangeCallback());
            }
          }}
        />
      );
    }

    if (isSearchFocus) this._searchFocusNode = node;
    if (this.props.searchColorSchema && isSearchMatch) {
      colorClassName = "color-schema-" + UU5.Environment.getColorSchema(this.props.searchColorSchema);
    } else if (
      this.props.dragColorSchema &&
      ((typeof this.props.draggable === "function" && this.props.draggable({ node })) || this.props.draggable === true)
    ) {
      colorClassName = "color-schema-" + UU5.Environment.getColorSchema(this.props.dragColorSchema);
    }

    classNames.push(colorClassName);
    classNames.push("uu5-common-bg-style-" + this.props.bgStyle);

    if (this.props.nodeElevation) {
      classNames.push("uu5-common-elevation-" + this.props.nodeElevation);
    }

    nodeProps.title = <UU5.Bricks.Span content={nodeProps.title || node.title} />;
    nodeProps.subtitle = <UU5.Bricks.Span content={nodeProps.subtitle || node.subtitle} />;

    nodeProps.className = classNames.filter(v => v).join(" ");

    nodeProps.id = node.id;

    if (this.props.onLoadSubItems && typeof this.props.onLoadSubItems === "function") {
      if (node.subItemsLoadable !== false) {
        if (node.children && node.children.length === 0) {
          //sortable tree is checking children.length for rendering collapse button
          node.children = [{ title: this.getDefault("loadingComponent") }];
        }
        nodeProps.onClick = e => this._handleOnLoadSubItems(e, nodeProps, node, path);
      }
    }

    return nodeProps;
  },

  _handleOnLoadSubItems(e, nodeProps, node, path) {
    let loading = [{ title: this.getDefault("loadingComponent") }];
    let errorMessage = this.getLsiValue("errorMessage");
    let errorCommon = [{ title: `<uu5string/><UU5.Common.Error inline content="${errorMessage}"/>` }];

    if (e.target.classList.contains(this.getDefault("expandedButtonClass"))) {
      let stateData = [...this.state.data];
      stateData.forEach(item => {
        let nodeFromData = this._findNodeInDataById(item, nodeProps.id);
        if (nodeFromData === node) {
          nodeFromData.expanded = true;
          let currentNode = { ...node };
          let nodeWithRemovedChildren;
          if (currentNode.children) {
            delete currentNode.children;
            nodeWithRemovedChildren = currentNode;
          }
          let childrenBeforeLoad = nodeFromData.children;
          nodeFromData.children = loading;
          this.changeNode(path, nodeFromData, () => {
            nodeFromData.children = childrenBeforeLoad;
            this.props
              .onLoadSubItems(nodeWithRemovedChildren)
              .then(data => {
                // add newly loaded children to current state node
                this._setNewNodeToState(path, data);
              })
              .catch(data => {
                node.children = errorCommon;
                this.changeNode(path, node, () => {
                  this.showError("onLoadSubItemsError", null, { data });
                });
              });
          });
        }
      });
    }
  },

  _setNewNodeToState(path, data) {
    let stateData = this.state.data;
    stateData.forEach(item => {
      let nodeFromData = this._findNodeInDataById(item, data.id);
      if (nodeFromData) {
        this.setState(state => ({
          data: changeNodeAtPath({
            treeData: state.data,
            newNode: {
              ...nodeFromData,
              children: data.children.length > 0 ? data.children : null,
              subItemsLoadable: data.subItemsLoadable
            },
            path,
            getNodeKey
          })
        }));
      }
    });
  },

  _findNodeInDataById(obj, id) {
    if (!obj) return null;
    let out = null;
    if (obj.id === id) out = obj;
    else if (obj.children) {
      for (let i = 0; i < obj.children.length; ++i) {
        let tmp = this._findNodeInDataById(obj.children[i], id);
        if (tmp) {
          out = tmp;
          break;
        }
      }
    } else return null;
    return out;
  },

  _onChange(treeData) {
    this.setData(treeData, this._getChangeCallback());
  },

  _setInputSearchRef(ref) {
    this._inputSearch = ref;
  },

  _onInputSearch(opt) {
    let value = this._inputSearch.getValue();
    let isValueChanged = value != this.state.searchQuery;
    if (isValueChanged) this.collapseAll();
    let indexChange = opt && opt.event && opt.event.shiftKey ? -1 : 1;
    this.setState(state => {
      return {
        searchQuery: value || null,
        lastSearchStartId: isValueChanged ? Math.random() : state.lastSearchStartId,
        searchFocusIndex: isValueChanged
          ? state.searchFocusIndex
          : (state.searchFocusIndex + indexChange + (state.searchResultCount || 1)) % (state.searchResultCount || 1)
      };
    });
  },

  _onInputKeyPress(event) {
    if ((event.keyCode || event.which) === 13 && !event.ctrlKey) {
      this._onInputSearch({ event });
    }
  },

  _onSearchCallback(matches) {
    this.setState(state => ({
      lastSearchEndId: state.lastSearchStartId,
      searchResultCount: matches.length,
      searchFocusIndex: matches.length > 0 ? state.searchFocusIndex % matches.length : 0
    }));
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let props = this.getMainPropsToPass();
    !this.props.height && (props.className += " " + this.getClassName("noScroll"));

    this.props.stretchNodeWidth && (props.className += " " + this.getClassName("treeStretch"));

    let style = this.props.treeProps && this.props.treeProps.style ? this.props.treeProps.style : {};
    style.height = this.props.height || this.getVisibleNodeCount() * this.props.nodeHeight;

    return (
      <UU5.Common.Div {...props}>
        {this.props.searchable ? (
          <UU5.Forms.TextButton
            ref_={this._setInputSearchRef}
            className={this.getClassName("searchInput")}
            buttons={[{ icon: "mdi-magnify", onClick: this._onInputSearch }]}
            inputAttrs={{
              onKeyPress: this._onInputKeyPress
            }}
            controlled={false}
            placeholder={this.getLsiValue("searchInputPlaceholder")}
            colorSchema="default"
          />
        ) : null}
        <SortableTreeWithoutDndContext
          {...this.props.treeProps}
          treeData={this.state.data}
          rowHeight={this.props.nodeHeight}
          onChange={this._onChange}
          canDrag={this.props.draggable}
          generateNodeProps={opt => this._generateNodeProps(opt)}
          getNodeKey={getNodeKey}
          style={style}
          searchMethod={defaultSearch}
          searchQuery={this.state.searchQuery}
          searchFocusOffset={this.state.searchFocusIndex}
          searchFinishCallback={this._onSearchCallback}
        />
      </UU5.Common.Div>
    );
  }
  //@@viewOff:render
});

export const SortableTreeBase = SortableTreeItem;
export const SortableTree = UU5.Common.DnD.withContext(SortableTreeItem);

SortableTree.getTreeFromFlatData = (flatData, opt = {}) => {
  return getTreeFromFlatData({
    flatData,
    getKey: opt.getKey || (node => node.id),
    getParentKey: opt.getParentKey || (node => node.parent || null),
    rootKey: opt.rootKey === undefined ? null : opt.rootKey
  });
};

SortableTree.getFlatDataFromTree = (treeData, opt = {}) => {
  return getFlatDataFromTree({
    treeData,
    getNodeKey: opt.getNodeKey || getNodeKey,
    ignoreCollapsed: opt.ignoreCollapsed || false
  });
};

export default SortableTree;
