"use strict";

const CLS = require("cls-hooked");
const BaseError = require("./base-error.js");

/**
 * ThreadLocal alike context store.
 */
class ContextStore {
  /**
   * Creates new context store
   * @param ctxName Context store name.
   * @param fn Function to which should context store be bound.
   * @returns {*} Return value of invoked function.
   */
  static create(ctxName, fn) {
    let namespace = CLS.getNamespace(ctxName);
    if (namespace) {
      if (namespace.active) {
        throw new BaseError(`Context "${ctxName}" is already created.`);
      }
    } else {
      namespace = CLS.createNamespace(ctxName);
    }
    let result;
    namespace.run(() => {
      result = fn();
    });
    return result;
  }

  /**
   * Returns context store bound to current context.
   * @param ctxName Context store name.
   * @returns {ContextStore} Instance of context store or null.
   */
  static get(ctxName) {
    let namespace = CLS.getNamespace(ctxName);
    if (namespace && namespace.active) {
      return new ContextStore(namespace);
    } else {
      return null;
    }
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  set(key, value) {
    this._namespace.set(key, value);
  }

  /**
   * Returns context attribute.
   * @param key Context attribute name.
   * @returns {*} Context attribute value.
   */
  get(key) {
    return this._namespace.get(key);
  }

  /**
   * Forks context and runs given function.
   * @param fn Function to be invoked.
   * @returns {*} Return value of invoked function.
   */
  fork(fn) {
    let result;
    this._namespace.run(() => {
      result = fn();
    });
    return result;
  }

  constructor(namespace) {
    this._namespace = namespace;
  }

  bindEmitter(emitter) {
    this._namespace.bindEmitter(emitter);
  }
}

module.exports = ContextStore;
