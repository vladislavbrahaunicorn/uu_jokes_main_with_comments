const glob = require("glob");
const fs = require("fs");
const path = require("path");
const BaseError = require("./base-error.js");

let externalModules = [];

/**
 * Finder simplifies resolving configuration files, middleware
 * and startup listeners in node_modules by encapsulating the
 * logic necessary to separate NPM and PNPM folder structures.
 */
class Finder {

  /**
   * Deeply matches the provided pattern against node_modules in the given root
   * and returns an array of matched paths.
   *
   * @param root {string} project root
   * @param globPattern {string} glob pattern to match in individual package folders
   *
   * @example
   * To match a mappings.json, use "config/mappings.json"
   * To match all middleware, use "{src,app}/middleware/*.js"
   *
   *
   * @returns {Array<String>} matched paths
   */
  static findInModules(root = process.cwd(), globPattern = "") {
    const globOpts = {
      dot: true,
      follow: false,
      realpath: true
    };
    root = (root || process.cwd()).replace(/\/$/, "");
    globPattern = (globPattern || "").replace(/^\//, "");

    let result = [];
    result = result.concat(isPnpm(root)
      ? glob.sync(`${root}/node_modules/*/*/*/node_modules/*/${globPattern}`, globOpts)
      : glob.sync(`${root}/node_modules/*/${globPattern}`, globOpts));
    externalModules.forEach((externalModule) => {
      result = result.concat(this.findInProject(externalModule, globPattern));
    });
    return result;
  }

  /**
   * Performs a search within the application.
   * @param root
   * @param globPattern
   * @returns {*}
   */
  static findInProject(root = process.cwd(), globPattern = "") {
    const globOpts = {
      follow: false,
      realpath: true
    };
    root = (root || process.cwd()).replace(/\/$/, "");
    globPattern = (globPattern || "").replace(/^\//, "");

    return glob.sync(`${root}/${globPattern}`, globOpts);
  }

  /**
   * Finds a path to the provided package. Necessary with PNPM since
   * require.resolve() is useless while using PNPM.
   * @param root {string} project root
   * @param name {string} package name
   * @param throwOnMultipleResults {boolean}
   * @returns {Array}
   */
  static findPackage(root = process.cwd(), name, throwOnMultipleResults = true) {
    let matchingExternalModules = externalModules.filter(function(module) {return path.basename(module) === name});
    if (matchingExternalModules && matchingExternalModules.length) {
      if (matchingExternalModules.length !== 1 && throwOnMultipleResults) {
        throw new BaseError(`Invalid number of packages found:\n ${matchingExternalModules.join("\n")}`);
      }
      return matchingExternalModules;
    } else if (isPnpm(root)) {
      const globOpts = {
        dot: true,
        follow: false,
        realpath: true
      };
      root = (root || process.cwd()).replace(/\/$/, "");
      let results = glob.sync(`${root}/node_modules/*/*/*/node_modules/${name}/`, globOpts);
      if (results.length !== 1 && throwOnMultipleResults) {
        throw new BaseError(`Invalid number of packages found:\n ${results.join("\n")}`);
      }
      return results;
    } else {
      let tailRegex = new RegExp(`${name}.*$`);
      try {
        return [require.resolve(name).replace(tailRegex, name)];
      } catch (err) {
        return null;
      }
    }
  }

  /**
   * Deeply matches the provided pattern against node_modules in the given root
   * and filters the result so only one config path is returned per module.
   * If module contains /config folder and /src|app/config folder, the second one is prefered.
   *
   * @param root {string} project root
   * @param globPattern {string} glob pattern to match in individual package folders
   *
   * @returns {Array<String>} matched paths
   */
  static findConfigInModules(root, globPattern = "") {
    let paths = Finder.findInModules(root, globPattern);

    const modules = new Map();
    paths.forEach(f => {
      f = f.replace(/\\/g, "/");
      let moduleName;
      f.replace(/node_modules\/([^\/]*)\//g, (m, g1) => {
        moduleName = g1;
      });
      if (!modules.has(moduleName) || f.match(/(app|src)\/config/)) {
        modules.set(moduleName, f);
      }
    });
    return Array.from(modules.values());
  }

  static findConfigInProject(root, globPattern = "") {
    let paths = Finder.findInProject(root, globPattern);

    let configPath;
    paths.forEach(f => {
      f = f.replace(/\\/g, "/");
      if (!configPath || f.match(/(app|src)\/config/)) {
        configPath = f;
      }
    });

    return configPath;
  }

  static injectExternalModule(modulePath) {
    modulePath = modulePath ? modulePath.replace(/\/$/, "") : "";
    if (modulePath && !externalModules.includes(modulePath)) {
      externalModules.push(modulePath);
    }
  }

  static removeExternalModule(modulePath) {
    modulePath = modulePath ? modulePath.replace(/\/$/, "") : "";
    let index = externalModules.indexOf(modulePath);
    if (index > -1) {
      externalModules.splice(index, 1);
    }
  }

  static clearExternalModules() {
    externalModules = [];
  }

}

module.exports = Finder;

function isPnpm(root) {
  return fs.existsSync(path.join(root, "node_modules", ".modules.yaml"));
}
