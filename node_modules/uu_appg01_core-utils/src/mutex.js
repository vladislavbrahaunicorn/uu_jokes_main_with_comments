"use strict";

const Digest = require("./digest.js");
const toPrunedJson = require("json-prune");

/**
 * Component providing synchronization methods
 * for running asynchronous functions.
 */
class Mutex {

  /**
   * Allows to suspend processing of method for given time. Returns the actual
   * number of milliseconds the processing was suspended, which is typically
   * slightly higher than given time (due to delay of callback invocation).
   * @param ms Number of milliseconds to sleep
   * @returns {Promise<number>} Number of milliseconds actually slept
   */
  static async sleep(ms) {
    let initiated = Date.now();
    return new Promise(resolve => {
      setTimeout(() => resolve(Date.now() - initiated), ms);
    });
  };

  /**
   * Allows to split long running functions to multiple segments in order to prevent
   * blocking of thread by long running operations (e.g. it can be called in each loop).
   * @returns {Promise<number>} Number of milliseconds how long function was interrupted
   */
  static async yield() {
    let initiated = Date.now();
    let interrupt = (async () => {})();
    return interrupt.then(() => {
      return Date.now() - initiated;
    });
  }

  /**
   * Creates new instance of Mutex.
   */
  constructor() {
    this._promises = {};
  }

  /**
   * Ensures given functionality is invoked only once at a time. Method internally
   * computes functionality invocation signature (or used given one) and in case
   * functionality with same signature as already running one is requested, it does
   * not perform new invocation but returns result of previous one.
   * @param sig Invocation signature which should be unique for given function
   *   and/or function argument values. If not given, default signature is
   *   computed as "${fn.name}:${sha1(JSON.stringify(args))}"
   * @param fn Function to be invoked
   * @param args Function arguments
   * @returns {Promise<*>} Result of invoked function
   */
  runOneAtTime(sig = null, fn, ...args) {
    if (typeof sig === "function") {
      args.unshift(fn);
      fn = sig;
      sig = null;
    }
    let signature = sig || this._getSignature(fn, ...args);
    let promise = this._promises[signature];
    if (!promise || promise._finished) {
      promise = this._invokeFn(fn, ...args);
      promise._finished = false;
      this._promises[signature] = promise;
      let finalize = () => {
        promise._finished = true;
        delete this._promises[signature];
      };
      promise.then(finalize, finalize);
    }
    return promise;
  }

  /**
   * Ensures given functionality is invoked after previously given one is finished.
   * @param fn Function to be invoked
   * @param args Function arguments
   * @returns {PromiseLike<*>} Result of invoked function
   */
  runInBand(fn, ...args) {
    let prevPromise = this._promises["runInBand"];
    let nextPromise;
    if (!prevPromise || prevPromise._finished) {
      nextPromise = this._invokeFn(fn, ...args);
    } else {
      let runNext = () => {
        return this._invokeFn(fn, ...args);
      };
      nextPromise = prevPromise.then(runNext, runNext);
    }
    nextPromise._finished = false;
    this._promises["runInBand"] = nextPromise;
    let finalize = () => {
      nextPromise._finished = true;
    };
    nextPromise.then(finalize, finalize);
    return nextPromise;
  }

  _getSignature(fn, ...args) {
    let argsString = toPrunedJson(args, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    let argsHash = Digest.sha1(argsString);
    return `${fn.name}:${argsHash}`;
  }

  _invokeFn(fn, ...args) {
    if (fn.constructor.name === 'AsyncFunction') {
      return fn(...args);
    } else {
      let asyncWrapper = async () => {
        return fn(...args);
      };
      return asyncWrapper();
    }
  }

}

module.exports = Mutex;
