"use strict";

const path = require("path");
const fs = require("fs");
const glob = require("glob");

const BaseError = require("./base-error.js");
const nameConverter = require("./name-converter.js");
const Finder = require("./finder.js");

/**
 * Loader class provides loading helpers that deal with loading of files
 * and resources that are shared or similar across multiple libraries.
 */
class Loader {

  /**
   * Realization loader takes care of turning a string representation
   * of a path + class + method (realization) usually found in a mappings.json
   * or persistence.json into a reference to the represented method.
   * @param sourcePath Path to app/library root folder (the folder containing app|src folder).
   * @param realization String representing path to Class.method from sourcePath.
   * @returns {Function} Reference to the realization class/method.
   * @constructor
   */
  static loadRealization(sourcePath, realization, getMethod = true) {
    // split realization definition into path and class with method definition
    const splitString = (index, str) => [str.substring(0, index), str.substring(index + 1)];
    realization = realization.replace(/\\/g, "/");
    let separatorIdx = realization.lastIndexOf("/");
    let [clazzPath, clazzAndMethod] = splitString(separatorIdx, realization);
    // separate class and method
    let [clazz, method] = clazzAndMethod.split(".");
    // get source file name from class name
    let clazzFile = nameConverter(clazz) + ".js";

    // find source file matching realization
    let sourceFiles = null;
    if (clazzPath.indexOf(":") > -1) {
      // realization is absolute format (module_name:path/to/Class[.method])
      let segments = clazzPath.trim().split(":");
      if (segments.length > 2) {
        throw new BaseError(`Realization in relative format must contain only 1 colon separator: ${realization}`);
      }
      // find module source directory
      let moduleName = segments[0];
      let [modulePath] = Finder.findPackage(sourcePath, moduleName);
      // find class source file
      clazzPath = segments[1];
      let globPattern = `{src,app}/${path.join(clazzPath, clazzFile)}`;
      sourceFiles = Finder.findInProject(modulePath, globPattern);
    } else {
      // realization declared as relative to given sourcePath (path/to/Class[.method])
      let globPattern = `{src,app}/${path.join(clazzPath, clazzFile)}`;
      sourceFiles = Finder.findInProject(sourcePath, globPattern);
    }
    // we have to have exactly one source file
    if (!sourceFiles || !sourceFiles.length) {
      throw new BaseError(`No source file found for "${realization}".`)
    } else if (sourceFiles.length > 1) {
      throw new BaseError(`Multiple source files found for "${realization}": ${sourceFiles}`);
    }

    // try to load class
    let loadedClazz = null;
    try {
      loadedClazz = require(sourceFiles[0]);
    } catch (e) {
      throw new BaseError(`Unable to require realization at ${sourceFiles[0]}.`, e);
    }

    // return particular method or whole class
    if (method && getMethod) {
      let loadedMethod = loadedClazz[method];
      if (!loadedMethod) {
        throw new BaseError(`Method "${method}" requested by "${realization}" is not available in source ${sourceFiles[0]}. Check if realization is correctly exported.`);
      }
      return loadedMethod.bind(loadedClazz);
    } else {
      return loadedClazz;
    }
  }

  /**
   * Config file loader traverses all installed library roots and
   * returns all files matching the pathFromModuleRoot parameter.
   * @example
   * configFileLoader("myApp", "config/info.json") will
   * find all info.json files at paths such as:
   * "myApp/node_modules/some_module/config/info.json"
   * "myApp/node_modules/some_other_module/config/info.json"
   * It will not match:
   * "myApp/node_modules/some_module/info.json".
   * "myApp/config/info.json"
   * etc.
   * @param serverRoot
   * @param pathFromModuleRoot
   * @returns {Array.<*>}
   */
  static loadConfigFiles(serverRoot, pathFromModuleRoot) {
    let files = [];
    let rootPath = path.join(serverRoot, pathFromModuleRoot);
    let libPath = path.join(serverRoot, "node_modules", "*", pathFromModuleRoot);
    if (fs.existsSync(rootPath)) files.push(rootPath);
    let libFiles = glob.sync(libPath);
    return files.concat(libFiles);
  }

  static convertPathToNamespace(filePath) {
    if (typeof filePath !== "string") throw new BaseError("Path to file must be a string.");
    let segments = path.normalize(filePath).split(path.sep);
    let fileName = segments.pop().split(".")[0];
    let className = nameConverter(fileName);
    let moduleName;
    let pathToClass;
    let i = segments.length;
    while (--i) {
      let item = segments[i];
      if (item === "src" || item === "app") {
        moduleName = segments[i - 1];
        pathToClass = segments.slice(i + 1).join("/");
        return `${moduleName}:${pathToClass ? pathToClass + "/" : ""}`;
      }
    }
    throw new BaseError("Provided path does not conform to convention, as it contains neither 'src' nor 'app' folder.");
  }
}

module.exports = Loader;
