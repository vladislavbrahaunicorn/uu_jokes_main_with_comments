"use strict";

if (typeof window == "undefined") {
  var fs = require("fs");
}

class ConfigSource {
  constructor(source, ttl = -1) {
    this._ttl = ttl;
    if (typeof source === "string" || source instanceof String) {
      let match = /^file:\/\/(.*)/i.exec(source);
      if (match !== null) {
        if (typeof window != "undefined")
          throw new TypeError("Unable to use " + source + " as configuration source in browser environment.");
        this._fileSrc = match[1];
      } else {
        match = /^env:\/\/([a-z_][a-z0-9_]*)/i.exec(source);
        if (match !== null) {
          this._senvSrc = match[1];
        } else {
          throw new TypeError("unable to use " + source + " as configuration source");
        }
      }
    } else if (source instanceof RegExp) {
      this._menvSrc = source;
    } else if (source && typeof source === "object") {
      this._data = source;
    } else {
      throw new TypeError("unable to use " + typeof source.constructor + " as configuration source");
    }
  }

  load(failOnError = false) {
    let loadedSrc;
    try {
      if (this._fileSrc !== undefined && this._fileSrc) {
        loadedSrc = this._fileSrc;
        let data = fs.readFileSync(this._fileSrc, "utf8");
        this._data = this._parse(data);
      } else if (this._senvSrc !== undefined && this._senvSrc) {
        loadedSrc = this._senvSrc;
        let data = process.env[this._senvSrc] || "";
        this._data = this._parse(data);
      } else if (this._menvSrc !== undefined && this._menvSrc) {
        loadedSrc = this._menvSrc;
        let regex = this._menvSrc;
        let envKeys = Object.keys(process.env);
        let result = {};
        envKeys.forEach(function(key) {
          if (regex.test(key)) {
            result[key.toLowerCase()] = process.env[key];
          }
        });
        this._data = result;
      }
      this._loaded = new Date();
    } catch (err) {
      let errMsg = `Loading of configuration from source [${loadedSrc}] failed: ${err.toString()}`;
      if (failOnError) {
        throw new Error(errMsg);
      } else {
        console.log(errMsg);
      }
    }
  }

  get(name) {
    if (this._reload()) this.load();
    return this._data[name];
  }

  setTtl(ttl) {
    this._ttl = ttl;
  }

  hasKey(name) {
    if (this._reload()) this.load();
    return this._data[name] !== undefined;
  }

  toJSON(failOnError = false) {
    if (this._reload()) this.load(failOnError);
    return JSON.parse(JSON.stringify(this._data));
  }

  _parse(sourceData) {
    if (/^[\r\n\t ]*{[\s\S]*}[\r\n\t ]*$/.test(sourceData)) {
      return JSON.parse(sourceData);
    } else {
      let result = {};
      sourceData = sourceData.replace(/\r\n?/g, "\n");
      let splitData = sourceData.split("\n");
      splitData.forEach(function(line) {
        line = line.trim();
        if (/^[#!]/.test(line)) return;
        let splitLine = line.split(/[=:](.*)/, 2);
        let name = splitLine[0];
        let value = splitLine[1];
        if (name === null) return;
        name = name.trim();
        if (name.length === 0) return;
        if (value === undefined) {
          value = null;
        } else {
          value = value.trimLeft();
          try {
            value = JSON.parse(value.trim());
          } catch (err) {
            // do nothing
          }
        }
        result[name] = value;
      });
      return result;
    }
  }

  _reload() {
    if (!this._loaded) return true;
    if (this._ttl < 0) return false;
    let t = new Date();
    let reload = t.getTime() > this._loaded.getTime() + this._ttl * 1000;
    if (this._fileSrc) {
      let stats = fs.statSync(this._fileSrc);
      if (stats.isFile()) {
        let mTime = new Date(stats["mtime"]);
        return reload && mTime.getTime() > this._loaded.getTime();
      } else {
        return reload;
      }
    } else {
      return reload;
    }
  }
}

module.exports = ConfigSource;
