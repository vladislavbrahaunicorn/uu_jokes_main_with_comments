"use strict";

const ConfigSource = require("./config-source");
const ConfigChain = require("./config-chain");

if (typeof window == "undefined") {
  const DupValidator = require("../duplicate-library-validator.js");
  DupValidator.ensureSingleVersion(module);
  var path = require("path");
  var fs = require("fs");
  var os = require("os");
}

/**
 * Main class for working with configuration (reading, updating, source registration)
 */
class Config {
  /**
   * Allows to provide default configuration of library or application.
   * @param {string|RegExp|Object} source
   */
  static registerImplicitSource(source) {
    Config.implicitSources.push(new ConfigSource(source));
    let profiles = Config.activeProfiles;
    if (profiles && profiles.length > 0) {
      Config.activateProfiles(profiles);
    }
  }

  /**
   * Allows registration of additional configuration source
   * @param {String} profile
   * @param {string|RegExp|Object} source
   * @param {Number} ttl
   */
  static registerSource(profile, source, ttl) {
    let profileSources = Config.sources[profile];
    if (profileSources) {
      profileSources.push(new ConfigSource(source, ttl));
    } else {
      Config.sources[profile] = [new ConfigSource(source, ttl)];
    }
    let profiles = Config.activeProfiles;
    if (profiles.includes(profile)) {
      Config.activateProfiles(profiles);
    }
  }

  static atProfileActivation(funktion, ...profiles) {
    Config.callbacks.push([funktion, profiles]);
  }

  /**
   * Activates given set of configuration profiles
   * @param {...profiles} profiles
   */
  static activateProfiles(...profiles) {
    let sources = [];
    if (typeof window == "undefined") {
      // 1) registered sources
      profiles.forEach(function(profile) {
        let profileSources = Config.sources[profile] || [];
        profileSources.reverse();
        sources.push(...profileSources);
        profileSources.reverse();
      });
      // 2) "legacy" source for backward compatibility with C3
      sources.push(new ConfigSource("env://SERVER_CFG"));
      // 3) configuration from environment
      sources.push(new ConfigSource(/.*/));
      // 4) configuration files
      let cfgDir = process.env["CONFIG_DIR"] || Config._getDefaultConfigDir();
      let sysCfgDir = process.env["SYS_CONFIG_DIR"] || Config._getDefaultSysConfigDir();
      profiles.forEach(function(profile) {
        let profileCfgPropertiesFile = path.join(cfgDir, profile.toLowerCase() + ".properties");
        let profileCfgJsonFile = path.join(cfgDir, profile.toLowerCase() + ".json");
        let sysProfileCfgPropertiesFile = path.join(sysCfgDir, profile.toLowerCase() + ".properties");
        let sysProfileCfgJsonFile = path.join(sysCfgDir, profile.toLowerCase() + ".json");
        if (fs.existsSync(sysProfileCfgJsonFile)) sources.push(new ConfigSource("file://" + sysProfileCfgJsonFile, 0));
        if (fs.existsSync(profileCfgJsonFile)) sources.push(new ConfigSource("file://" + profileCfgJsonFile, 0));
        if (fs.existsSync(sysProfileCfgPropertiesFile))
          sources.push(new ConfigSource("file://" + sysProfileCfgPropertiesFile, 0));
        if (fs.existsSync(profileCfgPropertiesFile))
          sources.push(new ConfigSource("file://" + profileCfgPropertiesFile, 0));

      });
      // 5) default configuration
      sources.push(...Config.implicitSources);
    } else {
      let uu5 = window["UU5"];
      let env = (uu5 ? uu5["Environment"] : null) || {};
      sources.push(new ConfigSource(env));
    }
    // create the chain
    let chain = new ConfigChain(sources, profiles);

    // Copy custom configuration added to config from previously
    // activated profiles (so runtime configuration is not lost)
    if (Config.chain) chain._custom = JSON.parse(JSON.stringify(Config.chain._custom));
    Config.chain = chain;

    // Force load of all configs, fail on errors (Configuration must be
    // complete at least on profile activation which is expected during
    // environment initialization)
    chain.load(true);

    // Invoke profile activation callbacks
    Config.callbacks.forEach(function(entry) {
      let cb = entry[0];
      let cbProfiles = entry[1];
      if (!Config._doArraysIntersect(profiles, cbProfiles)) cb.call();
    });

    Config.activeProfiles = Array.from(new Set([...Config.activeProfiles, ...profiles]));

    // TODO log it (when logging gets standardised)
    // console.log('\nProfile(s) ' + chain.activeProfiles() +  ' activated. Effective configuration:\n', chain.toJSON(),'\n')
  }

  /**
   * Checks if given profile(s) is(are) active.
   * @param {...profiles} profiles
   * @returns {boolean}
   */
  static isProfileActive(...profiles) {
    let activeProfiles = Config.activeProfiles;
    if (!activeProfiles) return false;
    return Config._doArraysIntersect(activeProfiles, profiles);
  }

  /**
   * Returns value of the given configuration parameter
   * @param {string} name
   * @param {Boolean} recursive
   * @returns {*}
   */
  static get(name, recursive = true) {
    return Config._getChain().get(name, recursive);
  }

  /**
   * Returns parameter value transformed to string using .toString().
   * @param {String} name
   * @param {boolean} recursive
   * @returns {String}
   */
  static getString(name, recursive = true) {
    return Config._getChain().getString(name, recursive);
  }

  /**
   * Returns parameter value transformed to number (if possible, else raises error).
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Number}
   */
  static getNumber(name, recursive = true) {
    return Config._getChain().getNumber(name, recursive);
  }

  /**
   * Returns parameter value transformed to boolean (if possible, else raises error).
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Boolean}
   */
  static getBoolean(name, recursive = true) {
    return Config._getChain().getBoolean(name, recursive);
  }

  /**
   * Returns parameter value transformed to a Date object using its constructor or raises error.
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Date}
   */
  static getTime(name, recursive = true) {
    return Config._getChain().getTime(name, recursive);
  }

  /**
   * Returns parameter value transformed to a class if possible, else raises error.
   * Source path needs to be provided, which is the path to the module that exports the requested class.
   * @param {String} name
   * @param {String} sourcePath
   * @param {boolean} recursive
   * @returns {Function}
   */
  static getClass(name, sourcePath, recursive = true) {
    return Config._getChain().getClass(name, sourcePath, recursive);
  }

  /**
   * Returns parameter value transformed to array of given types
   * @param {String} name
   * @param {String} type
   * @param {Boolean} recursive
   * @returns {Array}
   */
  static getArray(name, type = null, recursive = true, sourcePath = null) {
    return Config._getChain().getArray(name, type, recursive, sourcePath);
  }

  /**
   * Sets configuration parameter with highest priority (overrides value of any existing source).
   * @param {String} name
   * @param {*} value
   */
  static set(name, value) {
    Config._getChain().set(name, value);
  }

  /**
   * Deletes explicitly set configuration parameter.
   * @param {String} name
   */
  static delete(name) {
    Config._getChain().delete(name);
  }

  /**
   * Checks if configuration provides parameter of given name.
   * Returns false for undefined values and true for null values.
   * @param {String} name
   * @param {Boolean} recursive
   * @returns {*|Boolean|boolean}
   */
  static hasKey(name, recursive = true) {
    return Config._getChain().hasKey(name, recursive);
  }

  /**
   * Returns Object containing effective configuration.
   * @param {boolean} failOnError
   * @returns {*}
   */
  static toJSON(failOnError = false) {
    return Config._getChain().toJSON(failOnError);
  }

  /**
   * Forces reload of all configuration sources related to activated profiles.
   * @param {boolean} failOnError
   */
  static reload(failOnError = false) {
    Config._getChain().load(failOnError);
  }

  /**
   * Clears all configuration.
   */
  static clear() {
    Config.activeProfiles = [];
    Config.callbacks = [];
    Config.implicitSources = [];
    Config.sources = {};
    Config.chain = null;
  }

  static _getChain() {
    let chain = Config.chain;
    if (!chain) {
      let actProf = Config.activeProfiles;
      if (actProf.length === 0) {
        let envProfiles = process.env["CONFIG_PROFILE"] || process.env["NODE_ENV"];
        if (envProfiles) {
          let arr = envProfiles.split(",");
          actProf = [];
          arr.forEach(function(profile) {
            actProf.push(profile.trim());
          });
          Config.activateProfiles(...actProf);
        } else {
          actProf = "production";
          Config.activateProfiles(actProf);
        }
      }
      chain = Config.chain;
    }
    return chain;
  }

  // TODO move this function to some more appropriate place?
  static _doArraysIntersect(arr1, arr2) {
    let doTheyIntersect = false;
    arr1.forEach(function(el1) {
      if (arr2.includes(el1)) doTheyIntersect = true;
    });
    return doTheyIntersect;
  }

  static _getDefaultConfigDir() {
    let configPath = path.join(process.cwd(), "env");
    if (!fs.existsSync(configPath)) {
      configPath = path.join(process.cwd(), "config");
    }
    return configPath;
  }

  static _getDefaultSysConfigDir() {
    let configPath = path.join(os.homedir(), ".uu", "env");
    if (!fs.existsSync(configPath)) {
      configPath = path.join(os.homedir(), ".uu", "config");
    }
    return configPath;
  }
}

Config.activeProfiles = [];

Config.callbacks = [];

Config.implicitSources = [];

Config.sources = {};

Config.chain = null;

module.exports = Config;
