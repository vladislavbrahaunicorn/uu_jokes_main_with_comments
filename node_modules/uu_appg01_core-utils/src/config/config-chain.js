"use strict";

const BaseError = require("../base-error");
const ValueConverter = require("../value-converter.js");

const expression = /(?:^|[^\\])(\${([\w_.]+)(?::([^}]*))?}|#{([^}]+)})/;

class ConfigChain {
  constructor(sources, profiles) {
    this._sources = sources;
    this._profiles = profiles;
    this._custom = {};
  }

  activeProfiles() {
    return JSON.parse(JSON.stringify(this._profiles));
  }

  get(name, recursive = true, loopCheck = []) {
    let result;
    let self = this;
    if (recursive) {
      let parts = name.split(".");
      while (parts.length > 0) {
        let name = parts.join(".");
        if (this._custom[name] !== undefined) return this._custom[name];
        this._sources.forEach(function(source) {
          let value = source.get(name);
          if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
        });
        if (result !== undefined) return result;
        let length = parts.length;
        let idx = length === 1 ? 0 : length - 2;
        parts.splice(idx, 1);
      }
    } else {
      if (this._custom[name] !== undefined) return this._custom[name];
      this._sources.forEach(function(source) {
        let value = source.get(name);
        if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
      });
      if (result !== undefined) return result;
    }
    return result;
  }

  getString(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toString(value);
  }

  getNumber(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toNumber(value);
  }

  getBoolean(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toBoolean(value);
  }

  getTime(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toTime(value);
  }

  getClass(name, sourcePath, recursive = true) {
    let value = this.get(name, recursive);
    sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
    return ValueConverter.toClass(value, sourcePath);
  }

  getArray(name, type = null, recursive = true, sourcePath = null) {
    let value = this.get(name, recursive);
    sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
    return ValueConverter.toArray(value, type, sourcePath);
  }

  set(name, value) {
    this._custom[name] = value;
  }

  delete(name) {
    delete this._custom[name];
  }

  hasKey(name, recursive = true) {
    let hasKey = false;

    if (recursive) {
      let parts = name.split(".");
      while (parts.length > 0) {
        let name = parts.join(".");
        if (this._custom[name] !== undefined) return true;
        this._sources.forEach(function(source) {
          if (!hasKey && source.hasKey(name)) hasKey = true;
        });
        if (hasKey) {
          return hasKey;
        }
        let length = parts.length;
        let idx = length === 1 ? 0 : length - 2;
        parts.splice(idx, 1);
      }
    } else {
      if (this._custom[name] !== undefined) return true;
      this._sources.forEach(function(source) {
        if (source.hasKey(name)) {
          hasKey = true;
        }
      });
    }
    return hasKey;
  }

  toJSON() {
    let result = {};
    let resolver = this._resolve.bind(this);
    this._sources.reverse();
    this._sources.forEach(function(source) {
      let sourceJson = source.toJSON();
      let keys = Object.keys(sourceJson);
      keys.forEach(function(key) {
        result[key] = resolver(sourceJson[key]);
      });
    });
    this._sources.reverse();
    let keys = Object.keys(this._custom);
    let custom = this._custom;
    keys.forEach(function(key) {
      result[key] = resolver(custom[key]);
    });
    return result;
  }

  load(failOnError = false) {
    this._sources.reverse();
    this._sources.forEach(function(source) {
      source.load(failOnError);
    });
    this._sources.reverse();
  }

  _resolve(value, loopCheck = []) {
    if (!!value && value.constructor === Object) {
      let newObject = {};
      for (let key of Object.keys(value)) {
        newObject[key] = this._resolve(value[key])
      }
      return newObject;
    }
    if (!(typeof value === "string") && !(value instanceof String)) return value;
    let matchResult = value.match(expression);
    if (!matchResult) {
      return value;
    } else {
      let expression = matchResult[1];
      let key = matchResult[2];
      let defolt = matchResult[3];
      let prog = matchResult[4];
      if (prog) {
        value = eval(prog);
        return this._resolve(value);
      } else {
        if (loopCheck.includes(key)) throw new BaseError("endless configuration loop caused by [" + loopCheck + "]");
        loopCheck.push(key);
        let resolved = this.get(key, true, loopCheck);
        if (!resolved) resolved = defolt;
        value = value.replace(new RegExp(expression.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&"), "g"), resolved);
        return this._resolve(value);
      }
    }
  }

  _serverSourcePath() {
    return this.get("server_root");
  }
}

module.exports = ConfigChain;
