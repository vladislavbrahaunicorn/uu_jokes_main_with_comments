"use strict";

const BaseError = require("./base-error.js");

/**
 * Simple implementation of {https://en.wikipedia.org/wiki/Histogram histogram}.
 */
class Histogram {
  /**
   * Creates new histogram.
   * @param {number} min Minimum expected value (must be greater or equal to 1). In case lower value is received
   *   it is not forgotten but stored in lower threshold {https://en.wikipedia.org/wiki/Data_binning bin}.
   * @param {number} max Maximum expected value (must be greater than 1). In case higher value is received it is
   *   not forgotten but stored in upper threshold {https://en.wikipedia.org/wiki/Data_binning bin}.
   * @param {number} samples Number of {https://en.wikipedia.org/wiki/Data_binning bins} to be used (must be
   *   greater than 1). Higher number means higher precision, but also higher memory consumption and decreased
   *   performance (of both storing new values and reading results).
   * @param {boolean} logarithmic Flag whether {https://en.wikipedia.org/wiki/Data_binning bins} should
   *   use logarithmic distribution (toward lower values). Defaults to true.
   */
  constructor(min, max, samples, logarithmic = true) {
    if (min < 1) throw new BaseError("min value must be greater or equal to 1");
    if (max <= 1) throw new BaseError("max value must be greater than 1");
    if (max <= min) throw new BaseError("min value must be greater than min value");
    if (samples < 1) throw new BaseError("sample count must be greater of equal to 1");

    this._samples = [];
    this._samples.push({ rng: [min, min], sum: 0, cnt: 0 });
    let step = logarithmic ? (max / min) ** (1 / samples) : (max - min) / samples;
    let from = min;
    let to = logarithmic ? min * step : min + step;
    while (from < max) {
      from = this._round(from, 3);
      to = this._round(to, 3);
      if (to > max) to = max; // may happen due to rounding errors
      this._samples.push({ rng: [from, to], sum: 0, cnt: 0 });
      from = to;
      to = logarithmic ? to * step : to + step;
    }
    this._samples.push({ rng: [max, max], sum: 0, cnt: 0 });
    this._cnt = 0;
    this._threshold_cnt = 0;
    this._min = null;
    this._threshold_min = null;
    this._max = null;
    this._threshold_max = null;
  }

  /**
   * Records new value to histogram. Negative values
   * are ignored.
   * @param {number} val Value to be recorded.
   * @returns {void}
   */
  record(val) {
    if (val < 0) return;
    let sample;
    if (val < (sample = this._samples[0]).rng[1]) {
      sample.sum += val;
      sample.cnt++;
      this._threshold_cnt++;
      if (this._threshold_min == null || val < sample.rng[0]) {
        this._threshold_min = val;
        sample.rng = [val, sample.rng[1]];
      }
    } else if (val > (sample = this._samples[this._samples.length - 1]).rng[0]) {
      sample.sum += val;
      sample.cnt++;
      this._threshold_cnt++;
      if (this._threshold_max == null || val > sample.rng[1]) {
        this._threshold_max = val;
        sample.rng = [sample.rng[0], val];
      }
      if (this._threshold_max == null || val < this._threshold_max) this._threshold_max = val;
    } else {
      for (let i = 1; i <= this._samples.length - 2; i++) {
        sample = this._samples[i];
        if (!(val >= sample.rng[0] && val <= sample.rng[1])) continue;
        sample.sum += val;
        sample.cnt++;
        this._cnt++;
        if (this._min == null || val < this._min) this._min = val;
        if (this._max == null || val > this._max) this._max = val;
        break;
      }
    }
  }

  /**
   * Returns minimum recorded value (or null if no value was recorded).
   * @param {boolean} includeThreshold Flag whether minimum value should
   *   be returned only from values within expected range (false, default)
   *   or values from lower threshold bin should be included.
   * @returns {number} Minimum recorded value.
   */
  min(includeThreshold = false) {
    return includeThreshold ? this._threshold_min || this._min : this._min;
  }

  /**
   * Returns maximum recorded value (or null if no value was recorded).
   * @param {boolean} includeThreshold Flag whether maximum value should
   *   be returned only from values within expected range (false, default)
   *   or values from upper threshold bin should be included.
   * @returns {number} Maximum recorded value.
   */
  max(includeThreshold = false) {
    return includeThreshold ? this._threshold_max || this._max : this._max;
  }

  /**
   * Returns an average of recorded values.
   * @param {boolean} includeThreshold Flag whether only values from within
   *   expected range should be used (false, default) or all values
   *   (including lower threshold bin and upper threshold bin) should be used.
   * @returns {number} Average value.
   */
  average(includeThreshold = false) {
    let sum = 0;
    let cnt = 0;
    let samples = includeThreshold ? this._samples : this._samples.slice(1, -1);
    samples.forEach(sample => {
      sum += sample.sum;
      cnt += sample.cnt;
    });
    return cnt === 0 ? 0 : this._round(sum / cnt, 3);
  }

  /**
   * Returns median of recorded values.
   * @param {number} includeThreshold Flag whether only values from within
   *   expected range should be used (false, default) or all values
   *   (including lower threshold bin and upper threshold bin) should be used.
   * @returns {number} Percentile
   */
  median(includeThreshold = false) {
    return this.percentile(50, includeThreshold);
  }

  /**
   * Returns specified percentile of recorded values.
   * @param {number} val Requested percentile (between 0 and 100)
   * @param {number} includeThreshold Flag whether only values from within
   *   expected range should be used (false, default) or all values
   *   (including lower threshold bin and upper threshold bin) should be used.
   * @returns {number} Percentile
   */
  percentile(val, includeThreshold = false) {
    if (val < 0 || val > 100) throw new BaseError("value must be between 0 and 100");
    let total = includeThreshold ? this._cnt + this._threshold_cnt : this._cnt;
    let limit = this._round((total / 100) * val, 0);
    let count = 0;
    let value = 0;
    let samples = includeThreshold ? this._samples : this._samples.slice(1, -1);
    for (let i = 0; i < samples.length; i++) {
      let sample = samples[i];
      if (count < limit && sample.cnt > 0) {
        value = sample.rng[1];
      } else if (count >= limit) {
        break;
      }
      count += sample.cnt;
    }
    return value;
  }

  /**
   * Rounds value to given decimal precision. Avoids rounding errors caused
   * by floating point arithmetic.
   * @param {number} value Value to round.
   * @param {number} decimals Rounding decimal precision.
   * @returns {number} Rounded value.
   * @private
   */
  _round(value, decimals) {
    // noinspection JSCheckFunctionSignatures
    return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
  }
}

module.exports = Histogram;
