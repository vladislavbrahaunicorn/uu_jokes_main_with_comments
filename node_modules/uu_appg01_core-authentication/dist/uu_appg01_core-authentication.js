/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core-utils"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core-authentication", ["module", "uu_appg01_core-utils"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core-authentication"] = factory(require("module"), require("uu_appg01_core-utils"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["Authentication"] = factory(root["undefined"], root["UuApp.Utils"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/4.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/4.7.2/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  get AuthenticationService() {
    return __webpack_require__(4);
  },

  get Session() {
    return __webpack_require__(6);
  },

  get Identity() {
    return __webpack_require__(9);
  },

  get ClientIdentity() {
    return __webpack_require__(10);
  },

  get ApplicationIdentity() {
    return __webpack_require__(11);
  },

  get AuthenticationError() {
    return __webpack_require__(8);
  },

  get InvalidCredentials() {
    return __webpack_require__(12);
  },

  get UntrustedCredentials() {
    return __webpack_require__(7);
  }

};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError,
    Config = _require.Config;

var DEFAULT_PROVIDER_PARAM = "uu_app_default_authn_provider";
/**
 * Component encapsulating authentication process.
 */

var AuthenticationService = /*#__PURE__*/function () {
  function AuthenticationService() {
    _classCallCheck(this, AuthenticationService);
  }

  _createClass(AuthenticationService, null, [{
    key: "authenticate",

    /**
     * Authenticates user.
     * @param {*} credentials User credentials to be verified
     * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
     * @returns {Promise<Session>} User session for passed user credentials.
     * @throws {InvalidCredentials} In case credentials are not valid.
     * @throws {AuthenticationError} In case authentication fails.
     */
    value: function () {
      var _authenticate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(credentials) {
        var scope,
            realization,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                scope = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                realization = AuthenticationService.get();

                if (!scope) {
                  _context.next = 8;
                  break;
                }

                _context.next = 5;
                return realization.authenticate(credentials, scope);

              case 5:
                return _context.abrupt("return", _context.sent);

              case 8:
                _context.next = 10;
                return realization.authenticate(credentials);

              case 10:
                return _context.abrupt("return", _context.sent);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
    /**
     * Returns particular realization of authentication service.
     * @param {String} realizationName Name of required authentication service realization
     * @returns {*} Object responding to "authenticate" method
     * @throws {BaseError} In case realization with given name does not exist
     */

  }, {
    key: "get",
    value: function get() {
      var realizationName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var name = realizationName || Config.get(DEFAULT_PROVIDER_PARAM);

      if (!name) {
        throw new BaseError("Unable to get default authentication provider. Configuration parameter ".concat(DEFAULT_PROVIDER_PARAM, " is not set."));
      }

      var realization = AuthenticationService._realizations[name];

      if (realization) {
        return realization;
      } else {
        throw new BaseError("There is no authentication provider with name \"".concat(name, "\"."));
      }
    }
    /**
     * Registers custom realization of authentication service.
     * @param {String} realizationName Custom authentication service realization name
     * @param {*} realization Object responding to "authenticate" method
     * @private
     */

  }, {
    key: "_register",
    value: function _register(realizationName, realization) {
      AuthenticationService._realizations[realizationName] = realization;
    }
  }, {
    key: "DEFAULT_PROVIDER_PARAM",

    /**
     * @returns {string} Name of configuration parameter for accessing default realization of authentication service.
     */
    get: function get() {
      return DEFAULT_PROVIDER_PARAM;
    }
  }]);

  return AuthenticationService;
}();

AuthenticationService._realizations = {};
module.exports = AuthenticationService;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var UntrustedCredentials = __webpack_require__(7);
/**
 * Object providing result of authentication process. It holds information about the user's identity, the information
 * about the application and also attributes related to authentication process itself.
 */


var Session = /*#__PURE__*/function () {
  /**
   * Creates new instance of session.
   * @param {Object} data Authentication data.
   * @param {String} data.id Unique session instance ID.
   * @param {String} data.authenticationId Unique ID of authentication process (in whose scope was this session instance created).
   * @param {Date} data.authenticationTime Time of authentication process invocation (in whose scope was this session instance created).
   * @param {number} data.authenticationLevelOfAssurance Numeric representation of the means of authentication
   * @param {Identity} data.identity User identity
   * @param {ApplicationIdentity} data.applicationIdentity Application identity (deprecated, use clientIdentity)
   * @param {ClientIdentity} data.clientIdentity Client Application identity
   * @param {Object} data.attributes Implementation specific session attributes
   * @private
   */
  function Session() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Session);

    this._id = data.id || null;
    this._authenticationId = data.authenticationId || null;
    this._authenticationTime = data.authenticationTime || new Date();
    this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance ? parseInt(data.authenticationLevelOfAssurance) : 0;
    this._identity = data.identity;
    this._clientIdentity = data.clientIdentity;
    this._applicationIdentity = data.applicationIdentity;
    this._attributes = data.attributes || {};
    this._authenticated = !!(this._authenticationLevelOfAssurance && (this._identity || this._applicationIdentity || this._clientIdentity));
  }
  /**
   * Returns unique session instance ID.
   * @returns {String|null} Session ID.
   */


  _createClass(Session, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }
    /**
     * Returns unique ID of authentication process (in whose scope was this session instance created).
     * @returns {String|null} Unique ID of global session
     */

  }, {
    key: "getAuthenticationId",
    value: function getAuthenticationId() {
      return this._authenticationId;
    }
    /**
     * Returns the time of authentication process invocation (in whose scope was this session instance created).
     * @returns {Date|null} Time of authentication
     */

  }, {
    key: "getAuthenticationTime",
    value: function getAuthenticationTime() {
      return this._authenticationTime;
    }
    /**
     * Returns the means of authentication (type of credentials) for current user.
     * @returns {number} Numeric representation of the means of authentication
     */

  }, {
    key: "getAuthenticationLevelOfAssurance",
    value: function getAuthenticationLevelOfAssurance() {
      return this._authenticationLevelOfAssurance;
    }
    /**
     * Returns user identity.
     * @returns {Identity} User identity
     */

  }, {
    key: "getIdentity",
    value: function getIdentity() {
      return this._identity;
    }
    /**
     * Returns client application identity.
     * @returns {ClientIdentity|null} Client application identity
     */

  }, {
    key: "getClientIdentity",
    value: function getClientIdentity() {
      return this._clientIdentity;
    }
    /**
     * Returns application identity.
     * @returns {ApplicationIdentity|null} Application identity
     * @deprecated Use getClientIdentity.
     */

  }, {
    key: "getApplicationIdentity",
    value: function getApplicationIdentity() {
      return this._applicationIdentity;
    }
    /**
     * Returns true if the user is not anonymous.
     * @returns {boolean} True if user is not anonymous
     */

  }, {
    key: "isAuthenticated",
    value: function isAuthenticated() {
      return !!this._authenticated;
    }
    /**
     * Returns call token scope based on URI of invoked command. This value may be then used for obtaining of
     * actual call token provided by method getCallToken.
     * @param {String|URI} uri URI of command to be invoked (for which to obtain call token scope).
     * @param {Object} opts Call token options.
     * @param {String|null} otps.scopeMode Scope mode (one of [useCase, allUseCases, none]).
     * @returns {Promise<String>} Call token scope
     */

  }, {
    key: "getCallTokenScope",
    value: function () {
      var _getCallTokenScope = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(uri) {
        var opts,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                return _context.abrupt("return", uri ? uri.toString().split("?")[0] : uri);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getCallTokenScope(_x) {
        return _getCallTokenScope.apply(this, arguments);
      }

      return getCallTokenScope;
    }()
    /**
     * Returns token to be used by client to call functionality provided by other application server.
     * @param {String|URI} scope Scope (single value or array) representing functionality to be invoked with token.
     * @param {Object} opts Call token options.
     * @param {boolean|null} otps.useTokenExchange Flag if call should use new token (derived from existing) or directly reuse existing one.
     * @param {boolean|null} opts.excludeAuthenticationType Flag if call token should be returned without authentication type prefix.
     * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
     * @returns {Promise<String>} Call token
     */

  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(scope) {
        var opts,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                throw new Error("Method not implemented.");

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function getCallToken(_x2) {
        return _getCallToken.apply(this, arguments);
      }

      return getCallToken;
    }()
    /**
     * Checks if processed authentication conforms to required constraints.
     * @param {Object} constraints Session constraint object
     * @param {number|null} constraints.maxAuthenticationAge Maximum age of authentication in seconds
     * @param {number|null} constraints.minAuthenticationLevelOfAssurance Minimum required level of assurance
     * @throws {UntrustedCredentials} In case processed authentication does not conform to required constraints.
     */

  }, {
    key: "assertTrustiness",
    value: function assertTrustiness() {
      var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mla = constraints.minAuthenticationLevelOfAssurance;

      if (mla != undefined && mla != null && mla > this.getAuthenticationLevelOfAssurance()) {
        throw new UntrustedCredentials(this, "Minimum login level of assurance not met.");
      }

      var maxAge = constraints.maxAuthenticationAge;

      if (maxAge != undefined && maxAge != null) {
        var epochAuthTime = this.getAuthenticationTime().getTime() / 1000;
        var epochCurTime = Date.now / 1000;

        if (epochAuthTime + maxAge < epochCurTime) {
          throw new UntrustedCredentials(this, "User re-authentication required.");
        }
      }
    }
    /**
     * Returns custom session attribute (actual attributes are dependant on particular session instance based on
     * technology used for authentication process)
     * @param {String} name Name of session attribute
     * @returns {*} Attribute value
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this._attributes[name];
    }
    /**
     * Performs the log out of the user.
     */

  }, {
    key: "close",
    value: function close() {
      this._authenticated = false;
    }
    /**
     * Serializes user and client data. Does not contain ids so that result can
     * be used for comparison between multiple instances of session.
     * @returns {String}
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        identity: this._identity,
        clientIdentity: this._clientIdentity,
        applicationIdentity: this._applicationIdentity
      };
    }
  }]);

  return Session;
}();

module.exports = Session;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthenticationError = __webpack_require__(8);
/**
 * Error raised in case session does not meet required criteria
 * (e.g. login too old or authentication level of assurance not met )
 */


var UntrustedCredentials = /*#__PURE__*/function (_AuthenticationError) {
  _inherits(UntrustedCredentials, _AuthenticationError);

  var _super = _createSuper(UntrustedCredentials);

  /**
   * Creates new instance of error.
   * @param {Session} session Instance of session not matching requried criteria
   * @param {string} message Error message
   * @param {Error} cause Error cause
   */
  function UntrustedCredentials(session, message) {
    var _this;

    var cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, UntrustedCredentials);

    if (typeof session === "string") {
      cause = message;
      message = session;
      session = null;
    }

    _this = _super.call(this, message, cause);
    _this._session = session;
    return _this;
  }
  /**
   * Returns instance of untrusted session.
   * @returns {Session} Instance of untrusted session
   */


  _createClass(UntrustedCredentials, [{
    key: "getSession",
    value: function getSession() {
      return this._session;
    }
  }]);

  return UntrustedCredentials;
}(AuthenticationError);

module.exports = UntrustedCredentials;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError;
/**
 * Base error of all authentication errors.
 */


var AuthenticationError = /*#__PURE__*/function (_BaseError) {
  _inherits(AuthenticationError, _BaseError);

  var _super = _createSuper(AuthenticationError);

  function AuthenticationError() {
    _classCallCheck(this, AuthenticationError);

    return _super.apply(this, arguments);
  }

  return AuthenticationError;
}(BaseError);

module.exports = AuthenticationError;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The identity of a user.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Identity = /*#__PURE__*/function () {
  /**
   * Creates new instance of user identity.
   * @param {String} uuIdentity Unique identifier of the user
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the user
   * @param {String} data.type Type of the identity
   * @param {number} data.levelOfAssurance Numeric representation of identity verification level
   * @private
   */
  function Identity(uuIdentity, data) {
    _classCallCheck(this, Identity);

    this._uuIdentity = uuIdentity;

    if (typeof data === "string") {
      this._name = data;
    } else if (data) {
      this._name = data.name;
      this._type = data.type;
      this._levelOfAssurance = data.levelOfAssurance;
    }
  }
  /**
   * Returns a unique identifier of the user.
   * @returns {String} String representation of the unique identifier of the user
   */


  _createClass(Identity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }
    /**
     * Returns the name of the user.
     * @returns {String|null} User's name
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * Type of the identity.
     * @returns {String|null} Type of the identity
     */

  }, {
    key: "getType",
    value: function getType() {
      return this._type;
    }
    /**
     * Numeric representation of identity verification level.
     * @returns {number|null} Numeric representation of identity verification level
     */

  }, {
    key: "getLevelOfAssurance",
    value: function getLevelOfAssurance() {
      return this._levelOfAssurance;
    } // TODO Only for backward compatibility, drop for "1.0.0" release

    /**
     * Only for backward compatibility.
     * @private
     */

  }, {
    key: "getUUIdentity",
    value: function getUUIdentity() {
      return this.getUuIdentity();
    }
  }]);

  return Identity;
}();

module.exports = Identity;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The identity of a client application.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ClientIdentity = /*#__PURE__*/function () {
  /**
   * Creates new instance of client application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.uri Registered URI of client application
   * @param {String} data.product Client application product
   * @param {String} data.vendor Client application vendor
   * @param {String} data.app Client application name
   * @param {String} data.subApp Client application subapp
   * @param {String} data.asid Client application asid
   * @param {String} data.awid Client application awid
   * @private
   */
  function ClientIdentity(uuIdentity) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ClientIdentity);

    this._uuIdentity = uuIdentity;

    if (data) {
      this._uri = data.uri;
      this._product = data.product;
      this._vendor = data.vendor;
      this._app = data.app;
      this._subApp = data.subApp;
      this._asid = data.asid;
      this._awid = data.awid;
    }
  }
  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */


  _createClass(ClientIdentity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }
    /**
     * Returns registered URI of client application.
     * @returns {String|null} Registered URI of client application
     */

  }, {
    key: "getUri",
    value: function getUri() {
      return this._uri;
    }
    /**
     * Returns client application product.
     * @returns {String|null} Client application product
     */

  }, {
    key: "getProduct",
    value: function getProduct() {
      return this._product;
    }
    /**
     * Returns client application vendor.
     * @returns {String|null} Client application vendor
     */

  }, {
    key: "getVendor",
    value: function getVendor() {
      return this._vendor;
    }
    /**
     * Returns client application name.
     * @returns {String|null} Client application name
     */

  }, {
    key: "getApp",
    value: function getApp() {
      return this._app;
    }
    /**
     * Returns client application subapp.
     * @returns {String|null} Client application subapp
     */

  }, {
    key: "getSubApp",
    value: function getSubApp() {
      return this._subApp;
    }
    /**
     * Returns client application asid.
     * @returns {String|null} Client application asid
     */

  }, {
    key: "getAsid",
    value: function getAsid() {
      return this._asid;
    }
    /**
     * Returns client application awid.
     * @returns {String|null} Client application awid
     */

  }, {
    key: "getAwid",
    value: function getAwid() {
      return this._awid;
    }
  }]);

  return ClientIdentity;
}();

module.exports = ClientIdentity;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The identity of an application.
 * @deprecated Use ClientIdentity
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ApplicationIdentity = /*#__PURE__*/function () {
  /**
   * Creates new instance of application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the application
   * @param {String} data.code Code of the application
   * @private
   */
  function ApplicationIdentity(uuIdentity) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ApplicationIdentity);

    if (typeof data === "string") {
      this._code = uuIdentity;
      this._name = data;
    } else if (data) {
      this._uuIdentity = uuIdentity;
      this._code = data.code;
      this._name = data.name;
    }
  }
  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */


  _createClass(ApplicationIdentity, [{
    key: "getUuIdentity",
    value: function getUuIdentity() {
      return this._uuIdentity;
    }
    /**
     * Returns unique identifier of the application.
     * @returns {String} String representation of the unique identifier
     */

  }, {
    key: "getCode",
    value: function getCode() {
      return this._code;
    }
    /**
     * Returns name of the application.
     * @returns {String|null} Name of the application
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }]);

  return ApplicationIdentity;
}();

module.exports = ApplicationIdentity;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthenticationError = __webpack_require__(8);
/**
 * Error raised by AuthenticationService in case provided
 * credentials are not valid.
 */


var InvalidCredentials = /*#__PURE__*/function (_AuthenticationError) {
  _inherits(InvalidCredentials, _AuthenticationError);

  var _super = _createSuper(InvalidCredentials);

  function InvalidCredentials() {
    _classCallCheck(this, InvalidCredentials);

    return _super.apply(this, arguments);
  }

  return InvalidCredentials;
}(AuthenticationError);

module.exports = InvalidCredentials;

/***/ })
/******/ ]);
});