/**
 * @fileoverview Checks for correct import statements order
 * @author Milan Martinek
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const PROGRAM = "Program";

const LIBRARY = 1;
const UU5_LIBRARY = 2;
const LOCAL_FILE = 3;
const FILE_EXTENSION = 4;
const NOPE = 5;

const UU5_LIB = /g[0-9]{2}/; // contains generation string

module.exports = {
  meta: {
    type: "problem",
    fixable: "code",
    docs: {
      description: "Checks for correct import statements order",
      category: "uu5 Supportability",
      recommended: true,
      url:
        "https://uuapp.plus4u.net/uu-bookkit-maing01/78462435-0238a88bac124b3ca828835b57144ffa/book/page?code=c089f34c"
    },
    messages: {
      invalidImportOrder: "Invalid import order {{importText}}"
    }
  },

  create: function(context) {
    // variables should be defined here

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    function isFileExtension(importSource, filename) {
      // check less and -lsi.js ext
      let lessFile = importSource.indexOf(".less") > 0;
      let lsiFile = importSource.indexOf("-lsi") > 0;
      return isLocalFile && (lessFile || lsiFile);
    }

    function isLocalFile(importSource, filename) {
      // starts with "."
      return importSource.indexOf(".") === 0 || importSource === "calls";
    }

    function isUu5Library(importSource, filename) {
      // a bit hard to guess, lets assume it contains generation
      return !!importSource.match(UU5_LIB);
    }

    function isReactLibrary(importSource, filename) {
      // not a local file, should be library
      return !isLocalFile(importSource, filename);
    }

    function getImportType(node) {
      let importSource = node.source.value;
      if (isUu5Library(importSource)) {
        return UU5_LIBRARY;
      }
      if (isReactLibrary(importSource)) {
        return LIBRARY;
      }
      if (isFileExtension(importSource)) {
        return FILE_EXTENSION;
      }
      if (isLocalFile(importSource)) {
        return LOCAL_FILE;
      }

      return NOPE;
    }

    function isTopLevel(type) {
      return type === PROGRAM;
    }

    function getNodeIndent(node) {
      const sourceCode = context.getSourceCode();
      const token = sourceCode.getFirstToken(node);
      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
      const indentChars = srcCharsBeforeNode.slice(
        0,
        srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t")
      );

      return indentChars.reduce((result, char) => result + char, "");
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      ImportDeclaration(node) {
        if (!isTopLevel(context.getScope().block.type)) return;
        let importType = getImportType(node);

        let sourceCode = context.getSourceCode();

        let previousNodes = sourceCode.getTokensBefore(node);
        if (!previousNodes) return;

        let previousImports = previousNodes
          .map(token => sourceCode.getNodeByRangeIndex(token.start))
          .filter(importNode => importNode.type === "ImportDeclaration" && isTopLevel(importNode.parent.type));

        if (previousImports.length === 0) return;

        let result = {
          isError: false,
          fixImportType: null,
          fixImportNode: null
        };

        previousImports.forEach(previousImport => {
          let previousImportType = getImportType(previousImport);

          if (previousImportType > importType) {
            result.isError = true;

            if (!result.fixImportNode || result.fixImportType > previousImportType) {
              result.fixImportNode = previousImport;
              result.fixImportType = previousImportType;
            }
          }
        });

        if (result.isError) {
          context.report({
            messageId: "invalidImportOrder",
            loc: node.loc,
            data: { importText: sourceCode.getText(node) },
            fix: fixer => {
              let nodeIndent = getNodeIndent(node);
              let fixImportIndent = getNodeIndent(result.fixImportNode);
              let text = sourceCode.getText(node) + "\n" + fixImportIndent;
              return [
                fixer.insertTextBefore(result.fixImportNode, text),
                fixer.removeRange([node.range[0] - (nodeIndent.length + 1), node.range[1]])
              ];
            }
          });
        }
      }
    };
  }
};
