/**
 * @fileoverview check component comments
 * @author Martin FarkaÅ¡
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const Selectors = require("../core/selectors");

module.exports = {
  meta: {
    type: "problem",
    fixable: "code",
    docs: {
      description: "check component comments",
      category: "uu5 Supportability",
      recommended: true,
      url:
        "https://uuapp.plus4u.net/uu-bookkit-maing01/78462435-0238a88bac124b3ca828835b57144ffa/book/page?code=uu5ComponentComments"
    },
    messages: {
      viewOnCommentIsMissing: "Following comment is missing: {{commentText}}",
      viewOffCommentIsMissing: "Following comment is missing: {{commentText}}"
    }
  },
  create: function(context) {
    const VIEW_ON_PREFIX = "@@viewOn:";
    const VIEW_OFF_PREFIX = "@@viewOff:";

    const MIXIN_REGEXP = "^mixins$";
    const STATICS_REGEXP = "^statics$";
    const PROP_TYPES_REGEXP = "^propTypes$";
    const GET_DEFAULT_PROPS_REGEXP = "^getDefaultProps$";
    const OVERRIDING_REGEXP = "^.*_$";
    const PRIVATE_REGEXP = "^_.*$";
    const RENDER_REGEXP = "^render$";

    const REACT_LIFECYCLE_REGEXP =
      "^(" +
      "getDerivedStateFromProps|" +
      "componentDidMount|" +
      "shouldComponentUpdate|" +
      "getSnapshotBeforeUpdate|" +
      "componentDidUpdate|" +
      "UNSAFE_componentWillUpdate|" +
      "componentWillUpdate|" +
      "UNSAFE_componentWillReceiveProps|" +
      "componentWillReceiveProps|" +
      "UNSAFE_componentWillMount|" +
      "componentWillMount|" +
      "componentWillUnmount|" +
      "getDerivedStateFromError|" +
      "componentDidCatch|" +
      "getInitialState" +
      ")$";

    const INTERFACE_REGEXP =
      `(?!${MIXIN_REGEXP})` +
      `(?!${STATICS_REGEXP})` +
      `(?!${PROP_TYPES_REGEXP})` +
      `(?!${GET_DEFAULT_PROPS_REGEXP})` +
      `(?!${REACT_LIFECYCLE_REGEXP})` +
      `(?!${OVERRIDING_REGEXP})` +
      `(?!${PRIVATE_REGEXP})` +
      `(?!${RENDER_REGEXP})` +
      `^.*$`;

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    const importHandler = {
      name: "imports",
      checkViewOn,
      checkViewOff
    };

    const objectPropHandlers = [
      {
        name: "mixins",
        regExp: new RegExp(MIXIN_REGEXP),
        checkViewOn,
        checkViewOff
      },
      {
        name: "statics",
        regExp: new RegExp(STATICS_REGEXP),
        checkViewOn,
        checkViewOff
      },
      {
        name: "propTypes",
        regExp: new RegExp(PROP_TYPES_REGEXP),
        checkViewOn,
        checkViewOff
      },
      {
        name: "getDefaultProps",
        regExp: new RegExp(GET_DEFAULT_PROPS_REGEXP),
        checkViewOn,
        checkViewOff
      },
      {
        name: "reactLifeCycle",
        regExp: new RegExp(REACT_LIFECYCLE_REGEXP),
        checkViewOn: checkPrevPropOrViewOn,
        checkViewOff: checkNextPropOrViewOff
      },
      {
        name: "overriding",
        regExp: new RegExp(OVERRIDING_REGEXP),
        checkViewOn: checkPrevPropOrViewOn,
        checkViewOff: checkNextPropOrViewOff
      },
      {
        name: "private",
        regExp: new RegExp(PRIVATE_REGEXP),
        checkViewOn: checkPrevPropOrViewOn,
        checkViewOff: checkNextPropOrViewOff
      },
      {
        name: "render",
        regExp: new RegExp(RENDER_REGEXP),
        checkViewOn,
        checkViewOff
      },
      {
        name: "interface",
        regExp: new RegExp(INTERFACE_REGEXP),
        checkViewOn: checkPrevPropOrViewOn,
        checkViewOff: checkNextPropOrViewOff
      }
    ];

    function checkViewOn(context, node, sectionName) {
      const src = context.getSourceCode();
      const requiredComment = VIEW_ON_PREFIX + sectionName;

      const commentsBefore = src.getCommentsBefore(node);

      const comment = commentsBefore.find(comment => {
        return comment.type == "Line" && comment.value == requiredComment;
      });

      if (!comment) {
        context.report({
          messageId: "viewOnCommentIsMissing",
          loc: node.loc,
          data: { commentText: requiredComment },
          fix: fixer => {
            return fixer.insertTextBefore(node, `//${requiredComment}\n`);
          }
        });
      }
    }

    function checkViewOff(context, node, sectionName) {
      const src = context.getSourceCode();

      const nextToken = src.getTokenAfter(node);
      let lastToken;

      if (nextToken.type === "Punctuator" && nextToken.value === ",") {
        lastToken = nextToken;
      } else {
        lastToken = node;
      }

      let commentsAfter = src.getCommentsAfter(lastToken);

      const requiredComment = VIEW_OFF_PREFIX + sectionName;
      const commentAfter = commentsAfter.find(comment => {
        return comment.type == "Line" && comment.value == requiredComment;
      });

      if (!commentAfter) {
        context.report({
          messageId: "viewOffCommentIsMissing",
          loc: node.loc,
          data: { commentText: requiredComment },
          fix: fixer => {
            return fixer.insertTextAfter(lastToken, `\n//${requiredComment}`);
          }
        });
      }
    }

    function checkPrevPropOrViewOn(context, node, sectionName, regExp, prevNode) {
      if (prevNode && prevNode.key.name.match(regExp)) {
        return;
      }

      checkViewOn(context, node, sectionName);
    }

    function checkNextPropOrViewOff(context, node, sectionName, regExp, nextNode) {
      if (nextNode && nextNode.key.name.match(regExp)) {
        return;
      }

      checkViewOff(context, node, sectionName);
    }

    function checkImportSection(context, node) {
      const src = context.getSourceCode();
      const imports = src.getTokensBefore(node, {
        filter: token => token.type === "Keyword" && token.value === "import"
      });

      // Are there some imports in source code?
      if (!imports.length) {
        return;
      }

      // First token and last token of import section
      const firstToken = imports[0];
      const lastToken = src.getTokenAfter(imports[imports.length - 1], {
        filter: token => token.type === "Punctuator" && token.value === ";"
      });

      importHandler.checkViewOn(context, firstToken, importHandler.name);
      importHandler.checkViewOff(context, lastToken, importHandler.name);
    }

    function checkObjectDefinition(context, node) {
      let props = node.properties;

      for (let i = 0; i < props.length; i++) {
        const prop = props[i];

        const prevPropIndex = i - 1;
        const prevProp = prevPropIndex >= 0 ? props[prevPropIndex] : null;

        const nextPropIndex = i + 1;
        const nextProp = nextPropIndex < props.length ? props[nextPropIndex] : null;

        const handler = objectPropHandlers.find(handler => prop.key.name.match(handler.regExp));

        if (handler) {
          handler.checkViewOn(context, prop, handler.name, handler.regExp, prevProp);
          handler.checkViewOff(context, prop, handler.name, handler.regExp, nextProp);
        }
      }
    }

    function checkRule(context, node) {
      checkImportSection(context, node);
      checkObjectDefinition(context, node);
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      [Selectors.getCreateReactClassSelector()]: node => checkRule(context, node),
      [Selectors.getVsComponentCreateSelector()]: node => Selectors.checkVsComponent(context, node, checkRule)
    };
  }
};
