"use strict";

const { ContextStore, BaseError, Config } = require("uu_appg01_core-utils");
const Section = require("./section.js");
const SectionId = require("./section-id.js");
const Logger = require("./logger.js");

const CTX_STORE_NAME = "uuapp.perflog";
const SECTION_FILTER_PARAM = "uuapp.perflog.section_filter";

class Perflog {
  static initialize(parentId = null, emitters, fn) {
    if (typeof parentId === "function") {
      fn = parentId;
      parentId = null;
    } else if (typeof emitters === "function") {
      fn = emitters;
      emitters = Array.isArray(parentId) ? parentId : null;
    }

    if (ContextStore.get(CTX_STORE_NAME)) {
      throw new BaseError("Performance monitor is already initialized.");
    }
    return ContextStore.create(CTX_STORE_NAME, () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      if (parentId) {
        parentId = SectionId.create(parentId);
        ctxStore.set("parentId", parentId);
        ctxStore.set("traceLevel", parentId.getLevel() + 1);
      } else {
        ctxStore.set("parentId", null);
        ctxStore.set("traceLevel", 0);
      }
      if (emitters) {
        emitters.forEach(e => ctxStore.bindEmitter(e));
      }
      return fn();
    });
  }

  static async measureSection(name = null, attributes = {}, fn) {
    if (typeof name === "function") {
      fn = name;
      name = null;
      attributes = {};
    }
    if (name && typeof name === "object") {
      fn = attributes;
      attributes = name;
      name = null;
    }
    if (typeof attributes === "function") {
      fn = attributes;
      attributes = {};
    }

    let sectionWrapper = async () => {
      let section = Perflog._startMeasuredSection(name, attributes);
      try {
        let result = await fn(section);
        section.close();
        return result;
      } catch (e) {
        section.close();
        throw e;
      }
    };

    let ctxStore = ContextStore.get(CTX_STORE_NAME);
    if (ctxStore) {
      return ctxStore.fork(sectionWrapper);
    } else {
      return Perflog.initialize(sectionWrapper);
    }
  }

  static setSectionFilter(filter) {
    Config.set(SECTION_FILTER_PARAM, filter || ".*");
  }

  static _startMeasuredSection(name = null, attributes = {}) {
    if (name && typeof name === "object") {
      attributes = name;
      name = null;
    }
    let ctxStore = ContextStore.get(CTX_STORE_NAME);
    let traceLevel = ctxStore.get("traceLevel");
    let parentId = ctxStore.get("parentId");
    let sectionId;
    let isTraceable;
    if (parentId) {
      isTraceable = Perflog._isTraceable(name, parentId.getLevel() + 1, traceLevel);
      sectionId = isTraceable ? new SectionId(parentId.getTraceId(), parentId.getId(), parentId.getLevel()) : parentId;
    } else {
      sectionId = new SectionId(null, null);
      isTraceable = Perflog._isTraceable(name, sectionId.getLevel(), traceLevel);
    }
    if (isTraceable) {
      ctxStore.set("parentId", sectionId);
    }
    return new Section(sectionId, name, attributes, isTraceable);
  }

  static _isTraceable(name, level, traceLevel) {
    if (level <= traceLevel) {
      return true;
    }
    if (Logger.isVerbose()) {
      let regexp = new RegExp(Config.get(SECTION_FILTER_PARAM) || ".*");
      return regexp.test(name);
    }
    return false;
  }
}

module.exports = Perflog;
