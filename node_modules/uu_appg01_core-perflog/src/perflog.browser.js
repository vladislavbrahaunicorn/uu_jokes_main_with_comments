"use strict";

const Fingerprint = require("fingerprintjs");
const { ContextStore, Config } = require("uu_appg01_core-utils");
const Section = require("./section.js");
const SectionId = require("./section-id.js");
const Logger = require("./logger.js");

const CTX_STORE_NAME = "uuapp.perflog";
const SECTION_FILTER_PARAM = "uuapp.perflog.section_filter";
// Browser trace id is based on fingerprint (to identify all
// requests from same client).
const TRACE_ID = Number(new Fingerprint({ canvas: true }).get()).toString(16);

class Perflog {
  // In browser, section nesting is not supported

  static initialize(parentId = null, fn) {
    if (typeof parentId === "function") {
      fn = parentId;
      parentId = null;
    }
    return ContextStore.create(CTX_STORE_NAME, () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      if (parentId) {
        parentId = SectionId.create(parentId);
      } else {
        parentId = parentId = SectionId.create(TRACE_ID, TRACE_ID);
      }
      ctxStore.set("parentId", parentId);
      return fn();
    });
  }

  static measureSection(name = null, attributes = {}, fn) {
    if (typeof name === "function") {
      fn = name;
      name = null;
      attributes = {};
    }
    if (typeof name === "object") {
      fn = attributes;
      attributes = name;
      name = null;
    }
    if (typeof attributes === "function") {
      fn = attributes;
      attributes = {};
    }

    let sectionWrapper = async () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      let parentId = ctxStore.get("parentId");
      // Section is logged in case verbose logging is enabled or
      // if section matches filter regular expression.
      let isTraceable = Perflog._isTraceable(name);
      // In browser all sections have level 0 (they are not nested).
      let sectionId = isTraceable ? new SectionId(parentId.getTraceId(), parentId.getId(), -1) : parentId;
      let section = new Section(sectionId, name, attributes, isTraceable);
      try {
        let result = await fn(section);
        section.close();
        return result;
      } catch (e) {
        section.close();
        throw e;
      }
    };

    let ctxStore = ContextStore.get(CTX_STORE_NAME);
    if (ctxStore) {
      return ctxStore.fork(sectionWrapper);
    } else {
      return Perflog.initialize(sectionWrapper);
    }
  }

  static setSectionFilter(filter) {
    Config.set(SECTION_FILTER_PARAM, filter || ".*");
  }

  static _isTraceable(name) {
    if (Logger.isVerbose()) {
      return true;
    } else {
      let secFilter = Config.get(SECTION_FILTER_PARAM);
      if (secFilter) {
        return new RegExp(secFilter).test(name);
      } else {
        return false;
      }
    }
  }
}

module.exports = Perflog;
