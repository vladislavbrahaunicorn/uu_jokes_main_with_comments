"use strict";

const Logger = require("./logger.js");

const NS_PER_SEC = 1e9;

/**
 * Object provided by {UuApp::Perflog} representing
 * measured section.
 */
class Section {
  /**
   * Creates new instance of section.
   * @param id Section ID.
   * @param name Section name.
   * @param attributes Section attributes.
   * @param traceable Flag if section is traceable
   *   and thus should be visible in performance log.
   */
  constructor(id, name, attributes, traceable) {
    this._id = id;
    this._name = name || "";
    this._attributes = attributes || {};
    this._traceable = traceable;
    this._checkpoints = {};
    this._start = new Date();
    this._startRaw = process.hrtime();
  }

  /**
   * Section ID.
   * @returns {*} Section ID.
   */
  getId() {
    return this._id;
  }

  /**
   * User defined section name.
   * @returns {*} User defined section name.
   */
  getName() {
    return this._name;
  }

  /**
   * Sets user defined section attribute.
   * @param name Attribute name.
   * @param value Attribute value.
   */
  setAttribute(name, value) {
    this.getAttributes()[name] = value;
  }

  /**
   * User defined section attributes.
   * @returns {*|{}} User defined section attributes.
   */
  getAttributes() {
    return this._attributes;
  }

  /**
   * Returns user defined section attribute.
   * @param name Attribute name.
   * @returns {*} Attribute value.
   */
  getAttribute(name) {
    return this.getAttributes()[name];
  }

  /**
   * Sets section checkpoint (important milestone of section processing
   * which is not important enough to create nested measured section).
   * Name of checkpoint must be unique in scope of section.
   * @param name Checkpoint name.
   */
  setCheckpoint(name) {
    let diff = process.hrtime(this._startRaw);
    this._checkpoints[name] = Math.round(diff[0] * NS_PER_SEC + diff[1]);
  }

  /**
   * Set of currently processed checkpoints. Returned as
   * object where key is checkpont name, value is duration
   * (in nanoseconds) elapsed from section start.
   * @returns {{}|*} Processed checkpoints.
   */
  getCheckpoints() {
    return this._checkpoints;
  }

  /**
   * Returns duration of particular checkpoint (in nanoseconds).
   * @param name Checkpoint name
   * @returns {number|*} Checkpoint duration.
   */
  getCheckpoint(name) {
    return this.getCheckpoints()[name];
  }

  /**
   * Section start time.
   * @returns {Date} Section start time.
   */
  getStart() {
    return this._start;
  }

  /**
   * Section finish time. Returns null until section is closed.
   * @returns {Date} Section finish time.
   */
  getFinish() {
    return this._finish;
  }

  /**
   * Section duration (in nanoseconds). Returns null until
   * section is closed.
   * @returns {number|*} Section duration.
   */
  getDuration() {
    return this._duration;
  }

  /**
   * Closes section and publishes section data via Perflog logger
   * (based on Perflog logger verbosity configuration).
   */
  close() {
    if (this._finish) {
      return;
    }
    this._finish = new Date();
    let diff = process.hrtime(this._startRaw);
    this._duration = Math.round(diff[0] * NS_PER_SEC + diff[1]);
    if (this._traceable) {
      Logger.log(this);
    }
  }
}

module.exports = Section;
