"use strict";

const { Config, OptsReader } = require("uu_appg01_core-utils");
const Fs = require("fs");
const Logger = require("./logger.js");

const DEFAULT_SAMPLE_RATE = 1;
const DEFAULT_MAX_SAMPLES = 60;
const DEFAULT_CPU_LOAD_DELTA = 5;
const DEFAULT_MEM_USAGE_DELTA = 10;
const CPU_USAGE = "/sys/fs/cgroup/cpuacct/cpuacct.usage";
const MEM_USAGE = "/sys/fs/cgroup/memory/memory.usage_in_bytes";
const MEM_LIMIT = "/sys/fs/cgroup/memory/memory.limit_in_bytes";
const MEM_STAT = "/sys/fs/cgroup/memory/memory.stat";

class Provider {
  constructor(opts) {
    let config = new OptsReader(opts, Config);
    this.enabled = config.getBoolean("uuapp.sysmon.enabled", true);
    this.sampleRate = config.getNumber("uuapp.sysmon.sample_rate", DEFAULT_SAMPLE_RATE);
    this.maxSamples = config.getNumber("uuapp.sysmon.max_samples", DEFAULT_MAX_SAMPLES);
    this.cpuLoadDeltaLimit = config.getNumber("uuapp.sysmon.cpu_load_delta_limit", DEFAULT_CPU_LOAD_DELTA);
    this.memUsageDeltaLimit = config.getNumber("uuapp.sysmon.mem_usage_delta_limit", DEFAULT_MEM_USAGE_DELTA);

    this._prevCpuLoad = 0;
    this._prevCpuUsage = -1;
    this._prevMemUsage = -1;
    this._sampleCount = 0;
    this._cpuUsage = -1;
    this._cpuLoad = -1;
    this._cpuLoadDelta = -1;
    this._memUsage = -1;
    this._memUsageDelta = -1;
    this._memLimit = -1;
    this._pageCache = -1;
    this._rss = -1;

    this._capture();
  }

  startCollecting() {
    this._interval = setInterval(() => this._capture(), this.sampleRate * 1000);
  }

  stopCollecting() {
    clearInterval(this._interval);
  }

  async isSupported() {
    // cache support
    let isSupported = false;
    if (isSupported) return true;

    // wrap callback based FS functions in a promise
    return new Promise((resolve, reject) => {
      // use done() to check if all callbacks were called
      let count = 0;
      function done(err) {
        if (err) resolve(false);
        count++;
        if (count === 4) {
          isSupported = true;
          resolve(true);
        }
      }

      // check file existence asynchronously in parallel
      Fs.access(CPU_USAGE, done);
      Fs.access(MEM_USAGE, done);
      Fs.access(MEM_LIMIT, done);
      Fs.access(MEM_STAT, done);
    });
  }

  statistics() {
    let res = {};
    if (this.enabled) {
      res.cpuLoad = this._cpuLoad;
      res.cpuLoadDelta = this._cpuLoadDelta;
      res.memUsage = this._memUsage;
      res.memUsageDelta = this._memUsageDelta;
      res.memLimit = this._memLimit;
      res.pageCache = this._pageCache;
      res.rss = this._rss;
    } else {
      res.cpuLoad = -1;
      res.cpuLoadDelta = -1;
      res.memUsage = -1;
      res.memUsageDelta = -1;
      res.memLimit = -1;
      res.pageCache = -1;
      res.rss = -1;
    }
    return res;
  }

  async _capture() {
    if (!this.enabled) return;

    let [cpuUsage, memUsage, memLimit, pageCache, rss] = await this._readData();

    // exit from capture (do not rewrite last data) if any of the metrics is missing
    if (!(cpuUsage && memUsage && memLimit && pageCache && rss)) return;

    [this._cpuUsage, this._memUsage, this._memLimit, this._pageCache, this._rss] = [
      cpuUsage,
      memUsage,
      memLimit,
      pageCache,
      rss
    ];
    if (this._prevCpuUsage < 0) {
      this._prevCpuUsage = this._cpuUsage;
    }
    this._cpuLoad = Math.round((this._cpuUsage - this._prevCpuUsage) / 10000000);
    this._cpuLoadDelta = Math.abs(this._cpuLoad - this._prevCpuLoad);
    this._prevCpuUsage = this._cpuUsage;
    this._prevCpuLoad = this._cpuLoad;
    this._memUsageDelta = Math.abs(Math.round(this._memUsage / 1048576 - this._prevMemUsage / 1048576));
    this._prevMemUsage = this._memUsage;
    this._sampleCount++;

    if (!Logger.isEnabled()) return;
    if (
      this._memUsageDelta > this.memUsageDeltaLimit ||
      this._cpuLoadDelta > this.cpuLoadDeltaLimit ||
      this._sampleCount > this.maxSamples
    ) {
      if (await this.isSupported()) Logger.log(await this.statistics());
      this._sampleCount = 0;
    }
  }

  async _readData() {
    if (!(await this.isSupported())) {
      return [-1, -1, -1, -1, -1];
    }

    let cpuUsage, memUsage, memLimit, pageCache, rss;

    // wrap callback based FS functions in a promise
    return new Promise((resolve, reject) => {
      // use done() to check if all files were read
      let count = 0;
      function done(err) {
        if (err) reject(err);
        count++;
        if (count === 4) {
          resolve([cpuUsage, memUsage, memLimit, pageCache, rss]);
        }
      }

      // read files in parallel
      Fs.readFile(CPU_USAGE, "utf8", (err, data) => {
        if (err) return done(err);
        if (data) cpuUsage = parseInt(data.trim());
        done();
      });
      Fs.readFile(MEM_USAGE, "utf8", (err, data) => {
        if (err) return done(err);
        if (data) memUsage = parseInt(data.trim());
        done();
      });
      Fs.readFile(MEM_LIMIT, "utf8", (err, data) => {
        if (err) return done(err);
        if (data) memLimit = parseInt(data.trim());
        done();
      });
      Fs.readFile(MEM_STAT, "utf8", (err, data) => {
        if (err) return done(err);
        if (data) {
          let found = data.match(/^cache[ \t]+(\d+)/m);
          pageCache = found ? parseInt(found[1].trim()) : -1;

          found = data.match(/^rss[ \t]+(\d+)/m);
          rss = found ? parseInt(found[1].trim()) : -1;
        }
        done();
      });
    });
  }
}

module.exports = Provider;
