"use strict";

const BaseMessageFormatter = require("uu_appg01_core-logging").MessageFormatter;

const DEFAULT_MESSAGE_FORMAT =
  '[%d] PRFLG {"id":"%i","name":"%n","attributes":%a,"checkpoints":%c,"start":"%t","duration":"%D"}';

/**
 * Default log message formatter used by Perflog logger.
 */
class MessageFormatter extends BaseMessageFormatter {
  constructor() {
    super(DEFAULT_MESSAGE_FORMAT, null, null);
  }

  /**
   * Sets format of performance log message. Following tags are supported:
   * * <b>%%</b> - Escaped percent tag.
   * * <b>%a</b> - Section attributes in JSON format.
   * * <b>%c</b> - Section checkpoints in JSON format.
   * * <b>%C</b> - Full logger MDC in JSON format.
   * * <b>%d</b> - Date and time.
   * * <b>%D</b> - Section duration in nanos.
   * * <b>%f</b> - Section finish date and time.
   * * <b>%i</b> - Section ID.
   * * <b>%n</b> - Section name.
   * * <b>%t</b> - Section start date and time.
   * * <b>%{ KEY }a</b> - Section attribute with name KEY.
   * * <b>%{ KEY }c</b> - Duration of particular checkpoint with name KEY.
   * * <b>%{ KEY }C</b> - Custom attribute from logger MDC with name KEY.
   * * <b>%{ FMT }d</b> - Date and time in format matching FMT.
   * * <b>%{ FMT }f</b> - Section finish date and time in format matching FMT.
   * * <b>%{ ELM }i</b> - Section ID part, ELM = trace|parent|child|level.
   * * <b>%{ FMT }t</b> - Section start date and time in format matching FMT.
   * @param messageFormat Message format.
   */
  setMessageFormat(messageFormat) {
    super.setMessageFormat(messageFormat);
  }

  _processMessageFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "a":
        if (opts) {
          // TODO Format date if needed
          result = `message.getAttribute("${opts}")`;
        } else {
          result = "JSON.stringify(message.getAttributes())";
        }
        break;
      case "c":
        if (opts) {
          result = `message.getCheckpoint("${opts}")`;
        } else {
          result = "JSON.stringify(message.getCheckpoints())";
        }
        break;
      case "C":
        if (opts) {
          // TODO Format date if needed
          result = `LoggerMDC.get("${opts}")`;
        } else {
          result = "LoggerMDC.toJson()";
        }
        break;
      case "d":
        // TODO Format date
        result = "datetime.toISOString()";
        break;
      case "D":
        result = "message.getDuration()";
        break;
      case "f":
        // TODO Format date
        result = "message.getFinish() ? message.getFinish().toISOString() : null";
        break;
      case "i":
        switch (opts) {
          case /trace/i:
            result = "message.getId().getTraceId()";
            break;
          case /parent/i:
            result = "message.getId().getParentId()";
            break;
          case /child/i:
            result = "message.getId().getId()";
            break;
          case /level/i:
            result = "message.getLevel()";
            break;
          default:
            result = "message.getId().toString()";
        }
        break;
      case "I":
        // TODO Thread ID
        result = '"-"';
        break;
      case "n":
        result = "message.getName()";
        break;
      case "t":
        // TODO Format date
        result = "message.getStart().toISOString()";
        break;
    }
    return result;
  }
}

module.exports = MessageFormatter;
