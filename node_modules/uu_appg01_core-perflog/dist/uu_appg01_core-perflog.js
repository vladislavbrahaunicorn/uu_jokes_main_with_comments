/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core-utils"), require("uu_appg01_core-logging"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core-perflog", ["module", "uu_appg01_core-utils", "uu_appg01_core-logging"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core-perflog"] = factory(require("module"), require("uu_appg01_core-utils"), require("uu_appg01_core-logging"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["Perflog"] = factory(root["undefined"], root["UuApp.Utils"], root["UuApp.Logging"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__6__, __WEBPACK_EXTERNAL_MODULE__9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/4.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/4.7.2/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  Perflog: __webpack_require__(4),
  Section: __webpack_require__(7),
  SectionId: __webpack_require__(11),
  Logger: __webpack_require__(8),
  MessageFormatter: __webpack_require__(10)
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Fingerprint = __webpack_require__(5);

var _require = __webpack_require__(6),
    ContextStore = _require.ContextStore,
    Config = _require.Config;

var Section = __webpack_require__(7);

var SectionId = __webpack_require__(11);

var Logger = __webpack_require__(8);

var CTX_STORE_NAME = "uuapp.perflog";
var SECTION_FILTER_PARAM = "uuapp.perflog.section_filter"; // Browser trace id is based on fingerprint (to identify all
// requests from same client).

var TRACE_ID = Number(new Fingerprint({
  canvas: true
}).get()).toString(16);

var Perflog = /*#__PURE__*/function () {
  function Perflog() {
    _classCallCheck(this, Perflog);
  }

  _createClass(Perflog, null, [{
    key: "initialize",
    // In browser, section nesting is not supported
    value: function initialize() {
      var parentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var fn = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof parentId === "function") {
        fn = parentId;
        parentId = null;
      }

      return ContextStore.create(CTX_STORE_NAME, function () {
        var ctxStore = ContextStore.get(CTX_STORE_NAME);

        if (parentId) {
          parentId = SectionId.create(parentId);
        } else {
          parentId = parentId = SectionId.create(TRACE_ID, TRACE_ID);
        }

        ctxStore.set("parentId", parentId);
        return fn();
      });
    }
  }, {
    key: "measureSection",
    value: function measureSection() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var fn = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof name === "function") {
        fn = name;
        name = null;
        attributes = {};
      }

      if (_typeof(name) === "object") {
        fn = attributes;
        attributes = name;
        name = null;
      }

      if (typeof attributes === "function") {
        fn = attributes;
        attributes = {};
      }

      var sectionWrapper = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var ctxStore, parentId, isTraceable, sectionId, section, result;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  ctxStore = ContextStore.get(CTX_STORE_NAME);
                  parentId = ctxStore.get("parentId"); // Section is logged in case verbose logging is enabled or
                  // if section matches filter regular expression.

                  isTraceable = Perflog._isTraceable(name); // In browser all sections have level 0 (they are not nested).

                  sectionId = isTraceable ? new SectionId(parentId.getTraceId(), parentId.getId(), -1) : parentId;
                  section = new Section(sectionId, name, attributes, isTraceable);
                  _context.prev = 5;
                  _context.next = 8;
                  return fn(section);

                case 8:
                  result = _context.sent;
                  section.close();
                  return _context.abrupt("return", result);

                case 13:
                  _context.prev = 13;
                  _context.t0 = _context["catch"](5);
                  section.close();
                  throw _context.t0;

                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[5, 13]]);
        }));

        return function sectionWrapper() {
          return _ref.apply(this, arguments);
        };
      }();

      var ctxStore = ContextStore.get(CTX_STORE_NAME);

      if (ctxStore) {
        return ctxStore.fork(sectionWrapper);
      } else {
        return Perflog.initialize(sectionWrapper);
      }
    }
  }, {
    key: "setSectionFilter",
    value: function setSectionFilter(filter) {
      Config.set(SECTION_FILTER_PARAM, filter || ".*");
    }
  }, {
    key: "_isTraceable",
    value: function _isTraceable(name) {
      if (Logger.isVerbose()) {
        return true;
      } else {
        var secFilter = Config.get(SECTION_FILTER_PARAM);

        if (secFilter) {
          return new RegExp(secFilter).test(name);
        } else {
          return false;
        }
      }
    }
  }]);

  return Perflog;
}();

module.exports = Perflog;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* fingerprintJS 0.5.3 - Fast browser fingerprint library
* https://github.com/Valve/fingerprintjs
* Copyright (c) 2013 Valentin Vasilyev (valentin.vasilyev@outlook.com)
* Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
*/

;(function (name, context, definition) {
  if ( true && module.exports) { module.exports = definition(); }
  else if (true) { !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); }
  else {}
})('Fingerprint', this, function () {
  'use strict';
  
  var Fingerprint = function (options) {
    var nativeForEach, nativeMap;
    nativeForEach = Array.prototype.forEach;
    nativeMap = Array.prototype.map;

    this.each = function (obj, iterator, context) {
      if (obj === null) {
        return;
      }
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === {}) return;
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (iterator.call(context, obj[key], key, obj) === {}) return;
          }
        }
      }
    };

    this.map = function(obj, iterator, context) {
      var results = [];
      // Not using strict equality so that this acts as a
      // shortcut to checking for `null` and `undefined`.
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      this.each(obj, function(value, index, list) {
        results[results.length] = iterator.call(context, value, index, list);
      });
      return results;
    };

    if (typeof options == 'object'){
      this.hasher = options.hasher;
      this.screen_resolution = options.screen_resolution;
      this.canvas = options.canvas;
      this.ie_activex = options.ie_activex;
    } else if(typeof options == 'function'){
      this.hasher = options;
    }
  };

  Fingerprint.prototype = {
    get: function(){
      var keys = [];
      keys.push(navigator.userAgent);
      keys.push(navigator.language);
      keys.push(screen.colorDepth);
      if (this.screen_resolution) {
        var resolution = this.getScreenResolution();
        if (typeof resolution !== 'undefined'){ // headless browsers, such as phantomjs
          keys.push(this.getScreenResolution().join('x'));
        }
      }
      keys.push(new Date().getTimezoneOffset());
      keys.push(this.hasSessionStorage());
      keys.push(this.hasLocalStorage());
      keys.push(!!window.indexedDB);
      //body might not be defined at this point or removed programmatically
      if(document.body){
        keys.push(typeof(document.body.addBehavior));
      } else {
        keys.push(typeof undefined);
      }
      keys.push(typeof(window.openDatabase));
      keys.push(navigator.cpuClass);
      keys.push(navigator.platform);
      keys.push(navigator.doNotTrack);
      keys.push(this.getPluginsString());
      if(this.canvas && this.isCanvasSupported()){
        keys.push(this.getCanvasFingerprint());
      }
      if(this.hasher){
        return this.hasher(keys.join('###'), 31);
      } else {
        return this.murmurhash3_32_gc(keys.join('###'), 31);
      }
    },

    /**
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     * 
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     * 
     * @param {string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash 
     */

    murmurhash3_32_gc: function(key, seed) {
      var remainder, bytes, h1, h1b, c1, c2, k1, i;
      
      remainder = key.length & 3; // key.length % 4
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;
      
      while (i < bytes) {
          k1 = 
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;
        
        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
            h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
      }
      
      k1 = 0;
      
      switch (remainder) {
        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1: k1 ^= (key.charCodeAt(i) & 0xff);
        
        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= k1;
      }
      
      h1 ^= key.length;

      h1 ^= h1 >>> 16;
      h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
      h1 ^= h1 >>> 16;

      return h1 >>> 0;
    },

    // https://bugzilla.mozilla.org/show_bug.cgi?id=781447
    hasLocalStorage: function () {
      try{
        return !!window.localStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it exists
      }
    },
    
    hasSessionStorage: function () {
      try{
        return !!window.sessionStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it exists
      }
    },

    isCanvasSupported: function () {
      var elem = document.createElement('canvas');
      return !!(elem.getContext && elem.getContext('2d'));
    },

    isIE: function () {
      if(navigator.appName === 'Microsoft Internet Explorer') {
        return true;
      } else if(navigator.appName === 'Netscape' && /Trident/.test(navigator.userAgent)){// IE 11
        return true;
      }
      return false;
    },

    getPluginsString: function () {
      if(this.isIE() && this.ie_activex){
        return this.getIEPluginsString();
      } else {
        return this.getRegularPluginsString();
      }
    },

    getRegularPluginsString: function () {
      return this.map(navigator.plugins, function (p) {
        var mimeTypes = this.map(p, function(mt){
          return [mt.type, mt.suffixes].join('~');
        }).join(',');
        return [p.name, p.description, mimeTypes].join('::');
      }, this).join(';');
    },

    getIEPluginsString: function () {
      if(window.ActiveXObject){
        var names = ['ShockwaveFlash.ShockwaveFlash',//flash plugin
          'AcroPDF.PDF', // Adobe PDF reader 7+
          'PDF.PdfCtrl', // Adobe PDF reader 6 and earlier, brrr
          'QuickTime.QuickTime', // QuickTime
          // 5 versions of real players
          'rmocx.RealPlayer G2 Control',
          'rmocx.RealPlayer G2 Control.1',
          'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)',
          'RealVideo.RealVideo(tm) ActiveX Control (32-bit)',
          'RealPlayer',
          'SWCtl.SWCtl', // ShockWave player
          'WMPlayer.OCX', // Windows media player
          'AgControl.AgControl', // Silverlight
          'Skype.Detection'];
          
        // starting to detect plugins in IE
        return this.map(names, function(name){
          try{
            new ActiveXObject(name);
            return name;
          } catch(e){
            return null;
          }
        }).join(';');
      } else {
        return ""; // behavior prior version 0.5.0, not breaking backwards compat.
      }
    },

    getScreenResolution: function () {
      return [screen.height, screen.width];
    },

    getCanvasFingerprint: function () {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      // https://www.browserleaks.com/canvas#how-does-it-work
      var txt = 'http://valve.github.io';
      ctx.textBaseline = "top";
      ctx.font = "14px 'Arial'";
      ctx.textBaseline = "alphabetic";
      ctx.fillStyle = "#f60";
      ctx.fillRect(125,1,62,20);
      ctx.fillStyle = "#069";
      ctx.fillText(txt, 2, 15);
      ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
      ctx.fillText(txt, 4, 17);
      return canvas.toDataURL();
    }
  };


  return Fingerprint;

});


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Logger = __webpack_require__(8);
/**
 * Object provided by {UuApp::Perflog} representing
 * measured section.
 */


var Section = /*#__PURE__*/function () {
  /**
   * Creates new instance of section.
   * @param id Section ID.
   * @param name Section name.
   * @param attributes Section attributes.
   * @param traceable Flag if section is traceable
   *   and thus should be visible in performance log.
   */
  function Section(id, name, attributes, traceable) {
    _classCallCheck(this, Section);

    this._id = id;
    this._name = name || "";
    this._attributes = attributes || {};
    this._traceable = traceable;
    this._checkpoints = {};
    this._start = new Date();
    this._startRaw = window.performance.now();
  }
  /**
   * Section ID.
   * @returns {*} Section ID.
   */


  _createClass(Section, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }
    /**
     * User defined section name.
     * @returns {*} User defined section name.
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * Sets user defined section attribute.
     * @param name Attribute name.
     * @param value Attribute value.
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      this.getAttributes()[name] = value;
    }
    /**
     * User defined section attributes.
     * @returns {*|{}} User defined section attributes.
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this._attributes;
    }
    /**
     * Returns user defined section attribute.
     * @param name Attribute name.
     * @returns {*} Attribute value.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.getAttributes()[name];
    }
    /**
     * Sets section checkpoint (important milestone of section processing
     * which is not important enough to create nested measured section).
     * Name of checkpoint must be unique in scope of section.
     * @param name Checkpoint name.
     */

  }, {
    key: "setCheckpoint",
    value: function setCheckpoint(name) {
      this._checkpoints[name] = Math.round((window.performance.now() - this._startRaw) * 1000000);
    }
    /**
     * Set of currently processed checkpoints. Returned as
     * object where key is checkpont name, value is duration
     * (in nanoseconds) elapsed from section start.
     * @returns {{}|*} Processed checkpoints.
     */

  }, {
    key: "getCheckpoints",
    value: function getCheckpoints() {
      return this._checkpoints;
    }
    /**
     * Returns duration of particular checkpoint (in nanoseconds).
     * @param name Checkpoint name
     * @returns {number|*} Checkpoint duration.
     */

  }, {
    key: "getCheckpoint",
    value: function getCheckpoint(name) {
      return this.getCheckpoints()[name];
    }
    /**
     * Section start time.
     * @returns {Date} Section start time.
     */

  }, {
    key: "getStart",
    value: function getStart() {
      return this._start;
    }
    /**
     * Section finish time. Returns null until section is closed.
     * @returns {Date} Section finish time.
     */

  }, {
    key: "getFinish",
    value: function getFinish() {
      return this._finish;
    }
    /**
     * Section duration (in nanoseconds). Returns null until
     * section is closed.
     * @returns {number|*} Section duration.
     */

  }, {
    key: "getDuration",
    value: function getDuration() {
      return this._duration;
    }
    /**
     * Closes section and publishes section data via Perflog logger
     * (based on Perflog logger verbosity configuration).
     */

  }, {
    key: "close",
    value: function close() {
      if (this._finish) {
        return;
      }

      this._finish = new Date();
      this._duration = Math.round((window.performance.now() - this._startRaw) * 1000000);

      if (this._traceable) {
        Logger.log(this);
      }
    }
  }]);

  return Section;
}();

module.exports = Section;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(6),
    Config = _require.Config;

var LoggerFactory = __webpack_require__(9).LoggerFactory;

var BaseLogger = __webpack_require__(9).Logger;

var LogLevel = __webpack_require__(9).LogLevel;

var MessageFormatter = __webpack_require__(10);

var LOGGER_NAME = "UuApp.Perflog.Logger";
/**
 * Logger component internally used by Perflog for providing gathered performance
 * statistics data. Logger is transparently managed via LoggerFactory and
 * therefore supports external configuration via following configuration parameters:
 *
 * * <b>uuapp.perflog.logger.log_level</b><br>
 *   Defines log level. Level can be defined either via name, or its numeric representation. Defaults to +INFO+.
 *
 * * <b>uuapp.perflog.logger.log_message_format</b><br>
 *   Allows to define custom message format. See {UuApp::Perflog::MessageFormatter#message_format} for details.
 */

var Logger = /*#__PURE__*/function () {
  function Logger() {
    _classCallCheck(this, Logger);
  }

  _createClass(Logger, null, [{
    key: "setMessageFormat",

    /**
     * Overrides default message format.
     * @param messageFormat Format string.
     */
    value: function setMessageFormat(messageFormat) {
      Logger._getLogger().setMessageFormat(messageFormat);
    }
    /**
     * Logging severity threshold. Possible values are:
     # * OFF - Logger is disabled.
     # * INFO - Logger logs data of first level measured sections only.
     # * DEBUG - Logger logs data of all measured sections.
     * @param level Log level.
     */

  }, {
    key: "setLevel",
    value: function setLevel(level) {
      Logger._getLogger().setLevel(level);
    }
    /**
     * Checks if performance log is enabled (log level is set to anything other than "OFF").
     * @returns {boolean} True if log is enabled, else false.
     */

  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return Logger._getLogger().getLevel() < LogLevel.OFF;
    }
    /**
     * Checks verbosity of performance log. If log is in verbose mode (log
     * level is set to "DEBUG") it prints data of all measured sections. Else
     * it logs only first level sections.
     * @returns {boolean} True if perfomance log is in verbose mode, else false.
     */

  }, {
    key: "isVerbose",
    value: function isVerbose() {
      return Logger._getLogger().getLevel() < LogLevel.INFO;
    }
    /**
     * Transforms given section to log message and prints it.
     * @param section Section to be logged.
     */

  }, {
    key: "log",
    value: function log(section) {
      if (!section) {
        return;
      }

      Logger._getLogger().log(section);
    }
  }, {
    key: "_getLogger",
    value: function _getLogger() {
      if (!this._logger) {
        var logger = new BaseLogger(LOGGER_NAME);

        if (!Config.get("".concat(LOGGER_NAME.toLowerCase(), ".log_level"), false)) {
          Config.set("".concat(LOGGER_NAME.toLowerCase(), ".log_level"), "INFO");
        } // TODO Should be settable via Logger API


        logger._formatter = new MessageFormatter();
        LoggerFactory.configure(logger, false);
        this._logger = logger;
      }

      return this._logger;
    }
  }]);

  return Logger;
}();

module.exports = Logger;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9__;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var BaseMessageFormatter = __webpack_require__(9).MessageFormatter;

var DEFAULT_MESSAGE_FORMAT = '[%d] PRFLG {"id":"%i","name":"%n","attributes":%a,"checkpoints":%c,"start":"%t","duration":"%D"}';
/**
 * Default log message formatter used by Perflog logger.
 */

var MessageFormatter = /*#__PURE__*/function (_BaseMessageFormatter) {
  _inherits(MessageFormatter, _BaseMessageFormatter);

  var _super = _createSuper(MessageFormatter);

  function MessageFormatter() {
    _classCallCheck(this, MessageFormatter);

    return _super.call(this, DEFAULT_MESSAGE_FORMAT, null, null);
  }
  /**
   * Sets format of performance log message. Following tags are supported:
   * * <b>%%</b> - Escaped percent tag.
   * * <b>%a</b> - Section attributes in JSON format.
   * * <b>%c</b> - Section checkpoints in JSON format.
   * * <b>%C</b> - Full logger MDC in JSON format.
   * * <b>%d</b> - Date and time.
   * * <b>%D</b> - Section duration in nanos.
   * * <b>%f</b> - Section finish date and time.
   * * <b>%i</b> - Section ID.
   * * <b>%n</b> - Section name.
   * * <b>%t</b> - Section start date and time.
   * * <b>%{ KEY }a</b> - Section attribute with name KEY.
   * * <b>%{ KEY }c</b> - Duration of particular checkpoint with name KEY.
   * * <b>%{ KEY }C</b> - Custom attribute from logger MDC with name KEY.
   * * <b>%{ FMT }d</b> - Date and time in format matching FMT.
   * * <b>%{ FMT }f</b> - Section finish date and time in format matching FMT.
   * * <b>%{ ELM }i</b> - Section ID part, ELM = trace|parent|child|level.
   * * <b>%{ FMT }t</b> - Section start date and time in format matching FMT.
   * @param messageFormat Message format.
   */


  _createClass(MessageFormatter, [{
    key: "setMessageFormat",
    value: function setMessageFormat(messageFormat) {
      _get(_getPrototypeOf(MessageFormatter.prototype), "setMessageFormat", this).call(this, messageFormat);
    }
  }, {
    key: "_processMessageFormatTag",
    value: function _processMessageFormatTag(tag, opts) {
      var result;

      switch (tag) {
        case "a":
          if (opts) {
            // TODO Format date if needed
            result = "message.getAttribute(\"".concat(opts, "\")");
          } else {
            result = "JSON.stringify(message.getAttributes())";
          }

          break;

        case "c":
          if (opts) {
            result = "message.getCheckpoint(\"".concat(opts, "\")");
          } else {
            result = "JSON.stringify(message.getCheckpoints())";
          }

          break;

        case "C":
          if (opts) {
            // TODO Format date if needed
            result = "LoggerMDC.get(\"".concat(opts, "\")");
          } else {
            result = "LoggerMDC.toJson()";
          }

          break;

        case "d":
          // TODO Format date
          result = "datetime.toISOString()";
          break;

        case "D":
          result = "message.getDuration()";
          break;

        case "f":
          // TODO Format date
          result = "message.getFinish() ? message.getFinish().toISOString() : null";
          break;

        case "i":
          switch (opts) {
            case /trace/i:
              result = "message.getId().getTraceId()";
              break;

            case /parent/i:
              result = "message.getId().getParentId()";
              break;

            case /child/i:
              result = "message.getId().getId()";
              break;

            case /level/i:
              result = "message.getLevel()";
              break;

            default:
              result = "message.getId().toString()";
          }

          break;

        case "I":
          // TODO Thread ID
          result = '"-"';
          break;

        case "n":
          result = "message.getName()";
          break;

        case "t":
          // TODO Format date
          result = "message.getStart().toISOString()";
          break;
      }

      return result;
    }
  }]);

  return MessageFormatter;
}(BaseMessageFormatter);

module.exports = MessageFormatter;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // TODO Generate trace ID based on fingerprint

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_ID_PREFIX = ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);
/**
 * Object representation of Perflog mesured section ID.
 */

var SectionId = /*#__PURE__*/function () {
  _createClass(SectionId, null, [{
    key: "create",

    /**
     * Creates new section ID from qualified section ID.
     * @param qualifiedId Qualified section ID.
     * @returns {SectionId} Section ID.
     */
    value: function create(qualifiedId) {
      var match;

      if (!qualifiedId) {
        return new SectionId(null, null);
      } else if (match = /^([^-]+)-([^-]+)-([^-]+)-([^-]+)$/.exec(qualifiedId.toString())) {
        return new SectionId(match[1], match[2], match[3], Number(match[4] || 0));
      } else {
        var traceId = qualifiedId.toString().replace(/-/g, "");
        return new SectionId(traceId, traceId);
      }
    }
    /**
     * Creates new section ID instance.
     * @param traceId Trace ID.
     * @param parentId Parent section ID.
     * @param childId Child section ID.
     * @param level Nesting level. In case childId
     *   is given, level is considered as "child level". In case
     *   childId is not set, level is considered as "parent
     *   level" and thus will be increased in new section ID.
     */

  }]);

  function SectionId(traceId, parentId) {
    var childId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, SectionId);

    if (typeof childId === "number") {
      level = childId;
      childId = null;
    }

    this._traceId = traceId || TRACE_ID_PREFIX + ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);
    this._parentId = parentId || this._traceId;
    this._id = childId || ("00000000" + Math.floor(Math.random() * 4294967295).toString(16)).slice(-8);

    if (typeof level === "number") {
      this._level = childId ? level : level + 1;
    } else {
      this._level = 0;
    }

    this._qualifiedId = "".concat(this._traceId, "-").concat(this._parentId, "-").concat(this._id, "-").concat(("0000" + this._level.toString()).slice(-4));
  }
  /**
   * Trace ID shared by all sections within request scope (spanned
   * across clients and servers). For root section this ID is same
   * as parent ID.
   * @returns {*|string} Trace ID.
   */


  _createClass(SectionId, [{
    key: "getTraceId",
    value: function getTraceId() {
      return this._traceId;
    }
    /**
     * ID of parent section. For root section this ID is same as
     * trace ID.
     * @returns {*|string} Parent ID.
     */

  }, {
    key: "getParentId",
    value: function getParentId() {
      return this._parentId;
    }
    /**
     * ID of current section. This ID will be used as parent ID for
     * all nested sections.
     * @returns {*|string} Child/section ID.
     */

  }, {
    key: "getId",
    value: function getId() {
      return this._id;
    }
    /**
     * Section nesting level. For root section level is 0.
     * @returns {*|number} Nesting level.
     */

  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._level;
    }
    /**
     * Returns formatted qualified section ID.
     * @returns {string} Formatted qualified section ID.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._qualifiedId;
    }
  }]);

  return SectionId;
}();

module.exports = SectionId;

/***/ })
/******/ ]);
});