"use strict";
const { BaseError } = require("uu_appg01_core-utils");
const EMPTY = {};

/**
 * @class UuApp.Uri.Uri
 * @classdesc
 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
 * Note that minimal Uri consists of at least "app" and "tid".
 *
 * Examples of usage:
 *
 *     // uri from parsing current location
 *     let locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
 *     let baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
 *     let callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
 *
 *     // uri from parsing
 *     let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase);
 *     let params = uri.parameters; // always returns new copy of parameter map
 *     for (let k in params) console.log(k, "=", params[k]); // p1 = v1
 *
 *     // uri from UriBuilder
 *     let uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
 *
 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
 *     // Note that query parameter values shouldn't be injected via template string as they might need
 *     // to be encoded first.
 *     let product = "vendor-app";
 *     let workspace = "tid-awid";
 *     let uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
 *
 * @see UuApp.Uri.UriBuilder
 */
class Uri {
  /**
   * New instance of URI should be created using {@link UuApp.Uri.Uri.parse}.
   * @private
   */
  constructor(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
    this._scheme = scheme;
    this._hostname = hostname;
    this._port = port;
    this._vendor = vendor;
    this._app = app;
    this._subApp = subApp;
    this._spp = spp;
    this._tid = tid;
    this._awid = awid;
    this._useCase = useCase;
    this._memory = {};

    this._useCase = useCase ? useCase.replace(/^\//, "") : useCase;
    if (this._port && typeof this._port !== "number") {
      this._port = parseInt(this._port + "", 10);
    }

    this._memory.gatewayValue = EMPTY;
    this._memory.productValue = EMPTY;
    this._memory.workspaceValue = EMPTY;
    this._memory.baseUriValue = undefined;
    this._memory.relativeUriValue = undefined;
    this._memory.strValue = undefined;
    this._paramsValue = Object.assign({}, parameters);

    Object.freeze(this);
  }

  /**
   * Returns string representation of URI.
   * @return {string}
   * @method UuApp.Uri.Uri#toString
   */
  toString() {
    if (this._memory.strValue !== undefined) {
      return this._memory.strValue;
    } else {
      this._memory.strValue = this.Builder.format(this);
      return this._memory.strValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#toString} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get href() {
    return this.toString();
  }

  toJSON() {
    return this.toString();
  }

  /**
   * Returns URI containing only mandatory routing data
   * (including only {#gateway}, {#product} and {#workspace}).
   * @throws {BaseError} In case URI does not contain all required parts.
   * @returns {UuApp.Uri.Uri}
   * @method UuApp.Uri.Uri#getBaseUri
   */
  getBaseUri() {
    if (this._memory.baseUriValue !== undefined) {
      return this._memory.baseUriValue;
    }
    if (this.getGateway() == null || this.getProduct() == null || this.getWorkspace() == null) {
      throw new BaseError(
        "Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + this.toString()
      );
    }
    this._memory.baseUri = this.Builder.parse(this)
      .set({ useCase: null })
      .clearParameters()
      .toUri();
    return this._memory.baseUri;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getBaseUri} for further information.
   * @private
   */
  get baseUri() {
    return this.getBaseUri();
  }

  /**
   * Returns URI without gateway part.
   * @returns {UuApp.Uri.Uri}
   * @method UuApp.Uri.Uri#getRelativeUri
   */
  getRelativeUri() {
    if (this._memory.relativeUriValue !== undefined) {
      return this._memory.relativeUriValue;
    }
    this._memory.relativeUriValue = this.Builder.parse(this)
      .set({ gateway: null })
      .toUri();
    return this._memory.relativeUriValue;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getRelativeUri} for further information.
   * @private
   */
  get relativeUri() {
    return this.getRelativeUri();
  }

  /**
   * Returns Pathname (String representation of URI without gateway and parameters).
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get pathname() {
    return this.Builder.parse(this)
      .set({ gateway: null })
      .clearParameters()
      .toString();
  }

  /**
   * Returns Gateway (formatted {#scheme}, {#hostname} and {#port})
   * @returns {string}
   * @method UuApp.Uri.Uri#getGateway
   */
  getGateway() {
    if (this._memory.gatewayValue !== EMPTY) {
      return this._memory.gatewayValue;
    } else {
      this._memory.gatewayValue = this.Builder.formatGateway(this._scheme, this._hostname, this._port);
      return this._memory.gatewayValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getGateway} for further information.
   * @private
   */
  get gateway() {
    return this.getGateway();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set gateway(attr) {
    this.throwOnSet(attr);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getGateway} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get origin() {
    return this.getGateway();
  }

  /**
   * Returns Product (formatted {#vendor}, {#app}, {#sub_app} and {#spp})
   * @returns {string}
   * @method UuApp.Uri.Uri#getProduct
   */
  getProduct() {
    if (this._memory.productValue !== EMPTY) {
      return this._memory.productValue;
    } else {
      this._memory.productValue = this.Builder.formatProduct(this._vendor, this._app, this._subApp, this._spp);
      return this._memory.productValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getProduct} for further information.
   * @private
   */
  get product() {
    return this.getProduct();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set product(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Workspace (formatted {#tid} and {#awid})
   * @returns {string}
   * @method UuApp.Uri.Uri#getWorkspace
   */
  getWorkspace() {
    if (this._memory.workspaceValue !== EMPTY) {
      return this._memory.workspaceValue;
    } else {
      this._memory.workspaceValue = this.Builder.formatWorkspace(this._tid, this._awid);
      return this._memory.workspaceValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getWorkspace} for further information.
   * @private
   */
  get workspace() {
    return this.getWorkspace();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set workspace(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Scheme
   * @returns {string}
   * @method UuApp.Uri.Uri#getScheme
   */
  getScheme() {
    return this._scheme;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getScheme} for further information.
   * @private
   */
  get scheme() {
    return this.getScheme();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set scheme(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Scheme with colon (:) on the end.
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get protocol() {
    return this.getScheme() + ":";
  }

  /**
   * Returns Hostname
   * @returns {string}
   * @method UuApp.Uri.Uri#getHostname
   */
  getHostname() {
    return this._hostname;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getHostname} for further information.
   * @private
   */
  get hostname() {
    return this.getHostname();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set hostname(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Host (formatted {#hostname} and {#port})
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get host() {
    return this.getHostname() + ":" + this.getPort();
  }

  /**
   * Returns Port
   * @returns {number}
   * @method UuApp.Uri.Uri#getPort
   */
  getPort() {
    if (this._port) {
      return this._port;
    }
    if (this._scheme) {
      return this._scheme.match(/^https$/) ? 443 : 80;
    }
    return null;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getPort} for further information.
   * @private
   */
  get port() {
    return this.getPort();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set port(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Vendor
   * @returns {string}
   * @method UuApp.Uri.Uri#getVendor
   */
  getVendor() {
    return this._vendor;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getVendor} for further information.
   * @private
   */
  get vendor() {
    return this.getVendor();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set vendor(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Application
   * @returns {string}
   * @method UuApp.Uri.Uri#getApp
   */
  getApp() {
    return this._app;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getApp} for further information.
   * @private
   */
  get app() {
    return this.getApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set app(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Sub-application
   * @returns {string}
   * @method UuApp.Uri.Uri#getSubApp
   */
  getSubApp() {
    return this._subApp;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getSubApp} for further information.
   * @private
   */
  get subApp() {
    return this.getSubApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set subApp(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns SPP
   * @returns {string}
   * @method UuApp.Uri.Uri#getSpp
   */
  getSpp() {
    return this._spp;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getSpp} for further information.
   * @private
   */
  get spp() {
    return this.getSpp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set spp(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Tenant ID
   * @returns {string}
   * @method UuApp.Uri.Uri#getTid
   */
  getTid() {
    return this._tid;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getTid} for further information.
   * @private
   */
  get tid() {
    return this.getTid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set tid(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Application workspace ID
   * @returns {string}
   * @method UuApp.Uri.Uri#getAwid
   */
  getAwid() {
    return this._awid;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getAwid} for further information.
   * @private
   */
  get awid() {
    return this.getAwid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set awid(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Use Case
   * @returns {string}
   * @method UuApp.Uri.Uri#getUseCase
   */
  getUseCase() {
    return this._useCase;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getUseCase} for further information.
   * @private
   */
  get useCase() {
    return this.getUseCase();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set useCase(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
   * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
   * therefore usage should look like this:
   *
   *     // OPTIMAL (single read of "parameters" field on uri)
   *     let params = uri.parameters;
   *     for (let k in params) console.log(params[k]);
   *
   *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
   *     // for (let k in uri.parameters) console.log(uri.parameters[k]);
   *
   * @method UuApp.Uri.Uri#getParameters
   */
  getParameters() {
    return Object.assign({}, this._paramsValue);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getParameters} for further information.
   * @private
   */
  get parameters() {
    return this.getParameters();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set parameters(attr) {
    this.throwOnSet(attr);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getParameters} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get searchParams() {
    return this.getParameters();
  }

  /**
   * Returns string representation of all URI parameters
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get search() {
    return this.Builder.formatParameters(this.getParameters());
  }

  /**
   * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
   * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
   * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
   *
   * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
   * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
   * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples).
   *
   * @param {...string} path Absolute or relative paths to replace / add.
   * @return New Uri whose path is the result of the join.
   * @method UuApp.Uri.Uri#join
   * @example
   *  // replace path with an absolute path (effectively removing also query parameters)
   *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
   *  let uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
   *
   *  // add relative paths
   *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
   *  let uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
   *  let uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
   *  let uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
   */
  join(/* ... */) {
    if (arguments.length <= 0) {
      return this;
    }
    let root = this.getGateway() || "";
    let path = this.toString().substr(root.length);

    for (let i = 0; i < arguments.length; ++i) {
      let pathPart = arguments[i];
      if (!pathPart) {
        continue;
      }
      path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
      pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
      if (pathPart.charAt(0) === "/") {
        path = pathPart;
      } // new path part is absolute => replace whole path
      else if (pathPart.match(/^\+(\/|$)/)) {
        path = path.replace(/\/?$/, "/") + pathPart;
      } // new path part is relative with "+/" => append "/" and then new path
      else if (path.charAt(path.length - 1) === "/") {
        path += pathPart;
      } // new path part is relative and current path is a "folder" => append new path
      else {
        path = path.replace(/(^|\/)[^/]*$/, "$1") + pathPart;
      } // new path part is relative and current path is not a "folder" => replace last segment of current path
    }

    // normalize (modify segments to eliminate "../" and "./" from the path)
    let segments = [];
    path.split("/").forEach(function(part) {
      if (part === "..") {
        segments.pop();
      } else if (part !== "." && part !== "+") {
        segments.push(part);
      }
    });
    if (segments[0] !== "") {
      segments.unshift("");
    } // make sure that after "join" operation the path starts with "/"
    let resultPath = segments.join("/");
    return Uri.parse(root + resultPath);
  }

  throwOnSet(attr) {
    throw new BaseError(
      "Cannot set " + attr + "on Uri because instances of Uri are immutable. Use UriBuilder instead."
    );
  }

  /**
   * Checks whether the other URI is equal to this one and returns true iff it is.
   *
   * @param {UuApp.Uri.Uri} uri Uri to check equality against.
   * @return True iff the specified uri is equal to this one.
   * @method UuApp.Uri.Uri#equals
   */
  equals(Uri) {
    return this.toString() === (Uri || "").toString();
  }

  /**
   * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
   * @return {UuApp.Uri.Uri} Parsed URI.
   * @method UuApp.Uri.Uri.parse
   * @example
   *    let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
   */
  static parse(uriStr) {
    if (uriStr instanceof Uri) {
      return uriStr;
    }
    return this.prototype.Builder.parse(uriStr).toUri();
  }

  static createBuilder() {
    return new this.prototype.Builder();
  }
}

module.exports = Uri;
