const { BaseError } = require("uu_appg01_core-utils");
const InvalidUriPartError = require("./invalid-uri-part-error.js");

const UNRESERVED = "[\\w\\.\\-~]";
const UNRESERVED_ENCODED = "[\\w\\.\\-~%]";
const IDENTIFIER = "[a-zA-Z0-9_]";
const SCHEME = `(${UNRESERVED}+)`;

// No reason to match IPv4 (invalid IP address is always
// matched as generic hostname - we cannot distinguish them)
// IPV4_PART = "(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[0-9][0-9]?)"
// IPV4 = "(#{IPV4_PART}(\\.#{IPV4_PART}){3})"

// Only rough validation
// see http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses

const IPV6_PART = "([0-9a-fA-F]{1,4})";
const IPV6 = `(\\[${IPV6_PART}(:(${IPV6_PART})?){1,7}\\])`;

const HOSTNAME = `(${IPV6}|${UNRESERVED}+)`;
const PORT = "(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5][0-9]{4}|[1-9][0-9]{0,3})";
const GATEWAY = `(${SCHEME}://${HOSTNAME}(:${PORT})?)`;
const VENDOR = `(${IDENTIFIER}{1,32})`;
const APP = `(${IDENTIFIER}{1,32})`;
const SUB_APP = `(${IDENTIFIER}{1,32})`;
const SPP = `(${IDENTIFIER}{1,32})`;
const PRODUCT = `(?=[^/]{1,131}(?:/|$))((?:${VENDOR}\\-)?${APP}(?:\\-${SUB_APP}(?:\\-${SPP})?)?)`;
const TID = `(${IDENTIFIER}{1,32})`;
const AWID = `(${IDENTIFIER}{1,32})`;
const WORKSPACE = `(?=[^/\\?]{1,65}(?:/|\\?|$))((?:${TID}\\-)?${AWID})`;
const USE_CASE = `(${UNRESERVED_ENCODED}+(?:/${UNRESERVED_ENCODED}+)*)`;
const PARAMETER_NAME = `(?:${UNRESERVED_ENCODED}+)`;
const PARAMETER_NAME_DECODED = "(?:[\\w\\.\\-~\\[\\]]+)";
const PARAMETER_VALUE = "(?:[^=&#]*)";
const PARAMETER = `(?:(?:${PARAMETER_NAME}(?:=${PARAMETER_VALUE})?)?)`;
const PARAMETERS = `(${PARAMETER}(?:&${PARAMETER})*)`;
const URI_REGEXP = new RegExp(
  `^(?:${GATEWAY})?\\/${PRODUCT}\\/${WORKSPACE}(?:/${USE_CASE})?\\/?(?:\\?${PARAMETERS}?)?$`
);

class UriParser {
  parse(str, UriBuilder) {
    if (!UriBuilder) throw new BaseError("UriBuilder must be provided.");
    let result = (str || "").match(URI_REGEXP);
    //      console.log(result);
    if (!result) throw new BaseError("Parse error - invalid uri: " + (str || ""));

    UriBuilder.setScheme(result[2]);
    UriBuilder.setHostname(result[3]);
    UriBuilder.setPort(result[10]);
    UriBuilder.setVendor(result[12]);
    UriBuilder.setApp(result[13]);
    UriBuilder.setSubApp(result[14]);
    UriBuilder.setSpp(result[15]);
    UriBuilder.setTid(result[17]);
    UriBuilder.setAwid(result[18]);
    UriBuilder.setUseCase(result[19] ? decodeURIComponent(result[19]) : null);

    let uriBuilder = UriBuilder;

    let params = result[20];
    if (params) {
      params.split("&").forEach(function(pair) {
        if (!pair) return;
        let eqlSignIdx = pair.indexOf("=");
        let k = eqlSignIdx !== -1 ? pair.substr(0, eqlSignIdx) : pair;
        let v = eqlSignIdx !== -1 ? pair.substr(eqlSignIdx + 1) : "";
        uriBuilder.setParameter(decodeURIComponent(k), decodeURIComponent(v));
      });
    }
    return uriBuilder;
  }

  format(uri) {
    let parts = [];
    parts.push(`${uri.getGateway() || ""}/${uri.getProduct() || ""}/${uri.getWorkspace() || ""}`);
    let uc = uri.getUseCase();
    if (uc) {
      if (uc.charAt(0) !== "/") parts.push("/");
      parts.push(encodeURI(uc));
    }
    parts = [parts.join("").replace(/\/+$/, "")]; // remove all trailing slashes
    let params = uri.getParameters();
    let paramParts = this._createParamParts(params);
    parts = parts.concat(paramParts);
    return parts.join("");
  }

  parseGateway(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("gateway", value, GATEWAY);
    let result = value.match(new RegExp("^" + GATEWAY + "$"));
    if (!result) throw new InvalidUriPartError("gateway", value, GATEWAY);
    //  console.log(result);
    //      ["http://example.com:123", "http://example.com:123", "http",
    //       "example.com", undefined, undefined,
    //       undefined, undefined, undefined,
    //       ":123", "123"]
    return { scheme: result[2], hostname: result[3], port: result[10] };
  }

  formatGateway(scheme, hostname, port) {
    if (!scheme && !hostname && !port) return null;
    this.validateScheme(scheme);
    this.validateHostname(hostname);
    if (port != null) this.validatePort(port);
    return `${scheme}://${hostname}${port != null ? ":" + port : ""}`;
  }

  parseProduct(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("product", value, PRODUCT);
    let result = value.match(new RegExp("^" + PRODUCT + "$"));
    if (!result) throw new InvalidUriPartError("product", value, PRODUCT);
    return { vendor: result[2], app: result[3], subApp: result[4], spp: result[5] };
  }

  formatProduct(vendor, app, subApp, spp) {
    if (!vendor && !app && !subApp && !spp) return null;
    if (vendor) this.validateVendor(vendor);
    this.validateApp(app);
    if (subApp) this.validateSubApp(subApp);
    if (spp) this.validateSpp(spp);

    let result = [];
    if (vendor) result.push(vendor + "-");
    result.push(app);
    if (subApp) result.push("-" + subApp);
    if (spp) result.push("-" + spp);
    return result.join("");
  }

  parseWorkspace(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("workspace", value, WORKSPACE);
    let result = value.match(new RegExp("^" + WORKSPACE + "$"));
    if (!result) throw new InvalidUriPartError("workspace", value, WORKSPACE);
    return { tid: result[2], awid: result[3] };
  }

  formatWorkspace(tid, awid) {
    if (!tid && !awid) return null;
    if (tid) this.validateTid(tid);
    this.validateAwid(awid);

    let result = [];
    if (tid) result.push(tid + "-");
    result.push(awid);
    return result.join("");
  }

  formatParameters(params) {
    let parts = this._createParamParts(params);
    return parts.join("");
  }

  _createParamParts(params) {
    let parts = [];
    let paramKeys = Object.keys(params);
    paramKeys.sort();
    let first = true;
    for (let i = 0; i < paramKeys.length; i++) {
      let k = paramKeys[i];
      let value = params[k];

      if (Array.isArray(value)) {
        value.forEach(v => {
          this._encodeParams(first, k, v, parts);
          first = false;
        });
      } else {
        this._encodeParams(first, k, value, parts);
        first = false;
      }
    }
    return parts;
  }

  _encodeParams(first, k, v, parts) {
    parts.push(first ? "?" : "&");
    parts.push(encodeURIComponent(k));
    if (v == null || v === "") return parts;
    parts.push("=");
    parts.push(encodeURIComponent(v));
    return parts;
  }

  validate(value, regExp, name) {
    if (typeof value !== "string" || !value.match(new RegExp("^" + regExp + "$")))
      throw new InvalidUriPartError(name, value, regExp);
  }

  validateScheme(value, regExp = SCHEME) {
    this.validate(value, regExp, "scheme");
  }

  validateHostname(value, regExp = HOSTNAME) {
    this.validate(value, regExp, "hostname");
  }

  validatePort(value, regExp = PORT) {
    value = typeof value === "number" ? value + "" : value;
    this.validate(value, regExp, "port");
  }

  validateGateway(value, regExp = GATEWAY) {
    this.validate(value, regExp, "gateway");
  }

  validateVendor(value, regExp = VENDOR) {
    this.validate(value, regExp, "vendor");
  }

  validateApp(value, regExp = APP) {
    this.validate(value, regExp, "app");
  }

  validateSubApp(value, regExp = SUB_APP) {
    this.validate(value, regExp, "subApp");
  }

  validateSpp(value, regExp = SPP) {
    this.validate(value, regExp, "spp");
  }

  validateProduct(value, regExp = PRODUCT) {
    this.validate(value, regExp, "product");
  }

  validateTid(value, regExp = TID) {
    this.validate(value, regExp, "tid");
  }

  validateAwid(value, regExp = AWID) {
    this.validate(value, regExp, "awid");
  }

  validateWorkspace(value, regExp = WORKSPACE) {
    this.validate(value, regExp, "workspace");
  }

  validateUseCase(value, regExp = USE_CASE) {
    this.validate(value, regExp, "useCase");
  }

  validateParameterName(value, regExp = PARAMETER_NAME_DECODED) {
    this.validate(value, regExp, "parameterName");
  }

  validateParameterValue(value, regExp = null) {
    if (value != null && !(typeof value === "string" || Array.isArray(value)))
      throw new InvalidUriPartError("parameterValue", value, String);
    // for our generic uuUri following check is always true; will skip for optimization
    //      if (value != null && !encodeURIComponent(value).match(new RegExp("^" + PARAMETER_VALUE + "$"))) throw new InvalidUriPartError("parameterValue", value, PARAMETER_VALUE);
  }
}

module.exports = new UriParser();
