/*!  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("in-browser-transpilation", ["module"], factory);
	else if(typeof exports === 'object')
		exports["in-browser-transpilation"] = factory(require("module"));
	else
		root["in-browser-transpilation"] = factory(root["undefined"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/3.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/3.1.0/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

var currentScript = document.currentScript;

if (!currentScript) {
  var scripts = document.getElementsByTagName("script");
  currentScript = scripts[scripts.length - 1];
} // read configuration from the script element
// - find out glob pattern describing files that we want to transpile (besides inline scripts), such as:
//   "-" - turn off
//   "./*.js" (default) - all JS files from current folder and subfolders
//   "/*.js"  - all JS files from current domain


var transpilationUrlPattern;
if (currentScript) transpilationUrlPattern = currentScript.getAttribute("data-transpilation-url-pattern");
if (!transpilationUrlPattern) transpilationUrlPattern = "./*.js";
var cdnRoot;
if (currentScript) cdnRoot = currentScript.getAttribute("data-cdn-root");
if (cdnRoot == null) cdnRoot = ((window.UU5 || {}).Environment || {}).cdnBaseUri || "https://cdn.plus4u.net/";
if (cdnRoot && cdnRoot.charAt(cdnRoot.length - 1) !== "/") cdnRoot += "/"; // configure transpiler for SystemJS loader

var meta = {};

if (transpilationUrlPattern) {
  meta[transpilationUrlPattern] = {
    loader: "plugin-babel"
  };
}

SystemJS.config({
  map: {
    "plugin-babel": cdnRoot + "libs/systemjs-plugin-babel/0.0.21/plugin-babel.js",
    "systemjs-babel-build": cdnRoot + "libs/systemjs-plugin-babel/0.0.21/systemjs-babel-browser.js"
  },
  meta: meta,
  transpiler: "plugin-babel",
  babelOptions: {
    react: true,
    es2015: true
  }
});
var JSX_TRANSPILATION_FN_NAME = "__devkitJsx";
var JSX_TRANSPILATION_FN_TEXT = "\n;var ".concat(JSX_TRANSPILATION_FN_NAME, "0;\nfunction ").concat(JSX_TRANSPILATION_FN_NAME, "(...args) {\n  if (").concat(JSX_TRANSPILATION_FN_NAME, "0) return ").concat(JSX_TRANSPILATION_FN_NAME, "0(...args);\n  var resultFn;\n  if (typeof Uu5g05 !== \"undefined\" && Uu5g05 && Uu5g05.Utils && Uu5g05.Utils.Element && typeof Uu5g05.Utils.Element.create === \"function\") {\n    resultFn = Uu5g05.Utils.Element.create;\n  } else if (typeof UU5 !== \"undefined\" && UU5 && UU5.Common && UU5.Common.Element && typeof UU5.Common.Element.create === \"function\") {\n    resultFn = UU5.Common.Element.create;\n  } else {\n    resultFn = React.createElement;\n  }\n  ").concat(JSX_TRANSPILATION_FN_NAME, "0 = resultFn;\n  return resultFn(...args);\n}"); // also transpile inline scripts marked as <script type="text/babel"> in the current HTML page
// (with full support of "import" statements)

document.addEventListener("DOMContentLoaded", function (e) {
  var scripts = document.querySelectorAll('script[type="text/babel"]');
  if (scripts.length === 0) return; // we'll extract scripts texts and import them via SystemJS with transpilation

  var inlineBabels = {};
  SystemJS.config({
    meta: {
      "app-inline-script-*": {
        loader: "app-inline-script-loader"
      }
    }
  });
  SystemJS.set("app-inline-script-loader", SystemJS.newModule({
    // "helper" plugin which supplies script texts from "inlineBabels" variable, instead of downloading them from URLs
    fetch: function fetch(load) {
      load.metadata.format = "esm"; // mark as ES6 module (i.e. will be transpiled)
      // use our custom JSX fn instead of React.createElement (add to end to be overridable - 1st @jsx comment wins)

      var scriptText = inlineBabels[load.name.split(/\//).slice(-1)[0]];
      scriptText += "\n/* @jsx ".concat(JSX_TRANSPILATION_FN_NAME, " */\n") + JSX_TRANSPILATION_FN_TEXT;
      return scriptText;
    }
  }));
  var result = Promise.resolve();

  var _loop = function _loop(i) {
    var script = scripts[i];
    var name = script.src;

    if (name) {
      var _meta = {};
      _meta[name] = {
        loader: "plugin-babel"
      };
      SystemJS.config({
        meta: _meta
      });
    } else {
      name = "app-inline-script-" + i + ".js";
      inlineBabels[name] = script.textContent;
    } // execute scripts one after another (next one waits for the previous)


    result = result.catch(function (e) {
      return console.error(e);
    }).then(function () {
      return SystemJS.import(name);
    });
  };

  for (var i = 0; i < scripts.length; ++i) {
    _loop(i);
  }
}, false);

/***/ })
/******/ ]);
});