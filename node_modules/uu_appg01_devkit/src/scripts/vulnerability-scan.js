"use strict";

const Npm = require("global-npm");
const Got = require("got");
const Path = require("path");
const Fs = require("fs-extra");
const paths = require("../config/paths.js");

const COMPONENT_REPORT_CHUNK_SIZE = 128;
const COMPONENT_REPORT_URL = "https://ossindex.sonatype.org/api/v3/component-report";
const COMPONENT_REPORT_HEADERS = {"Accept": "application/vnd.ossindex.component-report.v1+json", "Content-Type": "application/vnd.ossindex.component-report-request.v1+json"};

module.exports = class VulnerabilityScan {

  constructor(config) {
    this.config = config;
  }

  async process() {
    let skipDevelopment = true;
    if (this.config.commandLineConfig.devDependencies && this.config.commandLineConfig.devDependencies === "true") {
      skipDevelopment = false;
    }
    console.log("Checking project dependencies.");
    let loadProjectDesc = new Promise(function(resolve, reject) {
      Npm.load(() => {
        console.log(" ...loading dependencies");
        Npm.commands.ls([], true, (err, data) => {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      });
    });
    let projectDesc = await loadProjectDesc;
    let dependencies = projectDesc.dependencies;
    let parsedDependencies = this._parseDependencies(dependencies, skipDevelopment);
    let dependencyList = Object.keys(parsedDependencies);
    console.log(` ...scanning ${dependencyList.length} libraries`);

    let i, chunk, scanned = 0;
    for (i = 0; i < dependencyList.length; i += COMPONENT_REPORT_CHUNK_SIZE) {
      chunk = dependencyList.slice(i, i + COMPONENT_REPORT_CHUNK_SIZE);
      let partialReport = await this._getComponentReport(chunk);
      for (let componentReport of partialReport) {
        let dependency = parsedDependencies[componentReport.coordinates];
        if (componentReport.description && !dependency.description) {
          dependency.description = componentReport.description;
        }
        if (componentReport.vulnerabilities.length > 0) {
          dependency.vulnerabilities = componentReport.vulnerabilities;
        }
      }
      scanned += chunk.length;
      if (scanned < dependencyList.length) {
        console.log(` ...${i + chunk.length} libraries scanned`);
      }
    }
    console.log(` ...scan complete`);

    let dependencyReport = Path.resolve(Path.join(paths.buildDir, "vulnerability_scan_report.json"));
    console.log(`\nGenerating report.`);
    Fs.mkdirpSync(Path.dirname(dependencyReport));
    Fs.writeFileSync(dependencyReport, JSON.stringify(parsedDependencies, null, 2));
    console.log(` => file://${Path.resolve(".", dependencyReport)}\n`)
  }

  _parseDependencies(dependencies, skipDevelopment, result = null, from = null, level = 0) {
    if (!result) {
      result = {};
    }
    if (!dependencies) {
      return result;
    }
    for (let pkgName in dependencies) {
      let dependency = dependencies[pkgName];
      if (!dependency.path || !dependency.version || (dependency._development && skipDevelopment)) {
        continue;
      }
      let coordinate = `pkg:npm/${pkgName.replace(/^@/, "")}@${dependency.version}`;
      let prevDependency = result[coordinate];
      if (!prevDependency || (prevDependency.level > level)) {
        result[coordinate] = {
          level: level,
          from: from || "ROOT",
          license: dependency.license || null,
          description: dependency.description || null,
          vulnerabilities: null
        };
      }
      this._parseDependencies(dependency.dependencies, skipDevelopment, result, coordinate, level + 1);
    }
    return result;
  }

  async _getComponentReport(dependencyList) {
    let body = JSON.stringify({coordinates: dependencyList});
    let result = await Got(COMPONENT_REPORT_URL, {
      headers: COMPONENT_REPORT_HEADERS,
      method: "post",
      body: body
    });
    return JSON.parse(result.body);
  }

};
