const fs = require("fs");
const path = require("path");
const semver = require("semver");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");

const DEFAULT_CDN_URL = "https://cdn.plus4u.net";
const EXTERNALS_TYPE_APP = "app";
const EXTERNALS_TYPE_LIB = "lib";
const LIB_REGISTRY_EXCLUDED_DEPS = {
  react: true,
  "react-dom": true,
  "create-react-class": true,
  "prop-types": true
};

module.exports = class DependencyProcessor {
  constructor(packageJson = "package.json", useCdn) {
    this.packageJson = packageJson;
    this.useCdn = useCdn;
  }

  /**
   * @param {"app"|"lib"} type Whether to return externals configuration as needed by "lib" project or by "app" project.
   */
  getExternals(type) {
    return this.getDetailedExternals(type).config;
  }

  getDetailedExternals(type) {
    // compute all externals, including transitive, from dependencies in package.json
    let externals = this._computeExternals("package.json", type);
    let externalsKeys = Object.keys(externals).sort();
    let hasErrors = false;
    let config = {};
    for (let k of externalsKeys) {
      if (externals[k].value instanceof Error) {
        let chain = [externals[k].name];
        let meta = externals[k].sourceMeta;
        while (meta) {
          chain.push(meta.moduleName);
          meta = meta.ownerMeta;
        }
        chain.splice(-1, 1, "<project>");
        console.error(
          externals[k].value.toString().replace(/^Error:/, require("chalk").red("ERROR")) +
            "\nDependency chain: " +
            chain.reverse().join(" -> ")
        );
        hasErrors = true;
      } else if (!(k in config)) {
        config[k] = externals[k].value;
      }
    }
    if (hasErrors) process.exit(1);

    if (type === EXTERNALS_TYPE_APP) {
      // TODO Is this really needed? uu5-app should still have direct dependency in their package.json so it should be in result...
      if (!config["systemjs"]) {
        Object.assign(config, {
          systemjs: {
            cdnBaseUri: DEFAULT_CDN_URL + "/libs/systemjs/0.19.47/",
            localBaseUri: chooseExistingPath(
              "node_modules/systemjs/dist/",
              path.join(__dirname, "../../../node_modules/systemjs/dist/")
            ),
            main: "system.src.js",
            mainMinified: "system.js"
          }
        });
      }
      if (!externals["systemjs"]) externals["systemjs"] = { value: config["systemjs"] };
    }

    return { detail: externals, config: config };
  }

  /**
   * Replaces expressions in depSettings. Supported expressions:
   * ${version}
   * ${floatingVersion}
   * ${dependency['some-dep'].version}
   * ${dependency['some-dep'].floatingVersion}
   * ${devDependency['some-dep'].version}
   * ...
   * Any key from package.json can be used in the expression.
   *
   * For backward compatibility, it's possible to use % as delimiters, i.e. %version%, ...
   */
  replaceDependencyExpressions(depName, depSettings, ownerMeta = this._getMeta("package.json")) {
    if (depSettings && typeof depSettings === "object") {
      for (let depOption in depSettings) {
        let depOptionValue = depSettings[depOption];
        if (typeof depOptionValue !== "string" || !depOptionValue) continue;
        depSettings[depOption] = depOptionValue.replace(/%([^%]*)%|\$\{([^}]*)\}/g, (m, ex1, ex2) => {
          // support %something% for backward compatibility
          let expression = ex1 || ex2;
          // extract bracketed values such as ['uu5g04'] into array (because they can contain dots) & replace them with ". "
          // ${dependencies['uu5g04'].version}  =>  ${dependencies. .version}
          let bracketedValues = [];
          expression = expression.replace(/\[([^\]]+)\]/g, (m, value) => {
            bracketedValues.push(value.replace(/^(['"])((\s|\S)*)\1$/, "$2"));
            return ". ";
          });
          // split by dot & replace spaces by bracketed values
          let parts = expression.split(".").map(it => (it === " " ? bracketedValues.shift() : it));
          if (parts.length === 1) parts = ["dependencies", depName].concat(parts);

          let resolvedValue = ownerMeta.json;
          let i = 0;
          let depMeta;
          while (i < parts.length && resolvedValue != null) {
            if (parts[i].match(/dependencies/i)) {
              depMeta = this._getDependencyMeta(parts[++i], ownerMeta.path, ownerMeta, true);
              resolvedValue = depMeta ? depMeta.json : { version: "0.0.0" };
            } else if (parts[i] === "floatingVersion") {
              if (depMeta && depMeta.requestedVersion) {
                resolvedValue = this._toCdnVersion(
                  depMeta.requestedVersion,
                  resolvedValue.version,
                  depMeta && depMeta.isUuAppLib
                );
              } else {
                resolvedValue = resolvedValue["version"];
              }
            } else {
              resolvedValue = resolvedValue[parts[i]];
            }
            i++;
          }
          return resolvedValue != null ? resolvedValue : m;
        });
      }
    }
    return depSettings;
  }

  _computeExternals(packageJsonFile, externalsType, meta = undefined, parentMeta = null, cumulativeResult = {}) {
    if (meta === undefined) meta = this._getMeta(packageJsonFile, undefined, parentMeta);
    let addExternal = (external, overwrite = false) => {
      let { name } = external; // name, value, sourceType, sourceLocation; "value" can be true (auto-compute as external; e.g. for 3rd-party libs)
      if (
        overwrite ||
        !(name in cumulativeResult) ||
        cumulativeResult[name].value === true ||
        external.topLevelExplicit ||
        (!cumulativeResult[name].topLevelExplicit &&
          isCdnVersionNewer(external.cdnVersion, cumulativeResult[name].cdnVersion, external.cdnVersionExact, cumulativeResult[name].cdnVersionExact))
      ) {
        cumulativeResult[name] = external;
      }
    };

    // add explicit externals from uuBuildSettings.externals
    let uuBuildSettings = meta.json.uuBuildSettings || {};
    let explicitExternals = uuBuildSettings.externals || uuBuildSettings.dependencies || {};
    Object.keys(explicitExternals).forEach(externalName => {
      let externalValue = explicitExternals[externalName];
      if (parentMeta !== null && externalName === meta.json.name) return; // e.g. uu5g04 has itself in its uuBuildSettings.externals because of submodules => skip self reference
      if (parentMeta !== null && externalValue === false) return; // skip those marked as locally non-external (if we're in transitive library)
      if (externalName === "UU_ENVIRONMENT" || externalName === "module") return; // skip legacy externals and "module" (RequireJS); these aren't typically explicitly given but e.g. uuappdesignkitg01 for some reason has it in its package.json...
      let { value, cdnVersion, cdnVersionExact } = parentMeta
        ? this._computeDepConfigValue(meta, externalName, externalValue, externalsType) // we're in transitive library => compute / fill
        : { value: externalValue }; // we're in top-level package.json => keep as-is as the developer specified it
      value = this.replaceDependencyExpressions(externalName, value, meta);
      addExternal({
        name: externalName,
        value: value,
        sourceType: "uuBuildSettings",
        sourceLocation: packageJsonFile,
        sourceMeta: meta,
        topLevelExplicit: !parentMeta,
        cdnVersion,
        cdnVersionExact
      });
    });

    if (meta.json.dependencies && (!meta.json.uuBuildSettings || !meta.json.uuBuildSettings.skipExternalsDiscovery)) {
      let browserField = meta.json.browser || {};
      let traverseTransitivelyList = [];
      for (let depName in meta.json.dependencies) {
        if (depName in browserField) continue; // skip dependencies that are re-mapped / bundled if building for browser

        if (depName.startsWith("uu_appg01_core-")) continue; // TODO Remove. Necessary because uu_appg01_oidc < 2.0.0 has direct import of uu_appg01_core-perflog (basically it bundles stuff from uu_appg01_core duplicitly). Also because uu_appg01_core bundles these inside and it doesn't have it in uuBuildSettings.externals: { uu_appg01_core-uri: false, ... }.
        if (depName === "uu_appg01_server-client") continue; // TODO Remove. Necessary because uu_appg01 bundles this inside and it doesn't have it in uuBuildSettings.externals: { uu_appg01_server-client: false }.

        let depMeta = this._getDependencyMeta(depName, packageJsonFile, meta);

        // add the dependency as external if it's uu5-lib / iso-lib, transitively
        if (depMeta.isUuAppLib) {
          if (!(depName in explicitExternals) || explicitExternals[depName] === true) {
            let { value: depValue, cdnVersion, cdnVersionExact } = this._computeDepConfigValue(meta, depName, undefined, externalsType);
            depValue = this.replaceDependencyExpressions(depName, depValue, meta);
            addExternal({
              name: depName,
              value: depValue,
              cdnVersion,
              cdnVersionExact,
              sourceType: "dependency",
              sourceLocation: packageJsonFile,
              sourceMeta: meta
            });
          }
          // we'll add transitive dependencies *after* we process the current package.json
          traverseTransitivelyList.push(() => {
            this._computeExternals(depMeta.path, externalsType, depMeta, meta, cumulativeResult);
          });
        }
      }
      traverseTransitivelyList.forEach(fn => fn());
    }

    // handle special cases:
    // 1. If uu_appg01_oidc is present in externals then for backward compatibility
    //    with oidcg01 configure uu_oidcg01 as external using uu_appg01_oidc values,
    //    but only if uu_oidcg01 config wasn't defined explicitly in uuBuildSettings.
    if (!parentMeta && "uu_appg01_oidc" in cumulativeResult && !("uu_oidcg01" in explicitExternals)) {
      let uuAppg01Oidc = cumulativeResult["uu_appg01_oidc"];
      addExternal(
        {
          ...uuAppg01Oidc,
          name: "uu_oidcg01",
          value: { main: "uu_appg01_oidc.js", mainMinified: "uu_appg01_oidc.min.js", ...uuAppg01Oidc.value },
          sourceType: "dependency-uu_appg01_oidc-backwardCompatibility",
          topLevelExplicit: false
        },
        true
      );
    }

    return cumulativeResult;
  }

  _getDependencyMeta(depName, packageJsonFile, ownerMeta = null, skipIfNonexisting = false) {
    try {
      // handle also case if depName is submodule ("uu5g04-bricks", i.e. we need node_modules/uu5g04/package.json)
      let name = depName;
      let depPkgJsonFile;
      let firstError;
      while (name) {
        try {
          depPkgJsonFile = require.resolve(name + "/package.json", {
            paths: this._projectHasDirectDependency(name) ? ["."] : [packageJsonFile.replace(/[^/\\]*$/, "")]
          });
          break;
        } catch (e) {
          if (!firstError) firstError = e;
          if (e.code === "MODULE_NOT_FOUND") {
            name = name
              .split("-")
              .slice(0, -1)
              .join("-");
          } else {
            throw e;
          }
        }
      }
      if (!depPkgJsonFile) throw firstError;
      let meta = this._getMeta(depPkgJsonFile, depName, ownerMeta);
      if (!meta.isUuAppLib && name !== depName) throw firstError; // we simplified depName, e.g. "react-dom" into "react" and ended in non-uuApp lib => don't allow that
      return meta;
    } catch (e) {
      if (skipIfNonexisting && e.code === "MODULE_NOT_FOUND") return null;
      throw e;
    }
  }

  _projectHasDirectDependency(depName) {
    let pkg = Package.getSingletonSync(this.packageJson).get();
    return pkg.dependencies && pkg.dependencies[depName];
  }

  _computeDepConfigValue(meta, libName, libValue, externalsType) {
    let result;
    if (
      libValue === false ||
      (externalsType === EXTERNALS_TYPE_LIB &&
        ((typeof libValue === "string" && LIB_REGISTRY_EXCLUDED_DEPS[libName]) ||
          (libValue && libValue.globalVariable && libValue.uri)))
    ) {
      result = { value: libValue };
    } else {
      let depMeta = this._getDependencyMeta(libName, meta.path, meta, true);
      if (!depMeta) {
        let depCdnName = (libName.indexOf("_") === -1 && libName.match(/^uu/) ? "uu-" + libName : libName).replace(/_/g, "-");
        result = {
          value: new Error(`Unable to find out URL & version for external dependency '${libName}' defined in ${
            meta.path
          }
Configure this library in your package.json in uuBuildSettings.externals manually, e.g.:
  ${JSON.stringify(libName)}: {
    ${
      externalsType === EXTERNALS_TYPE_APP
        ? `"cdnBaseUri": "${DEFAULT_CDN_URL}/${depCdnName}/X.Y.Z/"`
        : `"globalVariable": "${this._estimateGlobalVariableName(libName)}",
    "uri": "${DEFAULT_CDN_URL}/${depCdnName}/X.Y.Z/${libName}.min.js"`
    }
  }`)
        };
      } else {
        let localNaming = this._discoverLocalNamingForModule(depMeta, this.useCdn);
        let depValue = localNaming;
        if (!(depValue instanceof Error)) {
          let depCdnName = (depMeta.json.name.indexOf("_") === -1 && depMeta.json.name.match(/^uu/) ? "uu-" + depMeta.json.name : depMeta.json.name).replace(/_/g, "-");
          if (!depMeta.isUuAppLib) depCdnName = "libs/" + depCdnName;
          let depCdnVersion = this._toCdnVersion(depMeta.requestedVersion, depMeta.json.version, depMeta.isUuAppLib);
          let depCdnBaseUri = `${DEFAULT_CDN_URL}/${depCdnName}/${depCdnVersion}/`;
          if (externalsType === EXTERNALS_TYPE_APP) {
            depValue = {
              cdnBaseUri: depCdnBaseUri,
              ...depValue
            };
          } else if (externalsType === EXTERNALS_TYPE_LIB) {
            let globalVariableName =
              (libValue && libValue.globalVariable) ||
              this._discoverGlobalVariableNameForModule(
                depMeta,
                path.join(localNaming.localBaseUri, localNaming.main || localNaming.mainMinified)
              ) ||
              this._estimateGlobalVariableName(depMeta.moduleName);
            if (LIB_REGISTRY_EXCLUDED_DEPS[libName]) {
              depValue = globalVariableName;
            } else {
              depValue = {
                globalVariable: globalVariableName,
                uri: (libValue && libValue.uri) || depCdnBaseUri + localNaming.mainMinified
              };
            }
          } else {
            throw new Error("Unsupported externalsType: " + externalsType);
          }
        }
        result = { value: depValue };
      }
    }
    let uri = result && result.value ? result.value.uri || result.value.cdnBaseUri : null;
    let cdnVersion =
      uri && uri.startsWith(DEFAULT_CDN_URL)
        ? uri.match(/\/(\d+\.[^/]+)/)[1]
        : undefined;
    if (cdnVersion) {
      result.cdnVersion = cdnVersion;
      result.cdnVersionExact = uri.startsWith(DEFAULT_CDN_URL + "/libs/") || !cdnVersion.match(/^\d+\.0\.0$/);
    }
    return result;
  }

  _discoverLocalNamingForModule(meta, useCdn) {
    let result; // e.g. { localBaseUri: "node_modules/...", main: "uu_lib.js", mainMinified: "uu_lib.min.js" }
    let { moduleName } = meta;
    let moduleDir = path.dirname(meta.path);
    let candidates = meta.isUuAppLib ? ["dist", "target/dist"] : ["dist", "umd", "cjs", "target/dist", "."];
    for (let candidate of candidates) {
      let dir = path.resolve(moduleDir, candidate);
      if (fs.existsSync(dir)) {
        result = { localBaseUri: path.relative(".", dir).replace(/\\/g, "/") + "/" };
        // TODO Remove these special cases:
        // 1. react-dnd-touch-backend doesn't have pre-built files for browser in its npm module.
        //    Our CDN contains custom build of it => configure with naming used by our CDN.
        // 2. Production CDN uses renamed files for react & react-dom (react.min.js instead of react.production.min.js).
        if (moduleName === "react-dnd-touch-backend") {
          result.main = "Touch.browserified.js";
          result.mainMinified = "Touch.browserified.js";
        } else if (useCdn && moduleName.match(/^(react|react-dom)$/)) {
          result.main = moduleName + ".js";
          result.mainMinified = moduleName + ".min.js";
        } else {
          let main, mainMinified;
          for (let k of entryNameGenerator(moduleName, dir, true)) {
            if (fs.existsSync(path.join(dir, k))) {
              mainMinified = k;
              break;
            }
          }
          for (let k of entryNameGenerator(moduleName, dir, false)) {
            if (fs.existsSync(path.join(dir, k))) {
              main = k;
              break;
            }
          }
          if (!main && !mainMinified && meta.isUuAppLib && meta.moduleName === meta.json.name) {
            // NOTE This can happen when having multiple projects in single Git where one
            // depends on another which wasn't built yet. Since it's uuAppLib (built by devkit)
            // assume that it follows naming conventions.
            main = moduleName + ".js";
            mainMinified = moduleName + ".min.js";
          }
          if (!main) main = mainMinified;
          if (!mainMinified) mainMinified = main;
          if (!main) {
            result = new Error(`Unable to configure URL & naming for external library '${moduleName}'. There is no ${moduleName +
              ".js"} file in ${dir + path.sep}
Configure this library in your package.json in uuBuildSettings.externals manually.`);
          } else {
            result.main = main;
            result.mainMinified = mainMinified;
          }
        }
        break;
      }
    }
    if (!result) {
      result = new Error(`Unable to configure URL & naming for external library '${moduleName}'. There is no ${path.resolve(
        moduleDir,
        candidates[0]
      ) + path.sep} directory with ${moduleName + ".js"} file in it.
Configure this library in your package.json in uuBuildSettings.externals manually.`);
    }
    return result;
  }

  _discoverGlobalVariableNameForModule(meta, entryFilePath) {
    // TODO Remove if possible. Hardcoded for react-dnd-touch-backend because it doesn't have
    // pre-built files for browser in its npm module (use value suitable for our CDN).
    if (meta.moduleName === "react-dnd-touch-backend") return "reactDndTouchBackend";

    if (meta.moduleName === meta.json.name && meta.json.namespace) return meta.json.namespace;
    let jsContent = fs.readFileSync(entryFilePath, "utf-8");
    let namespace;
    // assume UMD header, i.e. something like:
    //   if (define.amd) define(["dep", ...], factory);
    //   else if (exports) root[cjsName] = factory(require("dep"), ...);
    //   else root["UU5"]["Bricks"] = factory(root["dep"], ...);     <=== this is what we need (our result should be "UU5.Bricks")
    // alternatively, if minified it looks like:
    //   else a.UU5.Bricks=b(a.dep,...)
    jsContent.replace(/\bdefine\(/, (m, index) => {
      let closingBracketIndex = jsContent.indexOf("}", index);
      let headerContent = jsContent.substr(index, closingBracketIndex);
      let factoryFnName = headerContent.match(/([a-zA-Z0-9_$]+)\s*\)/)[1]; // factory fn name, i.e. last parameter in define(...) call
      let exportVarExpressionRegExpStr = "[.\\[\\]'\"a-zA-Z0-9_$]+"; // for matching root["UU5"]['Bricks']
      let allMatches = headerContent.match(
        new RegExp(exportVarExpressionRegExpStr + "\\s*=\\s*" + factoryFnName + "\\(", "g")
      );
      if (allMatches) {
        let lastMatch = allMatches.pop().match(new RegExp("^(" + exportVarExpressionRegExpStr + ")"))[0];
        let dotParts = lastMatch.split(/\.|\[['"]|(?:['"]\](?:\[['"]|\.|$))/); // e.g. root["UU5"].Bricks => ["root", "UU5", "Bricks"]
        if (dotParts[dotParts.length - 1] === "") dotParts.pop(); // because split transforms: root["UU5"]["Bricks"] => ["root", "UU5", "Bricks", ""]
        if (dotParts.length > 1 && !dotParts.some(part => part.length === 0)) {
          namespace = dotParts.slice(1).join(".");
          if (namespace.match(/[^a-zA-Z0-9$_.]/)) namespace = undefined; // weird value (file probably does not have UMD header)
        }
      }
    });
    return namespace;
  }

  _estimateGlobalVariableName(libName) {
    return libName
      .replace(/g\d\d/, "")
      .replace(/-(.)/, (m, g) => "." + g.toUpperCase())
      .replace(/-(.)/g, (m, g) => g.toUpperCase())
      .replace(/^uu5(.)/, (m, g) => "UU5." + g.replace(".", "").toUpperCase())
      .replace(/^uu_plus4u5(.)/, (m, g) => "Plus4U5." + g.replace(".", "").toUpperCase())
      .replace(/(?:^|_)(.)/g, (m, g) => g.toUpperCase());
  }

  _toCdnVersion(versionSpecifier, installedVersion = null, isUuAppLib = false) {
    if (!isUuAppLib) return installedVersion || versionSpecifier; // currently, all 3rd-party libs must always be exact

    let match = versionSpecifier.match(/^(?:\^(\d+)|~(\d+\.\d+)|(\d+)\.x|(\d+\.\d+)\.x)/);
    // ^1.2.0 => 1.x
    // ~1.2.0 => 1.2.x
    // 1.x => 1.x
    // 1.2.x => 1.2.x
    // other => exact version
    // TODO Change to the above. We're now mapping inexact to 1.0.0 instead of 1.x / 1.2.x.
    let version;
    if (match) version = match[1] || match[3] ? (match[1] || match[3]) + ".0.0" : (match[2] || match[4]) + ".0";
    else version = installedVersion || versionSpecifier;
    return version;
  }

  _getMeta(packageJson, moduleName = null, ownerMeta = null) {
    let pkg = Package.getSingletonSync(packageJson).get();
    let requestedVersion =
      moduleName && moduleName !== pkg.name && ownerMeta && ownerMeta.moduleName === pkg.name // if moduleName is submodule ("uu5g04-bricks") then use the same requestedVersion as main ("uu5g04")
        ? ownerMeta.requestedVersion
        : ownerMeta && (ownerMeta.json.dependencies || {})[pkg.name]
          ? ownerMeta.json.dependencies[pkg.name]
          : pkg._from
            ? pkg._from.replace(/^[^@]+@/, "")
            : pkg.version;
    requestedVersion = requestedVersion.replace(
      /^https?:[^?]*\/(\d+[^/]*).*/, // some older uuApp modules have a URL to .tgz instead of version specifier in their dependencies
      (m, g) => (g.endsWith(".0.0") ? "^" + g : g)
    );
    return {
      json: pkg,
      path: packageJson,
      isUuAppLib: !!(
        (pkg.spec && pkg.spec.match(/^(uu5-lib|iso-lib|lib)/)) ||
        "uuBuildSettings" in pkg ||
        (moduleName || pkg.name).match(/^(uu_|uu5|uuappdesignkitg01$)/)
      ), // uu_* and uu5* for older uu_appg01, uu_oidcg01, uu5mathg01, ... which wouldn't be detected as uuApp libs (they use old template, not devkit)
      moduleName: moduleName || pkg.name,
      requestedVersion: requestedVersion,
      ownerMeta
    };
  }
};

function chooseExistingPath(...paths) {
  for (let p of paths) {
    if (fs.existsSync(p)) return p;
  }
}

function* entryNameGenerator(baseName, dir, minified = false) {
  // TODO Remove later. Serves for backward compatibility because entry point for uu_appg01 < 4.0.0 is uu_appg01-base.js.
  if (baseName === "uu_appg01") {
    yield "uu_appg01-base" + (minified ? ".min" : "") + ".js";
  }

  if (minified) {
    yield baseName + ".min.js";
    yield baseName + ".production.min.js";
  } else {
    yield baseName + ".js";
    yield baseName + ".development.js";
  }
  // try additional variants:
  // a) if there's single .js file in folder then take that (e.g. react-dnd-touch-backend has dist/Touch.js)
  // b) if there're only 2 .js files (X.js + X.min.js) then take those (e.g. react-dnd has dist/ReactDnD.js, ReactDnD.min.js)
  let jsFiles = fs
    .readdirSync(dir)
    .filter(fileName => fileName.endsWith(".js"))
    .sort();
  if (jsFiles.length === 1) yield jsFiles[0];
  else if (jsFiles.length === 2 && jsFiles[1] === jsFiles[0].replace(/\.js$/, ".min.js")) {
    if (minified) yield jsFiles[1];
    else yield jsFiles[0];
  }
}

function isCdnVersionNewer(versionA, versionB, versionAExact = true, versionBExact = true) {
  if (!versionA || !versionB) return undefined;
  if (versionA === versionB) return false;
  // if not exact, consider version such as "3.0.0" as latest 3.x
  let modVersionA = versionAExact ? versionA : versionA.replace(/^(\d+)\.0\.0$/, (m, g1) => g1 + ".999999999999999.0");
  let modVersionB = versionBExact ? versionB : versionB.replace(/^(\d+)\.0\.0$/, (m, g1) => g1 + ".999999999999999.0");
  return semver.gt(modVersionA, modVersionB);
}
