const fs = require("fs");
const path = require("path");
const chalk = require("chalk");
const cors = require("cors");
const open = require("open");
const webpack = require("webpack");

module.exports = class DevServer {
  constructor(webpackConfig, devServerConfig, projectType) {
    this.webpackConfig = webpackConfig;
    this.devServerConfig = devServerConfig;
    this.projectType = projectType;
  }
  start() {
    let {
      port,
      host,
      https,
      autoOpenInBrowser,
      hot,
      summarizeWebpackStats,
      basePath: devServerAppBaseUrlPath,
      appAssetsRelativeUrlPath,
      mappings,
      devServerMiddlewares = [],
      offline,
      onCompile
    } = this.devServerConfig;

    let compiler = webpack(this.webpackConfig);
    if (summarizeWebpackStats) customizeCompilerStats(compiler, summarizeWebpackStats);
    let firstWebpackConfig = Array.isArray(this.webpackConfig) ? this.webpackConfig[0] : this.webpackConfig;
    let outputAbsPath = firstWebpackConfig.output.path;

    // generate extra notification file when 1st compilation ends successfully
    let first = true;
    compiler.hooks.done.tap("uu_appg01_devkit 1st compilation done", stats => {
      if (first) fs.writeFileSync(path.join(outputAbsPath, ".finished"), new Date().toISOString(), "utf-8");
      first = false;
      if (typeof onCompile === "function") onCompile(stats);
    });

    // start server
    let express = require("express");
    let app = express();

    // add middlewares
    fixWebpackMiddlewareIssues(compiler);
    app.set("strict routing", true); // strict routing - "/home" is different than "/home/"

    // allow CORS when running via webpack-dev-server
    app.use(cors({ origin: true, credentials: true }));

    // make all requests require URL path prefix according to devServerAppBaseUrlPath, i.e. send redirect
    // if they don't have it
    devServerAppBaseUrlPath = (devServerAppBaseUrlPath || "").replace(/\/+$/, "");
    if (devServerAppBaseUrlPath) {
      app.use((req, res, next) => {
        if (
          req.method === "GET" &&
          !req.path.startsWith(devServerAppBaseUrlPath + "/") &&
          !req.path.startsWith("/__") // special URLs, e.g. for serving files from FS when in offline mode
        ) {
          return res.redirect(
            req.path === devServerAppBaseUrlPath ? devServerAppBaseUrlPath + "/" : devServerAppBaseUrlPath + req.path
          );
        }
        next();
      });
      app.use((req, res, next) => {
        // the request got past 1st middleware - remove the prefix so that webpack can return the file properly
        req.url = req.url.replace(devServerAppBaseUrlPath + "/", "/");
        next("route");
      });
    }

    // rewrite 'non-existent path && accept/html' to index.html (or other files as specified in server or client config/mappings.json)
    // NOTE This middleware must be before the one that removes appAssetsRelativeUrlPath from the path.
    if (Object.keys(mappings || {}).length > 0) {
      let ucMap = {};
      for (let k in mappings) Object.assign(ucMap, (mappings[k] || {})["useCaseMap"]);
      // create list of VUC mappings with matcher function ("matchFn") and the rule relevancy, such as:
      //   home/xy
      //   home/
      //   home
      //   home/{asdf}/{qwer}
      //   home/{asdf}
      let ucList = Object.keys(ucMap)
        .filter(k => ucMap[k].type === "VUC" || ucMap[k].type === "UVE")
        .map(k => {
          if (k === "defaultVuc" || k === "defaultUve")
            return { key: k, matchFn: (/*url*/) => true, relevancy: 0, value: ucMap[k] };
          let relX = 1;
          let regexpStr =
            "^(" +
            k.replace(/[^{]+|\{[^}]*\}/g, m => {
              if (m.charAt(0) === "{") relX *= 0.9;
              return m.charAt(0) === "{" ? "[^/]*(/[^/]*)*?" : regexpEscape(m);
            }) +
            ")$";
          let relevancy = relX == 1 ? 1 : 1 - relX;
          let regexp = new RegExp(regexpStr);
          return {
            key: k,
            matchFn:
              k.indexOf("{") === -1
                ? url => k === url
                : function(url) {
                    return !!url.match(regexp);
                  },
            relevancy: relevancy,
            value: ucMap[k]
          };
        });
      ucList.sort((a, b) => b.relevancy - a.relevancy || b.key.length - a.key.length);

      app.use((req, res, next) => {
        if (req.method == "GET" && (!appAssetsRelativeUrlPath || !req.url.startsWith("/" + appAssetsRelativeUrlPath))) {
          let expectsHtml = req.accepts(["application/json", "text/html"]) === "text/html"; // there might be multiple acceptable content types
          let expectsApplicationJsonOnly = req.get("Accept") === "application/json";
          let urlPath = req.path.replace(/^\/*/, "");

          // if the file exists, just return it as-is
          let filePath = path.resolve(outputAbsPath, urlPath);
          if (fs.existsSync(filePath) && fs.statSync(filePath).isFile())
            return res.sendFile(urlPath, { root: outputAbsPath });

          let targetUc = ucList.filter(uc => uc.matchFn(urlPath))[0];
          if (targetUc) {
            // if requesting application/json from a URL which is listed in mappings.json, return status 200
            if (expectsApplicationJsonOnly) return res.status(200).send({});

            // if requesting text/html from a URL which is listed in mappings.json, return corresponding HTML file (or defaultVuc)
            // but try file_v2.html first (contains newer preferred HTML version of page without document.write() fns)
            filePath = expectsHtml ? path.resolve(outputAbsPath, targetUc.value.realization || "") : null;
            // console.log(urlPath, filePath, targetUc);
            let filePathV2 = filePath && filePath.replace(/\.html$/, m => "_v2" + m);
            if (
              filePathV2 &&
              filePathV2 !== filePath &&
              fs.existsSync(filePathV2) &&
              fs.statSync(filePathV2).isFile()
            ) {
              let htmlContent = replaceHtmlExpressions(filePathV2);
              return res.status(200).type("text/html").send(htmlContent);
            }
            if (filePath && fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
              return res.sendFile(targetUc.value.realization, { root: outputAbsPath });
            }
          }
        }
        next();
      });
    }
    let replaceHtmlExpressions = (filePath) => {
      let result = fs.readFileSync(filePath, "utf-8");
      let uu5Environment = fs.readFileSync(path.join(outputAbsPath, "uu5-environment.js"), "utf-8");
      let cdnBaseUri = "https://cdn.plus4u.net/";
      uu5Environment.replace(/"cdnBaseUri\\*":\s*\\*"([^"\\]*)/, (m, g) => (cdnBaseUri = g)); // can be in eval() code, i.e. deeply escaped so ignore backslashes
      result = result.replace(/<%=appBasePath%>/g, (m) => this.devServerConfig.basePath);
      result = result.replace(/<%=uu5Environment%>/g, (m) => uu5Environment);
      result = result.replace(/<%=cdnBaseUri%>/g, (m) => cdnBaseUri);
      return result;
    };

    if (appAssetsRelativeUrlPath) {
      // rewrite routes starting with appAssetsRelativeUrlPath to omit it
      app.use((req, res, next) => {
        req.url = req.url.replace("/" + appAssetsRelativeUrlPath, "/");
        next("route");
      });
    }

    if (offline) {
      devServerMiddlewares = [require("./middlewares/offline-html-demos.js")].concat(devServerMiddlewares);
    }

    // add extra middlewares, if any
    devServerMiddlewares.forEach(middleware => {
      let MiddlewareClass;
      if (typeof middleware === "string") {
        if (middleware.match(/^\.[/\\]/)) MiddlewareClass = require(path.resolve(".", middleware));
        else MiddlewareClass = require(middleware, { paths: ["."] });
      } else if (typeof middleware === "function") {
        MiddlewareClass = middleware;
      }
      let expressFn;
      if (typeof MiddlewareClass.prototype.process === "function") {
        let instance = new MiddlewareClass(this.devServerConfig, this.webpackConfig);
        expressFn = instance.process.bind(instance);
      } else {
        expressFn = MiddlewareClass();
      }
      app.use(expressFn);
    });

    // files from outputAbsPath have biggest priority
    app.use((req, res, next) => {
      let relPath = req.path.replace(/^\/+/, "");
      if (relPath) {
        // send the file from output folder if it exists
        let file = path.resolve(outputAbsPath, relPath);
        if (fs.existsSync(file) && fs.statSync(file).isFile()) return res.sendFile(relPath, { root: outputAbsPath });

        // redirect to minified file if it exists (for "npm start" there aren't any; for "npm run start-prod" there are)
        let minFileRelPath = relPath.replace(/(\.js)$/, ".min$1");
        if (minFileRelPath !== relPath) {
          let minFile = path.resolve(outputAbsPath, minFileRelPath);
          if (fs.existsSync(minFile) && fs.statSync(minFile).isFile()) return res.redirect("/" + minFileRelPath);
        }
      }
      next();
    });

    // make OIDC callbacks available from anywhere for demo pages in library projects
    if (this.projectType.endsWith("lib")) {
      let clientId = `uu-oidc:unregistered-client:localhost`;
      app.use((req, res, next) => {
        if (req.path.endsWith("/callbacks/oidc-callback.html")) {
          return res.sendFile("callbacks/oidc-callback.html", { root: outputAbsPath });
        }
        if (req.path.endsWith("/oidc/callback")) {
          return res.sendFile("callbacks/oidc-callback.html", { root: outputAbsPath });
        }
        if (req.path.endsWith("/oidc/getClientId")) {
          return res.status(200).send({ clientId });
        }
        next();
      });
    }

    if (hot) {
      let webpackHotMiddleware = require("webpack-hot-middleware")(compiler, {
        log: false // server - don't log which bundles were built
      });
      app.use(webpackHotMiddleware);
    }
    let webpackDevMiddleware = require("webpack-dev-middleware")(compiler, {
      logLevel: summarizeWebpackStats ? "silent" : undefined, // we'll format & filter messages ourselves
      index: false,
      writeToDisk: true // so that Ruby/Node/Java server can serve files too
    });
    app.use(webpackDevMiddleware);

    let serveIndex = require("serve-index");
    app.use(
      "/",
      serveIndex(outputAbsPath, {
        stylesheet: path.join(__dirname, "misc", "serve-index.css")
      })
    );
    app.use("/", express.static(outputAbsPath));

    let httpServer = app.listen(port, host, () => {
      let boundToAllIPs = host === "0.0.0.0";
      let uri =
        "http" +
        (https ? "s" : "") +
        "://" +
        (boundToAllIPs ? "localhost" : host) +
        (port && ((https && port != 443) || (!https && port != 80)) ? ":" + port : "");
      console.log(`Project is running at ${chalk.blue(uri)}${boundToAllIPs ? " (bound to all IPs)" : ""}`);
      console.log(`Webpack output is served from ${chalk.blue(outputAbsPath)}`);
      console.log(`Compiling...`); // NOTE compiler.watch(...) is run from inside of webpack-dev-middleware.
      if (autoOpenInBrowser) {
        open(uri).catch(e => {
          console.log(
            "Unable to open browser. If you are running in a headless environment, please do not use autoOpenInBrowser flag in config/config.js.",
            e
          );
        });
      }
    });

    ["SIGINT", "SIGTERM"].forEach(sig => {
      process.on(sig, () => {
        httpServer.close();
        process.exit();
      });
    });
  }

  static start(webpackConfig, serverOpts, projectType) {
    let server = new DevServer(webpackConfig, serverOpts, projectType);
    server.start();
    return server;
  }
};

function customizeCompilerStats(compiler, summarizeWebpackStats) {
  let startTime = Date.now();
  let first = true;
  let isCompiling = true;

  // "invalid" <=> invalidated, i.e. a file is changed and Webpack is going to recompile bundles
  compiler.hooks.invalid.tap("uu_appg01_devkit watchlog", () => {
    if (!isCompiling) {
      console.log("Compiling...");
      isCompiling = true;
    }
  });

  // show messages when webpack ends recompiling
  compiler.hooks.done.tap("uu_appg01_devkit watchlog", stats => {
    let time;
    if (first) {
      time = Date.now() - startTime;
      first = false;
    }
    isCompiling = false;
    summarizeWebpackStats(stats, time);
  });

  return compiler;
}

function fixWebpackMiddlewareIssues(compiler) {
  // TODO Remove after fix.
  // https://github.com/webpack/webpack-dev-middleware/issues/290
  if (!compiler.hooks.afterEmit && compiler.compilers) {
    let tapable = require("tapable");
    compiler.hooks.afterEmit = new tapable.SyncHook(["compilation"]);
    compiler.compilers.filter(childCompiler => childCompiler.hooks.afterEmit).forEach(childCompiler =>
      childCompiler.hooks.afterEmit.tap("uu_appg01_devkit webpack-middleware-fix", (...args) => {
        compiler.hooks.afterEmit.call(...args);
      })
    );
  }

  // TODO Remove after fix.
  // webpack-dev-middleware@3.1.2 uses url-join for concatenating outputPath and request URL path
  // which results in "C://\path\on\disk\urlpath":
  // 1. We have to get rid of "//".
  // 2. We have to resolve the path so that it uses only single type of slashes.
  let util = require("webpack-dev-middleware/lib/util");
  let origGetFileNameFromUrl = util.getFilenameFromUrl;
  util.getFilenameFromUrl = function() {
    let result = origGetFileNameFromUrl.apply(this, arguments);
    if (result) {
      if (process.platform === "win32" && result.match(/^[a-z]:\/\//i)) result = result.replace(/^(.:)../, "$1");
      result = path.resolve(result);
    }
    return result;
  };
}

function regexpEscape(aValue) {
  if (!aValue) return "";
  return aValue.replace(/([[\]\\+*?{}()^$.|])/g, "\\$1");
}
