const path = require("path");
const chalk = require("chalk");

function formatMessage(message) {
  let lines = message.trim().split(/\r?\n/);
  lines = lines.filter(line => !line.match(/^ @ |^\s*at\s+/)); // strip info about from which other files was the errored file included as well as parser stacktrace, etc.
  lines = lines.filter(line => !line.match(/^Module build failed\s+\(from.*(babel-loader|less-loader)/)); // strip other non-relevant info
  let filename;
  if (lines[0]) {
    // replace:
    //   (lib_nameg01.js) ./bricks/button.less (C:/.../less-loader!./bricks/button.less)     =>
    //   (lib_nameg01.js) <blue>./bricks/button.less</blue>
    lines[0] = lines[0].replace(/^(\([^)]*\)\s+)(\.[/\\][^(]*)(?:\(.*\))?$/, (m, g1, g2) => {
      let g2Trim = g2.trim();
      filename = g2Trim.replace(/^\./, "").replace(/\//g, m => path.sep); // e.g.: \bricks\button.less
      return g1 + chalk.blue(g2Trim);
    });
    lines[0] = lines[0].replace(/^\(undefined\)\s+/, "");

    // if there's the same file name on the next line, then remove the previous one
    // (next line will have typically absolute path which is clickable in some IDEs and opens the file)
    if (filename && lines[1]) {
      let filenameEndIdx = lines[1].indexOf(filename);
      if (filenameEndIdx !== -1) lines.shift();
    }
  }

  // colorize all absolute file paths (within current directory)
  let cwd = process.cwd();
  lines = lines.map(line => {
    let result = line;
    let idx = line.indexOf(cwd);
    if (idx !== -1) {
      let length = cwd.length + line.substr(idx + cwd.length).search(/[^a-zA-Z0-9_\-/\\.]|$/);
      result = line.substr(0, idx) + chalk.blue(line.substr(idx, length)) + line.substr(idx + length);
    }
    return result;
  });

  return lines.join("\n").trim();
}

function summarizeWebpackStats(statsObj, time = null, colorSuccess = true) {
  const stats = statsObj.toJson({}, true);
  let timeStr = typeof time === "number" ? " [" + time + "ms]" : "";

  // NOTE Errors / warnings are modified in-place so that the same ones are sent to browser console.
  if (stats.errors.length) {
    // show errors (show only 1st one because others are usually due to the initial one)
    stats.errors = stats.errors.map(message => formatMessage(message));
    console.error(stats.errors[0]); // stats.errors.join("\n\n"));
    console.error(chalk.red("Failed to compile.") + timeStr);
  } else if (stats.warnings.length) {
    stats.warnings = stats.warnings.map(message => formatMessage(message));
    console.warn(stats.warnings.join("\n\n"));
    console.warn(chalk.yellow("Compiled with warnings.") + timeStr);
  } else {
    let colorFn = colorSuccess ? chalk.green.bind(chalk) : txt => txt;
    console.log(colorFn("Compiled successfully!") + timeStr);
  }

  return stats;
}

module.exports = summarizeWebpackStats;
