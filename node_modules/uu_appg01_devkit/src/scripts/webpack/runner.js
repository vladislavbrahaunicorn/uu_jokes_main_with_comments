const path = require("path");
const fs = require("fs");

const paths = require("../../config/paths.js");
const helpers = require("../../tools/helpers.js");
const summarizeWebpackStats = require("./summarize-webpack-stats.js");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");

const DEFAULT_MAPPINGS_JSON = {
  "{vendor}-{uuApp}-{uuSubApp}": {
    useCaseMap: {
      defaultVuc: {
        realization: "index.html",
        httpMethod: "GET",
        type: "VUC"
      }
    }
  }
};
module.exports = class WebpackRunner {
  constructor(webpackConfig, devServerConfig) {
    this.devServerConfig = devServerConfig;
    this.webpackConfig = webpackConfig;
  }

  async run({ watch, onCompile } = {}) {
    console.log("Running webpack.");

    // some tools need their config set to environment
    if (!process.env.BROWSERSLIST && !process.env.BROWSERSLIST_CONFIG) {
      let pkg = Package.getSingletonSync("package.json").get();
      if (!pkg.browserslist) {
        // NOTE Not using BROWSERSLIST_CONFIG variable as browserslist would read it with each query.
        let browserslist = fs.readFileSync(path.join(__dirname, "..", "..", "config", ".browserslistrc"), "utf-8");
        process.env.BROWSERSLIST = browserslist;
      }
    }
    await (watch ? this._watch({ onCompile }) : this._runSingle());
  }

  static mergeBuildConfig(projectConfig) {
    let pkg = Package.getSingletonSync("package.json").get();
    projectConfig.set(pkg.uuBuildSettings);
    mergeDefaultConfig(projectConfig, projectConfig.getUsedMode(), pkg);
    return projectConfig;
  }

  async _watch({ onCompile }) {
    let projectType = helpers.getTemplateInfo().type;
    let Server = require("./dev-server.js");
    Server.start(this.webpackConfig, { ...this.devServerConfig, summarizeWebpackStats, onCompile }, projectType);
    return new Promise(resolve => {}); // return unresolved promise
  }

  async _runSingle() {
    await new Promise((resolve, reject) => {
      const webpack = require("webpack");

      let startTime = Date.now();
      webpack(this.webpackConfig, (err, statsObj) => {
        if (err) {
          console.error(err);
          return reject(err);
        }

        let stats = summarizeWebpackStats(statsObj, Date.now() - startTime, false);
        if (stats.errors.length) return reject();

        resolve();
      });
    });
  }
};

function mergeDefaultConfig(projectConfig, mode, pkg) {
  let result = {};
  let templateType = helpers.getTemplateInfo().type;
  let config = projectConfig.getAll();

  if (config.host == null) result.host = process.env.HOST || "0.0.0.0";
  if (config.port == null) result.port = process.env.PORT || (templateType === "uu5-app" ? 1234 : 4321);
  if (config.https == null) result.https = false;
  if (config.autoOpenInBrowser == null) result.autoOpenInBrowser = false;
  if (config.sourcePath == null) result.sourcePath = paths.srcDir;
  if (config.hot == null) result.hot = mode === "development";
  if (config.watch == null) result.watch = mode === "development";
  if (config.transpileDependencies == null) result.transpileDependencies = false;

  if (templateType === "uu5-app") {
    let serverDirName = path.basename(process.cwd()).replace(/-(client|hi)/, "-server"); // "xyz-hi" => "xyz-server"; "xyz-client" => "xyz-server"
    let isWithoutServer = !fs.existsSync("../" + serverDirName);
    let outputPath = isWithoutServer ? "public" : `../${serverDirName}/public`;

    // TODO "basePath" is currently treated as application base when using *development server* only.
    // The application still uses "<preserve-2-path-segments>" (appBaseUrlPath) for computing its own base (if the value
    // was different, the generated HTML page would be simplified, i.e. different than what will be
    // in production - not a problem just a possibility of potential breakage, so we don't do it like that).
    if (config.basePath == null) result.basePath = isWithoutServer ? "" : "/vendor-app-subapp/0-0/"; // URL path that serves as root for all content (only on webpack development server)
    if (config.minify == null) result.minify = mode === "production";
    if (config.outputPath == null) result.outputPath = outputPath;
    if (config.useMockData == null) result.useMockData = true;
    if (config.packs == null) {
      result.packs = [
        {
          entryPoints: "<from-mappings-json>"
        }
      ];
      if (fs.existsSync(path.join(result.sourcePath || config.sourcePath, "loading.less"))) {
        result.packs.push({
          entryPoints: ["loading.less"],
          outputFile: "loading.css"
        });
      }
    }
    if (config.appBaseUrlPath == null) result.appBaseUrlPath = isWithoutServer ? "/" : "<preserve-2-path-segments>";
    // URL path (relative to appBaseUrlPath) where built client-side files are deployed
    if (config.appAssetsRelativeUrlPath == null) {
      let buildTimestamp = projectConfig.getBuildTimestamp();
      // add timestamp if using beta version (so that developer can deploy the same version to uuCloud over & over and
      // doesn't have to clear browser cache every time)
      result.appAssetsRelativeUrlPath = isWithoutServer
        ? ""
        : "public/" + config.version + ((config.version || "").match(/^\d+\.\d+\.\d+\D/) ? "." + buildTimestamp : "") + "/";
    }
    if (config.allowProjectPackages == null) result.allowProjectPackages = false;
    if (config.mappings == null) result.mappings = getMappingsJson(serverDirName);
  } else {
    if (config.outputPath == null) result.outputPath = paths.buildLibWebDir;
    if (config.packs == null) {
      if (templateType === "nodejs-lib") {
        result.packs = [];
      } else {
        result.packs = [
          {
            entryPoints: ["index.js"],
            outputFile: pkg.name + ".js",
            libraryGlobalVariable: pkg.namespace
          }
        ];
      }
    }
  }
  projectConfig.set(result);
}

function getMappingsJson(serverDirName) {
  let filePath = `../${serverDirName}/app/config/mappings.json`;
  if (!fs.existsSync(filePath)) filePath = "config/mappings.json";
  if (!fs.existsSync(filePath)) return DEFAULT_MAPPINGS_JSON;
  let mappingsJson = fs.readFileSync(filePath, "utf-8");
  return mappingsJson ? JSON.parse(mappingsJson) : {};
}
