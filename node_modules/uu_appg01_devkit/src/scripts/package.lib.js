const shell = require("shelljs");
const fs = require("fs-extra");
const path = require("path");

const paths = require("../config/paths.js");
const helpers = require("../tools/helpers.js");
const Pack = require("uu_appg01_devkit-common/src/tools/package.js");

module.exports = class Package {
  constructor(config) {
    this.config = config;
  }

  async process() {
    // Ensure project is built before packaging
    shell.exec("npm run --loglevel=error build -- " + this.config.toCommandLineArgs().join(" ")); // TODO Args escaping.
    Pack.getSingletonSync("package.json").loadSync(); // reload as version might have changed

    let pack = Pack.getSingletonSync("package.json");
    let pkg = pack.get();
    let { type } = helpers.getTemplateInfo();

    // move transpiled stuff to root directory so that "npm pack" includes it
    // (it can't be reconfigured to use different folder)
    console.log("Creating npm package.");
    let npmPackFile = await this._preparePackFiles(pkg, type);
    console.log("  " + npmPackFile);

    if (type === "uu5-lib" || type === "lib") {
      const zip = require("../tools/zip.js");
      const UuCloudLibraryConfig = require("./uu_cloud/uu-cloud-library-config");

      let loaderSettings;
      if (!pkg.uuBuildSettings || !pkg.uuBuildSettings.skipExternalsDiscovery) {
        const DependencyProcessor = require("./webpack/dependency-processor");
        loaderSettings = {
          ...pkg.uuBuildSettings,
          externals: new DependencyProcessor("package.json").getExternals("lib")
        };
      } else {
        loaderSettings = pkg.uuBuildSettings;
      }
      let uuCloudLibraryConfig = new UuCloudLibraryConfig(
        path.resolve("."),
        pkg.name,
        pkg.version,
        paths.buildDir,
        this.config,
        pkg.dependencies,
        loaderSettings
      );

      console.log("Creating CDN pack.");
      let projectName = pkg.name;
      let projectVersion = uuCloudLibraryConfig.getQualifiedVersion();
      let { vendor, nameNoVendor } = pack;
      let cdnPackName = vendor + "-" + nameNoVendor.replace(/_/g, "-");
      let cdnPackFile = `${projectName}-${projectVersion}.zip`;
      await zip(path.join(paths.buildDir, cdnPackFile), archive => {
        let inZipDir = path.join(cdnPackName, projectVersion);
        archive.directory(paths.buildLibWebDir, inZipDir);
        archive.file(npmPackFile, { name: pkg.name + ".tgz", prefix: inZipDir });
      });
      console.log(`  ${paths.buildDir}${path.sep}${cdnPackFile}`);

      console.log("Creating uuCloud descriptor.");
      let cloudDescriptorPath = uuCloudLibraryConfig.generateCloudDescriptor();
      uuCloudLibraryConfig.updateUuSubAppDescriptor();
      console.log("  " + cloudDescriptorPath);

      console.log("Creating uu5 library registry descriptor.");
      let libraryDescriptorPath = uuCloudLibraryConfig.generateLibraryDescriptor();
      console.log("  " + libraryDescriptorPath);
    }
  }

  async _preparePackFiles(pkg, type) {
    if (type === "uu5-lib") {
      return this._preparePackFilesInSeparateDir(pkg);
    }

    // prepare files for "npm pack" in current dir (where package.json is located)
    // - typically used in server-side / isomorphic libraries (which usually have only
    // src/ packaged)
    let ops = new ReversibleOps();
    let hasWebDir = await fs.exists(paths.buildLibWebDir);
    let hasNodeDir = await fs.exists(paths.buildLibNodeDir);
    let hasEsmDir = await fs.exists(paths.buildLibEsmDir);
    if (hasWebDir) ops.move(paths.buildLibWebDir, paths.npmPackTranspiledWebLibDir, { overwrite: true });
    if (hasNodeDir) ops.move(paths.buildLibNodeDir, paths.npmPackTranspiledNodeLibDir, { overwrite: true });
    if (hasEsmDir) ops.move(paths.buildLibEsmDir, paths.npmPackEsmDir, { overwrite: true });
    await ops.run();
    try {
      let packFile = shell.exec("npm pack", { silent: true }).stdout.trim();
      fs.moveSync(packFile, path.join(paths.buildDir, packFile), { overwrite: true });
      return path.join(paths.buildDir, packFile);
    } finally {
      await ops.rollback(); // move files back / delete copied ones
    }
  }
  async _preparePackFilesInSeparateDir(pkg) {
    let ops = new ReversibleOps();
    // prepare files for "npm pack" in target/npm-pack/ dir because
    // we need files from target/dist-root/* to be in the same directory
    // as package.json (when in .tgz) and don't want to encounter possible naming conflicts
    // while in project root
    let npmPackDir = path.join(paths.buildDir, "npm-pack");
    fs.emptyDirSync(npmPackDir);

    let hasRootDir = await fs.exists(paths.buildLibRootDir);
    let hasNodeDir = await fs.exists(paths.buildLibNodeDir);
    let hasWebDir = await fs.exists(paths.buildLibWebDir);
    let hasEsmDir = await fs.exists(paths.buildLibEsmDir);
    if (hasRootDir) ops.move(paths.buildLibRootDir, npmPackDir);
    await ops.run();
    if (hasNodeDir) ops.move(paths.buildLibNodeDir, path.join(npmPackDir, "dist-node"));
    if (hasWebDir) ops.move(paths.buildLibWebDir, path.join(npmPackDir, "dist"));
    if (hasEsmDir) ops.move(paths.buildLibEsmDir, path.join(npmPackDir, "dist-esm"));
    await ops.run();

    // copy all files as given by "files" field in package.json to our npmPackDir
    let isExpectedPkgMain = typeof pkg.main === "string" && pkg.main.match(/^(dist-node|src)\/index(\.js)?$/);
    let json = shell.exec("npm pack --dry-run --json", { silent: true }).stdout.trim();
    let extraFiles;
    try {
      extraFiles = json ? (((JSON.parse(json) || [])[0] || {}).files || []).map(it => it.path) : [];
    } catch (e) {
      // older versions of "npm" ignore "--json" flag therefore failing at JSON.parse
      extraFiles = ["package.json", "LICENSE", "README.md"];
      let isFatal;
      if (Array.isArray(pkg.files)) {
        let incompatible = pkg.files.filter(f => typeof f !== "string" || f.indexOf("*") !== -1 && !f.match(/^dist(\*|-node\/\*|-esm\/\*|\/\*)?$/));
        isFatal = incompatible.length > 0;
        if (!isFatal) extraFiles = extraFiles.concat(pkg.files.filter(f => f.indexOf("*") === -1));
      }
      const chalk = require("chalk");
      if (isFatal) {
        console.error("  " + chalk.red("ERROR") + ` Unable to create npm package - this project is using custom "files" value in package.json. Upgrade Node.js to >= 10.16.0 to fix this issue. If that is not possible then do not use glob patterns in "files" array (with the exception of "dist*" value).`);
        await ops.rollback();
        process.exit(1);
      }
      console.warn("  " + chalk.yellow("WARN") + " Old version of npm (Node.js) detected. You should upgrade Node.js to >= 10.16.0 to prevent future build issues.");
      extraFiles = [...new Set(extraFiles)].filter(f => fs.existsSync(f));
    }
    extraFiles = extraFiles.filter(it => !it.startsWith("dist"));
    if (isExpectedPkgMain) extraFiles = extraFiles.filter(it => it !== pkg.main);
    extraFiles.forEach(file => ops.copy(file, path.join(npmPackDir, file), { overwrite: false }));
    await ops.run();

    // update package.json
    let modPkg = JSON.parse(JSON.stringify(pkg));
    delete modPkg.files; // all files in folder will be included during "npm pack"
    if (isExpectedPkgMain) {
      modPkg.main = "index.js";
    }
    if (modPkg.module === "dist-esm/index.js" || modPkg.module === "dist-esm/index") {
      delete modPkg.module;
    }
    if (modPkg["jsnext:main"] === "dist-esm/index.js" || modPkg["jsnext:main"] === "dist-esm/index") {
      delete modPkg["jsnext:main"];
    }
    if (!modPkg["typings"] && fs.existsSync(path.join(npmPackDir, "index.d.ts"))) {
      modPkg["typings"] = "index.d.ts"; // must be explicitly present for JetBrains IDEs (VSCode does not need it)
    }
    fs.writeFileSync(path.join(npmPackDir, "package.json"), JSON.stringify(modPkg, null, 2), "utf-8");

    try {
      let packFile = shell.exec("npm pack", { silent: true, cwd: path.resolve(npmPackDir) }).stdout.trim();
      fs.moveSync(path.join(npmPackDir, packFile), path.join(paths.buildDir, packFile), { overwrite: true });
      return path.join(paths.buildDir, packFile);
    } finally {
      await ops.rollback(); // move files back / delete copied ones
    }
  }
};

class ReversibleOps {
  constructor() {
    this._ops = [];
    this._rollbackList = [];
  }
  async copy(...args) {
    let op = async () => fs.copy(...args);
    this._ops.push(op);
    this._rollbackList.push(() => this.remove(args[1]));
    return op;
  }
  async move(...args) {
    let op = async () => fs.move(args[0], args[1], { overwrite: true, ...args[2] }, ...args.slice(3));
    this._ops.push(op);
    this._rollbackList.push(() => this.move(args[1], args[0], { overwrite: true, ...args[2] }, ...args.slice(3)));
    return op;
  }
  async remove(...args) {
    let op = async () => fs.remove(...args);
    this._ops.push(op);
    return op;
  }
  async run(parallel = true) {
    let ops = this._ops;
    this._ops = [];
    if (parallel) return Promise.all(ops.map(op => op()));
    for (let op of ops) await op();
  }
  async rollback() {
    let rollbackList = this._rollbackList;
    this._rollbackList = [];
    rollbackList.splice(-this._ops.length, this._ops.length); // remove un-executed op rollbacks
    this._ops = [];
    rollbackList.reverse().forEach(op => op());
    return this.run(false); // in succession
  }
}
