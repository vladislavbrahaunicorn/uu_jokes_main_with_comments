const path = require("path");
const fs = require("fs-extra");

const shell = require("shelljs");
const paths = require("../config/paths.js");

let babel; // lazy-loaded
let helpers;
let WebpackRunner;
let Package;
let DependencyProcessor;

module.exports = class Build {
  constructor(config) {
    this.config = config;
  }
  async process() {
    console.log("Building project.");

    if (!this.config.getMode()) this.config.setMode("production");

    shell.mkdir("-p", paths.buildDir);

    let UpdateFromUuappJson = require("./update-from-uuapp-json.js");
    await new UpdateFromUuappJson(this.config).process();

    // NOTE Webpack might be run in nodejs-lib too, if it has configured
    // "uuBuildSettings" in package.json (used e.g. in uu_appg01_devkit
    // fpr building in-browser-transpilation.js which is used when using
    // "npm start -- --offline" in the project).
    if (!helpers) helpers = require("../tools/helpers.js");
    let templateType = helpers.getTemplateInfo().type;
    if (!Package) Package = require("uu_appg01_devkit-common/src/tools/package.js");
    let pkg = Package.getSingletonSync().get();
    if (templateType !== "nodejs-lib" || pkg.uuBuildSettings) {
      if (!WebpackRunner) WebpackRunner = require("./webpack/runner.js");
      WebpackRunner.mergeBuildConfig(this.config);
      let mode = this.config.getUsedMode();
      let { watch } = this.config.getAll();
      let config = this.config.getAll();

      // compute externals
      let externalsDetail;
      if (!DependencyProcessor) DependencyProcessor = require("./webpack/dependency-processor.js");
      let depProcessor = new DependencyProcessor("package.json");
      if (!config.skipExternalsDiscovery) {
        let { detail, config: externalsConfig } = depProcessor.getDetailedExternals("lib");
        config.externals = externalsConfig;
        externalsDetail = detail;
      } else if (config.externals) {
        for (let k in config.externals) {
          let dep = config.externals[k];
          if (!dep || typeof dep !== "object") continue;
          depProcessor.replaceDependencyExpressions(k, dep);
        }
      }

      // clean output directory
      let nodeDestDir = path.resolve(config.outputPath, "..", "dist-node");
      let cjsOutputPath = templateType === "uu5-lib" ? nodeDestDir : null;
      fs.emptyDirSync(config.outputPath);
      if (cjsOutputPath) fs.emptyDirSync(cjsOutputPath);

      // copy lib/ folder
      if (fs.existsSync("lib")) {
        shell.cp("-rf", "lib", config.outputPath);
        if (cjsOutputPath) shell.cp("-rf", "lib", cjsOutputPath);
      }

      this.showDependenciesSettings(config, pkg);

      // generate mock data
      if (config.useMockData) {
        fs.ensureDirSync("mock/data");
        fs.copySync(require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/mock/calls.js"), "mock/calls.js", {
          overwrite: false,
        });
        fs.copySync(
          require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/mock/http-client.js"),
          "mock/http-client.js",
          { overwrite: false }
        );
        fs.copySync(require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/src/calls.js"), "src/calls.js", {
          overwrite: false,
        });
      }

      // run webpack
      let env = {
        isDevServer: watch,
        isDistributionBuild: !watch && mode === "production"
      };
      let webpackConfig = require("../config/webpack.config.js").getFromConfig(config, env);
      if (webpackConfig && (!Array.isArray(webpackConfig) || webpackConfig.length > 0)) {
        await new WebpackRunner(webpackConfig, config).run({
          watch,
          onCompile: watch ? this._onWatchedCompile.bind(this, pkg) : null
        });

        // additional build steps
        if (templateType === "uu5-lib") {
          let srcDir = config.sourcePath;
          let destDir = config.outputPath;
          let srcDirAbsPath = path.resolve(srcDir);

          // finish building of CJS (Node-like) variant of the library by preparing submodule files
          // that will be in the root of built NPM .tgz file (these will ensure that applications
          // such as those created by create-react-app can import our submodules via "lib/submodule")
          // NOTE 2.x We'll preserve target/dist/, target/dist-node/, structure for backward compatibility.
          // In next major we should just make target/build/ and build all variants there.
          let distRootFilesDir = path.resolve(destDir, "..", "dist-root");
          fs.emptyDirSync(distRootFilesDir);
          let submodules = getSubmodules(config.packs, pkg.name);
          let cjsFileMap = { index: pkg.name };
          submodules.forEach(({ name }) => (cjsFileMap[name.substr(pkg.name.length + 1)] = name));
          for (let [cjsFile, builtFile] of Object.entries(cjsFileMap)) {
            let content = `module.exports = process.env.NODE_ENV === "production" ? require("./dist-node/${builtFile}.min.js") : require("./dist-node/${builtFile}.js");\n`;
            fs.writeFileSync(path.join(distRootFilesDir, cjsFile + ".js"), content, "utf-8");
          }
          // for backward compatibility generate also entrypoints based on packs
          // (e.g. uu5g04-bricks with entry point bricks/bricks-build.js will end-up in dist-node/bricks/bricks-build.js
          // and in .tgz file it will just redirect to require("../../bricks.js") which is during build located it dist-root/bricks.js)
          submodules.forEach(({ name, entryPoint }) => {
            let content = `module.exports = require(${JSON.stringify(
              path.relative(path.resolve(srcDir, entryPoint), path.resolve(srcDir)).replace(/\\/g, "/") +
                "/" +
                name.substr(pkg.name.length + 1) +
                ".js"
            )});\n`;
            let destFile = path.join(
              nodeDestDir,
              path.relative(path.resolve(srcDir), path.resolve(srcDir, entryPoint))
            );
            fs.ensureDirSync(path.dirname(destFile));
            fs.writeFileSync(destFile, content, "utf-8");
          });

          // generate index.d.ts file so that there's Intellisense available in IDEs
          if (!config.skipBuildIntellisense) {
            console.log("Generating files for better Intellisense in IDEs.");
            let srcIndexDTs = path.join(srcDir, "index.d.ts");
            let destIndexDTs = path.join(distRootFilesDir, "index.d.ts");
            if (fs.existsSync(srcIndexDTs)) fs.copySync(srcIndexDTs, destIndexDTs);
            else {
              let processEnv = require("../config/process-env.js")(pkg, "development", "browser");
              delete processEnv.NODE_ENV;
              let babelConfig = require("../config/.babelrc.js")("development", processEnv);
              const Es6ExportsReader = require("./intellisense/es6-exports-reader");
              let exportsReader = new Es6ExportsReader(babelConfig);

              let { packs = [] } = config;
              let mainNamespace = pkg.namespace;
              let packNsMap = {};
              for (let pack of packs) {
                if (
                  pack &&
                  pack.libraryGlobalVariable &&
                  (pack.libraryGlobalVariable === mainNamespace ||
                    pack.libraryGlobalVariable.startsWith(mainNamespace + "."))
                ) {
                  packNsMap[pack.libraryGlobalVariable] = pack;
                }
              }

              let mainExports;
              let mainNamespaceFixUp;
              let packsSorted = Object.values(packNsMap).sort(
                (a, b) => a.libraryGlobalVariable.length - b.libraryGlobalVariable.length
              ); // TODO Sort by dependencies in-between the packs (e.g. uu5g04 <= uu5g04-bricks <= uu5g04-forms).
              // 1st pack is always the one with the main namespace
              for (let pack of packsSorted) {
                let entryFile = (pack.entryPoints || []).slice(-1)[0];
                if (entryFile) {
                  let exports = exportsReader.getExportsFromFile(path.resolve(srcDirAbsPath, entryFile));
                  if (pack.libraryGlobalVariable === mainNamespace) mainExports = exports;
                  else {
                    let { default: _, ...exportsWithoutDefault } = exports;
                    let nsParts = pack.libraryGlobalVariable.substr(mainNamespace.length + 1).split(".");
                    if (!mainExports) {
                      // this can happen if there's pkg.namespace vs. packs[0].libraryGlobalVariable discrepancy
                      // e.g. uu_contentkitg01 is UuContentKit.Bricks, uu_contentkitg01-tables is UuContentKit.Tables,
                      //      but pkg.namespace === "UuContentKit"
                      // => we'll only process exports from 1st pack so that `import Xyz from "uu_contentkitg01";` has proper Intellisense - UuContentKit.Bricks.*
                      //    (`import "uu_contentkitg01-tables";` won't have Intellisense as it's correct that it is not present
                      //    in Xyz due to the discrepancy)
                      mainExports = exports;
                      mainNamespaceFixUp = pack.libraryGlobalVariable;
                      break;
                    }
                    let targetField = mainExports;
                    nsParts.forEach((part, i, list) => {
                      targetField[part] = {
                        type: "namespace",
                        objectFields: i === list.length - 1 ? exportsWithoutDefault : {}
                      };
                      targetField = targetField[part].objectFields;
                    });
                  }
                }
              }
              if (mainExports) {
                const ExportsToTypings = require("./intellisense/exports-to-typings");
                let exportsToTypings = new ExportsToTypings();
                let moduleNameOfNamespaceRoot =
                  mainNamespace.indexOf(".") === -1
                    ? pkg.name
                    : getLibraryNameByNamespace(mainNamespace.split(".").shift(), externalsDetail); // TODO Compute for non-roots. E.g. if mainNamespace === "UU5.Tiles" then root is "UU5" and module is "uu5g04".
                let typings = exportsToTypings.serialize(
                  mainExports,
                  mainNamespaceFixUp || mainNamespace,
                  mainNamespaceFixUp ? undefined : moduleNameOfNamespaceRoot
                );
                fs.writeFileSync(destIndexDTs, typings, "utf-8");
              }
            }
          }

          // generate also dist-esm/ folder (for backward compatibility) but keep it empty
          let distEsmFilesDir = path.resolve(destDir, "..", "dist-esm");
          fs.ensureDirSync(distEsmFilesDir);

          // build for NodeJS - transpile ES6 imports/exports to NodeJS require-s (e.g. to support tests via Jest)
          if (config.nodeBuildIncludes) {
            console.log(`Building for NodeJS (to support tests via Jest) into ${path.relative(".", nodeDestDir)}.`);
            let processEnv = require("../config/process-env.js")(pkg, "development", "browser");
            delete processEnv.NODE_ENV;
            let babelConfig = require("../config/.babelrc.js")("development", processEnv);
            let babelDistNodeConfig = {
              ...babelConfig,
              babelrc: false,
              plugins: babelConfig.plugins || []
            };
            let babelPluginTMC = "@babel/plugin-transform-modules-commonjs";
            let babelPluginTMCResolved = require.resolve(babelPluginTMC);
            if (
              babelDistNodeConfig.plugins.indexOf(babelPluginTMC) === -1 &&
              babelDistNodeConfig.plugins.indexOf(babelPluginTMCResolved)
            ) {
              babelDistNodeConfig.plugins.push(babelPluginTMCResolved);
            }
            let aliases = ((webpackConfig[0] || {}).resolve || {}).alias || {};
            let files = new Set();
            let globs = Array.isArray(config.nodeBuildIncludes)
              ? config.nodeBuildIncludes.map(it => srcDir + (it.startsWith("/") ? it : "/" + it))
              : [
                  srcDir +
                    (config.nodeBuildIncludes.startsWith("/")
                      ? config.nodeBuildIncludes
                      : "/" + config.nodeBuildIncludes)
                ];
            const glob = require("glob");
            globs.forEach(g => glob.sync(g).forEach(f => files.add(f)));
            [...files].sort().forEach(filePath => {
              let stats = fs.statSync(filePath);

              // ignore demo folders / files
              if (stats.isDirectory() && filePath.endsWith("/demo")) return;
              if (filePath.indexOf("/demo/") !== -1) return;
              if (stats.isDirectory() && filePath.endsWith("/assets")) return;
              if (filePath.indexOf("/assets/") !== -1) return;
              if (stats.isDirectory() && filePath.endsWith("/test")) return;
              if (filePath.indexOf("/test/") !== -1) return;

              // copy to target as-is, or with fixup of webpack aliases
              let relPath = path.resolve(filePath).substr(srcDirAbsPath.length + path.sep.length);
              let targetFile = path.join(nodeDestDir, relPath);
              if (stats.isDirectory()) fs.mkdirSync(targetFile);
              else if (!filePath.match(/\.jsx?$/)) fs.copySync(filePath, targetFile);
              else buildAsNodeJs(filePath, targetFile, aliases, babelConfig, { targetFolder: nodeDestDir }); // replace webpack aliases in files
            });
          }
        }
      }
    }
  }

  showDependenciesSettings(config, pkg) {
    let deps = config.externals;
    let externalDeps = {};
    let externalDepsInfo =
      Object.keys(deps)
        .filter(depName => !!deps[depName])
        .map(depName => {
          let dep = deps[depName];
          externalDeps[depName] = dep;
          let paddedDepName = (depName + "                      ").substr(0, Math.max(20, depName.length));
          return `${paddedDepName}`;
        })
        .join("\n") || "<none>";
    let bundledDepsInfo =
      Object.keys(pkg.dependencies || {})
        .filter(depName => !externalDeps[depName] && !depName.startsWith("systemjs-plugin-")) // hide SystemJS plugins
        .join("\n") || "<none>";
    console.log(`
BUILD OVERVIEW
External dependencies (including transitive):
${externalDepsInfo.replace(/(^|\n)/g, "$1  ")}

Dependencies from package.json bundled directly into main JS file (if imported):
${bundledDepsInfo.replace(/(^|\n)/g, "$1  ")}
`);
  }

  _onWatchedCompile(pkg, stats) {
    // run postbuild script from package.json after 1st compilation when in "watch" mode
    if (!this._ranPostBuildScript) {
      this._ranPostBuildScript = true;
      if (pkg && pkg.scripts && pkg.scripts.postbuild) {
        require("child_process").spawn("npm run -s postbuild", {
          shell: true,
          cwd: process.cwd(),
          stdio: "inherit"
        });
      }
    }
  }
};

function buildAsNodeJs(srcFile, targetFile, aliases, babelConfig, opts) {
  function getModuleName(moduleName) {
    if (!aliases || !aliases[moduleName]) return moduleName;

    // redirect webpack aliases to standalone files
    let redirectTo = opts.targetFolder + "/__" + moduleName.replace(/[/\\]/g, "__") + ".js";
    if (!fs.existsSync(redirectTo)) fs.copySync(aliases[moduleName], redirectTo);
    return "./" + path.relative(path.dirname(path.resolve(targetFile)), path.resolve(redirectTo)).replace(/\\/g, "/");
  }

  let content = fs.readFileSync(srcFile, "utf-8");

  // replace webpack aliases in "import" statements - copy contents of the aliased files
  // into targetFolder and redirect aliased names to the new file, e.g.:
  //   `import ns from "ns";`   =>  `import ns from "../../__ns.js"`
  // & copy contents of current "ns" alias to dist-esm/__ns.js
  if (!babel) babel = require("@babel/core");
  let ast = babel.parseSync(content, babelConfig);
  ((ast.program || {}).body || [])
    .filter(it => it.type === "ImportDeclaration")
    .forEach(importDecl => {
      let moduleName = importDecl.source.value;
      let usedModuleName = getModuleName(moduleName);
      if (usedModuleName !== moduleName) {
        // console.log(moduleName, "->", usedModuleName, srcFile);
        importDecl.source.value = importDecl.source.rawValue = usedModuleName;
        importDecl.source.raw = JSON.stringify(usedModuleName);
      }
    });
  let transResult = babel.transformFromAstSync(ast, content, babelConfig);
  let dirName = path.dirname(targetFile);
  if (dirName) fs.ensureDirSync(dirName);
  fs.writeFileSync(targetFile, transResult.code, "utf-8");
}

function getSubmodules(packs, pkgName) {
  let result = [];
  if (packs) {
    packs.forEach(pack => {
      if (!(pack.outputFile || "").match(/\.js$/)) return;
      let name = pack.outputFile
        .split(/[/\\]/)
        .pop()
        .replace(/(\.min)?\.js$/, "");
      if (name.startsWith(pkgName + "-")) {
        result.push({ name, entryPoint: pack.entryPoints[pack.entryPoints.length - 1] });
      }
    });
  }
  return result;
}

function getLibraryNameByNamespace(ns, externalsDetail) {
  if (!externalsDetail || !ns) return;
  for (let external of Object.values(externalsDetail)) {
    let { namespace, name } = ((external || {}).sourceMeta || {}).json || {};
    if (namespace === ns) return name;
  }
}
