const path = require("path");
const helpers = require("../tools/helpers.js");
const StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
const parse5 = require("parse5");
const os = require("os");
const { Parser } = require("acorn");
const util = require("util");
const ncp = require("ncp");
const promisified_ncp = util.promisify(ncp.ncp);

const { fileExists } = require("../tools/helpers");
const ModelGenerator = require("./cmd_generator/model-generator");
const ControllerGenerator = require("./cmd_generator/controller-generator");
const ErrorGenerator = require("./cmd_generator/error-generator");
const ValidationTypesGenerator = require("./cmd_generator/validation-types-generator");
const ConfigAdjuster = require("./cmd_generator/config-adjuster");

const OidcToken = require("uu_appg01_devkit-common/src/scripts/oidc-token.js");
const AppClient = require("uu_appg01_devkit-common/src/scripts/misc/app-client.js");


const LOAD_PAGE = "loadPage";

module.exports = class GenerateCmdBookit {
  constructor(config) {
    this.pageUri = config.commandLineConfig.pageUri;
  }
  async process() {
    console.log("Obtaining design info");
    let responseBody = await (new BookKitLoader()).getPage(this.pageUri);
    console.log("Parsing design info");
    let context = Context.get(responseBody);
    console.log("Generating uuCmd");
    await CmdGenerator.execute(context);
  }
};

class CmdGenerator {

  static async execute(context) {
    console.log("Creating backup of current project");
    let appPath = path.resolve(process.cwd(), "app");
    let libPath = path.resolve(process.cwd(), "src");
    let backupFolder = path.resolve(process.cwd(), "target", `cmd-backup-${(new Date()).toISOString().replace(/[:T]/g,"-").split(".")[0]}-${context.entity}-${context.cmdName}`);
    if ( fileExists(appPath) ) {
      await promisified_ncp(appPath, backupFolder);
    } else if ( fileExists(libPath) ) {
      await promisified_ncp(libPath, backupFolder);
    } else {
      console.log(`The current project ${process.cwd()} has neither app nor src folder. Nothing can be done in here...`);
      process.exit(1);
    }

    await (new ConfigAdjuster(context)).execute();
    await (new ControllerGenerator(context)).execute();
    await (new ModelGenerator(context)).execute();
    await (new ErrorGenerator(context)).execute();
    await (new ValidationTypesGenerator(context)).execute();
  }

}

class Context {

  static get(dtoOut) {
    let context = {};
    // look for cmd info
    let cmdInfo, validationType, errors;
    for ( let section of dtoOut.body ) {
      if ( section.content.indexOf("UuApp.DesignKit.UuCmdInfo") !== -1 ) {
        cmdInfo = parse5.parse(section.content);
      }
      if ( section.content.indexOf("DtoInType = shape({") !== -1 ) {
        validationType = parse5.parse(section.content);
      }
      if ( section.content.indexOf("UuApp.DesignKit.UuCmdErrorList") !== -1 ) {
        errors = parse5.parse(section.content);
      }
    }
    // get stuff from the cmd summary
    Context._processCmdInfo(context, cmdInfo);
    // get stuff from validation spec
    if(validationType) Context._processValidation(context, validationType);
    // get stuff from error list
    Context._processErrors(context, errors);
    return context;
  }

  static _processCmdInfo(context, parsedCmdInfo) {
    let element = Context._findElement(parsedCmdInfo, "UuApp.DesignKit.UuCmdInfo");
    let result;
    for ( let attr of element.attrs ) {
      if ( attr.name && attr.name === "data" ) {
        result = attr.value;
        break;
      }
    }

    let aSplit, parsingFailed, kombajn;
    try {
      aSplit = result.trim().replace(/^<uu5json\/>\s*\[\s*/, "").replace(/\s*]/, "").split(/"\s*,\s*/).map(x => x.replace(/^"/, "").replace(/"$/,""));
    } catch (e) {
      console.error(e);
      parsingFailed = true;
    }

    if ( parsingFailed || aSplit.length < 5 ) {
      console.log("Parsing of UuApp.DesignKit.UuCmdInfo failed.");
      process.exit(1);
    }

    let cmdNameSplit = aSplit[0].split("/");
    let entity = cmdNameSplit[0].trim();
    let cmdName = cmdNameSplit[1].trim();

    if ( !entity || !cmdName || (entity && entity === "sys") ) {
      console.log(`Generating new uuCmd cannot be run for ${aSplit[0].trim()} use case`);
      process.exit(1);
    }

    context.cmdName = cmdName;
    context.errorName = cmdName.charAt(0).toUpperCase() + cmdName.slice(1);
    context.classFile = StringUtil.dashCase(entity);
    context.constantName = StringUtil.snakeCase(entity).toUpperCase();
    context.className = entity.charAt(0).toUpperCase() + entity.slice(1);
    context.entity = entity.charAt(0).toLowerCase() + entity.slice(1);
    context.httpMethod = aSplit[2].toUpperCase();
    context.isPrivileged = aSplit[3].indexOf("{awid}") === 1;
    context.profiles = aSplit[4].split(",").map(x => x.trim());
  }

  static _processValidation(context, parsedValidationInfo) {
    let element = Context._findElement(parsedValidationInfo, "UuApp.DesignKit.EmbeddedText");
    element = Context._findElement(element, "#text");
    let validations, parsingFailed, parsedValidations, validationType;
    try {
      validations = element.value.trim().replace(new RegExp(/\r?\n\s+/, "g"), `${os.EOL}  `).replace(/\r?\n\s+}\)/, `${os.EOL}})`);
      if ( !validations.endsWith(";") ) validations = validations + ";";
      parsedValidations = Parser.parse(validations, { sourceType: "module" });
      validationType = parsedValidations.body[0].declarations[0].id.name;
    } catch (e) {
      console.error(e);
      parsingFailed = true;
    }

    if ( parsingFailed || !validations || !validationType ) {
      console.log("Parsing of validation failed");
      process.exit(1);
    }

    context.validations = validations;
    context.validationType = validationType;
  }

  static _processErrors(context, parsedErrorsInfo) {
    let cmdErrorList = Context._findElement(parsedErrorsInfo, "UuApp.DesignKit.UuCmdErrorList");
    let result;
    for ( let attr of cmdErrorList.attrs ) {
      if ( attr.name && attr.name === "data" ) {
        result = attr.value;
        break;
      }
    }
    let parsedErrors;
    try {
      // THIS WORKS I SWEAR! please..
      // parsedErrors = result.split("<uu5json/>")[1].trim().replace(/^\s*\[\s*/, "").replace(/\s*]$/, "").split(/]\s*,\s*\[/).map(x => x.replace(/^\[/, "").split(",").slice(0, 3).map(y => y.trim().replace(/"/g, "")));
      // let aaa = result.split("<uu5json/>")[1];
      // let proc = tmp.split(/]\s*,\s*\[/).map(x => x.replace(/^\[/,"").split(",").slice(0, 3).map(y => y.trim().replace(/"/g, "")));
      // tmp = 0;
      // parsedErrors = result.split("<uu5json/>[[")[1].split("]]")[0].split("],[").map(x => x.split(",").slice(0, 3).map(y => y.replace(/"/g, "")));
      parsedErrors = result.trim().replace(/^<uu5json\/>\s*\[\s*\[/, "").replace(/]\s*]$/, "").split(/]\s*,\s*\[/).map(x=>x.split(",").slice(0,3).map(y=>y.trim().replace(/"/g, "")));
      // parsedErrors = result.split("<uu5json/>")[1].trim().replace(/^\s*\[\s*/, "").replace(/\s*]$/, "").split(/]\s*,\s*\[/).map(x => x.replace(/^\[/, "").split(",").slice(0, 3).map(y => y.trim().replace(/"/g, "")));
      // tmp = 0;
    } catch (e) {
      console.error(e);
      console.log("Parsing of UuApp.DesignKit.UuCmdErrorList failed");
      process.exit(1);
    }
    let errors = [];
    let warnings = [];

    for ( let pe of parsedErrors ) {
      if ( pe[1] === "Error" ) {
        errors.push({ code: pe[0], message: pe[2] });
      } else if ( pe[1] === "Warning" ) {
        warnings.push({ code: pe[0], message: pe[2] });
      } else {
        console.log(`Unexpected type ${pe[1]} in UuApp.DesignKit.UuCmdErrorList`);
      }
    }

    context.errors = errors;
    context.warnings = warnings;
  }

  static _findElement(parsedHtml, elementName) {
    let stack = [parsedHtml];
    while ( stack.length !== 0 ) {
      let element = stack.pop();
      if ( !element.childNodes ) {
        continue;
      }
      for ( let node of element.childNodes ) {
        if ( node.nodeName && node.nodeName === elementName.toLowerCase() ) {
          return node;
        }
        stack.push(node);
      }
    }
    return null;
  }

}

class BookKitLoader {

  constructor() {
    let token = new OidcToken(process.cwd(), path.resolve(process.cwd(), "target", ".devkit-token"));
    this.client = new AppClient(token);
  }

  async getPage(pageUri) {
    if(!pageUri) {
      console.log("pageUri is mandatory but missing");
      process.exit(1);
    }

    let aSplit = pageUri.split("/");
    if ( aSplit.length !== 7 ) {
      console.log(`Invalid page uri: ${pageUri}`);
      process.exit(1);
    }
    let paramSplit = aSplit[6].split("?");
    if ( paramSplit.length !== 2 ) {
      console.log(`Invalid ${pageUri} - no uri parameters`);
      process.exit(1);
    }
    let requestUri = `${aSplit.slice(0, 5).join("/")}/${LOAD_PAGE}?${paramSplit[1]}`;

    // let requestUri = builder.setUseCase(LOAD_PAGE).toUri();
    let response = await this.client.exchange(requestUri.toString(), "get");
    return JSON.parse(response.body);
  }

}
