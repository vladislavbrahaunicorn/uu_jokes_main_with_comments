const { Parser } = require("acorn");
const path = require("path");
const util = require("util");
const fs = require("fs-extra");
const fs_readdir = util.promisify(fs.readdir);
const fs_readFile = util.promisify(fs.readFile);
const fs_writeFile = util.promisify(fs.writeFile);
const { evalTemplate, processFile } = require("uu_appg01_devkit-common/src/tools/template-helpers.js");
const { fileExists } = require("../../tools/helpers");
const os = require("os");

const MAIN_ERROR_IDENTIFIER = "extends UseCaseError";

class ErrorGenerator {

  constructor(context, executionQueue) {
    this.context = JSON.parse(JSON.stringify(context));
    this.errorPath = path.normalize(`${context.sourceCodePath}/api/errors/${context.classFile}-error.js`);
    this.errorClassTemplate = path.normalize(`${__dirname}/templates/error-class.js`);
    this.errorConstantTemplate = path.normalize(`${__dirname}/templates/error-constant.js`);
    this.errorTemplate = path.normalize(`${__dirname}/templates/error.js`);
    this.executionQueue = executionQueue;
  }

  async execute() {
    // Finding Nemo (i.e. the error class every other errors inherits from)
    let mainError = await this._getMainError();
    this.context.mainErrorClass = mainError.class;
    this.context.mainErrorFile = mainError.file;

    if (await fileExists(this.errorPath)) {
      console.log(`Checking contents of ${this.errorPath}`);
      // this could be read already in _getMainError :(
      let sourceCode = await fs_readFile(this.errorPath, "utf-8");
      // duplicity check
      let ast = Parser.parse(sourceCode, { sourceType: "module" });
      for (let entity of ast.body) {
        if (entity.type === "VariableDeclaration" && entity.kind === "const" && entity.declarations[0].id.name === this.context.errorName) {
          console.log(`${this.errorPath} already contains constant ${this.context.errorName}`);
          process.exit(1);
        }
      }

      // put the error constant as a last constant in class (easier to find)
      let moduleIdx = sourceCode.indexOf("module.exports");
      let moduleBodyIdx = sourceCode.indexOf("{", moduleIdx) + 1;
      let modulePart = `${sourceCode.substring(moduleIdx, moduleBodyIdx)}${os.EOL}  ${this.context.errorName},${sourceCode.substring(moduleBodyIdx)}`;
      let newError = `${sourceCode.substring(0, moduleIdx)}${await this._generateErrorConstant()};${os.EOL}${os.EOL}${modulePart}`;
      this.executionQueue.addEvent(async () => {
        console.log(`Modifying ${this.errorPath}`);
        await fs_writeFile(this.errorPath, newError);
      });
    } else {
      this.context.error = await this._generateErrorConstant();
      this.executionQueue.addEvent(async () => {
        console.log(`Creating ${this.errorPath}`);
        await processFile(this.errorTemplate, this.errorPath, this.context);
      });
    }
  }

  async _generateErrorConstant() {
    let errorClasses = [];
    // there is a new local context, bcs it changes per iteration
    // (the instance context could do the same tbh, but I liked it this way)
    let errorClassContext = {
      mainErrorClass: this.context.mainErrorClass,
      errorName: this.context.errorName
    };
    for (let error of this.context.errors) {
      errorClassContext.errorClassName = error.code.charAt(0).toUpperCase() + error.code.slice(1);
      errorClassContext.errorCode = error.code;
      errorClassContext.errorMessage = error.message;
      errorClasses.push((await evalTemplate(this.errorClassTemplate, errorClassContext)).trim());
    }
    // main context has errors and errorConstantTemplate context wants a different errors => another local context
    let errorConstantContext = {
      errors: "  " + errorClasses.join(`,${os.EOL}`).replace(new RegExp(os.EOL, "g"), `${os.EOL}  `),
      errorName: this.context.errorName,
      constantName: this.context.constantName,
      cmdName: this.context.cmdName
    };
    return (await evalTemplate(this.errorConstantTemplate, errorConstantContext)).trim();
  }

  async _getMainError() {
    let errorFolder = path.dirname(this.errorPath);
    let files = await fs_readdir(errorFolder);
    for (let file of files) {
      let sourceCode = await fs_readFile(path.join(errorFolder, file), "utf-8");
      if (sourceCode.indexOf(MAIN_ERROR_IDENTIFIER) !== -1) {
        let parsedSourceCode = Parser.parse(sourceCode, { sourceType: "module" });
        for (let entity of parsedSourceCode.body) {
          if (entity.type === "ClassDeclaration") {
            return { class: entity.id.name, file };
          }
        }
      }
    }
    console.log(`There is no main error class in ${errorFolder}`);
    process.exit(1);
  }

}

module.exports = ErrorGenerator;
