const readline = require("readline");

const HTTP_GET = "GET";
const HTTP_POST = "POST";
const SYS = "sys";
const AWID = "awid";
const ASID = "asid";
const DTO_IN = "dtoIn";
const SESSION = "session";
const AUTHZ_RESULT = "authorizationResult";

const WORD = "[A-Za-z0-9]{3,32}";
const USE_CASE_REGEXP = new RegExp(`^(${WORD}/)*${WORD}$`); // /^([A-Za-z]{3,32}\/)*[A-Za-z]{3,32}$/;
const YES_NO_REGEXP = /^(yes|no|)$/;
const HTTP_METHOD_REGEXP_STRICT = new RegExp(`^${HTTP_GET}|${HTTP_POST}$`);
const HTTP_METHOD_REGEXP =  new RegExp(`^(${HTTP_GET}|${HTTP_POST}|)$`);
const ENTITY_STRICT_REGEXP = new RegExp(`^${WORD}$`);
const ENTITY_RELAXED_REGEXP = new RegExp(`^(${WORD}|)$`);
const PROFILES_REGEXP = /^([0-9a-zA-Z_]{3,64}, *)*[0-9a-zA-Z_]{3,64}$|^$/;

// the name is quite the horsesh.., but I don't know any better
class UserInputExtractor {

  constructor() {
    this.readline = null;
  }

  async extractStatic(commandLineArgs) {
    let result = {};

    // useCase
    if (commandLineArgs.useCase === undefined) {
      console.log("useCase parameter is mandatory, but not present");
      process.exit(1);
    } else if (!commandLineArgs._commandLineArgs.some(x => x === `--useCase=${commandLineArgs.useCase}`)) {
      // this happens when the variables are not prefixed with double dash,
      // e.g. npm run something -- --useCase=correctOne forgottenDashes=something
      // or there are empty spaces in value definition
      // e.g. npm run something -- --useCase=correctOne --someList=one,two, three
      console.log("Invalid command line parametrization: Check the variables are prefixed withou double dash and there are no unquoted spaces within value definiton");
      process.exit(1);
    }
    if (!this._isString(commandLineArgs.useCase) || !commandLineArgs.useCase.match(USE_CASE_REGEXP)) {
      console.log(`Unsupporedt useCase value "${commandLineArgs.useCase}"`);
      process.exit(1);
    }
    result.useCase = commandLineArgs.useCase;

    // entity
    if (commandLineArgs.entity !== undefined) {
      if (!this._isString(commandLineArgs.entity) || !commandLineArgs.entity.match(ENTITY_STRICT_REGEXP)) {
        console.log(`Unsupported entity value "${commandLineArgs.entity}"`);
        process.exit(1);
      }
      result.entity = commandLineArgs.entity;
    } else {
      let ucSplit = result.useCase.split("/");
      if (ucSplit.length === 2  && ucSplit[0] !== SYS) {
        result.entity = ucSplit[0];
      } else {
        console.log(`entity was not specified and can not be inferred from useCase`);
        process.exit(1);
      }
    }

    // privileged
    result.privileged = !!commandLineArgs.privileged;

    // http method
    if (commandLineArgs.httpMethod !== undefined) {
      if (!this._isString(commandLineArgs.httpMethod) || !commandLineArgs.httpMethod.match(HTTP_METHOD_REGEXP_STRICT)) {
        console.log(`Unsupported httpMethod value "${commandLineArgs.httpMethod}"`);
        process.exit(1);
      }
      result.httpMethod = commandLineArgs.httpMethod;
    } else {
      result.httpMethod = HTTP_GET;
    }

    // profiles
    let cmdProfiles = commandLineArgs.profileList;
    if (cmdProfiles !== undefined) {
      if (!this._isString(cmdProfiles) || !commandLineArgs.profileList.match(PROFILES_REGEXP)) {
        console.log(`Unsupported profileList value "${commandLineArgs.profileList}"`);
        process.exit(1);
      }
      result.profiles = commandLineArgs.profileList;
    } else {
      result.profiles = "";
    }

    // the stubs
    result.daoStub = !!commandLineArgs.daoStub;
    result.testStub = !!commandLineArgs.testStub;

    return result;
  }

  async extractInteractive() {
    if (!this.readline) {
      this.readline = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
    }

    let result = {};
    result.useCase = await this._getUserInput("use case: ", USE_CASE_REGEXP);

    let ucSplit = result.useCase.split("/");
    let entity = ucSplit.length === 2 && ucSplit[0] !== SYS ? ucSplit[0] : null;
    let question = `entity (determines names of api and abl files)${entity ? `, [${entity}]` : ""}: `;
    if (entity) {
      result.entity = await this._getUserInput(question, ENTITY_RELAXED_REGEXP, val => val || entity);
    } else {
      result.entity = await this._getUserInput(question, ENTITY_STRICT_REGEXP);
    }

    result.isPrivileged = await this._getUserInput("privileged? - one of yes, no [no]: ", YES_NO_REGEXP, val => val === "yes");
    result.httpMethod = await this._getUserInput("HTTP method - one of GET, POST [GET]: ", HTTP_METHOD_REGEXP, val => val || HTTP_GET);
    result.profiles = await this._getUserInput("profileList - coma separated values []: ", PROFILES_REGEXP);

    result.daoStub = await this._getUserInput("create DAO stub? - one of yes, no [no]: ", YES_NO_REGEXP, val => val === "yes");
    result.testStub = await this._getUserInput("create test stub? - one of yes, no [no]: ", YES_NO_REGEXP, val => val === "yes");

    if (this.readline) {
      this.readline.close();
      this.readline = null;
    }

    return result;
  }

  _isString(value) {
    return typeof value === "string" || value instanceof String;
  }

  async _getUserInput(question, validationRegex, conversion) {
    let aSplit = question.split("-");
    if (aSplit.length === 1) {
      aSplit = question.split("(");
    }
    if (aSplit.length === 1) {
      aSplit = question.split(",");
    }
    if (aSplit.length === 1) {
      aSplit = question.split(":");
    }
    let important = aSplit[0].trim();

    let value;
    while (true) {
      value = await new Promise(resolve => {
          return this.readline.question(question, ans => {
            resolve(ans);
          });
        }
      );
      if (value.match(validationRegex)) {
        if (conversion) {
          return conversion(value);
        }
        return value;
      }
      console.log(`Unsupported ${important} value "${value}"`);
    }
  }

}

module.exports = UserInputExtractor;
