const util = require("util");
const path = require("path");
const fs = require("fs-extra");
const fs_readFile = util.promisify(fs.readFile);
const fs_writeFile = util.promisify(fs.writeFile);
const { evalTemplate, processFile } = require("uu_appg01_devkit-common/src/tools/template-helpers.js");
const { verifyClass, fileExists } = require("../../tools/helpers");
const os = require("os");

class ModelGenerator {

  constructor(context, executionQueue) {
    this.context = JSON.parse(JSON.stringify(context));
    this.modelPath = path.normalize(`${context.sourceCodePath}/abl/${context.classFile}-abl.js`);
    this.modelTemplate = path.normalize(`${__dirname}/templates/model.js`);
    this.modelMethodTemplate = path.normalize(`${__dirname}/templates/model-method.js`);
    this.modelMethodBodyTemplate = path.normalize(`${__dirname}/templates/model-method-body.js`);
    this.modelWarningTemplate = path.normalize(`${__dirname}/templates/model-warning.js`);
    this.context.daoModifier = context.daoStub ? "" : "// ";
    this.executionQueue = executionQueue;
  }

  async execute() {
    this.context.modelMethodBody = this.context.validations ? await evalTemplate(this.modelMethodBodyTemplate, this.context) : "";
    if (await fileExists(this.modelPath)) {
      console.log(`Checking contents of ${this.modelPath}`);
      let currentModel = await fs_readFile(this.modelPath, "utf8");
      verifyClass(currentModel, this.context.cmdName);

      // 1) add method
      let cmdMethod = await evalTemplate(this.modelMethodTemplate, this.context);
      let idx = currentModel.indexOf("constructor"); // this is where constructor is
      if (idx === -1) {
        console.log("The command can be added only to abl classes with constructor");
        process.exit(1);
      }
      idx = currentModel.indexOf("}", idx) + 1; // constructor end
      let newModel = `${currentModel.substring(0, idx)}${os.EOL}${os.EOL}  ${cmdMethod.trim()}${currentModel.substring(idx)}`;

      // 2) add warning
      if (this.context.warnings.length !== 0) {
        let warning = await this._getWarnings();
        idx = newModel.indexOf("WARNINGS"); // warnings' start
        idx = newModel.indexOf("{", idx) + 1; // warnings' body start
        newModel = `${newModel.substring(0, idx)}${os.EOL}  ${warning.trim()},${newModel.substring(idx)}`;
      }

      this.executionQueue.addEvent(async () => {
        // modify the code
        console.log(`Modifying ${this.modelPath}`);
        await fs_writeFile(this.modelPath, newModel);
      });
    } else {
      this.context.cmdMethod = await evalTemplate(this.modelMethodTemplate, this.context);
      this.context.cmdWarning = this.context.warnings.length !== 0 ? await this._getWarnings() : "";
      this.executionQueue.addEvent(async () => {
        console.log(`Creating ${this.modelPath}`);
        await processFile(this.modelTemplate, this.modelPath, this.context);
      });
    }
  }

  async _getWarnings() {
    let warningContext = {
      cmdName: this.context.cmdName,
      errorName: this.context.errorName
    };
    let result = [];
    for (let warning of this.context.warnings) {
      warningContext.code = warning.code;
      warningContext.message = warning.message;
      warningContext.pascalCasedCode = warning.code[0].toUpperCase() + warning.code.slice(1);
      result.push(`  ${(await evalTemplate(this.modelWarningTemplate, warningContext)).trim()}`);
    }
    return result.join(`,${os.EOL}`);
  }

}

module.exports = ModelGenerator;
