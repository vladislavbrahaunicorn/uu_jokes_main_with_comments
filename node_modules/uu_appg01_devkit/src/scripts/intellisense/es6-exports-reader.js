const path = require("path");
const fs = require("fs");

const babel = require("@babel/core");
const { getMemberNames, getMemberName } = require("./es6-exports-reader-util");
const Es6ExportsReaderPluginUU5 = require("./es6-exports-reader-plugin-uu5");
const Es6ExportsReaderPluginBasicTypes = require("./es6-exports-reader-plugin-basic-types");

class Es6ExportsReader {
  constructor(babelConfig) {
    this._babelConfig = babelConfig;
    this._plugins = [new Es6ExportsReaderPluginUU5(), new Es6ExportsReaderPluginBasicTypes()];
    this._getTypeFromNode = this._getTypeFromNode.bind(this);
    this._cache = {};
  }

  getExportsFromFile(file) {
    let fileResolved = path.resolve(file);
    let exports = this._cache[fileResolved];
    if (!exports) {
      let newDir = path.dirname(fileResolved);
      let jsContent = fs.readFileSync(fileResolved, "utf-8");
      let ast = babel.parseSync(jsContent, this._babelConfig);
      let moduleImporter = {
        getExports: this._getNestedExports.bind(this, newDir)
      };
      exports = this._getExportsFromAst(ast, moduleImporter);
      this._cache[fileResolved] = exports;
    }
    return exports;
  }

  _getNestedExports(dir, moduleImportName) {
    if (!moduleImportName || !moduleImportName.startsWith(".")) return {}; // process only relative files, not standalone modules

    let file;
    if (
      !fs.existsSync((file = path.resolve(dir, moduleImportName))) &&
      !fs.existsSync((file = path.resolve(dir, moduleImportName + ".js")))
    ) {
      return {};
    }

    return this.getExportsFromFile(file);
  }

  _getExportsFromAst(babelAst, moduleImporter) {
    let exports = {};
    let variables = {};
    let context = { exports, variables };

    let rootStatements = (babelAst.program || {}).body || [];
    rootStatements.forEach(it => {
      if (it.type === "ExportAllDeclaration") {
        if (it.source) {
          let nestedExports = moduleImporter.getExports(it.source.value);
          if (nestedExports) {
            for (let [name, ex] of Object.entries(nestedExports)) {
              if (name in exports || name === "default") continue;
              exports[name] = ex;
            }
          }
        }
      } else if (it.type === "ExportDefaultDeclaration") {
        if (it.declaration) {
          let name = getMemberName(it.declaration.id); // name can be null, e.g. `export default 123` vs. `export default function C(){}; C.propTypes={}`
          let ex = this._getTypeFromNode(it.declaration, context) || { type: "any" };
          if (name != null) variables[name] = ex;
          if (!("default" in exports)) exports["default"] = ex;
        }
      } else if (it.type === "ExportNamedDeclaration") {
        if (it.declaration) {
          for (let declaration of it.declaration.declarations || [it.declaration]) {
            let { name, type } = declaration.id || {};
            if (name && type === "Identifier") {
              variables[name] = this._getTypeFromNode(declaration, context) || { type: "any" };
              if (!(name in exports)) exports[name] = variables[name];
            }
          }
        } else {
          let origExports;
          for (let specifier of it.specifiers || []) {
            let { name, type } = specifier.exported || {};
            if (name && type === "Identifier") {
              let ex;
              let moduleImportName = (it.source || {}).value;
              if (moduleImportName) {
                if (!origExports) origExports = moduleImporter.getExports(moduleImportName);
                ex = origExports ? origExports[(specifier.local || {}).name || name] : undefined;
              } else {
                ex = this._getTypeFromNode(specifier.local || specifier.exported, context);
              }
              if (!(name in exports)) exports[name] = ex || { type: "any" };
            }
          }
        }
      } else if (it.type === "ImportDeclaration") {
        // remember imports; figure out their type lazily if needed at all
        for (let specifier of it.specifiers || []) {
          let { type } = specifier;
          let { name } = specifier.local || {};
          let moduleImportName = (it.source || {}).value;
          let originalName = type === "ImportDefaultSpecifier" ? "default" : (specifier.imported || {}).name || name;
          let resultType;
          if (name in variables) delete variables[name]; // shouldn't happen
          Object.defineProperty(variables, name, {
            configurable: true,
            enumerable: true,
            get() {
              if (!resultType) {
                let importedExports = moduleImporter.getExports(moduleImportName) || {};
                if (type === "ImportNamespaceSpecifier") {
                  // import * as Xyz from "..."
                  resultType = { type: "namespace", objectFields: { ...importedExports } };
                  delete resultType.objectFields["default"];
                } else if (type === "ImportDefaultSpecifier") {
                  resultType = importedExports["default"];
                } else if (type === "ImportSpecifier") {
                  resultType = importedExports[originalName];
                }
              }
              return resultType;
            },
            set(value) {
              delete variables[name];
              variables[name] = value;
            }
          });
        }
      } else if (it.type === "VariableDeclaration" || it.type === "FunctionDeclaration") {
        // remember types of variables / functions
        for (let declaration of it.declarations || [it]) {
          let { name, type } = declaration.id || {};
          // type can be also "ObjectPattern" and "ArrayPattern"
          if (name && type === "Identifier") {
            let varType = this._getTypeFromNode(declaration, context);
            if (varType) variables[name] = varType;
          }
        }
      } else if (it.type === "ExpressionStatement") {
        // handle simple dot/bracket expressions such as `Tools.abc = ...` by extending type of variable 'Tools' with field 'abc'
        let { expression } = it;
        if (expression && expression.type === "AssignmentExpression" && expression.operator === "=") {
          let { left, right } = expression;
          let names = getMemberNames(left);
          if (names && names.length > 0) {
            let varType = this._getTypeFromNode(right, context) || { type: "any" };
            let rootName = names.shift();
            let curVarDesc = variables[rootName];
            while (curVarDesc && names.length > 1) {
              let namePart = names.shift();
              if (curVarDesc.type === "namespace") curVarDesc = curVarDesc.objectFields[namePart];
              else if (curVarDesc.type === "object" || curVarDesc.type === "function") {
                let prop = (curVarDesc.properties || []).find(prop => prop.name === namePart);
                if (prop) curVarDesc = prop.value;
              }
            }
            if (curVarDesc && names.length === 1) {
              let propertyName = names.shift();
              if (curVarDesc.type === "namespace") curVarDesc.objectFields[propertyName] = varType;
              else if (
                (curVarDesc.type === "object" || curVarDesc.type === "function") &&
                !(curVarDesc.properties || []).some(prop => prop.name === propertyName)
              ) {
                if (!curVarDesc.properties) curVarDesc.properties = [];
                curVarDesc.properties.push({ name: propertyName, value: varType });
              }
            } else if (names.length === 0) {
              // global variable assignment (without "var" / "let" / "const" keyword) or variable re-assignment
              variables[rootName] = varType;
            }
          }
        }
      }
    });

    exports = this._postProcessExports(exports);
    return exports;
  }

  _getTypeFromNode(node, context) {
    if (!context) throw new Error("Invalid call of getTypeFromNode(node, context) - context is missing.");
    for (let plugin of this._plugins) {
      if (typeof plugin.getTypeFromNode === "function") {
        let result = plugin.getTypeFromNode(node, context, this._getTypeFromNode);
        if (result != null) return result;
      }
    }
  }

  _postProcessExports(exports) {
    for (let plugin of this._plugins) {
      if (typeof plugin.postProcessExports === "function") {
        exports = plugin.postProcessExports(exports) || exports;
      }
    }
    return exports;
  }
}

module.exports = Es6ExportsReader;
