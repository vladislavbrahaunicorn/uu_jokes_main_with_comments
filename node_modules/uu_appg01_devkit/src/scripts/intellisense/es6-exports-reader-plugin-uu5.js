const { getMemberNames, getMemberName, objectToInterface } = require("./es6-exports-reader-util");

class Es6ExportsReaderPluginUU5 {
  getTypeFromNode(node, context, getTypeFromNode) {
    if (!node) return;
    let { init, type } = node;
    if (type === "VariableDeclarator") return this.getTypeFromNode(init, context, getTypeFromNode); // intentionally calling self only, not any other plugin

    // consider return values of createReactClass() / UU5.Common.(Visual)Component.create() / createComponent() /
    // createVisualComponent() / createHoc() as React components (functions)
    if (node.type === "CallExpression" && node.callee) {
      let { name, type } = node.callee;

      // consider any withXyz(...) / memo / forwardRef as wrappers => dive into 1st parameter in such case (i.e. expect withXyz(createReactClass(...)))
      if (
        (typeof name === "string" && name.match(/^with[A-Z]|^(memo|forwardRef)$/)) ||
        (type === "MemberExpression" &&
          (getMemberNames(node.callee) || [])
            .join(".")
            .match(/(^|\.)with[A-Z][^.]*$|(^|\.)memo$|^UU5\.Common\.Reference\.forward$|(^|\.)forwardRef$/))
      ) {
        return getTypeFromNode((node.arguments || [])[0], context);
      }

      if (
        (typeof name === "string" &&
          name.match(/^(createReactClass|createComponent|createVisualComponent|createHoc)$/)) ||
        (type === "MemberExpression" &&
          (getMemberNames(node.callee) || []).join(".").match(/^UU5\.Common\.(Component|VisualComponent)\.create$/))
      ) {
        // get propTypes from component descriptor
        let propParam = { name: "props" };
        let componentDescType = getTypeFromNode((node.arguments || [])[0], context);
        if (componentDescType && componentDescType.type === "object") {
          let { properties } = componentDescType;
          let propTypesDesc = Array.isArray(properties) ? properties.find(it => it.name === "propTypes") : null;
          let objProperties = this._getPropertiesFromPropTypesField(propTypesDesc);
          if (objProperties) propParam.value = { type: "interface", properties: objProperties, name: "$Props" };
        }
        return { type: "function", parameters: [propParam] };
      }
    }

    // recognize PropTypes.* and UU5.PropTypes.* expressions as type definitions
    let propTypeType = this._getPropTypeType(node, context, getTypeFromNode);
    if (propTypeType) return propTypeType;
  }

  _getPropTypeType(node, context, getTypeFromNode) {
    if (!node) return;
    let propTypeMatch;
    let required;
    if (node.type === "MemberExpression" && getMemberName(node.property) === "isRequired" && node.object) {
      node = node.object;
      required = true;
    }
    if (
      (node.type === "CallExpression" &&
        node.callee &&
        node.callee.type === "MemberExpression" &&
        (propTypeMatch = (getMemberNames(node.callee) || [])
          .join(".")
          .match(/^(?:UU5\.)?PropTypes\.([a-zA-Z0-9_]+)$/))) ||
      (node.type === "MemberExpression" &&
        (propTypeMatch = (getMemberNames(node) || [])
          .join(".")
          .match(/^(?:UU5\.)?PropTypes\.([a-zA-Z0-9_]+)(\.isRequired)?$/)))
    ) {
      let name = propTypeMatch[1];
      if (propTypeMatch[2]) required = !!propTypeMatch[2];
      switch (name) {
        case "array":
          return { type: "array", optional: !required };
        case "bool":
          return { type: "boolean", optional: !required };
        case "func":
          return {
            type: "function",
            parameters: [{ name: "args", value: { type: "any" }, rest: true }],
            optional: !required
          };
        case "number":
          return { type: "number", optional: !required };
        case "object":
          return { type: "interface", properties: [], optional: !required };
        case "string":
          return { type: "string", optional: !required };
        case "symbol":
        case "node":
        case "element":
        case "elementType":
        case "any":
          return { type: "any", optional: !required };
        case "objectOf":
          return { type: "object", properties: [], optional: !required };
        case "oneOf":
        case "oneOfType": {
          let firstArgType = getTypeFromNode((node.arguments || [])[0], context);
          if (!firstArgType || firstArgType.type !== "array") return;
          let elements = firstArgType.elements || [];
          let usedElements = elements.filter(Boolean).map(it => this._postProcessPropTypeType(it));
          if (usedElements.length < elements.length) usedElements.push({ type: "any" });
          return { type: "union", elements: usedElements, optional: !required };
        }
        case "arrayOf": {
          let firstArgType = getTypeFromNode((node.arguments || [])[0], context);
          this._postProcessPropTypeType(firstArgType);
          return { type: "array", elementType: firstArgType, optional: !required };
        }
        case "shape":
        case "exact": {
          let firstArgType = getTypeFromNode((node.arguments || [])[0], context);
          if (!firstArgType || firstArgType.type !== "object") return;
          this._postProcessPropTypeType(firstArgType);
          firstArgType.optional = !required;
          return firstArgType;
        }

        case "instanceOf":
        default:
          return { type: "any", optional: !required };
      }
    }
  }
  _postProcessPropTypeType(desc) {
    if (desc && desc.type === "object") {
      desc = objectToInterface(desc);
    }
    return desc;
  }

  postProcessExports(exports) {
    for (let [name, desc] of Object.entries(exports)) {
      // handle functions starting with uppercase character and having static field "propTypes" as React Components
      // (make 1st parameter in the function accept fields as defined in propTypes)
      if (desc && desc.type === "function" && name.match(/^[A-Z]|^default$/)) {
        let { parameters, properties } = desc;
        if (
          !parameters ||
          parameters.length === 0 ||
          (parameters.length <= 2 && (((parameters[0] || {}).value || {}).type || "any").match(/^(any|interface)$/))
        ) {
          let propTypesDesc = Array.isArray(properties) ? properties.find(it => it.name === "propTypes") : null;
          if (propTypesDesc) {
            if (!desc.parameters) desc.parameters = [];
            if (desc.parameters.length === 0) {
              desc.parameters.push({ name: "props", value: { type: "interface", properties: [] } });
            } else {
              desc.parameters = [desc.parameters[0]]; // remove 2nd parameter if any (ref)
              if (desc.parameters[0].name.match(/^_*$/)) desc.parameters[0].name = "props";
              if (!desc.parameters[0].value) desc.parameters[0].value = {};
              if (!Array.isArray(desc.parameters[0].value.properties)) desc.parameters[0].value.properties = [];
            }

            let objProperties = this._getPropertiesFromPropTypesField(propTypesDesc);
            let set = new Set(desc.parameters[0].value.properties.map(prop => prop.name));
            let extraProperties = (objProperties || []).filter(prop => !set.has(prop.name));
            if (extraProperties.length > 0) {
              desc.parameters[0].value.type = "interface";
              desc.parameters[0].value.name = "$Props";
              desc.parameters[0].value.properties.push(...extraProperties);
            }

            // also remove "propTypes", "displayName", "defaultProps" fields since we recognize this as a React component
            if (Array.isArray(properties)) {
              for (let i = properties.length - 1; i >= 0; i--) {
                let name = (properties[i] || {}).name;
                if (typeof name === "string" && name.match(/^(propTypes|defaultProps|displayName)$/)) {
                  properties.splice(i, 1);
                }
              }
            }
          }
        }
      }

      // treat exports containing an empty object as namespaces
      if (desc && desc.type === "object" && (desc.properties || []).length === 0) {
        desc.type = "namespace";
        delete desc.properties;
        desc.objectFields = {};
      }

      // filter out private fields (those starting with "_")
      this._filterOutPrivateFields(desc);
    }

    return exports;
  }

  _filterOutPrivateFields(desc) {
    if (!desc) return;
    if (desc.objectFields) {
      for (let [k, nestedDesc] of Object.entries(desc.objectFields)) {
        if (k[0] === "_") delete desc.objectFields[k];
        else this._filterOutPrivateFields(nestedDesc);
      }
    } else if (Array.isArray(desc.properties)) {
      for (let i = desc.properties.length - 1; i >= 0; i--) {
        let { name, value } = desc.properties[i];
        if (name[0] === "_") desc.properties.splice(i, 1);
        else this._filterOutPrivateFields(value);
      }
    }
  }

  _getPropertiesFromPropTypesField(propTypesDesc) {
    let result;
    if (propTypesDesc) {
      let { properties: propTypesDescProperties } = propTypesDesc.value || {};
      let properties = Array.isArray(propTypesDescProperties)
        ? propTypesDescProperties.filter(Boolean).map(prop => {
            if (!prop.value) prop.value = {};
            if (typeof prop.value.optional !== "boolean") prop.value.optional = true;
            return prop;
          })
        : null;
      if (properties && properties.length > 0) result = properties;
    }
    return result;
  }
}

module.exports = Es6ExportsReaderPluginUU5;
