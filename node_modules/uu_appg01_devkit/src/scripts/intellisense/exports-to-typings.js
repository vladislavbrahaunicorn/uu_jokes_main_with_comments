const dom = require("dts-dom");

class ExportsToTypings {
  /**
   *
   * @param {*} exports
   * @param {*} namespace E.g. "UU5.Tiles".
   * @param {*} moduleNameOfNamespaceRoot E.g. "uu5g04" (for namespaces "UU5", "UU5.Tiles", ...).
   */
  serialize(exports, namespace = "Index", moduleNameOfNamespaceRoot = "", { exportAsGlobal = false } = {}) {
    this._nsStack = [(this._usedNames = {})];
    let content = this._serialize(exports, namespace, moduleNameOfNamespaceRoot, { exportAsGlobal });
    return content;
  }

  _serialize(exports, namespace, mainModuleName, { exportAsGlobal }) {
    // NOTE We're assuming that default export is same as "* as Lib".
    if (!exports) return "";

    // modules with no "." in their namespace (e.g. "UU5") should serialize as:
    //   export = UU5;
    //   declare namespace UU5 { ... }
    //
    // modules with "." in their namespace (e.g. "UU5.Tiles") should serialize as augmenting module, i.e.:
    //   import UU5 = require("uu5g04");
    //   export = UU5.Tiles;
    //   declare module "uu5g04" {
    //     namespace Tiles { ... }
    //   }
    //
    // ... and then the theory meets the real world:
    // 1. IntelliJ IDEA 2019.2.4 chokes on `export = UU5.Tiles` - there'll be no exports and no Intellisense for UU5.Tiles
    // => this can be fixed by duplicating namespace when augmenting module to root scope:
    //      export = Tiles;
    //      declare namespace Tiles { ... }
    //      declare module "uu5g04" {
    //        namespace Tiles { ... }
    //      }
    // 2. It then starts to have Intellisense and it works everywhere EXCEPT in JSX.
    //    Seems like JSX Intellisense works only with unaugmented declarations...
    // => global declaration fixes this, i.e. another duplication of exports:
    //      export = Tiles;
    //      declare namespace Tiles { ... }
    //      declare global {
    //        namespace UU5 {
    //          namespace Tiles { ... }
    //        }
    //      }
    //      declare module "uu5g04" {
    //        namespace Tiles { ... }
    //      }
    let emitables = [];
    let remainingNamespaceParts = namespace.split(".");
    let augmentModule = remainingNamespaceParts.length >= 2;
    let exportedNamespace = augmentModule ? remainingNamespaceParts[remainingNamespaceParts.length - 1] : namespace;
    emitables.push(dom.create.exportEquals(exportedNamespace));
    if (exportAsGlobal && namespace.indexOf(".") === -1) emitables.push(`export as namespace ${namespace};`);

    // serialize "exports" into a namespace
    let ns = dom.create.namespace(remainingNamespaceParts.pop());
    let exportsWithoutDefault = { ...exports };
    delete exportsWithoutDefault["default"];
    ns.members.push(...this._serializeNamespaceFields(exportsWithoutDefault));

    // if the namespace is multi-part, e.g. UU5.Foo.Bar then we now have `namespace Bar { ... }`
    // and we need to wrap it into `namespace UU5 { namespace Foo { ... } }`
    // - but if we're able to compute lib name (UU5 => uu5g04) then wrap it into a bit different structure
    if (remainingNamespaceParts.length > 0) {
      let upto = augmentModule ? 1 : 0;
      let root = ns;
      while (remainingNamespaceParts.length > upto) {
        let wrapNs = dom.create.namespace(remainingNamespaceParts.pop());
        wrapNs.members.push(root);
        root = wrapNs;
      }
      if (augmentModule) {
        let nearRootNs = root;

        // emit "declare namespace ..." stuff
        emitables.push(ns);

        // emit "declare module ..." stuff
        if (mainModuleName) {
          let module = dom.create.module(mainModuleName);
          module.members.push(root);

          emitables.unshift(dom.create.importEquals(remainingNamespaceParts[0], mainModuleName));
          emitables.push(module);
        }

        // emit "declare global ..." stuff (see above)
        emitables.push("declare global {");
        let rootNs = dom.create.namespace(remainingNamespaceParts[0]);
        rootNs.members.push(nearRootNs);
        emitables.push(dom.emit(rootNs, { rootFlags: dom.ContextFlags.InAmbientNamespace }));
        emitables.push("}");
      } else {
        emitables.push(root);
      }
    } else {
      emitables.push(ns);
    }

    return emitables
      .map(it => (typeof it === "string" ? it : dom.emit(it)))
      .map(it => it.trim().replace(/(?:\r?\n)+/g, "\n"))
      .filter(Boolean)
      .join("\n");
  }

  _serializeNamespace(name, objectFields) {
    let serializedName = name === "default" ? "_default" : name;
    let ns = dom.create.namespace(serializedName);
    this._nsStack.push((this._usedNames = {}));
    let list = this._serializeNamespaceFields(objectFields);
    ns.members.push(...list);
    this._nsStack.pop();
    this._usedNames = this._nsStack[this._nsStack.length - 1];
    return ns;
  }

  _serializeField(name, value = {}) {
    let members = [];
    let serializedName = name === "default" ? "_default" : name;
    if (value.type === "namespace") {
      members.push(this._serializeNamespace(name, value.objectFields));
    } else if (value.type === "function") {
      // declare as function, not as a variale of type function (anonymous); also add extra static fields if any
      members.push(
        dom.create.function(
          serializedName,
          ...this._getFunctionParamsAndReturnType(value, members, { name: serializedName })
        )
      );
      if (value.properties && value.properties.length > 0) {
        members.push(
          this._serializeNamespace(name, value.properties.reduce((r, it) => ((r[it.name] = it.value), r), {}))
        );
      }
    } else {
      members.push(dom.create.const(serializedName, this._getType(value, members, { name: serializedName })));
    }
    return members;
  }

  _getType(desc, nsMembers, parentInfo = {}) {
    if (!desc || !desc.type) return dom.type.any;
    let { type } = desc;
    if (type === "namespace") {
      // TODO Or throw (namespace is not a type)?
      desc = {
        type: "object",
        properties: Object.entries(desc.objectFields).map(([name, value]) => ({ name, value }))
      };
    }
    if (type === "any") return dom.type.any;
    if (type === "function") {
      return dom.create.functionType(...this._getFunctionParamsAndReturnType(desc, nsMembers, parentInfo));
    }
    if (type === "boolean") {
      return desc.value === true ? dom.type.true : desc.value === false ? dom.type.false : dom.type.boolean;
    }
    if (type === "string") return desc.value != null ? dom.type.stringLiteral(desc.value) : dom.type.string;
    if (type === "number") return desc.value != null ? dom.type.numberLiteral(desc.value) : dom.type.number;
    if (type === "array") {
      let elementType = (desc.elementType || {}).type;
      let arrayType;
      if (elementType === "number") arrayType = dom.type.number;
      else if (elementType === "string") arrayType = dom.type.string;
      else if (elementType === "boolean") arrayType = dom.type.boolean;
      else if (elementType === "union") arrayType = this._getType(desc.elementType, nsMembers, parentInfo);
      return dom.type.array(arrayType || dom.type.any);
    }
    if (type === "union") {
      let types = (desc.elements || []).map((it, i) => this._getType(it, nsMembers, parentInfo));
      return dom.create.union(types);
    }
    if (type === "object" || type === "interface") {
      let properties = (desc.properties || []).map(it => {
        let nestedParentInfo = { name: (parentInfo.name ? parentInfo.name + "$" : "") + it.name };
        let flags = it.value && it.value.optional ? dom.DeclarationFlags.Optional : dom.DeclarationFlags.None;
        if (it.value && it.value.type === "function") {
          return dom.create.method(
            it.name,
            ...this._getFunctionParamsAndReturnType(it.value, nsMembers, nestedParentInfo),
            flags
          );
        }
        return dom.create.property(it.name, this._getType(it.value, nsMembers, nestedParentInfo), flags);
      });
      if (type === "interface") {
        let iface = dom.create.interface(
          this._getUniqueName(
            (!desc.name || desc.name.startsWith("$")) && parentInfo.name
              ? parentInfo.name + (desc.name || "")
              : desc.name || "Interface"
          )
        );
        iface.members.push(...properties);
        nsMembers.push(iface);
        return iface;
      }
      return dom.create.objectType(properties);
    }
    throw new Error(`Serializing value of type ${type} not yet supported.`);
  }
  _getUniqueName(name) {
    // NOTE We're assuming that source code does not use names containing "$" (so that we
    // don't have to keep track of all the function/variable/... names we generated).
    if (name.indexOf("$") === -1) name += "$";
    let usedName = name;
    while (usedName in this._usedNames) usedName = name + "$" + this._usedNames[name]++;
    this._usedNames[name] = 0;
    return usedName;
  }

  _getFunctionParamsAndReturnType(desc, nsMembers, parentInfo) {
    let parameters = (desc.parameters || []).map(it => {
      if (it) {
        let flags = it.rest ? dom.ParameterFlags.Rest : dom.ParameterFlags.None;
        if (it.value && it.value.optional) flags |= dom.ParameterFlags.Optional;
        return dom.create.parameter(it.name, this._getType(it.value, nsMembers, parentInfo), flags);
      }
    });
    let returnType = this._getType(desc.returnValue, nsMembers, parentInfo);
    if (desc.async && (!returnType || returnType.name !== "Promise")) {
      returnType = "Promise<any>";
    }
    return [parameters, returnType];
  }

  _serializeNamespaceFields(fields) {
    let result = [];
    for (let [name, value] of Object.entries(fields)) {
      result.push(...this._serializeField(name, value));
    }
    return result;
  }
}

module.exports = ExportsToTypings;
