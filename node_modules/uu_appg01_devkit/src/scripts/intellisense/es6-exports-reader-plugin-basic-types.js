const { getMemberName, objectToInterface, renameLiteralValuesToInitialValues } = require("./es6-exports-reader-util");

class Es6ExportsReaderPluginBasicTypes {
  getTypeFromNode(node, context, getTypeFromNode) {
    if (!node) return;
    let { type } = node;
    if (type === "AssignmentExpression" && node.operator === "=") return getTypeFromNode(node.right, context);
    if (type === "VariableDeclarator") return getTypeFromNode(node.init, context);
    if (type === "ArrowFunctionExpression") return this._getFunctionType(node, context, getTypeFromNode);
    if (type === "BooleanLiteral") return this._getBooleanType(node, context, getTypeFromNode);
    if (type === "StringLiteral") return this._getStringType(node, context, getTypeFromNode);
    if (type === "NumericLiteral") return this._getNumberType(node, context, getTypeFromNode);
    if (type === "TemplateLiteral") return this._getStringType({}, context, getTypeFromNode); // `string ${expr} string`
    // if (type === "TaggedTemplateExpression") return ... // Css`abc` || String.raw`abc`
    if (type === "FunctionExpression") return this._getFunctionType(node, context, getTypeFromNode);
    if (type === "ObjectExpression") return this._getObjectType(node, context, getTypeFromNode);
    if (type === "FunctionDeclaration") return this._getFunctionType(node, context, getTypeFromNode);
    if (type === "ObjectMethod") return this._getFunctionType(node, context, getTypeFromNode);
    if (type === "SpreadElement") return this._getObjectType({}, context, getTypeFromNode);
    if (type === "ObjectProperty") return getTypeFromNode(node.value, context);
    if (type === "ObjectPattern") return this._getObjectType(node, context, getTypeFromNode);
    if (type === "LogicalExpression") {
      return getTypeFromNode(node.right, context) || getTypeFromNode(node.left, context);
    }
    if (type === "ArrayExpression") return this._getArrayType(node, context, getTypeFromNode);
    if (type === "Identifier") {
      let { name } = node;
      return context.variables[name];
    }
    if (type === "MemberExpression") {
      let baseMember = getTypeFromNode(node.object, context);
      let propertyName = getMemberName(node.property);
      let result;
      if (baseMember != null && propertyName != null) {
        if (baseMember.type === "namespace") result = baseMember.objectFields[propertyName];
        else if (baseMember.type === "object" || baseMember.type === "function") {
          let prop = (baseMember.properties || []).find(prop => prop.name === propertyName);
          if (prop) result = prop.value;
        }
      }
      return result;
    }
    if (type === "UnaryExpression" && node.operator === "-") {
      let numType = getTypeFromNode(node.argument, context);
      let result =
        numType && numType.type === "number" && typeof numType.value === "number"
          ? { ...numType, value: -numType.value }
          : undefined;
      return result;
    }
  }

  _getFunctionType({ params, async, generator }, context, getTypeFromNode) {
    let nameCounter = 0;
    let parameters = Array.isArray(params)
      ? params.map((it, i) => {
          let name, value, rest;
          if (it) {
            if (it.type === "AssignmentPattern") {
              name = it.left ? it.left.name : undefined;
              if (name === undefined && it.left && it.left.type === "ObjectPattern") {
                value = getTypeFromNode(it.left, context);
              } else {
                value = it.right ? getTypeFromNode(it.right, context) : undefined;
              }
              if (!value) value = {};
              if (typeof value.optional !== "boolean") value.optional = true;
            } else if (it.type === "ObjectPattern") {
              value = this._getObjectType(it, context, getTypeFromNode);
            } else if (it.type === "RestElement") {
              if (it.argument && it.argument.type === "Identifier") name = it.argument.name;
              rest = true;
            } else {
              name = it.name;
            }
            if (value && value.type === "object") {
              value = objectToInterface(value);
              value.name = "$" + i;
            } else {
              value = renameLiteralValuesToInitialValues(value);
            }
          }
          if (name === undefined) name = "_".repeat(++nameCounter);
          return { name, value, rest };
        })
      : [];
    return { type: "function", parameters, async, generator /*, returnValue: getTypeFromNode(...)*/ };
  }
  _getBooleanType({ value }) {
    return { type: "boolean", value };
  }
  _getStringType({ value }) {
    return { type: "string", value };
  }
  _getNumberType({ value }) {
    return { type: "number", value };
  }
  _getObjectType({ properties: initProperties }, context, getTypeFromNode) {
    let properties = Array.isArray(initProperties)
      ? initProperties
          .map(it => {
            if (!it) return;
            let name;
            if (it.key && it.key.type === "Identifier") {
              if (it.computed) {
                name = (context.variables[it.key.name] || {}).value;
                if (name != null) name += "";
              } else {
                name = it.key.name;
              }
            } else if (it.key && it.key.type === "StringLiteral") {
              name = it.key.value;
            }
            if (!name) return;
            return { name, value: getTypeFromNode(it, context) };
          })
          .filter(Boolean)
      : [];
    return { type: "object", properties };
  }
  _getArrayType({ elements: initElements }, context, getTypeFromNode) {
    let elementType;
    let elements = [];
    for (let node of initElements || []) {
      let el = getTypeFromNode(node, context);
      elements.push(el);
      if (!elementType) elementType = el;
    }
    return { type: "array", elementType, elements };
  }
}

module.exports = Es6ExportsReaderPluginBasicTypes;
