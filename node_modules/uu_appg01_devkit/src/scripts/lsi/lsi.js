const fs = require("fs-extra");
const path = require("path");
const util = require("util");
const readDir = util.promisify(fs.readdir);
const stat = util.promisify(fs.stat);
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const ensureDir = util.promisify(fs.ensureDir);
const callbackStringify = require("csv-stringify");
const stringify = util.promisify(callbackStringify);
const parseCallback = require("csv-parse");
const csvParse = util.promisify(parseCallback);
const { fileExists } = require("../../tools/helpers");
const { Parser } = require("acorn");
const walk = require("acorn-walk");
const escodegen = require("escodegen");

const LSI = "lsi.js";
const LSI_SUFFIX = `-${LSI}`;
const NODE_MODULES = "node_modules";
const DEFAULT_EXPORT_FOLDER = "target";
const DEFAULT_EXPORT_FILE = "lsi-export.csv";
const FILE = "file";
const LABEL = "label";
// the 8204 is an arbitrary whitespace character, because why not..
const LABEL_SEPARATOR = `${String.fromCodePoint(8204)}.${String.fromCodePoint(8204)}`;

class LsiExporter {

  constructor(opts = {}) {
    this.languages = {};
    this.languageCount = 0;
    this.registry = [];
    this.baseSourcePath = opts.baseSourcePath || process.cwd();
    this.sourcePath = path.resolve(this.baseSourcePath, opts.relativeSourcePath || "");
    let relativeTargetPath = opts.relativeTargetPath || path.join(DEFAULT_EXPORT_FOLDER, DEFAULT_EXPORT_FILE);
    this.targetPath = path.resolve(this.baseSourcePath, relativeTargetPath);
  }

  async getLsiPaths(pth) {
    let arr = await readDir(pth);
    let result = [];
    for (let file of arr) {
      if (file === NODE_MODULES) {
        continue;
      }
      let subPath = path.join(pth, file);
      let fileStat = await stat(subPath);
      if (fileStat.isDirectory()) {
        let partialRes = await this.getLsiPaths(subPath);
        result.push(...partialRes);
      } else if (file.endsWith(LSI_SUFFIX) || file === LSI) {
        result.push(path.join(pth, file));
      }
    }
    return result;
  }

  addLanguage(label) {
    let languages = Object.keys(this.languages);
    if (languages.indexOf(label) !== -1) {
      // it's registered already
      return;
    }
    let position = this.languageCount;
    this.languageCount += 1;
    this.languages[label] = position;
  }

  async fillRegistry() {
    let lsiPaths = await this.getLsiPaths(this.sourcePath);
    for (let lsiPath of lsiPaths) {
      console.log(`Parsing ${lsiPath}`);
      let sourceCode = await readFile(lsiPath, "utf-8");
      let ast;
      try {
        ast = Parser.parse(sourceCode, { sourceType: "module" });
      } catch (e) {
        console.log(`WARNING! skipping lsi file ${lsiPath}, reason: invalid file syntax`);
        continue;
      }
      let innerMostObjects = this.getInnerMostObject(ast);
      let oneFileRegistry = this.processLsiFile(ast, innerMostObjects, lsiPath);
      oneFileRegistry && this.registry.push(...oneFileRegistry);
    }
    // add the header
    this.registry.unshift([FILE, LABEL, ...Object.keys(this.languages)]);
  }

  processLsiFile(fileAst, innerMostObjects, lsiPath) {
    let oneFileRegistry = [];
    for (let innerMostObject of innerMostObjects) {
      let chain = this.getObjectExpressionHierarchy(fileAst, innerMostObject);
      let label = chain.join(LABEL_SEPARATOR);
      // if the label is an empty string or undefined, then the object is not an lsi object
      if (!label) {
        continue;
      }
      let oneItemRegistry = new Array(this.languageCount);
      for (let property of innerMostObject.properties) {
        let language = property.key.name || property.key.value;
        this.addLanguage(language);
        let pos = this.languages[language];
        let leafNode = property.value;
        if (leafNode.type === "TemplateLiteral") {
          let literalString = "";
          for (let i = 0; i < leafNode.quasis.length; i++) {
            literalString = `${literalString}${leafNode.quasis[i].value.raw}`;
            let expression = leafNode.expressions[i];
            if (expression) {
              literalString = `${literalString}\${${expression.name}}`;
            }
          }
          oneItemRegistry[pos] = `\`${literalString}\``;
        } else if (leafNode.type === "Literal") {
          oneItemRegistry[pos] = property.value.value;
        }
      }
      let relativePath = path.relative(this.baseSourcePath, lsiPath);

      // same labels in one file are undesirable
      if (oneFileRegistry.find(x => x[0] === relativePath && x[1] === label)) {
        console.log(`WARNING! skipping lsi file ${lsiPath}, reason: lsi objects with ambiguous labeling`);
        return null;
      }

      oneItemRegistry.unshift(label);
      oneItemRegistry.unshift(relativePath);
      oneFileRegistry.push(oneItemRegistry);
    }
    return oneFileRegistry;
  }

  // takes an innermost object node and search for its outer object nodes
  // as long as they are there, return an array of them starting from the
  // outermost and ending with the innermost
  //
  // example:
  // assuming source code { alpha: { beta: { cs: "some stuff" } } };
  // then innermostObjectNode is an AST representation of { cs: "some stuff" } object
  // and getObjectExpressionHierarchy returns [alpha, beta]
  getObjectExpressionHierarchy(fileAst, innermostObjectNode) {
    let res = [];
    let pos = innermostObjectNode.start - 1;
    let childNode = innermostObjectNode;
    let findRes;
    while (findRes = walk.findNodeAround(fileAst, pos, "ObjectExpression")) {

      for (let property of findRes.node.properties) {
        if (property.value === childNode) {
          // key.name for Identifier, i.e. {a:1}, key.value for Literal, i.e. {"a":1}
          res.unshift(property.key.name || property.key.value);
        }
      }

      childNode = findRes.node;
      pos = findRes.node.start - 1;
    }

    return res;
  }

  getInnerMostObject(ast) {
    let innerMostObjects = [];
    walk.simple(ast, {
      ObjectExpression: (node) => {
        if (this.isInnermostObject(node)) {
          innerMostObjects.push(node);
        }
      }
    });
    return innerMostObjects;
  }

  isInnermostObject(node) {
    if (node.type !== "ObjectExpression") {
      return false;
    }
    for (let property of node.properties) {
      if (!property.value || (property.value.type !== "Literal" && property.value.type !== "TemplateLiteral")) {
        return false;
      }
    }
    return true;
  }

  async process() {
    // check there is something to scan at all (even though no distinction between file and folder is made,
    // so one could try to scan a file if he is brave enough..)
    if (!await fileExists(this.sourcePath)) {
      console.log(`${this.sourcePath} does not exist. Aborting script.`);
      return;
    }

    // stuff it all into the memory
    await this.fillRegistry();

    // generate output (is all the handling of missing folders really that necessary if devkit will be the only one calling it?)
    let targetDir = path.dirname(this.targetPath);
    if (!await fileExists(targetDir)) {
      console.log(`Creating ${targetDir}`);
      await ensureDir(targetDir);
    }
    if (await fileExists(this.targetPath) && (await stat(this.targetPath)).isDirectory()) {
      this.targetPath = path.join(this.targetPath, DEFAULT_EXPORT_FILE);
    }
    let csvMegaString = await stringify(this.registry);
    console.log("Generating csv file");
    try {
      await writeFile(this.targetPath, csvMegaString, "utf-8");
    } catch (e) {
      console.log(`csv could not be exported, reason: ${e}`);
      return;
    }
    console.log(`lsi exported to ${this.targetPath}`);
  }
}

class LsiImporter {

  constructor(opts = {}) {
    this.registry = new LsiRegistry();
    this.baseSourcePath = opts.baseSourcePath || process.cwd();
    let relativeCsvPath = opts.relativeTargetPath || path.join(DEFAULT_EXPORT_FOLDER, DEFAULT_EXPORT_FILE);
    this.csvPath = path.resolve(this.baseSourcePath, relativeCsvPath);
  }

  async parse() {
    let csvFile = await readFile(this.csvPath, "utf-8");
    let parsedCsv = await csvParse(csvFile, { relax: true, relax_column_count: true });
    let header = parsedCsv.shift();
    for (let row of parsedCsv) {
      let lsiFile = this.registry.getLsiFile(row[0]);
      let lsiObject = new LsiObject(row[1]);
      lsiFile.addLsiObject(lsiObject);
      for (let i = 2; i < row.length; i++) {
        if (row[i]) {
          lsiObject.addLsi(new LsiEntry(header[i], row[i]));
        }
      }
    }
  }

  async import() {
    for (let file of this.registry.getRegistry()) {
      let absolutePath = path.resolve(this.baseSourcePath, file.getPath());
      console.log(`Importing to ${absolutePath}`);
      let sourceCode;
      try {
        sourceCode = await readFile(absolutePath, "utf-8");
      } catch (e) {
        console.log(`WARNING! lsi file ${absolutePath} does not exist, hence it can not be imported`);
        continue;
      }

      let ast;
      try {
        ast = Parser.parse(sourceCode, { sourceType: "module" });
      } catch (e) {
        console.log(`ERROR! Could not parse lsi file ${file.path}`, e);
        continue;
      }
      for (let lsiObject of file.getLsiObjects()) {
        let node = this.getLsiNode(ast, lsiObject.getLabel());
        node && this.replaceLsi(node, lsiObject);
      }

      try {
        let sourceCode = escodegen.generate(ast);
        await writeFile(absolutePath, sourceCode, "utf-8");
      } catch (e) {
        console.log(`ERROR! import of lsi file ${absolutePath} failed: ${e}`);
      }

    }
  }

  replaceLsi(node, lsiObject) {
    node.properties = [];
    for (let lsi of lsiObject.getLsis()) {
      let text = lsi.getText();
      let language = lsi.getLanguage();
      let property = {
        type: "Property",
        method: false,
        shorthand: false,
        computed: false,
        key: {
          type: "Literal",
          value: language
        },
        kind: "init"
      };
      if (text.startsWith("`") && text.endsWith("`") ) {
        text = text.slice(1).slice(0, text.length - 2);
        property.value = {
          "type": "TemplateLiteral",
          "expressions": [],
          "quasis": [
            {
              "type": "TemplateElement",
              "value": {
                "raw": text,
                "cooked": text
              },
              "tail": true
            }
          ]
        };
      } else {
        property.value = {
          type: "Literal",
          value: text,
          raw: `"${text}"`
        };
      }

      node.properties.push(property);
    }
  }

  // find the lsi node according to its label
  getLsiNode(ast, label) {
    let parts = label.split(LABEL_SEPARATOR);
    let found = false;
    let theChosenOne = null;
    walk.ancestor(ast, {
      // only ObjectExpression are interesting
      ObjectExpression(node, ancstrs) {
        // already found one
        if (found) {
          return;
        }
        // acorn-walk uses the array internally => deep copy
        let ancestors = JSON.parse(JSON.stringify(ancstrs));
        ancestors.pop(); // node is also the last entry in ancestors
        for (let i = parts.length - 1; i >= 0; i--) {
          // the closest ancestor has to be a property and it has to be labeled correctly
          let property = ancestors.pop();
          if (property.type !== "Property" || (property.key.name !== parts[i] && property.key.value !== parts[i])) {
            return;
          }
          // the second closest ancestors has to be an object
          let objectExpression = ancestors.pop();
          if (objectExpression.type !== "ObjectExpression") {
            return;
          }
        }
        // happiness!
        found = true;
        theChosenOne = node;
      }
    });
    return theChosenOne;
  }

  async process() {
    console.log("Parsing csv file");
    if (!await fileExists(this.csvPath)) {
      console.log(`csv file ${this.csvPath} does not exist. Aborting script.`);
      return;
    }
    await this.parse();
    console.log("Importing lsi files");
    await this.import();
    console.log("Finished");
  }

}

class LsiRegistry {

  constructor() {
    this.registry = [];
  }

  getLsiFile(path) {
    let existingFile = this.registry.find(lsiFile => lsiFile.path === path);
    if (existingFile) {
      return existingFile;
    }
    let newFile = new LsiFile(path);
    this.registry.push(newFile);
    return newFile;
  }

  getRegistry() {
    return this.registry;
  }

}

class LsiFile {

  constructor(path) {
    this.path = path;
    this.lsiObjects = [];
  }

  addLsiObject(entry) {
    this.lsiObjects.push(entry);
  }

  getLsiObjects() {
    return this.lsiObjects;
  }

  getPath() {
    return this.path;
  }

}

class LsiObject {

  constructor(label) {
    this.label = label;
    this.lsis = [];
  }

  addLsi(lsi) {
    this.lsis.push(lsi);
  }

  getLabel() {
    return this.label;
  }

  getLsis() {
    return this.lsis;
  }

}

class LsiEntry {

  constructor(language, text) {
    this.language = language;
    this.text = text;
  }

  getText() {
    return this.text;
  }

  getLanguage() {
    return this.language;
  }

}

module.exports = {
  LsiExporter,
  LsiImporter
};
