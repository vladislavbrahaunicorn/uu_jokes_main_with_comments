const path = require("path");
const fs = require("fs");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const UuCloudConfig = require("./uu-cloud-config.js");

const DEFAULT_SCHEMA_URI = "ues:SYSTEM:UU.OS/UUAPP-DEPLOY-SCHEMA-V2.3";
const DEFAULT_GATEWAY_URI = "https://cdn.plus4u.net";

class UuCloudLibraryConfig extends UuCloudConfig {

  constructor(projectRoot, projectName, projectVersion, targetDir, buildConfig, dependencies, loaderSettings) {
    super(projectRoot, projectName, projectVersion, targetDir, buildConfig);
    this.dependencies = dependencies || {};
    this.loaderSettings = loaderSettings || {};
    this.libraryDescriptorPath = this._getLibraryDescriptorPath() || this._getLegacyLibraryDescriptorPath(this.environment);
    this.libraryDescriptor = null;
    this.buildConfig = buildConfig;
  }

  uuAppBoxConfig() {
    let result = super.uuAppBoxConfig();
    let cloudDescriptor = this._getCloudDescriptor();
    result.appPackageCode = `${cloudDescriptor.code}/CDN-PACK`;
    result.libraryDescriptorCode = cloudDescriptor.code + "/UU5LIBRARYREGISTRY-DEPLOY";
    result.libraryDescriptorPath = this._getLibraryDescriptorPath();
    return result;
  }

  async uuDeployConfig() {
    return super.uuDeployConfig(false);
  }

  generateCloudDescriptor() {
    let qualifiedVersion = this.getQualifiedVersion();
    let descriptorPath = path.resolve(this.targetDir, `${this.projectName}-${qualifiedVersion}.json`);
    descriptorPath = path.relative(".", descriptorPath);

    let parsedName = Package.parseProduct(this.projectName);
    let cloudDescriptor = {};
    cloudDescriptor.schemaUri = DEFAULT_SCHEMA_URI;
    cloudDescriptor.data = {};
    cloudDescriptor.data.code = parsedName.product.toUpperCase().replace(/[\-_]/g, ".");
    cloudDescriptor.data.name = parsedName.name;
    // NOTE Not using unique version for CDN as it would have to be provided in URLs.
    cloudDescriptor.data.version = this.projectVersion;
    // TODO Improve (why is CDN deploy recognized by not having packs?).
    cloudDescriptor.data.packs = [];
    cloudDescriptor.data.nodeSets = [];

    fs.writeFileSync(descriptorPath, JSON.stringify(cloudDescriptor, null, 2));
    return descriptorPath;
  }

  generateLibraryDescriptor() {
    let qualifiedVersion = this.getQualifiedVersion();
    let descriptorPath = path.resolve(this.targetDir, `${this.projectName}-uu5libraryregistry-${qualifiedVersion}.json`);
    descriptorPath = path.relative(".", descriptorPath);

    let parsedProduct = Package.parseProduct(this.projectName);
    let {sourceUri, imageUri, docUri, namespace, description} = this.buildConfig.getAll();
    let libraryDescriptor = [{
      code: namespace,
      name: parsedProduct.name,
      vendor: parsedProduct.vendor,
      desc: description,
      source: sourceUri,
      doc: docUri,
      image: imageUri,
      dependencyMap: {},
      versionList: [
        {
          dependencyMap: Object.keys(this.loaderSettings.externals || {}).reduce((depMap, depName) => {
            let depItem = this.loaderSettings.externals[depName];
            if (depItem && depItem.uri !== undefined) {
              depMap[depName] = depItem.uri;
            }
            return depMap;
          }, {})
        }
      ]
    }];
    this._updateLibraryRegistryDescriptor(libraryDescriptor);

    fs.writeFileSync(descriptorPath, JSON.stringify(libraryDescriptor, null, 2));
    return descriptorPath;
  }

  _getLibraryDescriptorPath() {
    let baseVersion = this.projectVersion.replace(/([\.\-][a-zA-Z][a-zA-Z0-9]*)\.[0-9]+/, (match, g1) => {
      return g1;
    });
    if (!fs.existsSync(this.targetDir)) {
      return null;
    }
    let files = fs.readdirSync(this.targetDir).filter(fn => fn.match(new RegExp(`^${this.projectName}-uu5libraryregistry-${baseVersion}.*\.json`)));
    if (files.length > 0) {
      return path.resolve(this.targetDir, files.sort().pop());
    } else {
      return null;
    }
  }

  _getLibraryDescriptor() {
    if (!this.libraryDescriptor) {
      if (!this.libraryDescriptorPath) {
        throw new Error("Missing uu5 library registry descriptor. Run [package] task to create it.");
      }
      this.libraryDescriptor = JSON.parse(fs.readFileSync(this.libraryDescriptorPath));
    }
    return this.libraryDescriptor;
  }

  _getDependencyInfo(name) {
    let depPackageJsonPath = path.join(this.projectRoot, "node_modules", name, "package.json");
    let isThisProject = false;
    let version;
    if (fs.existsSync(depPackageJsonPath)) {
      let depPackageJson = JSON.parse(fs.readFileSync(depPackageJsonPath, "utf-8"));
      version = depPackageJson.version;
    } else if (name === this.projectName || name.startsWith(this.projectName + "-")) {
      version = this.projectVersion;
      isThisProject = true;
    }
    return {name, version, isThisProject};
  }

  _resolveAppUrl(tid = null, awid = null) {
    let parsedName = Package.parseProduct(this.projectName);
    let libNameWithVendor = parsedName.product.replace(/_/g, "-");
    let libVersion = this.projectVersion;
    let betaPrefix = libVersion.match(/beta/) ? "beta/" : "";
    let result = `${DEFAULT_GATEWAY_URI}/${betaPrefix}${libNameWithVendor}/${libVersion}/${this.projectName}.js`;
    return result;
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  _getLegacyLibraryDescriptorPath(environment = "development") {
    let descriptorPath = null;
    if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, "config", `-uu5libraryregistry-descriptor-${environment}.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, "config", `-uu5libraryregistry_descriptor_${environment}.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, `-uu5libraryregistry-descriptor-${environment}.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, `-uu5libraryregistry_descriptor_${environment}.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, "config", `-uu5libraryregistry-config.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, "config", `-uu5libraryregistry_config.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, `-uu5libraryregistry-config.json`))) {
    } else if (fs.existsSync(descriptorPath = path.resolve(this.projectRoot, `-uu5libraryregistry_config.json`))) {
    } else {
      descriptorPath = null;
    }
    return descriptorPath;
  }

  _updateLibraryRegistryDescriptor(descriptor) {
    // TODO Integrate method directly into generateLibraryDescriptor()
    // update versions and URLs of library registry items (copied from uu5g04)
    let knownDeps = {
      [this.projectName]: {
        name: this.projectName,
        version: this.projectVersion,
        external: true,
        isThisProject: true
      }
    };
    let loaderSettingsDeps = this.loaderSettings.externals || {};
    for (let depName in this.dependencies) {
      let {isThisProject, version} = this._getDependencyInfo(depName);
      knownDeps[depName] = {
        name: depName,
        version,
        external: depName in loaderSettingsDeps,
        isThisProject
      };
    }

    descriptor.forEach(lib => {
      let libName = lib.name.split("-")[0];

      // add generation & major
      let generation = libName.match(/g\d+$/) ? libName.replace(/^.*g(\d+)$/, "$1") : "";
      if (generation) lib.generation = Number(generation);
      lib.major = Number(this.projectVersion.replace(/\..*/, ""));

      // update URLs in dependencyMap
      updateDependencyMap.call(this, lib.dependencyMap, lib);

      // update 1st item in versionList
      if (lib.versionList && lib.versionList.length > 0) {
        let item = lib.versionList[0];
        item.version = this.projectVersion;

        // update URLs in dependencyMap-s
        lib.versionList.forEach(item => {
          if (!item.source) delete item.source;
          if (!item.dependencyMap) delete item.dependencyMap;
          else updateDependencyMap.call(this, item.dependencyMap, lib);
        });
      }
    });

    function updateDependencyMap(dependencyMap, lib) {
      if (dependencyMap) {
        for (let depLibFullName in dependencyMap) {
          let depLibUrl = dependencyMap[depLibFullName];
          if (!depLibUrl) {
            let depLibName = depLibFullName.split("-")[0];
            let depLibParams = knownDeps[depLibFullName] || knownDeps[depLibName];

            if (depLibParams) {
              if (!depLibParams.external) {
                throw new Error(
                  `Library ${depLibFullName} is declared as dependency for ${lib.name} in ${this.libraryDescriptorPath}` +
                  `but it's not marked as external dependency (listed in package.json in "uuBuildSettings.externals"),` +
                  ` i.e. it was bundled into the distribution package if it was imported somewhere in source files. Mark` +
                  ` it as external in package.json or remove it from library registry descriptor.`
                );
              }
              let depLibNameVendor = (depLibName.indexOf("_") === -1 && depLibName.match(/^uu/) ? "uu-" + depLibName : depLibName).replace(/_/g, "-");
              let isBeta = (depLibParams.version || "").match(/beta/);
              // we want to use major versions in registry so that there're fewest version conflicts
              // (but not for submodules such as -bricks, etc. of this library, if this library has some)
              let depLibUsedVersion = depLibParams.version || "0.0.0";
              if (!depLibParams.isThisProject) depLibUsedVersion = depLibUsedVersion.replace(/\..*/, ".0.0");
              let fileName = depLibFullName.replace(/^uu_uu5/, "uu5") + ".min.js";
              if (depLibFullName === "uu_appg01" && depLibUsedVersion.match(/^[0123]\./)) fileName = "uu_appg01-base.min.js"; // uu_appg01 < 4.x had non-standard naming of entry file
              depLibUrl = `${DEFAULT_GATEWAY_URI}/${isBeta ? "beta/" : ""}${depLibNameVendor}/${depLibUsedVersion}/${fileName}`;
              if (!depLibParams.version) {
                console.warn(
                  `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                  `, it has no URL specified there and it's not possible to find out its version. Following URL will be used for library` +
                  ` registry:\n  ${depLibUrl}\n If the URL is wrong, specify the URL in package.json in "uuBuildSettings.externals.` +
                  `${depLibFullName}.uri" or add the library as npm dependency (npm i -S ${depLibFullName}).`
                );
              }
              dependencyMap[depLibFullName] = depLibUrl;
            } else {
              throw new Error(
                `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                ` but it has no URL specified there. Specify the URL in package.json in "uuBuildSettings.externals.${depLibFullName}.uri"` +
                ` or add the library as npm dependency (npm i -S ${depLibFullName}) to compute the URL automatically (assuming the` +
                ` library conforms to standard UU naming conventions).`
              );
            }
          }
        }
      }
      return dependencyMap;
    }
  }
}

module.exports = UuCloudLibraryConfig;
