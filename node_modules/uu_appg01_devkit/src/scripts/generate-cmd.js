const path = require("path");
const util = require("util");
const ncp = require("ncp");
const promisified_ncp = util.promisify(ncp.ncp);
const StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
const fs = require("fs-extra");
const ensureDir = util.promisify(fs.ensureDir);

const { fileExists } = require("../tools/helpers");
const ModelGenerator = require("./cmd_generator/model-generator");
const ControllerGenerator = require("./cmd_generator/controller-generator");
const ErrorGenerator = require("./cmd_generator/error-generator");
const ValidationTypesGenerator = require("./cmd_generator/validation-types-generator");
const ConfigAdjuster = require("./cmd_generator/config-adjuster");
const DaoGenerator = require("./cmd_generator/dao-generator");
const TestGenerator = require("./cmd_generator/test-generator");
const UserInputExtractor = require("./cmd_generator/user-input-extractor");
const ExecutionQueue = require("./cmd_generator/execution-queue");

module.exports = class GenerateCmd {
  constructor(config) {
    if (Object.keys(config.commandLineConfig).length === 2) {
      this.userInput = true;
    } else {
      this.userInput = false;
      this.config = config;
    }

    this.userInputExtractor = new UserInputExtractor();
    this.sourceCodePath = null;
  }

  async process() {
    let appPath = path.join(process.cwd(), "app");
    let libPath = path.join(process.cwd(), "src");
    if (await fileExists(appPath)) {
      this.sourceCodePath = appPath;
    } else if (await fileExists(libPath)) {
      this.sourceCodePath = libPath;
    } else {
      this.endIt(`The current project ${process.cwd()} has neither app nor src folder. Nothing can be done here...`);
    }

    let userInputContext;
    if (this.userInput) {
      userInputContext = await this.userInputExtractor.extractInteractive();
    } else {
      userInputContext = await this.userInputExtractor.extractStatic(this.config.commandLineConfig);
    }
    let context = this.getContext(userInputContext);
    let executionQueue = new ExecutionQueue();
    await new ConfigAdjuster(context, executionQueue).execute();
    await new ControllerGenerator(context, executionQueue).execute();
    await new ModelGenerator(context, executionQueue).execute();
    await new ErrorGenerator(context, executionQueue).execute();
    await new ValidationTypesGenerator(context, executionQueue).execute(true);
    if (context.daoStub) {
      await new DaoGenerator(context, executionQueue).execute();
    }
    if (context.testStub) {
      await new TestGenerator(context, executionQueue).execute();
    }
    await this.backupProject(context);
    await executionQueue.execute(true);
  }

  getContext(userInputContext) {
    let entity = userInputContext.entity;
    let cmdName;
    if (entity !== userInputContext.useCase && userInputContext.useCase.startsWith(`${entity}/`)) {
      let aSplit = userInputContext.useCase.split(`${entity}/`);
      cmdName = aSplit[1];
    } else {
      cmdName = userInputContext.useCase;
    }
    cmdName = cmdName.replace(/\/+./g, m => m.charAt(m.length - 1).toUpperCase());

    let controllerParams = userInputContext.isPrivileged ? ["asid"] : ["awid"];
    controllerParams.push("dtoIn");
    return {
      sourceCodePath: this.sourceCodePath,
      useCase: userInputContext.useCase,
      cmdName: cmdName.charAt(0).toLowerCase() + cmdName.slice(1), // this constant name is bad, but it's everywhere, so it stays :( ...
      errorName: cmdName.charAt(0).toUpperCase() + cmdName.slice(1),
      classFile: StringUtil.dashCase(entity).replace(/([a-z]+)([0-9]+)/g, "$1-$2"),
      constantName: StringUtil.snakeCase(entity).toUpperCase(),
      className: entity.charAt(0).toUpperCase() + entity.slice(1),
      entity: entity.charAt(0).toLowerCase() + entity.slice(1),
      httpMethod: userInputContext.httpMethod.toUpperCase(),
      profiles: userInputContext.profiles ? userInputContext.profiles.split(",").map(x => x.trim()) : [],
      isPrivileged: userInputContext.isPrivileged,
      controllerParams,
      modelParams: controllerParams.join(", "),
      daoStub: userInputContext.daoStub,
      testStub: userInputContext.testStub,
      testFilePrefix: StringUtil.dashCase(cmdName),
      // warnings and errors are empty, because the code was originally for generating commands
      // from bookkit, and these arrays are expected somewhere... Just accept it!
      warnings: [],
      errors: []
    };
  }
  
  async backupProject(context) {
    console.log("Creating backup of current project");
    let targetDir = path.join(process.cwd(), "target");
    if (!await fileExists(targetDir)) {
      console.log(`Creating ${targetDir}`);
      await ensureDir(targetDir);
    }
    let timestamp = (new Date()).toISOString().replace(/[:T]/g, "-").split(".")[0];
    let ucstamp = context.useCase.replace(/\/+./g, m => m.charAt(m.length - 1).toUpperCase());

    // backup src / app
    let backupFolder = path.join(process.cwd(), "target", `cmd-backup-${timestamp}-${ucstamp}`, this.sourceCodePath.split(path.sep).slice(-1)[0]);
    await ensureDir(backupFolder);
    await promisified_ncp(this.sourceCodePath, backupFolder);

    // backup test
    let testPath = path.join(process.cwd(), "test");
    if (!await fileExists(testPath)) {
      return;
    }
    backupFolder = path.join(process.cwd(), "target", `cmd-backup-${timestamp}-${ucstamp}`, "test");
    await ensureDir(backupFolder);
    await promisified_ncp(testPath, backupFolder);
  }

  // this method is absolutely worth it
  endIt(message) {
    console.log(message);
    process.exit(1);
  }

};
