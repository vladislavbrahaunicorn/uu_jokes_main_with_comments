const path = require("path");
const fs = require("fs-extra");
const shell = require("shelljs");

const paths = require("../config/paths.js");
let helpers; // lazy-loaded
let WebpackRunner;
let Package;
let DependencyProcessor;

module.exports = class Build {
  constructor(config) {
    this.config = config;
  }
  async process() {
    console.log("Building project.");

    if (!this.config.getMode()) this.config.setMode("production");

    shell.mkdir("-p", paths.buildDir);

    let UpdateFromUuappJson = require("./update-from-uuapp-json.js");
    await new UpdateFromUuappJson(this.config).process();

    if (!WebpackRunner) WebpackRunner = require("./webpack/runner.js");
    WebpackRunner.mergeBuildConfig(this.config);
    let mode = this.config.getUsedMode();
    let { watch } = this.config.getAll();
    if (!Package) Package = require("uu_appg01_devkit-common/src/tools/package.js");
    let pkg = Package.getSingletonSync("package.json").get();
    let config = this.config.getAll();

    let showProdVsDevCdnWarning;
    let { useCdn } = config;
    if (useCdn == null || useCdn === true) {
      let isDevRepo = isUsingDevRepo();
      if (useCdn == null) useCdn = !isDevRepo;
      else showProdVsDevCdnWarning = useCdn === true && isDevRepo;
    }

    // compute externals
    if (!DependencyProcessor) DependencyProcessor = require("./webpack/dependency-processor.js");
    let depProcessor = new DependencyProcessor("package.json", useCdn);
    if (!config.skipExternalsDiscovery) {
      config.externals = depProcessor.getExternals("app");
    } else if (config.externals) {
      for (let k in config.externals) {
        let dep = config.externals[k];
        if (!dep || typeof dep !== "object") continue;
        depProcessor.replaceDependencyExpressions(k, dep);
      }
    }

    // workaround for react-dnd-touch-backend which doesn't have pre-built files for browser
    // (so using useCdn: false wouldn't work) => download pre-built files from our CDN
    if (!useCdn && config.externals && config.externals["react-dnd-touch-backend"]) {
      let { cdnBaseUri, localBaseUri, main, mainMinified } = config.externals["react-dnd-touch-backend"];
      if (cdnBaseUri && localBaseUri) {
        await this._downloadIfNotExist(path.join(localBaseUri, main), cdnBaseUri.replace(/\/+$/, "") + "/" + main);
        await this._downloadIfNotExist(
          path.join(localBaseUri, mainMinified),
          cdnBaseUri.replace(/\/+$/, "") + "/" + mainMinified
        );
      }
    }

    // allow project packages (src/<pack>/<pack>.js) to be loaded as external dependency (in separate on-demand HTTP request)
    // when developer uses "import * as Pack from 'app/<pack>'" or "SystemJS.import('app/<pack>').then(function (exports) { ... })"
    // in the source code
    if (config.allowProjectPackages) {
      if (!helpers) helpers = require("../tools/helpers.js");
      var packages = helpers.getProjectPackageList(config.sourcePath);
      config.projectPackages = packages;
      if (!config.aliases) config.aliases = {};
      if (!config.externals) config.externals = {};
      packages.forEach(pack => {
        config.aliases[pack.moduleName] = path.resolve(config.sourcePath, pack.entryPoint);
        config.externals[pack.moduleName] = {
          baseUri: pack.directory + "/",
          main: pack.name + (config.minify ? ".min" : "") + ".js"
        };
      });
    }

    fs.emptyDirSync(config.outputPath);
    fs.emptyDirSync(paths.buildWebpackTempDir);

    // copy lib/ folder
    console.log("Copying local dependencies to output...");
    if (fs.existsSync("lib")) shell.cp("-rf", "lib", config.outputPath);

    // resolve which URIs to use for dependencies and copy dependencies
    // to <destination>/lib/<depName>-<depVersion>/ folders if needed
    let srcLib = "lib";
    if (!config.externals) config.externals = {};
    if (Object.keys(config.externals).length > 0) {
      let srcLibs = (fs.existsSync(srcLib) ? fs.readdirSync(srcLib) : null) || [];
      let srcLibsMap = {};
      srcLibs.forEach(lib => (srcLibsMap[lib.replace(/-(\d+)(\.\d+)*$/, "")] = lib));
      let copiedMap = {};
      for (let depName in config.externals) {
        let depConfig = config.externals[depName];
        if (depConfig === false) continue;
        let depBaseUri = (useCdn ? depConfig.cdnBaseUri : null) || depConfig.localBaseUri;
        if (!depBaseUri && !useCdn) depBaseUri = depConfig.cdnBaseUri; // fallback to cdnBaseUri even if having "useCdn: false", if we don't have localBaseUri set (this might happen if developer explicitly configured this in externals; it shouldn't happen with automatic externals discovery, unless there's no such npm module)
        let usedBaseUri = depConfig.baseUri;
        if (usedBaseUri == null && depBaseUri) {
          if (depBaseUri.match(/^(\/|https?:)/)) {
            // full URL / absolute URL path => just use the URL (no copying of files)
            usedBaseUri = depBaseUri;
          } else if (copiedMap[depBaseUri]) {
            // source folder that was already copied to some target folder => reuse
            usedBaseUri = copiedMap[depBaseUri];
          } else {
            // copy to <destination>/lib/<depName>-<depVersion> if it's local path;
            // the URL will then be <appAssets>/lib/<depName>-<depVersion>
            let depTargetFldName;
            let doCopy = false;
            if (srcLibsMap[depName]) depTargetFldName = srcLibsMap[depName];
            else if (path.relative(path.resolve("."), path.resolve(depBaseUri)).startsWith("lib" + path.sep))
              depTargetFldName = path.relative(path.resolve("lib"), path.resolve(depBaseUri)).replace(/\\/g, "/");
            else {
              let { version } = getPackageJson(depName, {});
              depTargetFldName = depName + (version ? "-" + version : "");
              doCopy = true;
            }
            usedBaseUri = "lib/" + depTargetFldName + "/";
            if (doCopy) {
              let targetDir = config.outputPath + "/lib/" + depTargetFldName;
              fs.copySync(depBaseUri, targetDir, { dereference: true });

              // TODO Production CDN uses renamed files for react & react-dom (react.min.js instead of react.production.min.js).
              // When copying, we'll make the files available also under the names as present on the CDN. Remove when CDN is fixed.
              if (depName.match(/^(react|react-dom)$/)) {
                let fileName;
                if (fs.existsSync(fileName = path.join(depBaseUri, depName + ".production.min.js"))) {
                  fs.copySync(fileName, path.join(targetDir, depName + ".min.js"));
                }
                if (fs.existsSync(fileName = path.join(depBaseUri, depName + ".development.js"))) {
                  fs.copySync(fileName, path.join(targetDir, depName + ".js"));
                }
              }
            }
            copiedMap[depBaseUri] = usedBaseUri;
          }
        }

        delete depConfig.cdnBaseUri;
        delete depConfig.localBaseUri;
        depConfig.baseUri = usedBaseUri || false;
        let main =
          (mode === "production" ? depConfig.mainMinified : "") ||
          depConfig.main ||
          depName + (mode === "production" ? ".min" : "") + ".js";
        depConfig.main = main;
        delete depConfig.mainMinified;
      }
    }
    // modify OIDC callback page if not using CDN so that it doesn't link the uu_oidcg01-callback.min.js
    // (instead we'll inline it in the page)
    if (useCdn === false && !fs.existsSync("node_modules/uu_appg01_oidc")) {
      let oidcCallbacksDir = "node_modules/uu_oidcg01/dist/callbacks/oidc-callback.html";
      if (fs.existsSync(oidcCallbacksDir)) {
        let callbacksOutputDir = path.join(config.outputPath, "callbacks");
        fs.mkdirsSync(callbacksOutputDir);
        let callbackJs = fs.readFileSync("node_modules/uu_oidcg01/dist/uu_oidcg01-callback.min.js", "utf-8");
        fs.writeFileSync(path.join(callbacksOutputDir, "oidc-callback.html"), "<script>\n" + callbackJs + "\n</script>", "utf-8");
      }
    }

    // show dependencies settings
    this.showDependenciesSettings(config, pkg);
    if (showProdVsDevCdnWarning) {
      console.warn(
        require("chalk").yellow("WARNING") +
          ` You're using dev/beta NPM channel and the app is configured to download frontend libraries from production CDN - some of the libraries (versions) might not be available there yet. Set "uuBuildSettings.useCdn" to false in package.json if some of your libraries fail to load.\n`
      );
    }

    // run webpack
    let env = {
      isDevServer: watch,
      isDistributionBuild: !watch && mode === "production"
    };
    let webpackConfig = require("../config/webpack.config.js").getFromConfig(config, env);
    await new WebpackRunner(webpackConfig, config).run({
      watch,
      onCompile: watch ? this._onWatchedCompile.bind(this, pkg) : null
    });
  }

  showDependenciesSettings(config, pkg) {
    let deps = config.externals;
    let externalDeps = {};
    let externalDepsInfo =
      Object.keys(deps)
        .filter(
          depName => deps[depName].baseUri && typeof deps[depName].baseUri === "string" && !depName.startsWith("app/")
        )
        .map(depName => {
          let dep = deps[depName];
          externalDeps[depName] = dep;
          let paddedDepName = (depName + "                      ").substr(0, Math.max(20, depName.length));
          return `${paddedDepName} - ${dep.baseUri}${dep.main}`;
        })
        .join("\n") || "<none>";
    let bundledDepsInfo =
      Object.keys(pkg.dependencies || {})
        .filter(depName => !externalDeps[depName] && !depName.startsWith("systemjs-plugin-")) // hide SystemJS plugins
        .join("\n") || "<none>";
    let inBrowserEnvInfo = `loaded from URL: %APP_BASE%/${config.appAssetsRelativeUrlPath || ""}uu5-environment.js`;
    console.log(`
BUILD OVERVIEW
In-browser environment:
${inBrowserEnvInfo.replace(/(^|\n)/g, "$1  ")}

External dependencies (including transitive):
${externalDepsInfo.replace(/(^|\n)/g, "$1  ")}

Dependencies from package.json bundled directly into main JS file (if imported):
${bundledDepsInfo.replace(/(^|\n)/g, "$1  ")}
`);
  }

  _onWatchedCompile(pkg, stats) {
    // run postbuild script from package.json after 1st compilation when in "watch" mode
    if (!this._ranPostBuildScript) {
      this._ranPostBuildScript = true;
      if (pkg && pkg.scripts && pkg.scripts.postbuild) {
        require("child_process").spawn("npm run -s postbuild", {
          shell: true,
          cwd: process.cwd(),
          stdio: "inherit"
        });
      }
    }
  }

  async _downloadIfNotExist(target, url) {
    if (!fs.existsSync(target)) {
      try {
        let result = await require("got")(url);
        fs.writeFileSync(target, result.body, "utf-8");
      } catch (e) {
        console.error(`Unable to download missing file ${target} from ${url}`, e);
      }
    }
  }
};

/**
 * @param {*} moduleName The module name whose package.json to return.
 * @param {*} defaultValue The default value to return in case that given module doesn't exist.
 *   If defaultValue is not given, an exception will be thrown in this case.
 * @return Returns package.json (as a JSON object) of NPM module with given name.
 */
function getPackageJson(moduleName, defaultValue) {
  var depPkgJsonPath = "node_modules/" + moduleName + "/package.json";
  if (!fs.existsSync(depPkgJsonPath)) {
    if (defaultValue) return defaultValue;
    throw new Error(
      "Package.json for node module '" +
        moduleName +
        "' has not been found at " +
        depPkgJsonPath +
        ". Try 'npm install' or 'npm update', or remove the dependency mapping configuration from package.json's uuBuildSettings field."
    );
  }
  var depPkg = require(path.resolve(depPkgJsonPath));
  return depPkg;
}

function isUsingDevRepo() {
  let customNpmTag = getTagFromNpmrc(".npmrc");
  if (customNpmTag === undefined) customNpmTag = getTagFromNpmrc(path.join(require("os").homedir(), ".npmrc"));
  return customNpmTag === "uu_dev" || customNpmTag === "uu_beta";
}
function getTagFromNpmrc(npmrcPath) {
  if (!fs.existsSync(npmrcPath)) return;
  let tag;
  let npmrc = fs.readFileSync(npmrcPath, "utf-8");
  npmrc.replace(/(?:^|\n)\s*tag\s*=\s*(\S+)/, (m, g) => (tag = g));
  return tag;
}
