const path = require("path");
const fs = require("fs-extra");
const util = require("util");
const fs_access = util.promisify(fs.access);

function tryFile(fname) {
  return fs.existsSync(fname) ? fname : null;
}
function resolveByTemplateType(filePath, templateType = null) {
  let filePath0 = path.resolve(filePath);
  let name = path.basename(filePath0);
  let nameNoExt = name.replace(/\.[^.]*$/, "");
  let dotExt = name.substr(nameNoExt.length);
  let prefix = path.join(path.dirname(filePath0), nameNoExt);
  if (templateType == null) templateType = getTemplateInfo().type;

  return (
    tryFile(prefix + "." + templateType + dotExt) || // xyz.uu5-lib.js
    tryFile(prefix + "." + templateType.replace(/-.*/, "") + dotExt) || // xyz.uu5.js
    tryFile(prefix + "." + templateType.replace(/^[^-]*-/, "") + dotExt) || // xyz.lib.js
    tryFile(prefix + dotExt) // xyz.js
  );
}

function requireByTemplateType(filePath, templateType = null) {
  let fileByType = resolveByTemplateType(filePath, templateType);
  return require(fileByType || filePath);
}

// TODO Remove, use 'Package.getSingletonSync("package.json").templateInfo' instead.
var templateInfo;
function getTemplateInfo() {
  if (!templateInfo) {
    const Package = require("uu_appg01_devkit-common/src/tools/package.js");
    templateInfo = Package.getSingletonSync("package.json").templateInfo;
  }
  return templateInfo;
}

function getSpecString(templateInfo) {
  if (!templateInfo) return "";
  let { type, specName, specVersion } = templateInfo;
  return `${type || ""}; ${specName}${specVersion ? "@" + specVersion : ""}`;
}

function npmScriptBinFile(binFileName) {
  let partialPath = path.join(
    "node_modules",
    ".bin",
    process.platform === "win32" ? binFileName + ".cmd" : binFileName
  );
  let inDevkitPath = path.resolve(__dirname, "..", "..", partialPath);
  if (fs.existsSync(inDevkitPath)) return inDevkitPath; // when using pnpm
  return partialPath; // when using npm
}

function verifyClass(sourceCode, methodName) {
  const { Parser } = require("acorn");
  let parsedSourceCode = Parser.parse(sourceCode, { sourceType: "module" });
  let klass;
  // klass, i.e model, contains only one class
  for ( let entity of parsedSourceCode.body ) {
    if ( entity.type === "ClassDeclaration" ) {
      klass = entity;
      break;
    }
  }
  if ( !klass ) {
    console.log(`Source file doesn't contain a class`);
    process.exit(1);
  }
  // find if there is a method for this command already
  for ( let entity of klass.body.body ) {
    if ( entity.type === "MethodDefinition" && entity.key.name === methodName ) {
      console.log(`Class ${klass.id.name} already contains method ${methodName}`);
      process.exit(1);
    }
  }
}

async function fileExists(path) {
  try {
    await fs_access(path, fs.constants.F_OK);
    return true;
  } catch (err) {
    if ( err.code && err.code === "ENOENT" ) {
      return false;
    }
    throw err;
  }
}

module.exports = {
  npmScriptBinFile,
  resolveByTemplateType,
  requireByTemplateType,
  getTemplateInfo,
  getSpecString,
  verifyClass,
  fileExists
};
