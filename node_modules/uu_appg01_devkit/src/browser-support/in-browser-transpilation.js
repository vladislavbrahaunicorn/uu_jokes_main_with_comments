let currentScript = document.currentScript;
if (!currentScript) {
  let scripts = document.getElementsByTagName("script");
  currentScript = scripts[scripts.length - 1];
}

// read configuration from the script element
// - find out glob pattern describing files that we want to transpile (besides inline scripts), such as:
//   "-" - turn off
//   "./*.js" (default) - all JS files from current folder and subfolders
//   "/*.js"  - all JS files from current domain
let transpilationUrlPattern;
if (currentScript) transpilationUrlPattern = currentScript.getAttribute("data-transpilation-url-pattern");
if (!transpilationUrlPattern) transpilationUrlPattern = "./*.js";

let cdnRoot;
if (currentScript) cdnRoot = currentScript.getAttribute("data-cdn-root");
if (cdnRoot == null) cdnRoot = ((window.UU5 || {}).Environment || {}).cdnBaseUri || "https://cdn.plus4u.net/";
if (cdnRoot && cdnRoot.charAt(cdnRoot.length - 1) !== "/") cdnRoot += "/";

// configure transpiler for SystemJS loader
let meta = {};
if (transpilationUrlPattern) {
  meta[transpilationUrlPattern] = {
    loader: "plugin-babel"
  };
}
SystemJS.config({
  map: {
    "plugin-babel": cdnRoot + "libs/systemjs-plugin-babel/0.0.21/plugin-babel.js",
    "systemjs-babel-build": cdnRoot + "libs/systemjs-plugin-babel/0.0.21/systemjs-babel-browser.js"
  },
  meta: meta,
  transpiler: "plugin-babel",
  babelOptions: { react: true, es2015: true }
});

const JSX_TRANSPILATION_FN_NAME = "__devkitJsx";
const JSX_TRANSPILATION_FN_TEXT = `
;var ${JSX_TRANSPILATION_FN_NAME}0;
function ${JSX_TRANSPILATION_FN_NAME}(...args) {
  if (${JSX_TRANSPILATION_FN_NAME}0) return ${JSX_TRANSPILATION_FN_NAME}0(...args);
  var resultFn;
  if (typeof Uu5g05 !== "undefined" && Uu5g05 && Uu5g05.Utils && Uu5g05.Utils.Element && typeof Uu5g05.Utils.Element.create === "function") {
    resultFn = Uu5g05.Utils.Element.create;
  } else if (typeof UU5 !== "undefined" && UU5 && UU5.Common && UU5.Common.Element && typeof UU5.Common.Element.create === "function") {
    resultFn = UU5.Common.Element.create;
  } else {
    resultFn = React.createElement;
  }
  ${JSX_TRANSPILATION_FN_NAME}0 = resultFn;
  return resultFn(...args);
}`;

// also transpile inline scripts marked as <script type="text/babel"> in the current HTML page
// (with full support of "import" statements)
document.addEventListener(
  "DOMContentLoaded",
  function(e) {
    let scripts = document.querySelectorAll('script[type="text/babel"]');
    if (scripts.length === 0) return;

    // we'll extract scripts texts and import them via SystemJS with transpilation
    let inlineBabels = {};
    SystemJS.config({
      meta: {
        "app-inline-script-*": { loader: "app-inline-script-loader" }
      }
    });
    SystemJS.set(
      "app-inline-script-loader",
      SystemJS.newModule({
        // "helper" plugin which supplies script texts from "inlineBabels" variable, instead of downloading them from URLs
        fetch: function(load) {
          load.metadata.format = "esm"; // mark as ES6 module (i.e. will be transpiled)
          // use our custom JSX fn instead of React.createElement (add to end to be overridable - 1st @jsx comment wins)
          let scriptText = inlineBabels[load.name.split(/\//).slice(-1)[0]];
          scriptText += `\n/* @jsx ${JSX_TRANSPILATION_FN_NAME} */\n` + JSX_TRANSPILATION_FN_TEXT;
          return scriptText;
        }
      })
    );
    let result = Promise.resolve();
    for (let i = 0; i < scripts.length; ++i) {
      let script = scripts[i];
      let name = script.src;
      if (name) {
        let meta = {};
        meta[name] = { loader: "plugin-babel" };
        SystemJS.config({ meta: meta });
      } else {
        name = "app-inline-script-" + i + ".js";
        inlineBabels[name] = script.textContent;
      }
      // execute scripts one after another (next one waits for the previous)
      result = result.catch(e => console.error(e)).then(() => SystemJS.import(name));
    }
  },
  false
);
