const path = require("path");
const fs = require("fs-extra");
const CircularDependencyPlugin = require("circular-dependency-plugin");
const webpack = require("webpack");
// const eslintFormatter = require("eslint/lib/formatters/stylish");
const autoprefixer = require("autoprefixer");
const uuid = require("uuid/v4");

let CopyWebpackPlugin; // conditional load
let TerserWebpackPlugin; // conditional load
let OptimizeCSSAssetsPlugin; // conditional load
let HtmlWebpackPlugin; // conditional load
let MiniCssExtractPlugin; // conditional load
let CombineChunksPlugin; // conditional load
let MessagePlugin; // conditional load
let MergingStyleLoaderPlugin; // conditional load
let StringUtil; // conditional load
let HtmlPostProcessorV1;
let HtmlPostProcessorV2;

const SystemjsEs6DetectionFixPlugin = require("./webpack-misc/systemjs-es6-detection-fix-plugin.js");
const buildHelpers = require("../tools/helpers.js");
const paths = require("./paths.js");
const templateType = buildHelpers.getTemplateInfo().type;
let usedBundleNames = new Set();

module.exports = function() {
  let config = fs.existsSync("config/config.js") ? require(path.resolve("config/config.js")).getConfig() : {};
  return getFromConfig(config);
};
module.exports.getFromConfig = getFromConfig;

function getFromConfig(config, aEnv = null) {
  let env = Object.assign({}, aEnv);
  env = fillEnvDefaults(env);

  let packs = config.packs || [];
  packs = packs.filter(Boolean).map(pack => {
    let packConfig = Object.assign({}, config, pack);
    delete packConfig.packs;
    return packConfig;
  });

  // auto-open webpack chunks analysis for 1st JS pack
  if (config.analyzeChunks && config.analyzeChunksAutoOpen == null && !env.isDevServer) {
    let jsPacks = packs.filter(pack => !pack.outputFile || pack.outputFile.match(/\.js/));
    if (jsPacks.length > 0) jsPacks[0].analyzeChunksAutoOpen = true;
  }

  // for libraries, for each non-minified pack add another minified version when building distribution
  if (env.isDistributionBuild && templateType.endsWith("lib")) {
    let extraPacks = packs
      .filter(pack => (pack.outputFile || "").match(/\.(js|css)$/) && pack.minify == null)
      .filter(pack => !pack.outputFile.match(/\.min\.[^.]*$/))
      .map(pack => {
        let outputFileMin = pack.outputFile.replace(/\.([^.]+)$/, ".min.$1");
        let packConfig = Object.assign({}, pack, { minify: true, outputFile: outputFileMin });
        if (config.analyzeChunks && config.analyzeChunksAutoOpen == null) {
          pack.analyzeChunksAutoOpen = false; // prefer opening of analysis of minified file
        }
        return packConfig;
      });
    packs = packs.concat(extraPacks);

    // add also CJS builds so that the library is usable from standard tools, e.g. create-react-app
    if (templateType === "uu5-lib") {
      let outputPathCjs = paths.buildLibNodeDir;
      let cjsPacks = packs
        .filter(pack => (pack.outputFile || "").match(/\.js$/))
        .filter(pack => !pack.moduleType)
        .map(pack => {
          let packConfig = { ...pack, moduleType: "cjs", outputPath: outputPathCjs };
          return packConfig;
        });
      packs = packs.concat(cjsPacks);
    }
  }

  // each "pack" in "config" must be built separately
  let webpackConfig = packs.reduce((result, pack) => {
    if (result.length === 0) pack.copyFiles = true; // use copy plugin only for 1st invocation so that it isn't invoked for each built JS file
    let packWebpackConfig = getWebpackConfig(pack, env);
    return result.concat(packWebpackConfig);
  }, []);

  // add on-demand loadable "project packages" to the build
  let projectPackages = config.projectPackages;
  if (projectPackages) {
    webpackConfig = projectPackages.reduce(
      (result, pack) =>
        result.concat(
          getWebpackConfig(
            Object.assign({}, config, {
              outputFile: pack.name + "/" + pack.name + (env.isDistributionBuild ? ".min" : "") + ".js",
              entryPoints: [pack.entryPoint]
            }),
            env
          )
        ),
      webpackConfig
    );
  }

  return webpackConfig;
}

function fillDefaults(opts, env) {
  if (opts.minify == null) opts.minify = opts.outputFile && opts.outputFile.match(/\.min\./);
  if (opts.useSourceMaps == null) opts.useSourceMaps = !env.isDistributionBuild;
  if (opts.separateCss == null) opts.separateCss = opts.outputFile && opts.outputFile.match(/\.css$/);
  if (opts.sourcePath == null) opts.sourcePath = paths.srcDir;
  if (opts.outputPath == null) opts.outputPath = path.join(paths.buildDir, "dist");
  if (opts.entryPoints == null) opts.entryPoints = [];
  if (opts.https == null) opts.https = false;
  if (opts.copyFiles == null) opts.copyFiles = false;
  if (opts.includeDemoPages == null) opts.includeDemoPages = !env.isDistributionBuild;
  if (opts.appAssetsRelativeUrlPath == null) opts.appAssetsRelativeUrlPath = "";
  if (opts.appBaseUrlPath == null) opts.appBaseUrlPath = "";
  if (opts.externals == null) opts.externals = {};
  if (opts.transpileDependencies == null) opts.transpileDependencies = false;
  if (opts.targetEnvironment == null) {
    // "web" (default), "webworker"; https://webpack.js.org/configuration/target/
    opts.targetEnvironment =
      opts.entryPoints.length === 1 && opts.entryPoints[0].match(/-worker\.js$/) ? "webworker" : "web";
  }
  if (opts.moduleType == null) opts.moduleType = "umd";
  return opts;
}
function fillEnvDefaults(env) {
  if (env.isDistributionBuild == null) env.isDistributionBuild = true;
  if (env.isDevServer == null) env.isDevServer = false;
  return env;
}

function getWebpackConfig(options, env) {
  let opts = Object.assign({}, options);
  opts = fillDefaults(opts, env);
  let pkg = JSON.parse(fs.readFileSync("./package.json", "utf-8"));

  let srcAbsPath = path.resolve(opts.sourcePath);
  let src = path.relative(path.resolve("."), srcAbsPath).replace(/\\/g, "/");

  if (opts.entryPoints === "<from-mappings-json>") {
    opts.entryPoints = getHtmlFilesToProcess(opts.mappings, opts.sourcePath)
      .map(html => html.replace(/\.html?$/i, ".js"))
      .filter(jsFile => fs.existsSync(path.join(opts.sourcePath, jsFile)));
  }
  if (opts.entryPoints.length == 0) {
    throw new Error("At least 1 entry point must be specified in the configuration (config/config.js).");
  }
  fs.mkdirsSync(opts.outputPath);
  let outputAbsPath = path.resolve(opts.outputPath);

  let { targetEnvironment } = opts;
  let mode = opts.minify ? "production" : "development";
  let optimization = {};
  let hot = env.isDevServer && opts.hot !== false && targetEnvironment === "web";
  let hasReact =
    ("react" in (pkg.dependencies || {}) || "react" in (opts.externals || {})) && targetEnvironment === "web";
  // NOTE React hot loading doesn't currently work in uu5-lib because it needs special transpilation plugin
  // for root component (and for other files) and our root component is defined directly in demo .html page
  // and transpiled by SystemJS, not by webpack
  let reactHot = hasReact && hot && templateType === "uu5-app" && mode !== "production";

  let configName = (opts.outputFile || opts.entryPoints[0]).replace(/[^\w._-]/g, "_");
  let i = 0;
  while (usedBundleNames.has(configName)) configName = "bundle" + i++;
  usedBundleNames.add(configName);

  let processEnv = require("./process-env.js")(
    pkg,
    opts.minify ? "production" : "development",
    "browser",
    opts.outputFile,
    opts.libraryGlobalVariable
  );

  // CONFIG webpack rules
  // let eslintLoader = {
  //   loader: require.resolve("eslint-loader"),
  //   options: {
  //     formatter: function() {
  //       // omit summary "<number> problems" displayed after each file
  //       return eslintFormatter
  //         .apply(this, arguments)
  //         .split(/\n\n/)
  //         .slice(0, -1)
  //         .join("\n\n")
  //         .trim();
  //     },
  //     eslintPath: require.resolve("eslint")
  //   }
  // };
  let babelOptions = Object.assign({}, require("./.babelrc.js")(mode, null, opts.moduleType === "cjs"), {
    babelrc: false,
    cacheDirectory: true
  });
  if (reactHot) {
    if (!babelOptions.plugins) babelOptions.plugins = [];
    babelOptions.plugins.push(require.resolve("react-hot-loader/babel"));
  }
  let babelLoader = {
    loader: require.resolve("babel-loader"),
    options: babelOptions
  };
  let cssRule, lessRule;
  let cssDataOwner =
    pkg.name + "/" + ((opts.outputFile || "").replace(/(\.min)?\.(js|css)$/, "") || pkg.name) + "@" + pkg.version; // NOTE Should be in sync with how we generate config.js in uu5-app.
  let cssEmotionKey = (opts.libraryGlobalVariable || pkg.namespace || pkg.name)
    .replace(/\./g, "-")
    .toLowerCase()
    .replace(/[^a-z-]/g, "");
  let styleLoader = {
    loader: require.resolve("style-loader"),
    options: {
      insertInto: getStyleLoaderInsertInto(cssDataOwner, cssEmotionKey, srcAbsPath, configName),
      hmr: hot
      // singleton: !!opts.minify, // !!! DON'T USE (1400ms singleton vs. 60ms separate in uu5g04-bricks@1.21.0).
    }
  };
  // let mergingLoader = { loader: require.resolve("./webpack-misc/merging-style-loader.js") }; // TODO Enable when ready. Currently building of uu5-app fails ("Multiple assets emit to the same filename index.js") because the loader performs rebuildModule() which tries to re-emit the asset.
  let cssLoader = { loader: require.resolve("css-loader") };
  let postCssPlugins = [autoprefixer()];
  if (opts.minify) postCssPlugins.push(require("cssnano")({ preset: "default" }));
  let postCssLoader = {
    loader: require.resolve("postcss-loader"),
    options: { ident: "postcss", plugins: postCssPlugins } // ident serves for passing these options to the loader via JS: `import '!style-loader!css-loader!postcss-loader??postcss!./file.css';`
  };
  let lessLoader = {
    loader: require.resolve("less-loader"),
    options: {
      globalVars: Object.keys(processEnv).reduce((r, k) => ((r[k] = JSON.stringify(processEnv[k])), r), {})
    }
  };
  let fileLoader = {
    loader: require.resolve("file-loader"),
    options: { ident: "file", name: "[path][name].[ext][query]" }
  };
  let rules = [
    {
      oneOf: [
        // use only first matched
        {
          test: /\.jsx?$/,
          exclude: opts.transpileDependencies ? undefined : /node_modules/,
          use: [babelLoader /*, eslintLoader*/],
          parser: { import: true, system: false }
        },
        (cssRule = { test: /\.css$/, use: [styleLoader, /*mergingLoader, */ cssLoader, postCssLoader] }),
        (lessRule = { test: /\.less$/, use: [styleLoader, /*mergingLoader, */ cssLoader, postCssLoader, lessLoader] }),
        { exclude: /\.(jsx?|json)$/, use: [fileLoader] } // if import-ing anything else just copy it
      ]
    }
  ];
  if (opts.separateCss && !MiniCssExtractPlugin) MiniCssExtractPlugin = require("mini-css-extract-plugin");
  let extractCss = opts.separateCss
    ? new MiniCssExtractPlugin({
        filename: ((opts.outputFile || "").replace(/\.(js|css)$/, "") || "[name]") + ".css"
      })
    : null;
  let cssMinimizer = null;
  if (extractCss) {
    cssRule.use.splice(0, 1, MiniCssExtractPlugin.loader);
    lessRule.use.splice(0, 1, MiniCssExtractPlugin.loader);
    Object.assign(optimization, {
      splitChunks: {
        cacheGroups: {
          styles: {
            name: "styles",
            test: /\.css$/,
            chunks: "all",
            enforce: true
          }
        }
      }
    });
    if (opts.minify) {
      if (!OptimizeCSSAssetsPlugin) OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");
      cssMinimizer = new OptimizeCSSAssetsPlugin({});
    }
  }

  // CONFIG webpack plugins
  let processEnvStrMap = {};
  for (let k in processEnv) {
    if (opts.moduleType === "cjs" && !opts.minify && k === "NODE_ENV") {
      processEnvStrMap[k] = "process.env." + k;
      optimization.nodeEnv = false;
    } else {
      processEnvStrMap[k] = JSON.stringify(processEnv[k]);
    }
  }
  let plugins = [
    new webpack.DefinePlugin({
      "process.env": processEnvStrMap
    })
  ];
  // optimize built .less styles by merging all of them in each chunk into single big style
  // !!! Careful if changing condition - the plugin doesn't currently support re-compilation (watch mode) nor source maps.
  // TODO Enable when ready (see "mergingLoader" above).
  // if (env.isDistributionBuild && opts.minify && !env.isDevServer && !opts.useSourceMaps && !opts.skipStyleMerging) {
  //   if (!MergingStyleLoaderPlugin) MergingStyleLoaderPlugin = require("./webpack-misc/merging-style-loader-plugin.js");
  //   plugins.push(new MergingStyleLoaderPlugin());
  // }

  // uu5-app
  // process HTML files via EmbeddedJS templating system (updates <base> tag depending on whether we're using Ruby server)
  if (opts.copyFiles) {
    let htmlPostProcessedFiles = getHtmlFilesToProcess(opts.mappings, opts.sourcePath).filter(name =>
      fs.existsSync(path.join(src, name))
    );
    let processorV1;
    let processorV2;
    htmlPostProcessedFiles.forEach(function(htmlFile) {
      if (!HtmlWebpackPlugin) HtmlWebpackPlugin = require("html-webpack-plugin");
      if (!processorV1) {
        if (!HtmlPostProcessorV1) HtmlPostProcessorV1 = require("./webpack-misc/html-post-processor-v1");
        if (!HtmlPostProcessorV2) HtmlPostProcessorV2 = require("./webpack-misc/html-post-processor-v2");

        let { appBaseUrlPath, appAssetsRelativeUrlPath } = opts;
        let preserveSegmentsMatch = (appBaseUrlPath || "").match(/^<preserve-(\d+)-path-segments?>$/);
        processorV1 = new HtmlPostProcessorV1({
          appBaseUrlPath,
          appAssetsRelativeUrlPath,
          externals: opts.externals || {},
          preserveSegments: preserveSegmentsMatch ? Number(preserveSegmentsMatch[1]) : undefined
        });
        processorV2 = new HtmlPostProcessorV2({
          appAssetsRelativeUrlPath,
          externals: opts.externals || {}
        });
      }
      let pluginOpts = {
        template: "!!" + require.resolve("ejs-loader") + "!" + src + "/" + htmlFile,
        renderTemplate: (fileName, context) => renderTemplate(src + "/" + htmlFile, fileName, context),
        inject: false,
        minify: {
          removeComments: true,
          minifyJS: function(text) {
            // when performing SystemJS.import("./file.js") in HTML files, the path is relative to HTML file within src/ folder,
            // but we must replace such path to be relative to our href in <base href="...">, i.e. add the subfolder chain within src/,
            // upto the file (src/abc/cde/index.html, using "./index.js" => change into "./abc/cde/index.js")
            return text.replace(/(System(?:JS)?\.import\s*\(\s*['"])([^'"]*)/g, function(m, g1, url) {
              if (url.charAt(0) === ".")
                url = ["."].concat(htmlFile.split(/[\\/]/).slice(0, -1)).join("/") + "/" + url.replace(/^\.\//, "");
              return g1 + url;
            });
          }
        }
      }
      plugins.push(
        new HtmlWebpackPlugin({
          ...pluginOpts,
          filename: htmlFile,
          ejsFixUrls: htmlSnippet => processorV1.processHead(htmlSnippet)
        })
      );
      plugins.push(
        new HtmlWebpackPlugin({
          ...pluginOpts,
          filename: htmlFile.replace(/(\.html?)$/, "_v2$1"),
          ejsFixUrls: htmlSnippet => processorV2.processHead(htmlSnippet)
        })
      );
    });

    // copy unrecognized files as-is ("from" path is relative to webpack's context, i.e. srcAbsPath)
    if (!CopyWebpackPlugin) CopyWebpackPlugin = require("copy-webpack-plugin");
    let cwpSettings = [
      {
        from: "**/*",
        ignore: [
          "*.js",
          "*.jsx",
          "*.css",
          "*.less",
          "**/demo/**",
          "assets/**",
          "**/test/**",
          "**/__snapshots__/**"
        ].concat(htmlPostProcessedFiles)
      },
      { from: "assets/**" } // copy assets/ folder as-is (including any .less, ..., files)
    ];
    if (opts.includeDemoPages) cwpSettings.push({ from: "**/demo/**" });
    if (templateType === "uu5-app" || (opts.includeDemoPages && templateType === "uu5-lib")) {
      // copy OIDC callbacks but don't overwrite if they already exist (e.g. build of uu5-app modifies
      // them in some cases)
      if (!fs.existsSync(path.join(outputAbsPath, "callbacks"))) {
        if (fs.existsSync("node_modules/uu_appg01_oidc")) {
          cwpSettings.push({
            context: "../node_modules/uu_appg01_oidc/src/controllers",
            from: "callback.html",
            to: "callbacks/oidc-callback.html"
          });
        } else {
          cwpSettings.push({ context: "../node_modules/uu_oidcg01/dist", from: "callbacks/**" });
        }
      }
    }
    if (!env.isDistributionBuild) cwpSettings.push({ context: path.resolve("."), from: "mock/**" });
    plugins.push(new CopyWebpackPlugin(cwpSettings));
  }

  // add copyright
  let licenseText;
  let bannerFn;
  plugins.push(
    new webpack.BannerPlugin({
      banner: (info) => {
        // { filename, hash, chunk }
        if (licenseText === undefined) {
          if (fs.existsSync("LICENSE")) licenseText = fs.readFileSync("LICENSE", "utf-8").trim();
          else if (fs.existsSync("../LICENSE")) licenseText = fs.readFileSync("../LICENSE", "utf-8").trim();
          else licenseText = "";
          if (!licenseText.includes("\n")) licenseText = `/*! ${licenseText.replace(/\*\//g, "* /")} */`;
          else licenseText = `/*!\n * ${licenseText.replace(/\*\//g, "* /").split("\n").join("\n * ")}\n */`;
        }
        if (opts.banner) {
          if (bannerFn === undefined) {
            try {
              bannerFn = fs.existsSync(opts.banner) ? require(path.resolve(opts.banner)) : null;
            } catch (e) {
              console.error("Failed to load banner file - it must be a JavaScript file exporting function.", e);
            }
            if (typeof bannerFn !== "function") bannerFn = null;
          }
        }
        return bannerFn ? bannerFn(info, licenseText) : licenseText;
      },
      raw: true,
      test: /\.js$/,
    })
  );

  // extract CSS & minify
  if (extractCss) plugins.push(extractCss);
  if (opts.minify) {
    if (!TerserWebpackPlugin) TerserWebpackPlugin = require("terser-webpack-plugin");
    optimization.minimizer = [
      new TerserWebpackPlugin({
        cache: true,
        parallel: true,
        sourceMap: !!opts.useSourceMaps,
        extractComments: false, // don't extract license comments into file.js.LICENSE.txt
        terserOptions: {
          output: {
            max_line_len: 200
          }
        }
      })
    ];
    if (cssMinimizer) optimization.minimizer.push(cssMinimizer);
  }

  // add detection of circular dependencies
  plugins.push(
    new CircularDependencyPlugin({
      exclude: /node_modules/,
      failOnError: false
    })
  );

  // fix emitted JS files so that SystemJS loader doesn't mis-detect their format as ES6
  plugins.push(new SystemjsEs6DetectionFixPlugin());

  // enable hot module replacement
  // NOTE react-hot-loader@4.x doesn't work with createReactClass (and won't be fixed)
  // https://github.com/gaearon/react-hot-loader/issues/831 => we're using latest @3.x.
  if (hot) {
    plugins.push(new webpack.HotModuleReplacementPlugin());
  }

  // set various optimization flags
  optimization.namedModules = env.isDevServer && !env.isDistributionBuild;
  optimization.concatenateModules = mode === "production";
  optimization.noEmitOnErrors = env.isDistributionBuild;
  optimization.minimize = mode === "production";

  // configure splitting into chunks via import() function
  // https://webpack.js.org/plugins/split-chunks-plugin/
  if (opts.codeSplitting !== false && (!opts.outputFile || !opts.outputFile.match(/\.css$/))) {
    if (!optimization.splitChunks) optimization.splitChunks = {};
    optimization.splitChunks = {
      ...optimization.splitChunks,
      chunks: "async",
      cacheGroups: {
        ...optimization.splitChunks.cacheGroups,
        vendors: false, // don't create extra cache group for modules from node_modules/ (reason in webpack's doc about caching doesn't apply for us - our libs / app cache themselves by having version in URL)
        default: {
          // this should ensure that modules are never duplicated in different chunks
          // (we'll combine small chunks back to larger ones via plugin)
          minSize: 1,
          minChunks: 2,
          reuseExistingChunk: true,
          priority: -5
        }
      }
    };
    if (!CombineChunksPlugin) CombineChunksPlugin = require("./webpack-misc/combine-chunks-plugin.js");
    plugins.push(
      new CombineChunksPlugin({
        verbose: opts.analyzeChunks,
        combinedMaxSize: opts.combinedChunksMaxSize || 30000 // we'd like upto 30kB minified chunks
      })
    );
    if (opts.analyzeChunks) {
      // https://github.com/webpack-contrib/webpack-bundle-analyzer
      const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
      if (!MessagePlugin) MessagePlugin = require("./webpack-misc/message-plugin.js");
      let reportFileName = path.resolve(
        paths.buildDir,
        "webpack-chunks-" + configName.replace(/[^a-zA-Z0-9\-_]/g, "_") + ".html"
      );
      plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: "static",
          reportFilename: reportFileName,
          openAnalyzer: opts.analyzeChunksAutoOpen == null ? false : opts.analyzeChunksAutoOpen,
          statsOptions: {
            excludeModules: /[\\/](react-hot-loader|css-loader|style-loader|webpack-tmp|uu_appg01_devkit)[\\/]/
          },
          generateStatsFile: true,
          statsFilename: path.resolve(
            paths.buildDir,
            "webpack-stats-" + configName.replace(/[^a-zA-Z0-9\-_]/g, "_") + ".json"
          ),
          logLevel: "warn"
        }),
        new MessagePlugin({
          message: "Webpack chunks report has been written to: " + reportFileName
        })
      );
    }
  }

  // configuration of dependencies
  let externalsConfig = opts.externals || {};
  externalsConfig["module"] = { baseUri: true, format: "global", exports: "undefined" }; // force external (shimmed to be undefined if loading directly via <script> tag)
  if (opts.moduleType === "cjs") {
    // aliasing "module" doesn't work for some reason => redirect it via NormalModuleReplacement
    // to a module exporting null
    let moduleFile;
    plugins.push(
      new webpack.NormalModuleReplacementPlugin(/^module$/, function(resource) {
        if (!resource || !resource.request || !resource.context) return;

        if (!moduleFile) moduleFile = createTemporaryModuleFile("module.exports = null;\n");
        let newRequest = ("./" + path.relative(resource.context, moduleFile).replace(/\\/g, "/")).replace(
          /^\.\/\.\.\//,
          "../"
        );
        let origRequest = resource.request;
        resource.request = newRequest;
        (resource.dependencies || []).forEach(depInfo => {
          if (depInfo && depInfo.request === origRequest) depInfo.request = newRequest;
        });
        // console.log(origRequest + " -> " + resource.request);
      })
    );
  }
  let hotLoaderReactCommonFile = "hot-loader-react-common.js";
  let hotLoaderReactDomFile = "hot-loader-react-dom.js";
  let hotLoaderReactHotLoaderFile = "hot-loader-react-hot-loader.js";
  if (reactHot) {
    // NOTE How React hot loading works in react-hot-loader@4.x:
    // 1. react-dom must be patched - this is done by using react-hot-loader/webpack loader on a react-dom package
    // 2. Hence react-dom must be redirected to our patched version when in browser.
    // 3. Lazy components seem to work only if react-hot-loader is in page in single chunk / single something,
    //    therefore we build it together when patching react-dom:
    //     - hot-loader-react-common.js - exports patched ReactDOM & react-hot-loader
    //     - hot-loader-react-dom.js - imports hot-loader-react-common, re-exports patched ReactDOM
    //     - hot-loader-react-hot-loader.js - imports hot-loader-react-common, re-exports react-hot-loader (app uses this file when SystemJS loads "react-hot-loader")
    //     + app (SystemJS) is configured to load "react-dom" from hot-loader-react-dom.js, getting patched ReactDOM (any external libraries of app will get already patched version of ReactDOM too)
    //     + app uses react-hot-loader (in index.js) as an external dependency and loads it from hot-loader-react-hot-loader.js, and therefore it's singleton even if there are more chunks in page
    // 4. Lazy components seem to work only with older API, i.e. using AppContainer directly.
    externalsConfig["hot-loader-react-common"] = { baseUri: "./", main: hotLoaderReactCommonFile };
    externalsConfig["react-dom"] = { baseUri: "./", main: hotLoaderReactDomFile };
    externalsConfig["react-hot-loader"] = { baseUri: "./", main: hotLoaderReactHotLoaderFile };
  }

  let submodules = {};
  if (templateType === "uu5-lib") {
    ((pkg.uuBuildSettings || {}).packs || []).forEach(pack => {
      if (!(pack.outputFile || "").match(/\.js$/)) return;
      let name = pack.outputFile
        .split(/[/\\]/)
        .pop()
        .replace(/(\.min)?\.js$/, "");
      if (name.startsWith(pkg.name + "-")) submodules[name] = true;
    });
  }

  // aliases for resolving modules
  let useMockData = opts.useMockData && !env.isDistributionBuild && fs.existsSync("mock/calls.js");
  let aliases = { ...opts.aliases };
  for (let k in aliases) {
    if (typeof aliases[k] === "string" && aliases[k].match(/^\.\.?[/\\]/)) aliases[k] = path.resolve(aliases[k]);
  }
  Object.assign(aliases, {
    __project__: srcAbsPath, // alias for root of src folder (used by all on-the-fly created modules / chunks)
    calls: useMockData ? path.resolve("mock/calls.js") : path.resolve(srcAbsPath, "calls.js")
  });
  if (!reactHot) {
    // using reactHot is handled by using external "react-hot-loader"; this is here for cases
    // when it's turned off (npm start -- --no-hot) and uu5-app source code contains import to it
    aliases["react-hot-loader"] = path.dirname(require.resolve("react-hot-loader"));
  }
  if (hot) {
    // webpack-hot-middleware ignores errors during accept phase of hot reloading
    // => patch it to trigger page reload in such case
    let processUpdateStr = fs.readFileSync(require.resolve("webpack-hot-middleware/process-update.js"), "utf-8");
    processUpdateStr +=
      "\n" + "applyOptions.ignoreUnaccepted = applyOptions.ignoreDeclined = applyOptions.ignoreErrored = false;\n";
    aliases["__webpack-hot-middleware-process-update-fix"] = createTemporaryModuleFile(
      processUpdateStr,
      "__webpack-hot-middleware-process-update-fix.js"
    );
    plugins.push(
      new webpack.NormalModuleReplacementPlugin(/\/process-update/, resource => {
        if (resource.context.indexOf("webpack-hot-middleware") !== -1)
          resource.request = "__webpack-hot-middleware-process-update-fix";
      })
    );
  }

  // routing support - prepare proper <base> element snippet
  if (opts.appBaseUrlPath && !opts.appBaseUrlPath.match(/^</)) {
    // it's not a special value
    opts.appBaseUrlPath = opts.appBaseUrlPath.replace(/\/*$/, "/"); // make sure it ends with "/"
  }
  if (opts.appAssetsRelativeUrlPath) {
    if (opts.appAssetsRelativeUrlPath.match(/^\//))
      throw new Error(
        "Configuration option appAssetsRelativeUrlPath must be relative URL path (must not start with slash)."
      );
    opts.appAssetsRelativeUrlPath = opts.appAssetsRelativeUrlPath.replace(/\/*$/, "/").replace(/^\.\//, ""); // make sure it ends with "/" and doesn't start with "./"
  }

  // configure output verbosity - https://webpack.js.org/configuration/stats/
  let stats = {
    modules: false,
    moduleTrace: false,
    colors: true,
    hash: false,
    version: false
  };

  // prepare webpack configuration
  let webpackConfig = [];

  // convert entry files from entryPoints to webpack configuration (we'll need to generate different entry file
  // for each of these as a workaround because we need to set publicPath during runtime, not during compile time
  // which is not as straightforward with webpack - https://github.com/webpack/webpack/issues/2776)
  let entryList = opts.outputFile ? [{ files: opts.entryPoints }] : opts.entryPoints.map(it => ({ files: [it] })); // if outputFile is given, assume all entries are to be bundled there; otherwise make separate output for each entry
  let entryMap = entryList.reduce((result, entry, idx) => {
    let initialFile = "./" + path.relative(srcAbsPath, path.resolve(srcAbsPath, entry.files[0])).replace(/\\/g, "/"); // "./entry/index.js"
    let name = initialFile.substr(2).replace(/\.(js|css|less)$/, ""); // "entry/index"
    let isCssOnly = !entry.files.some(filePath => !filePath.match(/\.(css|less|sass)$/));

    // make sure that the target name was not used yet
    if (result[name]) {
      let i = 0;
      while (result[name + "-" + i]) ++i;
      name += "-" + i;
    }

    let files;
    let dynamicPublicPath = true;
    if (!isCssOnly) {
      files = entry.files.map(filePath =>
        createEntryPointFile(
          "./" + path.relative(srcAbsPath, path.resolve(srcAbsPath, filePath)).replace(/\\/g, "/"),
          opts,
          pkg.version
        )
      );
    } else {
      dynamicPublicPath = false;
      files = [
        createTemporaryModuleFile(
          entry.files
            .map(
              filePath =>
                `require(${JSON.stringify(
                  "./" +
                    path
                      .relative(path.resolve(paths.buildWebpackTempDir), path.resolve(srcAbsPath, filePath))
                      .replace(/\\/g, "/")
                )});`
            )
            .join("\n")
        )
      ];
    }
    if (hot && !isCssOnly) {
      let isFirstHot = opts.copyFiles && idx === 0; // :-/ copyFiles flag also indicates that this is 1st (main) config
      files.unshift(
        require.resolve("webpack-hot-middleware/client") +
          getHotClientOptions(configName, opts, dynamicPublicPath, !isFirstHot)
      );
    }
    result[name] = files;
    return result;
  }, {});

  let resolveLoaderModules = ["node_modules"];
  if (fs.existsSync("node_modules/uu_appg01_devkit")) {
    let devkitModulesPath = path.resolve(fs.realpathSync("node_modules/uu_appg01_devkit"), "node_modules");
    if (fs.existsSync(devkitModulesPath)) resolveLoaderModules.push(devkitModulesPath);
    let projectModulesPath = path.resolve("node_modules");
    let devkitPnpmModulesPath = path.resolve(fs.realpathSync("node_modules/uu_appg01_devkit"), "..");
    if (devkitPnpmModulesPath !== projectModulesPath && devkitPnpmModulesPath !== devkitModulesPath) {
      resolveLoaderModules.push(devkitPnpmModulesPath);
    }
  }
  let webpackOutputFileName =
    opts.outputFile && opts.outputFile.match(/\.(css|less)$/)
      ? path.join(path.relative(outputAbsPath, paths.buildWebpackTempDir), "__ignored", uuid())
      : opts.outputFile || "[name].js"; // for CSS we cannot emit directly into outputFile because it'll be emitted by mini-css-extract-plugin
  webpackConfig.push({
    context: srcAbsPath,
    mode,
    name: configName,
    entry: entryMap,
    target: targetEnvironment,
    output: {
      filename: webpackOutputFileName,
      chunkFilename: `chunks/${configName.replace(/(\.min)?\.js$/, "")}/[id]-[hash]${opts.minify ? ".min" : ""}.js`,
      hotUpdateChunkFilename: `__webpack-hot-update/${configName.replace(
        /(\.min)?\.js$/,
        ""
      )}/[id].[hash].hot-update.js`,
      hotUpdateMainFilename: `__webpack-hot-update/${configName.replace(/(\.min)?\.js$/, "")}/[hash].hot-update.json`,
      path: outputAbsPath,
      // publicPath: undefined, // publicPath is configured during runtime (in browser)
      pathinfo: !opts.minify && !env.isDistributionBuild,
      jsonpFunction: (
        "__webpack_jsonp_" +
        pkg.name +
        "_" +
        pkg.version +
        "_" +
        configName.replace(/(\.min)?\.js$/, "")
      ).replace(/[^a-zA-Z0-9_]/g, "_"), // to prevent collisions between libraries if they load chunks themselves
      ...(targetEnvironment === "web"
        ? {
            libraryTarget: opts.moduleType === "cjs" ? "commonjs2" : "umd",
            library: {
              root: opts.libraryGlobalVariable ? opts.libraryGlobalVariable.split(".") : "[name]",
              amd: webpackOutputFileName.replace(/(\.min)?\.js/, ""),
              commonjs: webpackOutputFileName.replace(/(\.min)?\.js/, "")
            },
            umdNamedDefine: true
          }
        : null),
      devtoolModuleFilenameTemplate: opts.useSourceMaps
        ? !env.isDistributionBuild
          ? // when debugging in IDE (RubyMine, VS Code) IDEs map sourceMap addresses into workspace folders;
            // VS Code uses "sourceMapPathOverrides" for that and we want the value not to change between
            // different projects/app so we'll not include package name & version while developing
            "webpack:///" + src.replace(/\\/g, "/") + "/[resource-path]"
          : // include package name & version in source map names so that they don't collide
            // in an application which uses more libraries built by these tools
            "webpack:///" + pkg.name + "@" + pkg.version + "/" + src.replace(/\\/g, "/") + "/[resource-path]"
        : undefined
    },
    resolve: {
      alias: aliases
    },
    resolveLoader: {
      // make loaders available to the project (without having to have them in package.json)
      modules: resolveLoaderModules
    },
    module: {
      rules: rules
    },
    plugins: plugins,
    optimization,
    externals: function(context, request, callback) {
      if (request.match(/\.less$/)) return callback(); // .less files are always considered non-external

      // distinguish externals by using static "externalsConfig" configuration
      let conf;
      let rootModule = request.replace(/\/.*/, ""); // "module/that/is/nested" => "module"
      if (externalsConfig[request] === false) conf = false;
      else if (externalsConfig[request] != null) conf = externalsConfig[request];
      else conf = externalsConfig[rootModule];

      // CJS build should preserve require("xyz") for require-s going outside of src/ (i.e. those that are in pkg.dependencies)
      let loadAsExternal;
      if (opts.moduleType === "cjs") {
        if (rootModule in (pkg.dependencies || {})) loadAsExternal = request;
      }

      if (!loadAsExternal && (!conf || conf.baseUri === false)) return callback(); // configured as not external
      if (!loadAsExternal) {
        let usedRequest =
          rootModule === pkg.name && request.replace(/\//, "-") in submodules ? request.replace(/\//, "-") : request; // allow importing submodules via "/", i.e. redirect `import "uu5g04/bricks"` to `import "uu5g04-bricks"`
        loadAsExternal = {
          amd: usedRequest,
          commonjs: usedRequest,
          commonjs2: usedRequest,
          root:
            typeof conf == "string"
              ? conf.split(".")
              : conf.globalVariable
              ? conf.globalVariable.split(".")
              : /*conf.format == "global" ?*/ conf.exports /*:*/ || usedRequest
        };
      }

      // redirect own submodules to proper files (e.g. importing uu5g04-bricks from uu5g04-forms should end up with require("../bricks.js"))
      if (opts.moduleType === "cjs") {
        let isSelf = request === pkg.name;
        let isSubmodule = request in submodules;
        if (isSelf || isSubmodule) {
          loadAsExternal.commonjs = loadAsExternal.commonjs2 = isSelf
            ? "../index.js"
            : "../" + request.substr(pkg.name.length + 1) + ".js";
        }
      }

      return callback(null, loadAsExternal);
    },
    devtool: opts.useSourceMaps ? (opts.minify ? "source-map" : "cheap-module-eval-source-map") : false,
    bail: env.isDistributionBuild,
    performance: {
      hints: false
    },
    stats
  });

  // add generating of modified react-dom so that React's hot reload works
  if (reactHot && opts.copyFiles) {
    let hotLoaderReactCommonEntry = createTemporaryModuleFile(
      `module.exports = { ReactDOM: require("react-dom"), ReactHotLoader: require("react-hot-loader/dist/react-hot-loader.development.js") };\n`,
      hotLoaderReactCommonFile
    );
    let hotLoaderReactDomEntry = createTemporaryModuleFile(
      `module.exports = require("hot-loader-react-common").ReactDOM;\n`,
      hotLoaderReactDomFile
    );
    let hotLoaderReactHotLoaderEntry = createTemporaryModuleFile(
      `module.exports = require("hot-loader-react-common").ReactHotLoader;\n`,
      hotLoaderReactHotLoaderFile
    );
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-common",
      entry: { [hotLoaderReactCommonFile.replace(/\.js$/, "")]: hotLoaderReactCommonEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: {
          root: "HotLoaderReactCommon",
          amd: "hot-loader-react-common",
          commonjs: "hot-loader-react-common",
        },
      },
      externals: {
        react: { commonjs: "react", commonjs2: "react", amd: "react", _: "React" },
        "prop-types": { commonjs: "prop-types", commonjs2: "prop-types", amd: "prop-types", _: "PropTypes" }
      },
      plugins: [new webpack.DefinePlugin({ "process.env": { NODE_ENV: JSON.stringify("development") } })],
      module: {
        rules: [
          {
            test: /\.jsx?$/,
            include: /node_modules/,
            use: [require.resolve("react-hot-loader/webpack")],
          }
        ],
      },
      stats: false,
      devtool: false,
    });
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-dom",
      entry: { [hotLoaderReactDomFile.replace(/\.js$/, "")]: hotLoaderReactDomEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: { root: "ReactDOM", amd: "react-dom", commonjs: "react-dom" },
      },
      externals: {
        "hot-loader-react-common": {
          commonjs: "hot-loader-react-common",
          commonjs2: "hot-loader-react-common",
          amd: "hot-loader-react-common",
          _: "HotLoaderReactCommon",
        },
      },
      stats: false,
      devtool: false,
    });
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-hotLoader",
      entry: { [hotLoaderReactHotLoaderFile.replace(/\.js$/, "")]: hotLoaderReactHotLoaderEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: { root: "ReactHotLoader", amd: "react-hot-loader", commonjs: "react-hot-loader" },
      },
      externals: {
        "hot-loader-react-common": {
          commonjs: "hot-loader-react-common",
          commonjs2: "hot-loader-react-common",
          amd: "hot-loader-react-common",
          _: "HotLoaderReactCommon",
        },
      },
      stats: false,
      devtool: false,
    });
  }

  // add generating of uu5-environment.js file
  if (templateType === "uu5-app" && opts.copyFiles && process.env.NODE_ENV !== "test") {
    let uu5EnvPlugins = [];
    // NOTE hot-reload for uu5-environment.js is now disabled as it is being inlined into uu5-app's html page
    // and the HMR code makes it really big (developer can still change the settings and do F5 in browser)
    // we'll additionally make it as small as possible, i.e. turn on production mode
    let mode = "production";
    // if (hot) {
    //   uu5EnvPlugins.push(new webpack.HotModuleReplacementPlugin());
    // }
    let uu5EnvConfigName = "uu5-environment";
    if (usedBundleNames.has(uu5EnvConfigName))
      throw new Error(
        'Unable to bundle uu5-environment. It is probably defined in config/config.js "packs" field - remove it from there.'
      );

    // set various optimization flags
    let uu5EnvOptimization = {};
    uu5EnvOptimization.namedModules = env.isDevServer && !env.isDistributionBuild;
    uu5EnvOptimization.concatenateModules = mode === "production";
    uu5EnvOptimization.noEmitOnErrors = env.isDistributionBuild;
    uu5EnvOptimization.minimize = mode === "production";
    let uu5EnvFileContents;
    let uu5EnvData;
    if (env.isDistributionBuild) {
      uu5EnvData = opts.uu5Environment || require(path.resolve("env/production.json")).uu5Environment || {};
      uu5EnvFileContents = `window.UU5={Environment: ${JSON.stringify(uu5EnvData)}};`;
    } else {
      uu5EnvData =
        opts.uu5Environment ||
        Object.assign(
          {},
          require(path.resolve("env/production.json")).uu5Environment,
          require(path.resolve("env/development.json")).uu5Environment
        );
      uu5EnvFileContents = `
var devConfig = require(${JSON.stringify(path.resolve("env/development.json"))}).uu5Environment;
var config = require(${JSON.stringify(path.resolve("env/production.json"))}).uu5Environment || {};
if (devConfig) for (var k in devConfig) config[k] = devConfig[k];
window.UU5 = { Environment: config };
`;
    }
    // TODO Make uu5-environment.json file auto-update on file change too.
    let uu5EnvJsonFile = createTemporaryModuleFile(JSON.stringify(uu5EnvData, null, 2), "uu5-environment.json");
    uu5EnvPlugins.push(
      new CopyWebpackPlugin([{ context: path.dirname(uu5EnvJsonFile), from: "uu5-environment.json" }])
    );
    let entryValue = [createTemporaryModuleFile(uu5EnvFileContents, "uu5-environment.js")];
    // if (hot) {
    //   entryValue.unshift(
    //     require.resolve("webpack-hot-middleware/client") + getHotClientOptions(uu5EnvConfigName, opts, false, true) // logging is off because each standalone file logs everything so we would have duplicities
    //   );
    // }

    webpackConfig.push({
      context: srcAbsPath,
      mode,
      name: uu5EnvConfigName,
      entry: { "uu5-environment": entryValue },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        hotUpdateChunkFilename: "__webpack-hot-update/[id].[hash].hot-update.js",
        hotUpdateMainFilename: "__webpack-hot-update/[hash].hot-update.json"
      },
      plugins: uu5EnvPlugins,
      optimization: uu5EnvOptimization,
      bail: env.isDistributionBuild,
      performance: {
        hints: false
      },
      stats,
      devtool: false
    });
  }

  return webpackConfig;
}

function createEntryPointFile(name, opts, version) {
  fs.mkdirsSync(paths.buildWebpackTempDir + "/" + name.replace(/^(.*\/).*/, "$1").replace(/^\.\//, ""));
  let noRelativeName = name.replace(/^\.\//, "");
  let noRelativeOutputName = opts.outputFile
    ? opts.outputFile.replace(/^\.\//, "").replace(/\\/g, "/")
    : noRelativeName;
  let depthFromAppAssetsBase = noRelativeOutputName.split(/\//).length;
  let majorVersion = version.replace(/\..*/, "");
  let entryFileContents = `module.exports = require("__project__/${noRelativeName}");\n`;
  if (opts.moduleType !== "cjs") {
    entryFileContents = `var mod=require("module");
var isDoc = typeof document !== "undefined";
var uri = ${
      opts.targetEnvironment === "webworker"
        ? "location.href"
        : '((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();'
    }
uri = uri.split(/\\//).slice(0, -${depthFromAppAssetsBase}).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/${majorVersion}.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/${version}/";
__webpack_public_path__ = uri;
${entryFileContents}`;
  }

  // NOTE Use file name so that following scenario works:
  // 1. npm start
  // 2. npm test (while npm start is up) => without file name, the names would be "temp-0.js" and
  //    this would overwrite the files used in step 1 by CJS variants, leading to "Compilation failed"
  //    all the time, i.e. developer would have to restart npm start.
  return createTemporaryModuleFile(
    entryFileContents,
    noRelativeName.replace(/(\.[^.]*)?$/, m => "-" + opts.moduleType + m)
  );
}

let tempCounter = 0;
function createTemporaryModuleFile(fileContents, optionalFileName) {
  let tmpFilePath =
    paths.buildWebpackTempDir + "/" + (optionalFileName ? optionalFileName : "temp-" + tempCounter++ + ".js");
  fs.removeSync(tmpFilePath);
  fs.ensureDirSync(path.dirname(tmpFilePath));
  fs.writeFileSync(tmpFilePath, fileContents, "utf-8");

  // prevent re-compilation loop during first few seconds after "npm start"
  // https://github.com/webpack/watchpack/issues/25
  let timeInPast = Date.now() / 1000 - 10;
  fs.utimesSync(tmpFilePath, timeInPast, timeInPast);
  return path.resolve(tmpFilePath);
}

function getHtmlFilesToProcess(mappingsJson, srcPath) {
  let resultSet = new Set();
  if (mappingsJson) {
    for (let k in mappingsJson) {
      // iterate over UCs in the mappings.json and pick those which are VUC and end with .html (or .htm)
      let ucMap = (mappingsJson[k] || {})["useCaseMap"] || {};
      Object.keys(ucMap)
        .filter(
          uc => (ucMap[uc].type === "VUC" || ucMap[uc].type === "UVE") && (ucMap[uc].realization || "").match(/\.html?$/i)
        )
        .map(uc => ucMap[uc].realization.replace(/^\/+/, ""))
        .forEach(htmlFile => resultSet.add(htmlFile));
    }
  }
  let filesInSrc = fs.readdirSync(srcPath, { withFileTypes: true });
  filesInSrc.filter((item) => item.name.match(/\.html?$/) && item.isFile()).forEach((item) => resultSet.add(item.name));
  return [...resultSet];
}

function getHotClientOptions(name, devServerConfig, dynamicPublicPath = true, noInfo = false) {
  let result = `?name=${encodeURIComponent(name)}&reload=true`;
  if (dynamicPublicPath) result += `&dynamicPublicPath=true`; // NOTE Must not be present in result if it's supposed to be false.
  if (noInfo) result += "&noInfo=true"; // NOTE Must not be present in result if it's supposed to be false.
  let { https, host, port } = devServerConfig;
  let hmrUrl =
    (https ? "https" : "http") + "://" + (host === "0.0.0.0" ? "localhost" : host) + ":" + port + "/__webpack_hmr";
  result += "&path=" + encodeURIComponent(hmrUrl);
  return result;
}

function getStyleLoaderInsertInto(dataOwner, emotionKey, srcAbsPath, configName) {
  let content = fs.readFileSync(require.resolve("./webpack-misc/style-loader-insert-into.ejs"), "utf-8");
  content = content.replace(/<%=\s*EMOTION_KEY\s*%>/g, () => emotionKey);
  content = content.replace(/<%=\s*DATA_OWNER\s*%>/g, () => dataOwner);

  let filePath = createTemporaryModuleFile(content, `__styles/${configName}-insert-into.js`);
  let modulePath =
    "__project__/" +
    path
      .relative(srcAbsPath, filePath)
      .replace(/\\/g, "/")
      .replace(/^\.\//, "");
  return new Function(`return require(${JSON.stringify(modulePath)})();`);
}

function renderTemplate(sourceFile, filePath, context) {
  let resolvedPath;
  if (filePath.match(/^\.\.?[/\\]/)) resolvedPath = path.resolve(path.dirname(sourceFile), filePath);
  else {
    resolvedPath = path.resolve(
      path.dirname(require.resolve("uu_appg01_devkit-common/package.json")),
      "src/templates-generator/__uu5",
      filePath
    );
  }
  let result = "";
  if (fs.existsSync(resolvedPath)) {
    result = fs.readFileSync(resolvedPath, "utf-8");
    if (context) {
      if (!StringUtil) StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
      result = StringUtil.evalExpressions(result, context, resolvedPath);
    }
  }
  return result;
}
