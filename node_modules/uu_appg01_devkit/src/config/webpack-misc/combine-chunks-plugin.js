// based on webpack/lib/optimize/MinChunkSizePlugin.js

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const path = require("path");

const minificationFactor = 1.7;
const sizeOptions = {
  chunkOverhead: 1,
  entryChunkMultiplicator: 1
};

class CombineChunksPlugin {
  constructor(options) {
    this.options = options;
  }

  apply(compiler) {
    let { combinedMaxSize, verbose } = this.options;
    let combinedMaxSizeUnminified = combinedMaxSize * minificationFactor;
    compiler.hooks.compilation.tap("CombineChunksPlugin", compilation => {
      compilation.hooks.optimizeChunksAdvanced.tap("CombineChunksPlugin", chunks => {
        if (compilation.name.match(/mini-css-extract-plugin|html-webpack-plugin|HtmlWebpackCompiler|\.css$/)) return; // don't process extra (non-JS) compilations performed by some plugins

        if (verbose) {
          console.log(`------- CombineChunksPlugin - combining small chunks into bigger one limiting to ${Math.round(combinedMaxSizeUnminified / 1000)} kB unminified, ${Math.round(combinedMaxSize / 1000)} kB minified (approximation).`);
          console.log(compilation.name + " - initial chunks:\n" + chunks.map(chunk => "  " + prettyPrintChunk(chunk)).join("\n"));
        }

        // filter out big chunks (over the threshold), sort chunks by group count
        // (how many times is the chunk referenced from others) and by size
        let items = chunks
          .map(chunk => ({
            chunk,
            size: chunk.size(sizeOptions),
            groupCount: chunk.getNumberOfGroups()
          }))
          .filter(it => it.size < combinedMaxSizeUnminified)
          .sort((a, b) => (a.chunk.entryModule ? 1 : 0) - (b.chunk.entryModule ? 1 : 0) || a.groupCount - b.groupCount || a.size - b.size);

        // combine most used chunks with each other, fallback to combining biggest ones
        let changedMap = new Map();
        for (let i = items.length - 1; i >= 0; --i) {
          let itemBig = items[i];
          // try to integrate into itemBig as many smaller chunks as possible, starting with most used & big ones
          for (let j = i - 1; j >= 0; --j) {
            let item = items[j];
            if (item.chunk.entryModule) continue; // never merge entry chunks elsewhere (but non-entry chunks into entry chunks is allowed)
            let comboSize = itemBig.chunk.integratedSize(item.chunk, sizeOptions);
            if (!comboSize) continue; // cannot be integrated together
            if (comboSize < combinedMaxSizeUnminified) {
              // console.log(`integrating ${item.size} + ${itemBig.size}\n  A: ${prettyPrintChunk(item.chunk)}\n  B: ${prettyPrintChunk(itemBig.chunk)}`);
              let integrated = itemBig.chunk.integrate(item.chunk, "min-size");
              if (integrated) {
                changedMap.set(itemBig.chunk, true);
                let newSize = itemBig.chunk.size(sizeOptions);
                itemBig.size = newSize;
                chunks.splice(chunks.indexOf(item.chunk), 1);
                items.splice(j, 1);
                --i;
              }
            }
          }
        }

        if (verbose) {
          if (changedMap.size > 0) {
            console.log("\n" + compilation.name + " - final chunks:\n" + chunks.map(chunk => "  " + prettyPrintChunk(chunk, changedMap.has(chunk) ? " changed" : " not changed")).join("\n") + "\n");
          } else {
            console.log("\n" + compilation.name + " - final chunks unchanged\n");
          }
        }

        return false; // return true if another round of "optimizeChunksAdvanced" hook should be run => we don't need it
      });
    });
  }
}

function prettyPrintChunk(chunk, extra = "") {
  let size = chunk.size(sizeOptions);
  let modules = Array.from(chunk._modules)
    .filter(
      it =>
        !it.external &&
        (!it.resource ||
          (!it.resource.match(/[\\/](react-hot-loader|css-loader|style-loader|webpack-tmp|uu_appg01_devkit)[\\/]/) && // omit development / temporary / style-injection related modules
            (!it.rawRequest || !it.rawRequest.match(/!/)))) // not complex requests such as !style-loader...?file.less
    )
    .map(it => (it.resource ? path.relative(".", it.resource) : it.userRequest));
  let entry = chunk.entryModule ? "(entry) " : "";
  return `${chunk.debugId}, ~${(Math.round(size / 1000) + "").padStart(3, " ")} kB, ${chunk.getNumberOfGroups()} refs,${extra} ${entry}[${modules.join(", ")}]`;
}
module.exports = CombineChunksPlugin;
