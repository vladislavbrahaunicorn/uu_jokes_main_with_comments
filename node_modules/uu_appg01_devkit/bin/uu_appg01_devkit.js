#! /usr/bin/env node

const path = require("path");
const shell = require("shelljs");

const helpers = require("../src/tools/helpers.js");

// throw error whenever shell command fails
shell.config.fatal = true;

// display error stack for unhandled Promise rejections
process.on("unhandledRejection", r => {
  throw r instanceof Error ? r : new Error(r);
});
Error.stackTraceLimit = 1000; // default is 10 (too low)

// show warning if using old version of NodeJS
if (!process.env.UU_APPG01_DEVKIT_NODEVC) {
  process.env.UU_APPG01_DEVKIT_NODEVC = "1";
  let { NODEJS_VERSION } = require("uu_appg01_devkit-common/src/config/preconditions.js");
  if (parseFloat(process.version.replace(/^v/, "")) < parseFloat(NODEJS_VERSION)) {
    console.warn(
      require("chalk").yellow("WARNING") +
        ` Old NodeJS version ${process.version} detected. Use newest LTS version, at least ${NODEJS_VERSION.replace(/(\.0)+$/, ".x")}.`
    );
  }
}

// stop on Ctrl+C (without the useless confirmation message on Windows)
// NOTE For Windows we have to use "readline" API which, however, prevents process from ending
// (because it waits for user input) - we'll keep it open only while command handler is running,
// i.e. see getScript method which closes it.
// let readline;
// if (process.platform === "win32") {
//   readline = require("readline")
//     .createInterface({
//       input: process.stdin,
//       output: process.stdout
//     })
//     .on("SIGINT", function() {
//       process.emit("SIGINT");
//     });
// }
// process.on("SIGINT", function() {
//   process.exit();
// });

const yargs = require("yargs");
yargs
  .command("clean", "Clean up target build directory.", {}, getScript("clean"))
  .command("start", "Starts application/library with file change watcher.", {}, getScript("start"))
  .command("test", "Run project tests.", {}, getScript("test"))
  .command(
    "testBrowser",
    "Run project tests in browser environment (library for both Node & browser environments).",
    {},
    getScript("testBrowser")
  )
  // .command("doc", "Generate documentation.", {}, getScript("doc"))
  .command("build [version]", "Build project distribution files.", {}, getScript("build"))
  .command("package", "Package project distribution files (also ensures project build).", {}, getScript("package"))
  .command("deploy [tokenFile]", "Deploys project packages to repository.", {}, getScript("deploy"))
  .command("undeploy [tokenFile]", "Unshares then undeploys an application.", {}, getScript("undeploy"))
  // .command("eject", "Ejects tools into current project to make it fully configurable. This operation is IRREVERSIBLE.", {}, getScript("eject"))
  .command("prettify", "Runs prettier on source & test files.", {}, getScript("prettify"))
  .command("vulnerabilityScan", "Scans all project dependencies and checks them for known vulnerabilities.", {}, getScript("vulnerabilityScan"))
  .command("npmDeploy", "Publishes NPM package to NPM repository.", {}, getScript("npmDeploy"))
  .command("uuAppBox [tokenFile]", "Creates uuAppBox.", {}, getScript("uuAppBox"))
  .command("uuCloudDeploy [tokenFile]", "Deployment of the application.", {}, getScript("uuCloudDeploy"))
  .command("uuCloudUndeploy [tokenFile]", "Undeployment of the application.", {}, getScript("uuCloudUndeploy"))
  .command("uuCloudShare [tokenFile]", "Share the application.", {}, getScript("uuCloudShare"))
  .command("uuCloudUnshare [tokenFile]", "Unshare the application.", {}, getScript("uuCloudUnshare"))
  .command("uuCloudDeployList [tokenFile]", "Show deploy list of the application.", {}, getScript("uuCloudDeployList"))
  .command("uuCloudSwap [tokenFile]", "Swaps appdeployment between the PRODUCTION and BETA slots.", {}, getScript("uuCloudSwap"))
  .command("uuLogStoreExport [tokenFile]", "Export logs of the application.", {}, getScript("uuLogStoreExport"))
  .command("uuCloudLogStoreExport [tokenFile]", "Export logs of the application.", {}, getScript("uuCloudLogStoreExport"))
  // .command("postinstall", "Perform postinstall check of devkit version in project.", {}, getScript("postinstall"))
  // .command("projectUpdate", "Update project template.", {}, getScript("projectUpdate"))
  .command("generate [entityType]", "Generate component / package / route / entity.", {}, getScript("generate"))
  .command("uuCmdCreateBookit [pageUri]", "Generate uuCMD according to it's standardised design", {}, getScript("generateCmdBookit"))
  .command("uuCmdCreate [useCase] [httpMethod] [profiles]", "Generate uuCMD", {}, getScript("generateCmd"))
  .command("lsiExport", "Exports lsis to a csv file", {}, getScript("lsiExport"))
  .command("lsiImport", "Imports lsis from a csv file", {}, getScript("lsiImport"))
  .command("generateProfilesJson", "Merge profiles.json of all libraries with application profiles.json and save them to the /target folder.", {}, getScript("generateProfilesJson"))
  .command("generateMappingsJson", "Merge mappings.json of all libraries with application mappings.json and save them to the /target folder.", {}, getScript("generateMappingsJson"))
  .demandCommand(2, "Must provide a valid command!") // TODO Needs 2 instead of 1 due to some bug in yargs.
  .showHelpOnFail(false)
  .help("help")
  .alias("h", "help")
  .alias("e", "environment")
  .version(false).argv;

function getScript(scriptName, templateType = null) {
  return async function(argv) {
    let scriptDirPath = path.resolve(__dirname, "..", "src", "scripts");
    let scriptNameDashCase = scriptName.replace(/[A-Z]/g, m => "-" + m.toLowerCase());
    let scriptPath = path.join(scriptDirPath, scriptNameDashCase + ".js");
    let file = helpers.resolveByTemplateType(scriptPath, templateType);
    if (!file) {
      throw new Error(
        `Script '${scriptName}' is not supported by uu_appg01_devkit for project type ${
          templateType != null ? templateType : helpers.getTemplateInfo().type
        }.`
      );
    }

    // // check project's spec version prior to executing most scripts
    // if (
    //   process.env.UU_APPG01_DEVKIT_CHECK_SPEC !== "false" &&
    //   scriptName !== "postinstall" &&
    //   scriptName !== "projectUpdate"
    // ) {
    //   const ProjectUpdate = require("../src/scripts/project-update.js");
    //   let hasWarnings = ProjectUpdate.showWarnings();
    //   // if (hasWarnings) process.exit(1);
    // }

    let Script = require(file);
    if (argv._) argv._.splice(0, 1); // remove name of command ("build", ...)
    delete argv.$0;
    delete argv.h;
    delete argv.help;
    delete argv.e;
    argv._commandLineArgs = process.argv.slice(3);
    const ProjectConfig = require("uu_appg01_devkit-common/src/config/project-config.js");
    ProjectConfig.instance.setCommandLineConfig(argv);
    // console.log(argv);
    await new Script(ProjectConfig.instance).process();
    // if (readline) readline.close();
  };
}
