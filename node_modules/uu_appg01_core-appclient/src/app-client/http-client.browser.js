"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, OptsReader, BaseError } = require("uu_appg01_core-utils");
const Helpers = require("./helpers.js");

class HttpClient {
  constructor(options = null) {
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  // function InvokeClient (cmdClient, httpClientOpts, finalRequest, finalOpts) {
  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // TODO Implement abortion support
    // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

    let xhr = (request.xhr = new XMLHttpRequest());
    return new Promise((resolve, reject) => {
      let canHaveBody = request.method.match(/^(put|post)$/i);
      let url = request.uri.toString();
      let body;
      if (!canHaveBody) {
        if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
      } else {
        body = request.body;
      }
      let headers = request.headers;
      let timeout = opts.getNumber("requestTimeout", 300);
      if (this._logger.isDebugLoggable())
        this._logger.debug(
          "Invoking Ajax request: " +
          JSON.stringify({
            method: request.method,
            url: url,
            body: body,
            requestTimeout: timeout,
            headers: headers
          })
        );

      xhr.open(request.method, url, true);
      if (timeout > 0) xhr.timeout = timeout * 1000;
      xhr.withCredentials = true;
      for (let k in headers) {
        let v = headers[k];
        if (k && v != null) {
          // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
          // it with proper boundary and server won't be able to parse the body
          if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
          xhr.setRequestHeader(k.replace(/(^|-)./g, m => m.toUpperCase()), v + "");
        }
      }
      xhr.ontimeout = e => {
        // TimeoutError
        this._logger.error("Request timed out: " + JSON.stringify({ url: url }), e);
        reject(Helpers.interceptorMakeResponse(xhr, { error: new BaseError("Request timed out - " + url, e) }));
      };
      xhr.onload = e => {
        // status 200 - 5xx
        let formatted = this._formatResponse(xhr);
        if (this._logger.isDebugLoggable())
          this._logger.debug(
            "Received response: " +
            JSON.stringify({
              url: url,
              status: xhr.status,
              data: formatted.response
            })
          );
        resolve(Helpers.interceptorMakeResponse(formatted));
      };
      xhr.onabort = e => {
        // user / developer abort; AbortError
        this._logger.warn("Request has been aborted: " + JSON.stringify({ url: url }), e);
        reject(Helpers.interceptorMakeResponse(xhr, { error: new BaseError("Request has been aborted - " + url, e) }));
      };
      xhr.onerror = e => {
        // network error; NetworkError
        let responseData = opts.getBoolean("transformResponse") === false ? new Uint8Array(xhr.response) : xhr.response;
        this._logger.error("Request ended with network error: " + JSON.stringify({ url: url }), e);
        reject(
          Helpers.interceptorMakeResponse(xhr, {
            error: new BaseError("Network error - " + url, e),
            data: responseData
          })
        );
      };
      xhr.onreadystatechange = () => {
        if (!(xhr.readyState === 2)) return;
        const transformResponse = opts.getBoolean("transformResponse", true) === true;
        if (!transformResponse) {
          xhr.responseType = "arraybuffer";
          return;
        }

        this._autodetectBinaryData(xhr);
      };
      xhr.send(body);
    });
  }

  _formatResponse(xhr) {
    if (xhr.responseType === "arraybuffer") {
      xhr.body = new Uint8Array(xhr.response);
    } else {
      xhr.body = xhr.response;
    }
    return xhr;
  }

  _autodetectBinaryData(xhr) {
    let cDisp;
    try {
      cDisp = xhr.getResponseHeader("Content-Disposition");
    } catch (e) {
      // do nothing
    }

    if (!cDisp) return;

    xhr.responseType = "arraybuffer";
    xhr.filename = _findMatch(cDisp);
    let cType = xhr.getResponseHeader("Content-Type");
    if (cType) {
      let cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
      xhr.contentType = cTypeItems[1] || null;
      xhr.encoding = cTypeItems[2] || null;
    }

    function _findMatch(cDisp) {
      let regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
      let match;
      let results = [];
      while ((match = regex.exec(cDisp)) != null) {
        results = results.concat(match.slice(1).filter(m => m));
      }

      let last = results[results.length - 1];

      return last ? decodeURIComponent(last) : null;
    }
  }
}

module.exports = HttpClient;
