"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, OptsReader, BaseError } = require("uu_appg01_core-utils");
const Got = require("got");
const getStream = require("get-stream");
const FormData = require("form-data");
const Helpers = require("./helpers.js");
const { PassThrough, Readable, Writable } = require("stream");
const https = require("https");

class HttpClient {
  constructor(options = null) {
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // enable self-signed certificates
    let sslOpts = new OptsReader(
      options,
      this._options, // remap Config param to internal opt
      { verifySsl: Config.get("uu_app_client_verify_ssl") }
    );
    let rejectUnauthorized = sslOpts.getBoolean("verifySsl", true);

    // TODO Implement abortion support
    // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

    // check whether to send parameters in body or querystring
    let canHaveBody = request.method.match(/^(put|post)$/i);
    let url = request.uri.toString();
    let body;
    if (!canHaveBody) {
      // attach preserialized body as query for GET requests (see Form serializer)
      if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
    } else {
      body = request.body;
    }

    // map request parameters to underlying Got API
    let gotOptions = {
      method: request.method,
      headers: request.headers,
      body: this._transformBodyForGot(body),
      retries: 0 // got retries twice by default
    };
    // use the agent with disabled SSL verification
    if (url.match(/^https:/i) && rejectUnauthorized === false) {
      gotOptions.agent = new https.Agent({ rejectUnauthorized });
    }

    // use FormData header that already includes proper multipart boundary
    if (body instanceof FormData) {
      gotOptions.headers["content-type"] = body.getHeaders()["content-type"];
      gotOptions.headers["transfer-encoding"] = gotOptions.headers["transfer-encoding"] || body.getHeaders()["transfer-encoding"];
    }

    gotOptions.headers["user-agent"] = `uuAppClient (Node.js)`;

    // transform timeout from s to ms
    let timeout = opts.getNumber("requestTimeout");
    if (timeout > 0) gotOptions.timeout = timeout * 1000;

    if (this._logger.isDebugLoggable()) {
      this._logger.debug(
        `Invoking request: ${JSON.stringify({ method: request.method, url, headers: request.headers, body })}`
      );
    }

    let response = await new Promise(async (resolve, reject) => {
      let stream = Got.stream(url, gotOptions);

      // rerouting response stream to resolve https://github.com/sindresorhus/got/issues/223
      let pt = this._passThrough(stream);

      stream.on("error", async (error, body, res) => {
        if (error.name === "HTTPError") {
          // moving relevant data to our own stream
          pt.headers = res.headers;
          pt.statusCode = res.statusCode;

          try {
            resolve(await this._formatResponse(pt, opts));
          } catch (err) {
            reject(err);
          }
        } else {
          reject(new BaseError("Request failed", error));
        }
      });

      stream.on("response", async res => {
        // moving relevant data to our own stream
        pt.headers = res.headers;
        pt.statusCode = res.statusCode;

        try {
          resolve(await this._formatResponse(pt, opts));
        } catch (err) {
          reject(err);
        }
      });
    });

    if (this._logger.isDebugLoggable()) {
      this._logger.debug(`Received response: ${JSON.stringify({ url, status: response.status, data: response.data })}`);
    }

    return Helpers.interceptorMakeResponse(response);
  }

  /**
   * Rerouting to a pass-through stream is necessary to
   * avoid Got reading out
   * @param {Response} stream
   * @returns {stream.PassThrough}
   * @private
   */
  _passThrough(stream) {
    let pt = new PassThrough();
    pt.statusCode = stream.statusCode;
    pt.headers = stream.headers;
    return stream.pipe(pt);
  }

  _transformBodyForGot(body) {
    if (body == null) return Buffer.from([]);
    if (this._isBodyValid(body)) return body;

    try {
      body = JSON.stringify(body);
    } catch (e) {
      throw new BaseError("Unable to serialize body.", e);
    }

    return body;
  }

  _isBodyValid(body) {
    return typeof body === "string" || body instanceof Buffer || body instanceof Readable || body instanceof FormData;
  }

  async _formatResponse(res, opts) {
    const doNotTransform = opts.getBoolean("transformResponse", true) !== true;
    if (doNotTransform) return res;

    let cDisp = res.headers["content-disposition"];
    if (cDisp) {
      res.filename = _findMatch(cDisp);
      let cType = res.headers["content-type"];
      if (cType) {
        let cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
        res.contentType = cTypeItems[1] || null;
        res.encoding = cTypeItems[2] || null;
      }
      return res;
    }

    res.body = await getStream(res);

    return res;

    function _findMatch(cDisp) {
      let regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
      let match;
      let results = [];
      while ((match = regex.exec(cDisp)) != null) {
        results = results.concat(match.slice(1).filter(m => m));
      }

      let last = results[results.length - 1];

      return last ? decodeURIComponent(last) : null;
    }
  }
}

module.exports = HttpClient;
