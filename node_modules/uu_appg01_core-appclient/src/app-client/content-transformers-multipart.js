"use strict";

const FormData = require("form-data");
const { BaseError } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { Readable } = require("stream");
const path = require("path");

let logger;

const MultiPart = {
  serialize: function(value) {
    if (!value) return value;
    if (typeof value !== "object") {
      this._getLogger().warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", {
        value: value
      });
      return value;
    }

    if (value instanceof FormData) {
      return value;
    }
    // make a list and:
    // 1) separate possible binaries and attach them at the end
    // 2) attempt to serialize objects since FormData does not support nested structures
    let list = [];
    let binary;
    for (const k in value) {
      let item = value[k];
      if (item instanceof Readable || item instanceof Buffer) {
        if (binary) {
          throw new BaseError("Too many binary fields. Only single binary field per multipart request is supported.");
        }
        binary = { key: k, value: item, type: "binary" };
      } else if (typeof item === "object") {
        try {
          list.push({ key: k, value: JSON.stringify(item), type: "object" });
        } catch (e) {
          throw new BaseError(
            `Serialization of key: ${k} into FormData failed.` + `Try serializing the nested object beforehand.`,
            e
          );
        }
      } else {
        list.push({ key: k, value: item });
      }
    }
    binary && list.push(binary);

    // fill values into FormData
    let formData = new FormData();
    // TODO Workaround for https://github.com/form-data/form-data/issues/90 which is not
    //   fixed despite being closed (see https://github.com/form-data/form-data/pull/70
    //   and https://github.com/mscdex/busboy/issues/137)
    // Workaround forces form-data to use chunked transfer encoding when other than
    // file stream is appended
    formData.origAppend = formData.append.bind(formData);
    formData.append = (function(name, value, ...otherArgs) {
      this.origAppend(name, value, ...otherArgs);
      if (value instanceof Readable && !value.hasOwnProperty('fd')) {
        formData.origGetHeaders = formData.getHeaders.bind(formData);
        formData.getHeaders = (function() {
          return {
            ...this.origGetHeaders(),
            ...{ "transfer-encoding": "chunked" }
          };
        }).bind(formData);
      }
    }).bind(formData);

    list.forEach(it => {
      if (it.type === "binary") {
        const opts = { filename: path.basename(it.value.name || it.value.filename || it.value.path || `${Date.now()}.bin`) };
        if (value.mediaType || value.contentType || value.type) {
          opts.contentType = value.mediaType || value.contentType || value.type;
        }
        formData.append(it.key, it.value, opts);
      } else if (it.type === "object") {
        formData.append(it.key, it.value, { contentType: "application/json" });
      } else if (it.value != undefined) {
        formData.append(it.key, it.value);
      }
    });
    return formData;
  },
  deserialize: function(value) {
    throw new BaseError("Deserializing multipart/form-data is not supported. Value: " + value);
  },
  _getLogger: function() {
    if (!logger) {
      logger = LoggerFactory.get("UuApp.AppClient.Client");
    }
    return logger;
  }
};

module.exports = MultiPart;
