/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core-utils"), require("uu_appg01_core-logging"), require("uu_appg01_core-perflog"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core-appclient", ["module", "uu_appg01_core-utils", "uu_appg01_core-logging", "uu_appg01_core-perflog"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core-appclient"] = factory(require("module"), require("uu_appg01_core-utils"), require("uu_appg01_core-logging"), require("uu_appg01_core-perflog"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["AppClient"] = factory(root["undefined"], root["UuApp.Utils"], root["UuApp.Logging"], root["UuApp.Perflog"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/4.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/4.7.2/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  get AppClient() {
    return __webpack_require__(4);
  },

  get RemoteError() {
    return __webpack_require__(14);
  },

  get ApplicationError() {
    return __webpack_require__(13);
  },

  get SystemError() {
    return __webpack_require__(15);
  },

  get PerflogHandler() {
    return __webpack_require__(10);
  },

  get RemoteErrorHandler() {
    return __webpack_require__(12);
  },

  get SessionHandler() {
    return __webpack_require__(21);
  },

  get TransformParametersHandler() {
    return __webpack_require__(16);
  },

  get UriHandler() {
    return __webpack_require__(20);
  }

};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError;

var Helpers = __webpack_require__(6);

var HttpClient = __webpack_require__(8);

var PerflogHandler = __webpack_require__(10);

var RemoteErrorHandler = __webpack_require__(12);

var TransformParametersHandler = __webpack_require__(16);

var UriHandler = __webpack_require__(20);

var DEFAULT_INTERCEPTORS = [PerflogHandler, UriHandler, RemoteErrorHandler, TransformParametersHandler];
/**
 * Creates an instance of command client which will use specified configuration when invoking commands.
 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
 *
 * **Interceptors**
 *
 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
 * interceptors, e.g. transformParameters). Example:
 *
 *     function MyInterceptor(request, options, nextInterceptorFn) {
 *       // pre-process in any way
 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
 *       let start = new Date().getTime();
 *       return nextInterceptorFn(request, options).then(function (response) {
 *         // post-process in any way, e.g. add extra field to the response object
 *         response.timeTaken = new Date().getTime() - start;
 *         return response;
 *       }, function error(response) {
 *         // ...
 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
 *       });
 *     }
 *
 *     // usage of the interceptor
 *     let client = new UuApp.AppClient.Client({
 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *     });
 *
 * @class UuApp.AppClient.Client
 * @classdesc
 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
 * Besides communication, the client solves also other points of interest, such as authentication or
 * performance logging.
 *
 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
 * to provide access to the result of the call.
 *
 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
 *       console.log(response.data, response.status, response.headers());
 *     }, function (response) { // error
 *       console.log(response.error, response.status, response.headers());
 *     });
 *
 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
 * call or, alternatively, a client instance can be created with defaults that override the global ones.
 *
 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
 *
 * **Configuration**
 *
 * Some options are automatically configured from the environment during
 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
 * the client or in method invocations. Supported environment options:
 *
 *     {
 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
 *     }
 *
 * @param {Object} options Default options for this instance of the command client.
 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
 *   HTTP requests.
 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
 *   as "gatewayUri" which then take precedence over those from global environment.
 *
 * @example
 *    let client = new UuApp.AppClient.Client({
 *      requestTimeout: 20,
 *      headers: {
 *        "x-my-extra-header": "abcd"
 *      },
 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *    });
 *
 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
 */

var Client = /*#__PURE__*/function () {
  _createClass(Client, null, [{
    key: "get",

    /**
     * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().get(uri, options)
     *
     * @see {@link UuApp.AppClient.Client#get Client#get}
     * @method UuApp.AppClient.Client.get
     */
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(uri) {
        var dtoIn,
            options,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dtoIn = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                return _context.abrupt("return", new Client().get(uri, dtoIn, options));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function get(_x) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
     * configuration, i.e.:
     *
     *     new UuApp.AppClient.Client().post(uri, dtoIn, options)
     *
     * @see {@link UuApp.AppClient.Client#post Client#post}
     * @method UuApp.AppClient.Client.post
     */

  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(uri) {
        var dtoIn,
            options,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                dtoIn = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : null;
                return _context2.abrupt("return", new Client().post(uri, dtoIn, options));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function post(_x2) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }]);

  function Client(options) {
    _classCallCheck(this, Client);

    this._options = options || {};
    this._options.headers = Helpers.keysToLowerCase(this._options.headers);
    this._aborted = false;
  }
  /**
   * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
   * for detailed options and behaviour.
   *
   * Keep in mind that the "dtoIn" parameter is sent via URL parameter(s)
   * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
   * doesn't exceed 2048 bytes.
   *
   * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
   * @param {*} dtoIn The parameters to send in the request URL.
   * @param {Object} options Optional options for the remote call.
   * @return Promise resolving to a response object (or rejecting to a response object with error field).
   * @method UuApp.AppClient.Client#get
   * @see {@link UuApp.AppClient.Client#post Client#post}
   *
   * @example
   *    // simple call
   *    let baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
   *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
   *      let data = response.data; // contains parsed response entity
   *      console.log(response.status, response.headers(), response.data);
   *    }, function error(response) {
   *      let error = response.error; // contains parsed response error
   *      console.log(response.status, response.headers(), response.error);
   *    });
   *
   * @example
   *    // parameterizing uuUri and the call
   *    let uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
   *      workspace: "15634-34e5684da3435",
   *      useCase: "getConfig",
   *      parameters: { p1: "v1" }
   *    }).toUri();
   *    client.get(uri, null, {
   *      requestTimeout: 5,
   *      headers: {
   *        "x-my-header": "abc"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   *
   * @example
   *    // accept any response and don't parse it
   *    let workspace = "...";
   *    let guestbookId = "...";
   *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
   *      transformResponse: false,
   *      headers: {
   *        "accept": "*\/*"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   */


  _createClass(Client, [{
    key: "get",
    value: function () {
      var _get2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(uri, dtoIn, options) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this._invoke("get", uri, dtoIn, options));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function get(_x3, _x4, _x5) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Invokes remote call using HTTP POST request. Default values for settings will
     * be filled in from Client instance configuration and then from global defaults.
     *
     * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
     * to the specified "content-type" HTTP request/response header.
     * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
     * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
     * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
     * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
     *
     * **Return value**
     *
     * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * resolving / rejecting to a response object which contains following fields:
     *
     * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
     *     unless option transformResponse is false (in which case it's left as received from browser).
     * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected.
     * * {number} status - the HTTP status code.
     * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
     *   If called with no arguments, an array with all response headers is returned.
     * * {Object} config - final configuration options that were used for launching AJAX request.
     *
     * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
     *
     * **File upload**
     *
     * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
     * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
     * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
     * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
     * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
     * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
     *
     * Don't forget to **disable timeout when performing the upload** so that it doesn't get cancelled.
     *
     * **Error handling**
     *
     * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
     * rejected with response object which will contain "error" field set to an instance of one of these error types
     * (when using default interceptors):
     *
     *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
     *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
     *     several errors - in such case only first error is extracted into "error" field.
     *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
     *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
     *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
     *
     * The resulting response object contains also HTTP status code and will contain "data"
     * field set to the response entity (usually containing parsed error list).
     *
     * **Timeout**
     *
     * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
     * operation prior to executing the remote call, it's not counted towards the timeout.
     *
     * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
     * @param {(FormData|*)} dtoIn The DTO to send in the request body.
     * @param {Object} options Optional options for the remote call.
     * @param {number} options.requestTimeout The timeout for the command invocation. Default is 300.
     * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
     *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
     *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
     *   sent during this invocation, specify the header and use null as its value.
     * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
     *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
     * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
     * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
     *   as "gatewayUri" which then take precedence over those from global environment.
     * @return Promise resolving to a response object (or rejecting to a response object with error field).
     * @method UuApp.AppClient.Client#post
     *
     * @example
     *    // command call sending data
     *    let tenant = "UU-BT";
     *    let guestbookId = "123";
     *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
     *      name: "Modified guestbook",
     *      invitesLimit: 10,
     *      public: true
     *    }).then(console.log.bind(console), console.log.bind(console));
     *
     * @example
     *     // uploading file(s) - let iant 1 (explicit Content-Type header)
     *     let file = inputElement.files[0];
     *     let params = {
     *       file: file,
     *       anotherValue: "abc"
     *     }
     *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
     *       requestTimeout: 0,
     *       headers: {
     *         "content-type": "multipart/form-data"
     *       }
     *     });
     *
     *     // uploading file(s) - let iant 2 (usage of FormData)
     *     // !!! append files as the last values
     *     let formData = new FormData();
     *     formData.append("anotherValue", "abc");
     *     formData.append("file", file);
     *     let promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData, {
     *       requestTimeout: 0
     *     });
     *     promise.then(...); // process response / error
     *
     *     // aborting ongoing call
     *     elementForUploadCancel.onclick = function (e) {
     *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
     *     };
     *
     * @example
     *    // error distinguishing
     *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
     *      console.log(response.status, response.headers(), response.data);
     *    }, function error(response) {
     *      console.log(response.status, response.headers(), response.data);
     *      let error = response.error;
     *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
     *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
     *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
     *      else if (response.status == 401) console.log("Not authenticated.");
     *      else if (response.status < 500) {
     *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
     *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
     *      else console.log("Unrecognized problem.", error);
     *    });
     *
     * @example
     *    // send data in custom format
     *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
     *      transformParameters: false,
     *      headers: {
     *        "content-type": "text/x-my-super-format"
     *      }
     *    }).then(console.log.bind(console), console.log.bind(console));
     */

  }, {
    key: "post",
    value: function () {
      var _post2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(uri, dtoIn, options) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this._invoke("post", uri, dtoIn, options));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function post(_x6, _x7, _x8) {
        return _post2.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "_invoke",
    value: function () {
      var _invoke2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(method, uri, dtoIn, options) {
        var _this = this;

        var request, invocationChain;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // prepare request
                request = {
                  method: (method || "post").toLowerCase(),
                  uri: uri,
                  body: dtoIn,
                  headers: _objectSpread({}, this._options.headers, Helpers.keysToLowerCase((options || {}).headers))
                }; // build invocation chain

                invocationChain = ((options || {}).interceptors || (this._options || {}).interceptors || this.constructor.getDefaultInterceptors() || []).reduceRight(function (result, interceptorClass) {
                  return new interceptorClass(result, _this._options);
                }, new HttpClient(this._options)); // invoke request

                return _context5.abrupt("return", invocationChain.invoke(request, options));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _invoke(_x9, _x10, _x11, _x12) {
        return _invoke2.apply(this, arguments);
      }

      return _invoke;
    }()
  }], [{
    key: "getDefaultInterceptors",
    value: function getDefaultInterceptors() {
      return DEFAULT_INTERCEPTORS;
    }
  }]);

  return Client;
}();

module.exports = Client;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var makeResponse = __webpack_require__(7);

var Helpers = /*#__PURE__*/function () {
  function Helpers() {
    _classCallCheck(this, Helpers);
  }

  _createClass(Helpers, null, [{
    key: "keysToLowerCase",
    value: function keysToLowerCase(map) {
      if (!map || _typeof(map) !== "object") return null;
      var result = {};

      for (var k in map) {
        result[k.toLowerCase()] = map[k];
      }

      return result;
    }
  }, {
    key: "interceptorMakeResponse",
    value: function interceptorMakeResponse(response, request, extraArgs) {
      var rawResponse = makeResponse(response, request, extraArgs);

      if (typeof window == "undefined") {
        // Allow "flat" access to attributes of dtoOut. See test "response-wrapper.test.js" for details.
        // Downside is that it is not possible to flatly access dtoOut attributes in case they are named
        // "status" or "headers".
        // TODO This is only temporary solution for backward compatibility. In can be dropped once proxy
        // is supported by all browsers (so that new API can be used on backend and frontend for some
        // time before old response object is removed).
        return new Proxy(rawResponse, {
          get: function get(target, prop) {
            var result;

            if (prop === "unwrap") {
              result = function result() {
                return {
                  status: target.status,
                  headers: target.headers,
                  body: target.data
                };
              };
            } else if (prop === "status" || prop === "headers") {
              // TODO Do not print deprecation warning until same API is available on frontend
              // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
              result = target[prop];
            } else if (prop === "data") {
              var body = target.data;

              if (typeof body == "undefined" || body === null) {
                result = body;
              } else if (body.hasOwnProperty("data")) {
                result = new Proxy(body, {
                  get: function get(target, prop) {
                    var bodyData = target.data;

                    if (prop == "toJSON") {
                      return function () {
                        return target;
                      };
                    } else if (typeof bodyData == "undefined" || bodyData === null) {
                      return target[prop];
                    } else {
                      var _result = bodyData[prop];

                      if (typeof _result === "undefined") {
                        return target[prop];
                      }

                      if (typeof _result === "function") {
                        _result = _result.bind(bodyData);
                      }

                      return _result;
                    }
                  }
                });
              } else {
                // TODO Do not print deprecation warning until same API is available on frontend
                // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
                result = body;
              }
            } else if (prop == "toJSON") {
              result = function result() {
                return target.data;
              };
            } else {
              var _body = target.data;

              if (typeof _body != "undefined" && _body != null && typeof _body[prop] != "undefined") {
                result = _body[prop];

                if (typeof result === "function") {
                  result = result.bind(_body);
                }
              } else {
                result = target[prop];
              }
            }

            return result;
          },
          ownKeys: function ownKeys(target) {
            var body = target.data;

            if (typeof body == "undefined" || body === null) {
              return null;
            } else {
              return Object.keys(body);
            }
          },
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {
            var body = target.data;

            if (typeof body == "undefined" || body === null) {
              return null;
            } else {
              var descriptor = Object.getOwnPropertyDescriptor(body, prop);

              if (descriptor) {
                descriptor.configurable = true;
              }

              return descriptor;
            }
          },
          has: function has(target, key) {
            var body = target.data;

            if (typeof body == "undefined" || body === null) {
              return false;
            } else {
              return key in body;
            }
          }
        });
      } else {
        // TODO Proxy is not supported by IE
        return rawResponse;
      }
    }
  }]);

  return Helpers;
}();

module.exports = Helpers;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function makeResponse(xhr, error) {
  var res = {
    status: xhr ? xhr.status : 0,
    headers: function headers(aHeader) {
      if (!aHeader) return xhr ? xhr.getAllResponseHeaders() : [];
      return xhr ? xhr.getResponseHeader(aHeader) : null;
    },
    data: xhr.body != null ? xhr.body : xhr
  };
  if (xhr.filename) res.filename = xhr.filename;
  if (xhr.contentType) res.contentType = xhr.contentType;
  if (xhr.encoding) res.encoding = xhr.encoding;
  return error ? _objectSpread({}, res, error) : res;
}

module.exports = makeResponse;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(9),
    LoggerFactory = _require.LoggerFactory;

var _require2 = __webpack_require__(5),
    Config = _require2.Config,
    OptsReader = _require2.OptsReader,
    BaseError = _require2.BaseError;

var Helpers = __webpack_require__(6);

var HttpClient = /*#__PURE__*/function () {
  function HttpClient() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, HttpClient);

    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  } // function InvokeClient (cmdClient, httpClientOpts, finalRequest, finalOpts) {


  _createClass(HttpClient, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var _this = this;

        var options,
            opts,
            xhr,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                opts = new OptsReader(options, this._options, Config); // TODO Implement abortion support
                // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

                xhr = request.xhr = new XMLHttpRequest();
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var canHaveBody = request.method.match(/^(put|post)$/i);
                  var url = request.uri.toString();
                  var body;

                  if (!canHaveBody) {
                    if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
                  } else {
                    body = request.body;
                  }

                  var headers = request.headers;
                  var timeout = opts.getNumber("requestTimeout", 300);
                  if (_this._logger.isDebugLoggable()) _this._logger.debug("Invoking Ajax request: " + JSON.stringify({
                    method: request.method,
                    url: url,
                    body: body,
                    requestTimeout: timeout,
                    headers: headers
                  }));
                  xhr.open(request.method, url, true);
                  if (timeout > 0) xhr.timeout = timeout * 1000;
                  xhr.withCredentials = true;

                  for (var k in headers) {
                    var v = headers[k];

                    if (k && v != null) {
                      // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
                      // it with proper boundary and server won't be able to parse the body
                      if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
                      xhr.setRequestHeader(k.replace(/(^|-)./g, function (m) {
                        return m.toUpperCase();
                      }), v + "");
                    }
                  }

                  xhr.ontimeout = function (e) {
                    // TimeoutError
                    _this._logger.error("Request timed out: " + JSON.stringify({
                      url: url
                    }), e);

                    reject(Helpers.interceptorMakeResponse(xhr, {
                      error: new BaseError("Request timed out - " + url, e)
                    }));
                  };

                  xhr.onload = function (e) {
                    // status 200 - 5xx
                    var formatted = _this._formatResponse(xhr);

                    if (_this._logger.isDebugLoggable()) _this._logger.debug("Received response: " + JSON.stringify({
                      url: url,
                      status: xhr.status,
                      data: formatted.response
                    }));
                    resolve(Helpers.interceptorMakeResponse(formatted));
                  };

                  xhr.onabort = function (e) {
                    // user / developer abort; AbortError
                    _this._logger.warn("Request has been aborted: " + JSON.stringify({
                      url: url
                    }), e);

                    reject(Helpers.interceptorMakeResponse(xhr, {
                      error: new BaseError("Request has been aborted - " + url, e)
                    }));
                  };

                  xhr.onerror = function (e) {
                    // network error; NetworkError
                    var responseData = opts.getBoolean("transformResponse") === false ? new Uint8Array(xhr.response) : xhr.response;

                    _this._logger.error("Request ended with network error: " + JSON.stringify({
                      url: url
                    }), e);

                    reject(Helpers.interceptorMakeResponse(xhr, {
                      error: new BaseError("Network error - " + url, e),
                      data: responseData
                    }));
                  };

                  xhr.onreadystatechange = function () {
                    if (!(xhr.readyState === 2)) return;
                    var transformResponse = opts.getBoolean("transformResponse", true) === true;

                    if (!transformResponse) {
                      xhr.responseType = "arraybuffer";
                      return;
                    }

                    _this._autodetectBinaryData(xhr);
                  };

                  xhr.send(body);
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }, {
    key: "_formatResponse",
    value: function _formatResponse(xhr) {
      if (xhr.responseType === "arraybuffer") {
        xhr.body = new Uint8Array(xhr.response);
      } else {
        xhr.body = xhr.response;
      }

      return xhr;
    }
  }, {
    key: "_autodetectBinaryData",
    value: function _autodetectBinaryData(xhr) {
      var cDisp;

      try {
        cDisp = xhr.getResponseHeader("Content-Disposition");
      } catch (e) {// do nothing
      }

      if (!cDisp) return;
      xhr.responseType = "arraybuffer";
      xhr.filename = _findMatch(cDisp);
      var cType = xhr.getResponseHeader("Content-Type");

      if (cType) {
        var cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
        xhr.contentType = cTypeItems[1] || null;
        xhr.encoding = cTypeItems[2] || null;
      }

      function _findMatch(cDisp) {
        var regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
        var match;
        var results = [];

        while ((match = regex.exec(cDisp)) != null) {
          results = results.concat(match.slice(1).filter(function (m) {
            return m;
          }));
        }

        var last = results[results.length - 1];
        return last ? decodeURIComponent(last) : null;
      }
    }
  }]);

  return HttpClient;
}();

module.exports = HttpClient;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9__;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(11),
    Perflog = _require.Perflog;
/**
 * Interceptor for performance logging.
 */


var PerfLogHandler = /*#__PURE__*/function () {
  function PerfLogHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, PerfLogHandler);

    this._next = next;
  }

  _createClass(PerfLogHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var options,
            next,
            promise,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                next = this._next;
                Perflog.measureSection("UU_APP_CLIENT_REQUEST", function (section) {
                  request.headers["x-request-id"] = section.getId().toString();
                  var uri = request.uri.toString().replace(/access_token=[^&]+/, "access_token=hidden");
                  section.setAttribute("uri", uri);
                  promise = next.invoke(request, options);
                });
                return _context.abrupt("return", promise);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }]);

  return PerfLogHandler;
}();

module.exports = PerfLogHandler;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__11__;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ApplicationError = __webpack_require__(13);

var SystemError = __webpack_require__(15);
/**
 * Interceptor for extracting error information from response.
 */


var RemoteErrorHandler = /*#__PURE__*/function () {
  function RemoteErrorHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, RemoteErrorHandler);

    this._next = next;
  }

  _createClass(RemoteErrorHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var options,
            response,
            errorData,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                _context.next = 3;
                return this._next.invoke(request, options);

              case 3:
                response = _context.sent;

                if (!(response.status >= 400)) {
                  _context.next = 11;
                  break;
                }

                errorData = response.data || {};

                if (!(response.status < 500)) {
                  _context.next = 10;
                  break;
                }

                throw new ApplicationError(errorData, response);

              case 10:
                throw new SystemError(errorData, response);

              case 11:
                return _context.abrupt("return", response);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }]);

  return RemoteErrorHandler;
}();

module.exports = RemoteErrorHandler;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var RemoteError = __webpack_require__(14);

var ApplicationError = /*#__PURE__*/function (_RemoteError) {
  _inherits(ApplicationError, _RemoteError);

  var _super = _createSuper(ApplicationError);

  function ApplicationError() {
    var _this;

    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, ApplicationError);

    _this = _super.call(this, message, response);

    if (!_this.status) {
      _this.status = 400;
    }

    return _this;
  }

  return ApplicationError;
}(RemoteError);

module.exports = ApplicationError;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError;

var RemoteError = /*#__PURE__*/function (_BaseError) {
  _inherits(RemoteError, _BaseError);

  var _super = _createSuper(RemoteError);

  function RemoteError() {
    var _this;

    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, RemoteError);

    if (typeof message === "string") {
      _this = _super.call(this, message);
      _this.paramMap = {};
      _this.dtoOut = {};
    } else if (message.uuAppErrorMap) {
      var keys = Object.keys(message.uuAppErrorMap);

      if (keys.length === 0) {
        // Error in response format (serialized error is missing)
        _this = _super.call(this, JSON.stringify(message));
        _this.paramMap = {};
        _this.dtoOut = {};
      } else {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            var error = message.uuAppErrorMap[key];

            if (error.type === "error") {
              _this = _super.call(this, error.message);
              _this.code = key;

              if (error.id) {
                _this.id = error.id;
              }

              _this.paramMap = error.paramMap;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        _this.dtoOut = message;
      }
    } else {
      _this = _super.call(this, JSON.stringify(message));
      _this.paramMap = {};
      _this.dtoOut = {};
    }

    if (response) {
      _this.response = response;
      _this.status = response.status;
    }

    return _possibleConstructorReturn(_this);
  }

  return RemoteError;
}(BaseError);

module.exports = RemoteError;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var RemoteError = __webpack_require__(14);

var SystemError = /*#__PURE__*/function (_RemoteError) {
  _inherits(SystemError, _RemoteError);

  var _super = _createSuper(SystemError);

  function SystemError() {
    var _this;

    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SystemError);

    _this = _super.call(this, message, response);

    if (!_this.status) {
      _this.status = 500;
    }

    return _this;
  }

  return SystemError;
}(RemoteError);

module.exports = SystemError;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ContentTransformers = __webpack_require__(17);

var _require = __webpack_require__(5),
    Config = _require.Config,
    OptsReader = _require.OptsReader,
    BaseError = _require.BaseError;
/**
 * Interceptor for transforming request parameters / response entity according to the Content Type.
 * Recognized options:
 *
 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
 */


var TransformParametersHandler = /*#__PURE__*/function () {
  function TransformParametersHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, TransformParametersHandler);

    this._next = next;
    this._options = options;
  }

  _createClass(TransformParametersHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var options,
            opts,
            paramsInBody,
            contentTransformers,
            contentType,
            isMultipartPreferred,
            contentHandler,
            response,
            respContentDisposition,
            respContentType,
            _contentHandler,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                opts = new OptsReader(options, this._options, Config); // add default Content-Type & Accept headers

                paramsInBody = request.method.match(/^(put|post)$/i);
                contentTransformers = ContentTransformers.contentTransformers || {};
                contentType = paramsInBody ? request.headers["content-type"] : null;

                if (!("content-type" in request.headers)) {
                  if (paramsInBody) {
                    isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || _typeof(request.body) == "object" && Object.keys(request.body).some(function (it) {
                      return request.body[it] instanceof Blob;
                    }));
                    contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
                    request.headers["content-type"] = contentType;
                  } else {
                    contentType = "application/x-www-form-urlencoded";
                  }
                }

                if (!("accept" in request.headers)) request.headers["accept"] = "application/json"; // wrap request data into "dto" parameter if requested to do so

                if (opts.getBoolean("transformParameters") !== false && !paramsInBody && request.body != null && opts.getBoolean("wrapQuery") && contentType === "application/x-www-form-urlencoded") {
                  request.body = {
                    dto: JSON.stringify(request.body)
                  };
                } // transform request data


                if (!(opts.getBoolean("transformParameters") !== false && request.body != null)) {
                  _context.next = 17;
                  break;
                }

                contentHandler = contentTransformers[this._getMimeMainType(contentType)];
                _context.prev = 10;
                if (contentHandler) request.body = contentHandler.serialize(request.body);
                _context.next = 17;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](10);
                throw new BaseError("Error while serializing data.", _context.t0);

              case 17:
                _context.next = 19;
                return this._next.invoke(request, options);

              case 19:
                response = _context.sent;
                respContentDisposition = response.headers("content-disposition");

                if (!(opts.getBoolean("transformResponse") !== false && !respContentDisposition)) {
                  _context.next = 31;
                  break;
                }

                respContentType = response.headers("content-type");
                _contentHandler = contentTransformers[this._getMimeMainType(respContentType)];
                _context.prev = 24;
                if (response.status === 204) response.data = null;else if (_contentHandler) response.data = _contentHandler.deserialize(response.data);
                _context.next = 31;
                break;

              case 28:
                _context.prev = 28;
                _context.t1 = _context["catch"](24);
                throw new BaseError("Error while deserializing response data.", _context.t1);

              case 31:
                return _context.abrupt("return", response);

              case 32:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 14], [24, 28]]);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }, {
    key: "_getMimeMainType",
    value: function _getMimeMainType(mimeType) {
      return (mimeType || "").replace(/[+;].*/, "").trim();
    }
  }]);

  return TransformParametersHandler;
}();

module.exports = TransformParametersHandler;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(9),
    LoggerFactory = _require.LoggerFactory;

var MultiPart = __webpack_require__(18);

var dotNotate = __webpack_require__(19);

var logger;

var ContentTransformers = /*#__PURE__*/function () {
  function ContentTransformers() {
    _classCallCheck(this, ContentTransformers);
  }

  _createClass(ContentTransformers, null, [{
    key: "_getLogger",
    value: function _getLogger() {
      if (!logger) {
        logger = LoggerFactory.get("UuApp.AppClient.Client");
      }

      return logger;
    }
  }, {
    key: "_stringify",
    value: function _stringify(key, value, result, topLevel) {
      if (Array.isArray(value)) {
        value.forEach(function (item, i) {
          return ContentTransformers._stringify("".concat(key, "[").concat(i, "]"), item, result, false);
        });
      } else if (value && _typeof(value) === "object") {
        for (var k in value) {
          ContentTransformers._stringify("".concat(key).concat(topLevel ? "" : ".").concat(k), value[k], result, false);
        }
      } else {
        result.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
      }
    }
  }, {
    key: "contentTransformers",

    /**
     * Transformers which serialize / deserialize content that is sent to / received from
     * server using specific MIME type.
     */
    get: function get() {
      return Object.freeze({
        "application/json": ContentTransformers.Json,
        // "application/json+extended": Json,
        //"application/x-msgpack": MessagePack,
        //"application/msgpack": MessagePack,
        "application/x-www-form-urlencoded": ContentTransformers.Form,
        "multipart/form-data": ContentTransformers.MultiPart
      });
    }
  }, {
    key: "Json",
    get: function get() {
      return {
        serialize: function serialize(value) {
          return JSON.stringify(value);
        },
        deserialize: function deserialize(value) {
          return value ? JSON.parse(value) : null;
        }
      };
    }
  }, {
    key: "Form",
    get: function get() {
      return {
        serialize: function serialize(value) {
          if (value == null) return value;

          if (_typeof(value) !== "object") {
            ContentTransformers._getLogger().warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", {
              value: value
            });

            return value;
          }

          var result = dotNotate(value);
          return result.map(function (_ref) {
            var key = _ref.key,
                value = _ref.value;
            return value == null ? "" : "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
          }).join("&");
        },
        deserialize: function deserialize(value) {
          if (value == null) return value;

          if (typeof value !== "string") {
            ContentTransformers._getLogger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", {
              value: value
            });

            return value;
          }

          var pairs = value.replace(/\+/g, " ").split("&");
          var result = {};

          for (var i = 0; i < pairs.length; ++i) {
            var pair = pairs[i];
            pair.replace(/^([^=]*)=?(.*)$/, function (m, g1, g2) {
              var dg1 = decodeURIComponent(g1);
              var dg2 = decodeURIComponent(g2);

              if (result.hasOwnProperty(dg1)) {
                if (!Array.isArray(result[dg1])) {
                  result[dg1] = [result[dg1]];
                }

                result[dg1].push(dg2);
              } else {
                result[dg1] = dg2;
              }
            });
          }

          return result;
        }
      };
    }
  }, {
    key: "MultiPart",
    get: function get() {
      return MultiPart;
    }
  }]);

  return ContentTransformers;
}();

module.exports = ContentTransformers;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError;

var _require2 = __webpack_require__(9),
    LoggerFactory = _require2.LoggerFactory;

var dotNotate = __webpack_require__(19);

var logger;
var MultiPart = {
  serialize: function serialize(value) {
    if (!value) return value;

    if (_typeof(value) !== "object") {
      this._getLogger().warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", {
        value: value
      });

      return value;
    }

    if (value instanceof FormData && typeof value.entries !== "function") return value; // FormData without support for iterating over its entries

    if (value instanceof Blob) value = {
      file: value
    }; // make a list and reorder values so that the file instances are at the end of the list

    var data = {};

    if (value instanceof FormData) {
      var _iterator = _createForOfIteratorHelper(value.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pair = _step.value;
          data[pair[0]] = pair[1];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      data = value;
    }

    var list = [];
    var hasBinary;

    for (var k in data) {
      var item = data[k];

      if (item instanceof Blob) {
        if (hasBinary) {
          this._getLogger().warn("Too many binary fields. Only single binary field per multipart request is supported.");
        }

        hasBinary = true;
      } else if (_typeof(item) === "object") {
        try {
          list = list.concat(dotNotate(item, k));
          continue;
        } catch (e) {
          throw new BaseError("Serialization of key: ".concat(k, " into FormData failed.") + "Try serializing the nested object beforehand.", e);
        }
      }

      list.push({
        key: k,
        value: item
      });
    }

    var max = list.length;
    var idx = 0;
    list.sort(function (a, b) {
      // stable sort
      var result = (a.value instanceof Blob ? idx + max : idx) - (b.value instanceof Blob ? idx + max : idx);
      idx++;
      return result;
    }); // fill values into FormData

    var formData = new FormData();
    list.forEach(function (it) {
      if (it.value instanceof Blob) {
        formData.append(it.key, it.value, it.value.name || "".concat(Date.now(), ".bin"));
      } else {
        formData.append(it.key, it.value);
      }
    });
    return formData;
  },
  deserialize: function deserialize(value) {
    throw new BaseError("Deserializing multipart/form-data is not supported. Value: " + value);
  },
  _getLogger: function _getLogger() {
    if (!logger) {
      logger = LoggerFactory.get("UuApp.AppClient.Client");
    }

    return logger;
  }
};
module.exports = MultiPart;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(5),
    BaseError = _require.BaseError;

module.exports = function dotNotate(object) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var result = [];
  recurse(parent, object, result, parent ? 1 : 0);
  return result;
};

function recurse(key, value, result, level) {
  if (level > 5) throw new BaseError("Nesting level too deep. Possible circular reference.");

  if (Array.isArray(value)) {
    value.forEach(function (item, i) {
      return recurse("".concat(key, "[").concat(i, "]"), item, result, level + 1);
    });
  } else if (value instanceof Date) {
    result.push({
      key: key,
      value: value.toISOString()
    });
  } else if (value && _typeof(value) === "object") {
    for (var k in value) {
      recurse("".concat(key).concat(level ? "." : "").concat(k), value[k], result, level + 1);
    }
  } else {
    result.push({
      key: key,
      value: value
    });
  }
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(5),
    Config = _require.Config,
    OptsReader = _require.OptsReader;
/**
 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
 */


var UriHandler = /*#__PURE__*/function () {
  function UriHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, UriHandler);

    this._next = next;
    this._options = options;
  }

  _createClass(UriHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var options,
            uri,
            ucUri,
            opts,
            baseUri,
            gatewayUri,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                uri = "";
                ucUri = (request.uri || "").toString();

                if (!ucUri.match(/^https?:/i)) {
                  opts = new OptsReader(options, this._options);
                  baseUri = opts.getString("baseUri");

                  if (!baseUri || !baseUri.match(/^https?:/i)) {
                    opts = new OptsReader(options, this._options, Config);
                    gatewayUri = opts.getString("gatewayUri", "https://uuappg01.plus4u.net");
                    uri += "".concat(gatewayUri.replace(/\/$/, ""), "/");
                  }

                  if (baseUri) {
                    uri += "".concat(baseUri.replace(/^\/|\/$/g, ""), "/");
                  }

                  uri += ucUri.replace(/^\//, "");
                } else {
                  uri += ucUri;
                }

                request.uri = uri;
                return _context.abrupt("return", this._next.invoke(request, options));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }]);

  return UriHandler;
}();

module.exports = UriHandler;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Interceptor for Client which authenticates command calls by using token from session object.
 *
 * Interceptor is skipped if there's request header "authorization" set for the command call, even
 * if the header value is null.
 */

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SessionHandler = /*#__PURE__*/function () {
  function SessionHandler(next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SessionHandler);

    this._next = next;
    this._options = options || {};
  }

  _createClass(SessionHandler, [{
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
        var options,
            hasCustomAuthn,
            opts,
            session,
            scope,
            callToken,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                hasCustomAuthn = "authorization" in request.headers;

                if (!hasCustomAuthn) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", this._next.invoke(request, options));

              case 4:
                opts = Object.assign(this._options, options);
                session = opts.session;

                if (!session) {
                  _context.next = 19;
                  break;
                }

                scope = null;

                if (!(typeof session.getCallTokenScope === "function")) {
                  _context.next = 14;
                  break;
                }

                _context.next = 11;
                return session.getCallTokenScope(request.uri, opts);

              case 11:
                scope = _context.sent;
                _context.next = 15;
                break;

              case 14:
                scope = request.uri.toString().split("?")[0];

              case 15:
                _context.next = 17;
                return session.getCallToken(scope, opts);

              case 17:
                callToken = _context.sent;

                if (callToken) {
                  request.headers["authorization"] = callToken;
                }

              case 19:
                return _context.abrupt("return", this._next.invoke(request, options));

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function invoke(_x) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }]);

  return SessionHandler;
}();

module.exports = SessionHandler;

/***/ })
/******/ ]);
});