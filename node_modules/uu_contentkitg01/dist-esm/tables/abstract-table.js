import * as UU5 from "uu5g04";
import "uu5g04-bricks";

import Tools from "../core/tools.js";

import Lsi from "../config/lsi.js";
import "./abstract-table.less";

import Cfg from "../core/_config.js";

const AbstractTable = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ScreenSizeMixin, UU5.Common.NestingLevelMixin],

  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.tag("Tables.AbstractTable"),
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "box"),
    classNames: {
      main: `${Cfg.CSS} ${Cfg.css("abstract-table")}`,
      xs: Cfg.css("abstract-table-xs"),
      fixed: Cfg.css("abstract-table-fixed")
    },
    defaults: {
      minHeight: "height:47.2px;"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(UU5.PropTypes.arrayOf(UU5.PropTypes.any)),
    transpose: UU5.PropTypes.bool,
    responsive: UU5.PropTypes.bool,
    rowHeader: UU5.PropTypes.bool,
    colHeader: UU5.PropTypes.bool,
    colWidth: UU5.PropTypes.arrayOf(UU5.PropTypes.number),
    tableHeaders: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    sorted: UU5.PropTypes.bool,
    colTemplate: UU5.PropTypes.object,
    showEmpty: UU5.PropTypes.bool,
    colHeaderTable: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      transpose: false,
      responsive: true,
      rowHeader: false,
      colHeader: false,
      sorted: false,
      tableHeaders: null,
      colTemplate: null,
      showEmpty: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _sortData(data) {
    const newData = [...data];
    return newData.sort();
  },

  _getMaxCol(data) {
    let max = 0;
    for (let i = 0; i < data.length; i++) {
      if (data[i].length > max) {
        max = data[i].length;
      }
    }
    return max;
  },

  _fillEmptyData(data) {
    if (data && (Tools.assertType(data, Array) && data.length > 1)) {
      return data;
    }
    let col = 1;
    let row = 1;
    if (this.props.tableHeaders) {
      if (this.props.rowHeader || (!this.props.colHeader || (this.props.colHeader && this.props.transpose))) {
        col = this.props.tableHeaders.length;
      } else if (this.props.colHeader) {
        row = this.props.tableHeaders.length;
      }
    }
    let empty = [];
    !data && (data = []);
    data.length === 1 &&
      (!data[0] || data[0].length === 0 || (data[0].length === 1 && data[0][0] === "")) &&
      (data = []);

    for (let i = 0; i < col; i++) empty.push("");
    for (let i = data.length; i < row; i++) {
      data.push(Object.assign([], empty));
    }
    return data;
  },

  _isEmpty(data) {
    if (!data) return true;
    let empty = true;
    if (data.length === 1 && Tools.assertType(data[0], Array)) {
      for (let i = 0; i < data[0].length; i++) {
        if (data[0][i]) {
          empty = false;
          break;
        }
      }
    } else {
      for (let i = 0; i < data.length; i++) {
        if (Tools.assertType(data[i], Array) && data[i].length !== 0) {
          empty = false;
          break;
        }
      }
    }

    return empty;
  },

  _fillMissingData(data) {
    if (this.props.transpose && this.props.tableHeaders && this.props.colHeader) {
      !data[0] && (data[0] = []);
      if (data[0].length < this.props.tableHeaders.length) {
        for (let i = data[0].length; i < this.props.tableHeaders.length; i++) {
          data[0].push("");
        }
      }
    }
    return data;
  },

  _getChild() {
    let data = this.props.data ? [...this.props.data] : [];

    if (!data || this._isEmpty(data)) {
      if (this.props.showEmpty) {
        data = this._fillEmptyData(data);
      } else {
        return (
          <UU5.Bricks.Text {...this.getMainPropsToPass()}>
            {this.getLsiItem(Lsi.LSI_LABEL_TABLE_NO_DATA)}
          </UU5.Bricks.Text>
        );
      }
    }
    data = this._fillMissingData(data);
    if (!Tools.assertType(data, Array)) {
      return (
        <UU5.Bricks.Text {...this.getMainPropsToPass()}>{this.getLsiItem(Lsi.LSI_LABEL_INVALID_DATA)}</UU5.Bricks.Text>
      );
    } else {
      if (this.props.sorted) {
        data = this._sortData(data);
      }
      if (this.props.transpose) data = this._getTransposeData(data);
      const maxRow = data.length;
      const maxCol = this._getMaxCol(data);
      if ((this.isXs() || this.isS()) && this.props.responsive) {
        return this._getSection(data, maxCol, maxRow);
      } else {
        return this._getTable(data, maxCol);
      }
    }
  },

  _getCorrectHeaders(bigSize, index) {
    const tableHeaders = this.props.tableHeaders || [];
    let correct = [];
    if (index || index === 0) {
      if (tableHeaders[index] && Tools.assertType(tableHeaders[index], Array)) {
        if (bigSize) {
          correct.push(tableHeaders[index][0]);
        } else {
          correct.push(tableHeaders[index][1]);
        }
      } else {
        correct.push(tableHeaders[index]);
      }
    } else {
      for (let param of tableHeaders) {
        if (Tools.assertType(param, Array)) {
          if (bigSize) {
            correct.push(param[0]);
          } else {
            correct.push(param[1]);
          }
          continue;
        }
        correct.push(param);
      }
    }
    return correct;
  },

  _getTransposeData(data) {
    let transpArray = [];
    let maxLength = 0;
    data.map((row, i) => {
      if (Tools.assertType(row, Array)) {
        row.map((col, j) => {
          if (j >= maxLength) {
            maxLength++;
            transpArray.push([]);
          }
          transpArray[j][i] = col;
        });
      }
    });
    return transpArray;
  },

  _getSection(data, maxCol, maxRow) {
    if (this.props.rowHeader === true || (this.props.colHeader === false && this.props.tableHeaders)) {
      return this._getXsRowHeader(data, maxCol, maxRow);
    } else if (this.props.colHeader === true) {
      return this._getXsColHeader(data, maxCol, maxRow);
    } else {
      return this._getTable(data, maxCol);
    }
  },

  _getXsRowHeader(data, maxCol, maxRow) {
    let xsRow = [];
    let table = [];
    let row;
    const tableHeaders = this.props.tableHeaders && this.props.tableHeaders;
    for (let i = tableHeaders ? 0 : 1; i < maxRow; i++) {
      xsRow = [];
      for (let j = 0; j < maxCol; j++) {
        if (this.props.colHeader && j === 0) {
          row = <UU5.Bricks.Table.Th content={this._getContent(j)((data[i] && data[i][j]) || "", j)} />;
        } else {
          row = <UU5.Bricks.Table.Td content={this._getContent(j)((data[i] && data[i][j]) || "", j)} />;
        }
        xsRow.push(
          <UU5.Bricks.Table.Tr key={j}>
            {
              <UU5.Bricks.Table.Th
                content={
                  this.props.tableHeaders
                    ? this._getCorrectHeaders(false, j)
                    : this._getContent(j)((data[0] && data[0][j]) || "", j)
                }
              />
            }
            {row}
          </UU5.Bricks.Table.Tr>
        );
      }
      table.push(<UU5.Bricks.Table.TBody key={i}>{xsRow}</UU5.Bricks.Table.TBody>);
    }

    return (
      <div {...this.getMainAttrs()}>
        <UU5.Bricks.Table className={this.getClassName("xs")} responsive={true}>
          {table}
        </UU5.Bricks.Table>
      </div>
    );
  },
  _getXsColHeader(data, maxCol, maxRow) {
    let xsRow = [];
    let table = [];
    const tableHeaders = this.props.tableHeaders && this.props.tableHeaders;

    table = [];
    for (let i = tableHeaders ? 0 : 1; i < maxCol; i++) {
      xsRow = [];
      for (let j = 0; j < maxRow; j++) {
        xsRow.push(
          <UU5.Bricks.Table.Tr key={j}>
            <UU5.Bricks.Table.Th
              content={
                tableHeaders
                  ? this._getCorrectHeaders(false, j)
                  : this._getContent(j)((data && data[j] && data[j][0]) || "", j)
              }
            />
            <UU5.Bricks.Table.Td content={this._getContent(j)((data && data[j] && data[j][i]) || "", j)} />
          </UU5.Bricks.Table.Tr>
        );
      }
      table.push(<UU5.Bricks.Table.TBody key={i}>{xsRow}</UU5.Bricks.Table.TBody>);
    }
    return (
      <div {...this.getMainAttrs()}>
        <UU5.Bricks.Table className={this.getClassName("xs")} responsive={true}>
          {table}
        </UU5.Bricks.Table>
      </div>
    );
  },

  _getTable(data, maxCol) {
    const { rowHeader, colHeader, tableHeaders } = this.props;
    let className = null;
    return (
      <UU5.Bricks.Div {...this.getMainPropsToPass()}>
        <UU5.Bricks.Table className={className} content={null} header={null} footer={null}>
          <UU5.Bricks.Table.TBody>
            {tableHeaders && (!colHeader || rowHeader) && (
              <UU5.Bricks.Table.Tr
                key="header"
                content={this._getRowHeader(this._getCorrectHeaders(true), maxCol, null)}
              />
            )}
            {data.map((row, i) => {
              let content = "";
              if (row.length !== 0) {
                if ((tableHeaders && !colHeader) || (!rowHeader && !colHeader) || (rowHeader && !colHeader && i > 0)) {
                  content = this._getDefaultRow(row, maxCol);
                } else if (!tableHeaders && rowHeader && i === 0) {
                  content = this._getRowHeader(row, maxCol);
                } else if (
                  (colHeader && rowHeader && i > 0) ||
                  (colHeader && !rowHeader) ||
                  (colHeader && rowHeader && tableHeaders)
                ) {
                  content = this._getColHeader(row, maxCol, i);
                }
              }
              return <UU5.Bricks.Table.Tr key={i} content={content} />;
            })}
          </UU5.Bricks.Table.TBody>
        </UU5.Bricks.Table>
      </UU5.Bricks.Div>
    );
  },

  _removeUu5String(value) {
    if (!value) {
      return "";
    }
    if (!value.replace) {
      return value;
    }
    return value.replace(/^<uu5string(\/>| \/>)/, "");
  },

  _capitalizeFirstLetter(string) {
    if (!string) return "";
    let name = string.split(" ")[0];
    return name.charAt(0).toUpperCase() + name.slice(1);
  },

  _getContent(index) {
    const colTemplate = this.props.colTemplate;
    if (colTemplate && colTemplate[index + 1]) {
      const template = colTemplate[index + 1];
      if (template.func) return this._customInput;
      const name = template.name || colTemplate[index + 1];

      if (this[`_get${this._capitalizeFirstLetter(name)}`]) {
        return this[`_get${this._capitalizeFirstLetter(name)}`];
      } else return this._getText;
    }
    return this._getText;
  },

  _customInput(cell, index) {
    const out = this.props.colTemplate[index + 1].func(cell, {
      ...this.props.colTemplate[index + 1],
      bookUri: this.props.colTemplate.bookUri
    });
    return out || this._getPlainText(cell, index);
  },

  _getText(cell) {
    return <UU5.Bricks.Span content={cell} />;
  },

  _getPlainText(cell) {
    return this._getText(cell);
  },

  _getCode(cell) {
    return this._removeUu5String(cell) && <UU5.Bricks.Code content={cell} />;
  },

  _getList(cell, index) {
    let list = [];
    const template = this.props.colTemplate[index + 1];

    if (template.list) {
      return template.list(cell);
    } else {
      if (!Tools.assertType(cell, Array)) return this._getText(cell);
      for (let i = 0; i < cell.length; i++) {
        list.push(<UU5.Bricks.Li key={i} content={cell[i]} />);
      }
      return <UU5.Bricks.Ul content={list} />;
    }
  },

  _getDefaultRow(row, maxCol) {
    let tableRow = [];
    const height = this.getDefault("minHeight");
    for (let i = 0; i < maxCol; i++) {
      const content = this._getContent(i)((row && row[i]) || "", i);
      const width = this.props.colWidth && this.props.colWidth[i] ? `width:${this.props.colWidth[i]}px;` : null;
      tableRow.push(<UU5.Bricks.Table.Td key={i} content={content} style={width ? height + width : height} />);
    }
    return tableRow;
  },
  _getRowHeader(row, maxCol, rowIndex) {
    let tableRow = [];
    const height = this.getDefault("minHeight");
    for (let i = 0; i < maxCol; i++) {
      let content;
      const width = this.props.colWidth && this.props.colWidth[i] ? `width:${this.props.colWidth[i]}px;` : null;
      if (rowIndex === null) content = (row && row[i]) || "";
      else content = this._getContent(0)((row && row[i]) || "", i);
      tableRow.push(<UU5.Bricks.Table.Th key={i} content={content} style={width ? height + width : height} />);
    }
    return tableRow;
  },
  _getColHeader(row, maxCol, rowIndex) {
    let tableRow = [];
    const height = this.getDefault("minHeight");
    if (this.props.tableHeaders && !this.props.rowHeader) {
      const width = this.props.colWidth && this.props.colWidth[0] ? `width:${this.props.colWidth[0]}px;` : null;
      tableRow.push(
        <UU5.Bricks.Table.Th
          key="header"
          content={this._getCorrectHeaders(true, rowIndex)}
          style={width ? height + width : height}
        />
      );
    }
    for (let i = 0; i < maxCol; i++) {
      let index = this.props.colHeaderTable ? rowIndex : i;
      const width =
        this.props.colWidth && this.props.colWidth[this.props.tableHeaders ? i + 1 : i]
          ? `width:${this.props.colWidth[this.props.tableHeaders ? i + 1 : i]}px;`
          : null;
      if (i === 0 && tableRow.length === 0) {
        tableRow.push(
          <UU5.Bricks.Table.Th
            key={i}
            content={this._getContent(index)(row && row[i], index)}
            style={width ? height + width : height}
          />
        );
      } else {
        tableRow.push(
          <UU5.Bricks.Table.Td
            key={i}
            content={this._getContent(index)(row && row[i], index)}
            style={width ? height + width : height}
          />
        );
      }
    }
    return tableRow;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this.getNestingLevel() ? this._getChild() : null;
  }
  //@@viewOff:render
});

export default AbstractTable;
