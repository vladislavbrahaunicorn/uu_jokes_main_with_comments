//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../core/_config.js";

import Tools from "../core/tools.js";
import UndoManager from "../tables-editable/undo-manager.js";
import Row from "./abstract-table-editable-row.js";

import "./abstract-table-editable.less";
import Input from "./input.js";
//@@viewOff:imports

const TBODY_ALLOW_TAGS = [Row.tagName]; // single array instance to prevent re-renders

const TableEditable = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [
    UU5.Common.BaseMixin,
    UU5.Common.ScreenSizeMixin,
    UU5.Common.NestingLevelMixin,
    UU5.Forms.FormMixin,
    UU5.Common.PureRenderMixin
  ],

  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.tag("TablesEditable.AbstractTableEditable"),
    nestingLevelList: UU5.Environment.getNestingLevelList("bigBoxCollection", "box"),
    classNames: {
      main: `${Cfg.CSS} ${Cfg.css("abstract-table")}`,
      editable: Cfg.css("abstract-table-editable"),
      xs: Cfg.css("abstract-table-xs"),
      contextItemLabel: Cfg.css("abstract-table-editable-context-item-label"),
      shortcut: Cfg.css("abstract-table-editable-context-item-label-shortcut")
      // fixed: Cfg.CSS + "-table-editable-fixed",
      // resize: Cfg.CSS + "-table-editable-resize"
    },
    defaults: {
      tablePlaceholder: "",
      shortcutsRow: {
        removeRow: " Alt + F12",
        addRowBefore: " F12",
        addRowAfter: " Ctrl + F12"
      },
      shortcutsCol: {
        removeCol: " Alt + F11",
        addColBefore: " F11",
        addColAfter: " Ctrl + F11"
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(UU5.PropTypes.arrayOf(UU5.PropTypes.any)),
    transpose: UU5.PropTypes.bool,
    responsive: UU5.PropTypes.bool,
    rowHeader: UU5.PropTypes.bool,
    colHeader: UU5.PropTypes.bool,
    colWidth: UU5.PropTypes.arrayOf(UU5.PropTypes.number),
    tableHeaders: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    colTemplate: UU5.PropTypes.object,
    // colTemplate: PropTypes.objectOf([PropTypes.objectOf([PropTypes.oneOf(["text", "select", "link", "icon", "static", "list", "short", "plainText"])])]),
    // selectLists: PropTypes.arrayOf([PropTypes.arrayOf([PropTypes.string])]),
    modifyRow: UU5.PropTypes.bool,
    modifyCol: UU5.PropTypes.bool,
    // iconPrefix: PropTypes.string,
    returnEmpty: UU5.PropTypes.bool,
    customMenu: UU5.PropTypes.arrayOf(UU5.PropTypes.object),
    changeWidth: UU5.PropTypes.bool,
    dynamicColWidth: UU5.PropTypes.bool,
    colHeaderTable: UU5.PropTypes.bool,
    controlled: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      transpose: false,
      responsive: true,
      rowHeader: false,
      colHeader: false,
      tableHeaders: null,
      colTemplate: null,
      modifyRow: false,
      modifyCol: false,
      // iconPrefix: null,
      returnEmpty: false,
      changeWidth: false,
      colWidth: null,
      dynamicColWidth: false,
      controlled: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._modalRef = UU5.Common.Reference.create();
    let tableColWidth;
    if (this.props.dynamicColWidth) {
      tableColWidth = [];
    }
    return {
      data: this._prepareData(Tools.deepArrayCopy(this.props.data), true),
      modal: false,
      colWidth: this.props.colWidth,
      tableColWidth: tableColWidth
    };
  },

  componentWillReceiveProps(nextProps) {
    let out = {};
    this.setState(prevState => {
      if (this.props.controlled && prevState.data !== nextProps.data) {
        if (!this._isEmpty(nextProps.data) && !this._isEmpty(prevState.data)) {
          out.data = nextProps.data;
        }
      }

      if (this.props.transpose !== nextProps.transpose) {
        const data = this._getTransposeData(out.data || prevState.data);
        this._maxCol = this._getMaxCol(data);

        out.data = data;
        out.tableColWidth = [];
      }
      return out;
    });
  },

  componentDidMount() {
    if (!this.state.modal && this._modalRef.current) this.setState({ modal: true });

    let size = { x: this.state.data.length, y: this.getMaxCol(this.state.data.length) };
    this._undoManager = new UndoManager(this.manageUndo, this.getData, size);
    this._undoManager.bindEvents(this);

    this._domNode = this.findDOMNode();
  },

  componentWillUnmount() {
    this._undoManager.unbindEvents(this);
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  focus() {
    if (typeof this.focus_ === "function") {
      this.focus_();
    } else {
      this.findDOMNode().focus(); // eslint-disable-line
    }

    return this;
  },

  /**
   * @param data new data for table from undoManager
   * method calculate new _maxCol value and apply new data
   */
  manageUndo(data) {
    this._fillEmptyData(data);
    const preMaxCol = this._maxCol;
    this._maxCol = this._getMaxCol(data);
    if (this.props.dynamicColWidth && preMaxCol !== this._maxCol)
      this.setState({ data: data, tableColWidth: [] }, () => {
        this.focus();
      });
    else
      this.setState({ data: data }, () => {
        this.focus();
      });
  },

  getData() {
    return [...this.state.data];
  },

  getFormValues() {
    let data = Tools.deepArrayCopy(this.state.data);
    if (this.props.transpose) data = this._getTransposeData(data);
    if (!this.props.returnEmpty && this._isEmpty(data)) data = [];
    return data;
  },

  getMaxCol() {
    return this._maxCol;
  },

  getEditedCol() {
    return this._colEditNumber;
  },

  getListContextMenu(indexes, contextMenuItems) {
    return { onContextMenu: evt => this._openListContextMenu(evt, indexes, contextMenuItems) };
  },

  addOrRemoveListItem(type) {
    this.setState(
      preState => {
        const row = this._rowEditNumber;
        const col = this._colEditNumber;
        const index = this._listItemEditNumber;
        const emptyField = "";
        const data = Tools.deepArrayCopy(preState.data);
        const line = data[row][col];

        let output = [];
        if (line.forEach) {
          line.forEach((elem, i) => {
            if (i !== parseInt(index)) {
              output.push(elem);
            } else {
              let out = this._addColOrRowElem(elem, emptyField, type).out;
              out && output.push(...out);
            }
          });
        } else {
          let out = this._addColOrRowElem(line, emptyField, type).out;
          out && output.push(...out);
        }
        if (output.length === 0) output = [""];

        let change = { x: row, y: col, val: data[row][col] };

        data[row][col] = output;
        this._commitChange([change]);
        return { data: data };
      },
      () => {
        this.focus();
      }
    );
  },

  getModal() {
    return this._modalRef.current;
  },

  getColWidth() {
    let output = [];
    const colWidth = this.state.colWidth;
    if (colWidth && colWidth.length > 0) output = colWidth;
    return output;
  },

  setTableColWidth(width, index) {
    if (this.getMaxCol() - 1 === parseInt(index)) return;
    this.setState(prevState => {
      let tableColWidth = [...prevState.tableColWidth] || [];
      if (!tableColWidth[index] || tableColWidth[index] < width) {
        tableColWidth[index] = width;
        return { tableColWidth: tableColWidth };
      }
    });
  },

  changeTableElement(newValue, indexes) {
    //indexes-[placeholder, indexX, indexY, indexZ]
    const x = indexes[1];
    const y = indexes[2];
    const z = indexes[3];

    this.setState(state => {
      const data = Tools.deepArrayCopy(state.data);
      const value = data[x][y];

      if (z) {
        let zValue;
        let output = Array(parseInt(z) + 1).fill("");
        value &&
          value.forEach &&
          value.forEach((elem, i) => {
            if (elem) output[i] = elem;
          });
        zValue = value[z] || "";
        output[z] = newValue || "";

        if (zValue !== newValue) {
          let change = { x: x, y: y, val: data[x][y] };
          data[x][y] = output;
          this._commitChange([change]);
          return { data: data, focus: undefined };
        }
      } else {
        if (value !== newValue) {
          let change = { x: x, y: y, val: data[x][y] };

          data[x][y] = newValue;
          this._commitChange([change]);
          return { data: data, focus: undefined };
        } else {
          return { focus: undefined };
        }
      }
    });
  },

  colWidthOnChange(value, index) {
    this.setState(
      prevState => {
        const colWidth = prevState.colWidth || [];
        if (colWidth[index[1]] !== value) {
          let output = [...colWidth];
          output[index[1]] = value;
          return { colWidth: output };
        }
      },
      () => {
        this.focus();
      }
    );
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  _commitChange(value, size = { x: this.state.data.length, y: this.getMaxCol() }) {
    let change = {
      value: value,
      size: size
    };
    this._undoManager.commitChange(change);
    // this._undoManager.printStack();
  },

  _isEmpty(data) {
    if (!data) return true;
    let empty = true;
    if (data.length === 1 && Tools.assertType(data[0], Array)) {
      for (let i = 0; i < data[0].length; i++) {
        if (Tools.assertType(data[0][i], Array)) {
          for (let j = 0; j < data[0][i].length; j++) {
            if (data[0][i][j]) {
              empty = false;
              break;
            }
          }
        } else if (data[0][i]) {
          empty = false;
          break;
        }
      }
    } else {
      for (let i = 0; i < data.length; i++) {
        if (Tools.assertType(data[i], Array) && data[i].length !== 0) {
          empty = false;
          break;
        }
      }
    }
    return empty;
  },

  _sortData(data) {
    const newData = [...data];
    return newData.sort();
  },

  _getMaxCol(data) {
    let max = 0;
    for (let i = 0; i < data.length; i++) {
      if (data[i].length > max) {
        max = data[i].length;
      }
    }
    return max;
  },

  _fillEmptyData(data, initial) {
    if (data && (Tools.assertType(data, Array) && data.length > 1)) {
      if (!(this.props.colHeader && this.props.tableHeaders && data.length < this.props.tableHeaders.length)) {
        return data;
      }
    }
    let col = 1;
    let row = 1;
    if (this.props.tableHeaders) {
      if (
        !this.props.colHeader ||
        (this.props.colHeader && this.props.transpose) ||
        (this.props.colHeader && this.props.rowHeader)
      ) {
        col = this.props.tableHeaders.length;
      } else if (this.props.colHeader && !this.props.rowHeader) {
        row = this.props.tableHeaders.length;
      }
    }
    if (this.props.transpose && !initial) [col, row] = [row, col];

    let empty = [];
    !data && (data = []);
    data.length === 1 &&
      (!data[0] || data[0].length === 0 || (data[0].length === 1 && data[0][0] === "")) &&
      (data = []);

    if (this.props.transpose && this.props.tableHeaders && initial) {
      !data[0] && (data[0] = []);
      if (data[0].length < this.props.tableHeaders.length) {
        for (let i = data[0].length; i < this.props.tableHeaders.length; i++) {
          data[0].push("");
        }
      }
    } else {
      for (let i = 0; i < col; i++) empty.push("");
      for (let i = data.length; i < row; i++) {
        data.push(Object.assign([], empty));
      }
    }

    return data;
  },

  _prepareData(data = Tools.deepArrayCopy(this.state.data), initial) {
    data = this._fillEmptyData(data, initial);

    if (Tools.assertType(data, Array)) {
      if (this.props.transpose) {
        data = this._getTransposeData(data);
      }

      this._maxCol = this._getMaxCol(data);
    } else {
      //nevalidni data
    }
    return data;
  },

  _isAllowLazyRichtext() {
    let { data } = this.props;
    return Array.isArray(data) && !UU5.Common.Tools.isIE(); // focusing exact cursor position doesn't work in IE
  },

  _getChild() {
    const data = this.state.data;
    // console.log('TEdata', data)
    let table;
    let preloadedRichtextInput;
    if (!Tools.assertType(data, Array)) {
      return <UU5.Bricks.Text {...this.getMainPropsToPass()}>{Cfg.LSI_LABEL_INVALID_DATA}</UU5.Bricks.Text>;
    } else {
      // render table conditionally - this._modalRef.current is read & sent to outer API in each Row and it would always cause re-render
      // during mount as it is not available in 1st render
      if (!this.state.modal) {
        table = null;
        let { colTemplate } = this.props;
        let hasRichtext =
          !colTemplate ||
          Object.keys(colTemplate).length < this._maxCol ||
          Object.keys(colTemplate).some(k => typeof colTemplate[k] === "string" && colTemplate[k] === "text");
        preloadedRichtextInput =
          hasRichtext && this._isAllowLazyRichtext() ? (
            <Input
              name="_preloadRichtext"
              data=""
              // prettier-ignore
              style={{ opacity: 0, overflow: "hidden", height: "1px", width: "1px", position: "fixed", top: "-10000px", left: "-10000px", pointerEvents: "none" }}
            />
          ) : null;
      } else if ((this.isXs() || this.isS()) && this.props.responsive) {
        table = this._getSection(this._maxCol, data.length);
      } else {
        table = this._getTable(this._maxCol);
      }
    }

    let attrs = this.getMainAttrs();
    attrs.tabIndex = 0;

    return (
      <div {...attrs}>
        {/* Using scrollableBackground is performance optimization. Without it, when opening/closing Modal on a Page
            with a lot of DOM elements, Modal would disable/enable scrollbar on BODY
            which takes ~3s "Recalculate style" on a Page with 16000 DOM elements (corresponds to Table with 150 rows and 5 cols;
            each cell in Table edit mode has ~20 DOM elements, due to styling and Richtext editor). */}
        <UU5.Bricks.Modal ref_={this._modalRef} controlled={false} scrollableBackground location="portal" />
        {this.props.changeWidth && <UU5.Bricks.Text content={Cfg.LSI_DCC_TABLE_COL_WIDTH} />}
        {table}
        {preloadedRichtextInput}
        {this._getContextMenu()}
      </div>
    );
  },

  _getTransposeData(data) {
    let transpArray = [];
    let maxLength = 0;
    data.map((row, i) => {
      row.map((col, j) => {
        if (j >= maxLength) {
          maxLength++;
          transpArray.push([]);
        }
        transpArray[j][i] = col;
      });
    });
    return transpArray;
  },

  _storePosition(row, col) {
    this._rowEditNumber = row;
    this._colEditNumber = col;
  },

  _getXsRowHeader(maxCol, maxRow) {
    const data = this.state.data;
    let xsRow = [];
    let table = [];
    const { tableHeaders, rowHeader, colHeader } = this.props;
    for (let i = tableHeaders ? 0 : 1; i < maxRow; i++) {
      xsRow = [];
      for (let j = 0; j < maxCol; j++) {
        xsRow.push(this._renderRow(data[i], i, rowHeader, colHeader, tableHeaders, maxCol, "row", j, data[0]));
      }
      table.push(
        <UU5.Bricks.Table.TBody allowTags={TBODY_ALLOW_TAGS} key={`tbody-${i}`}>
          {xsRow}
        </UU5.Bricks.Table.TBody>
      );
    }
    return (
      <UU5.Bricks.Table {...this.getMainPropsToPass()} className={this.getClassName("xs")} responsive={true}>
        {table}
      </UU5.Bricks.Table>
    );
  },

  _getXsColHeader(maxCol, maxRow) {
    const data = this.state.data;
    let xsRow = [];
    let table = [];
    const { tableHeaders, rowHeader, colHeader } = this.props;
    for (let i = tableHeaders ? 0 : 1; i < maxCol; i++) {
      xsRow = [];
      for (let j = 0; j < maxRow; j++) {
        xsRow.push(this._renderRow(data[j], j, rowHeader, colHeader, tableHeaders, maxCol, "col", i, data[0]));
      }
      table.push(
        <UU5.Bricks.Table.TBody allowTags={TBODY_ALLOW_TAGS} key={`tbody-${i}`}>
          {xsRow}
        </UU5.Bricks.Table.TBody>
      );
    }
    return (
      <UU5.Bricks.Table {...this.getMainPropsToPass()} className={this.getClassName("xs")} responsive={true}>
        {table}
      </UU5.Bricks.Table>
    );
  },

  _getSection(maxCol, maxRow) {
    if (this.props.rowHeader === true || (this.props.tableHeaders && !this.props.colHeader)) {
      return this._getXsRowHeader(maxCol, maxRow);
    } else if (this.props.colHeader === true) {
      return this._getXsColHeader(maxCol, maxRow);
    } else {
      return this._getTable(maxCol);
    }
  },

  _openListContextMenu(evt, indexes, contextMenuItems) {
    evt.preventDefault();
    evt.stopPropagation();
    this._rowEditNumber = indexes[1] || 0;
    this._colEditNumber = indexes[2] || 1;
    this._listItemEditNumber = indexes[3];
    this._contextMenu.open({ event: evt, content: contextMenuItems });
  },

  _openContextMenu(row, evt, col) {
    evt.preventDefault();
    evt.stopPropagation();
    this._rowEditNumber = row;
    this._colEditNumber = col;
    const contextMenuItems = [
      ...this._getRowContextMenuItems(),
      ...this._getColContextMenuItems(),
      ...this._getCustomContextMenuItems()
    ];
    this._contextMenu.open({ event: evt, content: contextMenuItems });
  },
  _openWidthContextMenu(evt) {
    evt.preventDefault();
    evt.stopPropagation();

    const contextMenuItems = [...this._getCustomContextMenuItems()];
    contextMenuItems.length > 0 && this._contextMenu.open({ event: evt, content: contextMenuItems });
  },

  /**
   * @param {lsi item} lsi lsi of label of context menu item
   * @param {string} shortcut string representation of the shortcut
   * @returns lsi item or span containing lsi item and shortcut
   */
  _getContextMenuItemLabel(lsi, shortcut) {
    if (!shortcut) return lsi;
    return (
      <UU5.Bricks.Span className={this.getClassName("contextItemLabel")}>
        <UU5.Bricks.Span>{lsi}</UU5.Bricks.Span>
        <UU5.Bricks.Span className={this.getClassName("shortcut")}>{shortcut}</UU5.Bricks.Span>
      </UU5.Bricks.Span>
    );
  },

  _getRowContextMenuItems() {
    let contextMenuItems = [];
    if (this.props.modifyRow) {
      const shortcutsRow = this.getDefault("shortcutsRow");
      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="row-0"
          label={this._getContextMenuItemLabel(
            Cfg.LSI_DCC_TABLE_CONTEXT_MENU_ADD_ROW_BEFORE,
            shortcutsRow.addRowBefore
          )}
          onClick={evt => {
            this._addOrRemoveRow(1), evt.component.close();
          }}
        />
      );
      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="row-1"
          label={this._getContextMenuItemLabel(Cfg.LSI_DCC_TABLE_CONTEXT_MENU_ADD_ROW_AFTER, shortcutsRow.addRowAfter)}
          onClick={evt => {
            this._addOrRemoveRow(2), evt.component.close();
          }}
        />
      );
      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="row-2"
          label={this._getContextMenuItemLabel(Cfg.LSI_DCC_TABLE_CONTEXT_MENU_REMOVE_ROW, shortcutsRow.removeRow)}
          onClick={evt => {
            this._addOrRemoveRow(3), evt.component.close();
          }}
        />
      );
      if (this.props.modifyCol || this.props.customMenu) {
        contextMenuItems.push(<UU5.Bricks.ContextMenu.Item key="row-3" divider />);
      }
    }
    return contextMenuItems;
  },

  _getColContextMenuItems() {
    let contextMenuItems = [];
    if (this.props.modifyCol) {
      const shortcutsCol = this.getDefault("shortcutsCol");

      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="col-1"
          label={this._getContextMenuItemLabel(
            Cfg.LSI_DCC_TABLE_CONTEXT_MENU_ADD_COL_BEFORE,
            shortcutsCol.addColBefore
          )}
          onClick={evt => {
            this._addOrRemoveCol(1), evt.component.close();
          }}
        />
      );
      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="col-2"
          label={this._getContextMenuItemLabel(Cfg.LSI_DCC_TABLE_CONTEXT_MENU_ADD_COL_AFTER, shortcutsCol.addColAfter)}
          onClick={evt => {
            this._addOrRemoveCol(2), evt.component.close();
          }}
        />
      );
      contextMenuItems.push(
        <UU5.Bricks.ContextMenu.Item
          key="col-3"
          label={this._getContextMenuItemLabel(Cfg.LSI_DCC_TABLE_CONTEXT_MENU_REMOVE_COL, shortcutsCol.removeCol)}
          onClick={evt => {
            this._addOrRemoveCol(3), evt.component.close();
          }}
        />
      );
      if (this.props.customMenu) {
        contextMenuItems.push(<UU5.Bricks.ContextMenu.Item key="col-4" divider />);
      }
    }
    return contextMenuItems;
  },

  _getCustomContextMenuItems() {
    const customMenu = this.props.customMenu;
    let contextMenuItems = [];
    if (customMenu) {
      customMenu.forEach((elem, index) => {
        contextMenuItems.push(
          <UU5.Bricks.ContextMenu.Item
            key={`custom-${index}`}
            label={elem.label}
            onClick={evt => {
              elem.onClick(this), evt.component.close();
            }}
          />
        );
      });
    }
    return contextMenuItems;
  },

  _getContextMenu() {
    return (
      <UU5.Bricks.ContextMenu
        allowTags={["ul"]}
        ref_={contextMenu => (this._contextMenu = contextMenu)}
        parentElement={this}
      />
    );
  },

  /**
   * @param {number} type type of operation, 1-add before, 2-add after, 3-remove row
   * @param {number} index index of work row
   */
  _addOrRemoveCol(type, index = this._colEditNumber) {
    this.setState(
      prevState => {
        const data = Tools.deepArrayCopy(prevState.data);
        const emptyField = "";
        let output = [],
          tableColWidth;

        let changes = [];
        data.forEach(row => {
          let col = [];
          row.forEach((element, j) => {
            if (j != index) {
              col.push(element);
            } else {
              let { out, change } = this._addColOrRowElem(element, emptyField, type);
              out && col.push(...out), (change || change === "") && changes.push(change);
            }
          });
          if (col.length !== 0) output.push(col);
        });

        output = this._fillEmptyData(output);
        this._maxCol = this._getMaxCol(output);
        if (this.props.dynamicColWidth) {
          tableColWidth = [];
          for (let i = 0; i < this.getMaxCol() - 1; i++) {
            if (i != index) tableColWidth.push(null);
            else {
              let out = this._addColOrRowElem(null, 100, type).out;
              out && tableColWidth.push(...out);
            }
          }
        }

        if (!changes || changes.length < 1) changes = null;

        const size = { x: output.length, y: this.getMaxCol() };
        this._commitChange(this._prepareChanges(changes, type === 2 ? index + 1 : index, false), size);
        let focus;
        if (this._focus) {
          focus = this._focus;
        }
        return { data: output, tableColWidth: tableColWidth, focus: focus };
      },
      () => {
        this.focus();
        if (this._focus) {
          this._focus = undefined;
        }
      }
    );
  },

  _handleAddOrRemoveCol(type, row, col, focus) {
    this._storePosition(row, col);
    this._focus = focus;
    this.props._addOrRemoveCol(type);
  },

  _addColOrRowElem(element, empty, type) {
    let out;
    let change;
    switch (type) {
      case 1:
        out = [empty, element];
        break;
      case 2:
        out = [element, empty];
        break;
      case 3:
        change = element;
        break;
      default:
        console.error("Col or Row delete line error default");
    }
    return { out, change };
  },

  _addOrRemoveRow(type, index = this._rowEditNumber) {
    this.setState(
      prevState => {
        const data = Tools.deepArrayCopy(prevState.data);
        const maxCol = this._maxCol;
        let emptyRow = [];
        for (let i = 0; i < maxCol; i++) {
          emptyRow.push("");
        }
        let output = [];
        let changes = [];
        data.forEach((element, i) => {
          if (i !== index) {
            output.push(element);
          } else {
            let { out, change } = this._addColOrRowElem(element, emptyRow, type);
            (changes = change), out && output.push(...out);
          }
        });
        if (!changes || changes.length < 1) changes = null;

        output = this._fillEmptyData(output);

        const size = { x: output.length, y: this.getMaxCol() };
        this._commitChange(this._prepareChanges(changes, type === 2 ? index + 1 : index, true), size);
        let focus;
        if (this._focus) {
          focus = this._focus;
        }

        return { data: output, focus: focus };
      },
      () => {
        this.focus();
        if (this._focus) {
          this._focus = undefined;
        }
      }
    );
  },

  _handleAddOrRemoveRow(type, row, col, focus) {
    this._storePosition(row, col);
    this._focus = focus;
    this.props._addOrRemoveRow(type);
  },

  /**
   * @param changes is array of old values
   * @param index is index of modified row/col
   * @param isRow is bool if actual change is row or not
   * @returns array of objects with x,y and val element, example [{x:1,y:2,val:"some"},...]
   * method prepare data for commit to undoManager
   */
  _prepareChanges(changes, index, isRow) {
    if (!changes) return [isRow ? { x: index, val: null } : { y: index, val: null }];
    if (isRow) {
      return changes.map((elem, i) => {
        return { x: index, y: i, val: elem };
      });
    } else {
      return changes.map((elem, i) => {
        return { x: i, y: index, val: elem };
      });
    }
  },

  _prepareColWidths() {
    const { colWidth, tableColWidth } = this.state;

    if (!colWidth && !tableColWidth) return;
    let prevPreparedColWidth = this._preparedColWidth;
    this._preparedColWidth = [];

    for (let i = 0; i < this.getMaxCol() - 1; i++) {
      this._preparedColWidth[i] =
        colWidth && colWidth[i]
          ? `width:${colWidth[i]}px;`
          : tableColWidth && tableColWidth[i]
          ? `width:${tableColWidth[i]}px;`
          : null;
    }
    // use previous instance if values are exactly the same to prevent re-render
    if (
      prevPreparedColWidth &&
      prevPreparedColWidth.length === this._preparedColWidth.length &&
      prevPreparedColWidth.every((it, i) => it === this._preparedColWidth[i])
    ) {
      this._preparedColWidth = prevPreparedColWidth;
    }

    // :-( this makes lazy-initialized Richtexts in rows propagate column width back here the same way
    // as non-lazy Richtexts do (it's "weird" because non-lazy Richtexts measure column width during the time
    // when there's no content in them so columns are mostly same width)
    let availableColDynamicWidth = 0;
    let availableDynamicWidth = this._domNode ? this._domNode.getBoundingClientRect().width : null;
    if (availableDynamicWidth) {
      let dynamicColCount = this.getMaxCol();
      for (let i = 0; i < this.getMaxCol() - 1; i++) {
        let width = parseFloat(colWidth && colWidth[i]);
        if (!width) continue;
        availableDynamicWidth -= width;
        dynamicColCount--;
      }
      availableColDynamicWidth = Math.floor(availableDynamicWidth / dynamicColCount);
      if (availableColDynamicWidth < 0) availableColDynamicWidth = 0;
    }
    this._availableColDynamicWidth = availableColDynamicWidth;
  },

  _getTable(maxCol) {
    const { rowHeader, colHeader, tableHeaders, changeWidth } = this.props;
    const data = this.state.data;

    this._prepareColWidths();

    return (
      <UU5.Bricks.Table className={`${this.getClassName("editable")}`} content={null} header={null} footer={null}>
        <UU5.Bricks.Table.TBody allowTags={TBODY_ALLOW_TAGS}>
          {changeWidth &&
            this._renderRow(undefined, Row.INDEX_CHANGE_WIDTH, rowHeader, colHeader, tableHeaders, maxCol)}
          {tableHeaders &&
            (!colHeader || rowHeader) &&
            this._renderRow(undefined, Row.INDEX_HEADER, rowHeader, colHeader, tableHeaders, maxCol)}
          {data.map((rowData, i) => this._renderRow(rowData, i, rowHeader, colHeader, tableHeaders, maxCol))}
        </UU5.Bricks.Table.TBody>
      </UU5.Bricks.Table>
    );
  },

  _renderRow(
    rowData,
    rowIndex,
    rowHeader,
    colHeader,
    tableHeaders,
    maxCol,
    xsType = undefined,
    xsColIndex = undefined,
    xsHeaderRowData = undefined
  ) {
    let { focus, colWidth } = this.state;
    let { colHeaderTable, colTemplate, dynamicColWidth, changeWidth, modifyCol, modifyRow } = this.props;
    let isXs = xsColIndex !== undefined;
    return (
      <Row
        key={!isXs ? rowIndex : rowIndex + "-" + xsColIndex}
        index={rowIndex}
        data={rowData}
        xsType={xsType}
        xsColIndex={xsColIndex}
        xsHeaderRowData={xsHeaderRowData}
        rowHeader={rowHeader}
        colHeader={colHeader}
        tableHeaders={tableHeaders}
        maxCol={maxCol}
        colHeaderTable={colHeaderTable}
        colTemplate={colTemplate}
        dynamicColWidth={dynamicColWidth}
        changeWidth={changeWidth}
        modifyCol={modifyCol}
        modifyRow={modifyRow}
        tableEditableApi={this}
        modalRef={this._modalRef}
        preparedColWidths={this._preparedColWidth}
        colWidth={rowIndex === Row.INDEX_CHANGE_WIDTH ? colWidth : undefined} // colWidth is needed only by "changeWidth" row
        focus={focus && focus.startsWith(`-${rowIndex}-`) ? focus : undefined} // pass focus info only to the row with focus (so that when focus changes, not all rows would have to re-render)
        allowLazyRichtext={this._isAllowLazyRichtext()}
        availableColDynamicWidth={this._availableColDynamicWidth}
        onContextMenu={this._openContextMenu}
        onSetTableColWidth={this.setTableColWidth}
        onChangeTableElement={this.changeTableElement}
        onAddOrRemoveCol={this._handleAddOrRemoveCol}
        onAddOrRemoveRow={this._handleAddOrRemoveRow}
        onColWidthChange={this.colWidthOnChange}
        onColWidthContextMenu={this._openWidthContextMenu}
      />
    );
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    return this.getNestingLevel() ? this._getChild() : null;
  }
  //@@viewOff:render
});

export default TableEditable;
