const Tools = require("../core/tools.js").default;

class UndoManager {
  constructor(triggerUndoHandler, getData, size) {
    this.stackLength = 30;
    this.stack = [];
    this.index = 0;
    this.triggerUndoHandler = triggerUndoHandler;
    this.getData = getData;

    this.commitChange({ value: [], size });
  }

  /**
   * @param {object} component object to bind keydown event
   */
  bindEvents(component) {
    const onKeyDownHandler = e => {
      if (e.ctrlKey) {
        let defaultPrevented = true;
        switch (e.keyCode) {
          case 89:
            // console.log("redo")
            component.focus();
            this.triggerRedo();
            break;
          case 90:
            // console.log("undo")
            component.focus();
            this.triggerUndo();
            break;
          default:
            defaultPrevented = false;
        }
        return defaultPrevented ? e.preventDefault() : e;
      } else return e;
    };

    UU5.Environment.EventListener.addEvent(component.findDOMNode(), "keydown", component.getId(), onKeyDownHandler); // eslint-disable-line
  }

  unbindEvents(component) {
    UU5.Environment.EventListener.removeEvent(component.findDOMNode(), "keydown", component.getId()); // eslint-disable-line
  }

  /**
   * @param change object of changes and table size, example {value:[{val:"aa",x:1,y:3},{val:"bb",x:0,y:1},...], size:{x:2,y:4}}
   * method check if pointer point at 0 field of stack, if not removes previous values and change pointer to 0,
   * make deep copy of change values, save changes and check if size of stack exceed stack size, otherwise remove oldest change
   */
  commitChange(change) {
    if (this.index !== 0) {
      this.stack.splice(0, this.index);
      this.index = 0;
    }
    change.value.forEach(elem => {
      elem.val = Tools.deepArrayCopy(elem.val);
    });
    this.stack.unshift(change);
    if (this.stack.length > this.stackLength) this.stack.pop();
  }

  /**
   * calculate difference of param changeA and param changeB sizes
   * @returns
   *  undefined if one of changes missing - corner
   *  null if there is no change in sizes
   *  {x: 1} if size of changeB.x is bigger than changeA.x - add row
   *  {x: -1} if size of changeA.x is bigger than changeB.x - remove row
   *  {y: 1} if size of changeB.y is bigger than changeA.y - add col
   *  {y: -1} if size of changeA.y is bigger than changeB.y - remove col
   */
  compareSize(changeA, changeB) {
    if (!changeA || !changeB) {
      return;
    }
    let diff = null;
    if (changeA.size.x !== changeB.size.x) {
      if (changeA.size.x > changeB.size.x) {
        diff = { x: -1 };
      } else {
        diff = { x: 1 };
      }
    } else if (changeA.size.y !== changeB.size.y) {
      if (changeA.size.y > changeB.size.y) {
        diff = { y: -1 };
      } else {
        diff = { y: 1 };
      }
    }
    return diff;
  }

  /**
   * Method load from stack actual and previous change and calculate size difference.
   * If there is no difference in sizes, store actual value to change and apply value from change.
   * If diff.x exist, then need to change rows, if diff.y exist, then need to change cols.
   * In case of add row/col (x/y = 1), its response to remove row/col, apply values from change to create row/col.
   * In case of remove row/col (x/y = -1), its response to add row/col, so are no values in removed row.
   * Then call undoHandler method with prepared data.
   */
  triggerUndo() {
    const change = this.stack[this.index];
    const preChange = this.stack[this.index + 1];
    const diff = this.compareSize(change, preChange); // calculate difference in sizes

    if (diff === undefined) return; // end if change or preChange missing - corner

    const data = Tools.deepArrayCopy(this.getData());

    if (diff) {
      // there is difference in sizes, add or remove, row or col
      if (diff.x) {
        // row size different
        const index = change.value[0].x;
        if (diff.x === 1) {
          // add saved row values
          const line = Array.from({ length: change.size.y }, () => "");
          data.splice(index, 0, line); //create empty line
          change.value.map(elem => {
            if (!data[elem.x] && data[elem.x] !== "") {
              // create more rows if there is change on undefined row
              data.splice(elem.x, 0, Array.from({ length: change.size.y }, () => ""));
            }
            data[elem.x][elem.y] = elem.val; // fill values
          });
        } else {
          // remove row
          data.splice(index, 1);
        }
      } else {
        // coll size different
        const index = change.value[0].y;
        if (diff.y === 1) {
          // add saved col value to each row
          change.value.forEach(elem => data[elem.x].splice(index, 0, elem.val));
        } else {
          // remove col value from each row
          data.forEach(elem => elem.splice(index, 1));
        }
      }
    } else {
      // sizes are same, change of inner element
      change.value.forEach(elem => {
        elem.newVal = Tools.deepArrayCopy(data[elem.x][elem.y]); // backup of new value
        data[elem.x][elem.y] = elem.val; // apply val
      });
    }

    this.index++;
    this.triggerUndoHandler(data);
  }

  triggerRedo() {
    const change = this.stack[this.index - 1];
    const preChange = this.stack[this.index];
    const diff = this.compareSize(preChange, change); // calculate difference in sizes

    if (diff === undefined) return; // end if change or preChange missing - corner
    this.index--;

    let data = Tools.deepArrayCopy(this.getData());

    if (diff) {
      // there is difference in sizes, add or remove, row or col
      if (diff.x) {
        // row size different
        const index = change.value[0].x;
        if (diff.x === 1) {
          // add empty row
          let line = Array.from({ length: change.size.y }, () => "");
          data.splice(index, 0, line);
        } else {
          // remove row
          for (let i = change.value.length - 1; i >= 1; i--) {
            if (change.size.x <= change.value[i].x) {
              data.splice(change.value[i].x, 1);
            }
          }
          data.splice(index, 1); //O
        }
      } else {
        // coll size different
        const index = change.value[0].y;
        if (diff.y === 1) {
          // add empty col to each row
          data.forEach(elem => elem.splice(index, 0, ""));
        } else {
          // remove col from each row
          data.forEach(elem => elem.splice(index, 1));
        }
      }
    } else {
      // sizes are same, change of inner element
      change.value.forEach(elem => (data[elem.x][elem.y] = elem.newVal)); // apply newVal
    }
    this.triggerUndoHandler(data);
  }

  printStack() {
    console.log(this.index, Tools.deepArrayCopy(this.stack));
  }
}

export default UndoManager;
