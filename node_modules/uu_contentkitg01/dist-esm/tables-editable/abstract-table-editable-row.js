//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks";
import Cfg from "../core/_config.js";

import Tools from "../core/tools.js";
import Input from "./input.js";
//@@viewOff:imports

export const Row = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.tag("TablesEditable.AbstractTableEditable.DataRow"),
    classNames: {
      main: `${Cfg.css("abstract-table-data-row")}`,
      changeWidthBorder: Cfg.css("abstract-table-editable-change-width-border"),
      colWidth: Cfg.css("abstract-table-editable-col-width-border"),
      textWithLazyRichtext: Cfg.css("abstract-table-editable-text-with-lazy-richtext")
    },
    defaults: {
      tablePlaceholder: ""
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(UU5.PropTypes.any),
    index: UU5.PropTypes.number,
    maxCol: UU5.PropTypes.number,
    rowHeader: UU5.PropTypes.bool,
    colHeader: UU5.PropTypes.bool,
    colWidth: UU5.PropTypes.arrayOf(UU5.PropTypes.number),
    tableHeaders: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    colTemplate: UU5.PropTypes.object,
    modifyRow: UU5.PropTypes.bool,
    modifyCol: UU5.PropTypes.bool,
    changeWidth: UU5.PropTypes.bool,
    dynamicColWidth: UU5.PropTypes.bool,
    colHeaderTable: UU5.PropTypes.bool,

    modalRef: UU5.PropTypes.any,
    focus: UU5.PropTypes.string,
    onAddOrRemoveCol: UU5.PropTypes.func,
    onAddOrRemoveRow: UU5.PropTypes.func,
    onContextMenu: UU5.PropTypes.func,
    onChangeTableElement: UU5.PropTypes.func,
    onSetTableColWidth: UU5.PropTypes.func,
    preparedColWidths: UU5.PropTypes.arrayOf(UU5.PropTypes.string),
    xsColIndex: UU5.PropTypes.number,
    xsHeaderRowData: UU5.PropTypes.arrayOf(UU5.PropTypes.any),
    xsType: UU5.PropTypes.oneOf(["row", "col"]),
    allowLazyRichtext: UU5.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: undefined,
      index: undefined,
      maxCol: undefined,
      rowHeader: undefined,
      colHeader: undefined,
      colWidth: undefined,
      tableHeaders: undefined,
      colTemplate: undefined,
      modifyRow: undefined,
      modifyCol: undefined,
      changeWidth: undefined,
      dynamicColWidth: undefined,
      colHeaderTable: undefined,

      modalRef: undefined,
      focus: undefined,
      onAddOrRemoveCol: undefined,
      onAddOrRemoveRow: undefined,
      onContextMenu: undefined,
      onChangeTableElement: undefined,
      onSetTableColWidth: undefined,
      preparedColWidths: undefined,
      xsColIndex: undefined,
      xsHeaderRowData: undefined,
      xsType: undefined,
      allowLazyRichtext: undefined
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._initFromLazyRaf = undefined;
    this._usedLazyRichtexts = [];
    return {
      hadEverFocus: this.props.focus
    };
  },

  componentDidMount() {
    this._manageLazyRichtextColWidths();
  },

  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState(state => {
      let { hadEverFocus } = state;
      if (!hadEverFocus) hadEverFocus = !!nextProps.focus;
      return hadEverFocus === state.hadEverFocus ? undefined : { hadEverFocus };
    });
  },

  shouldComponentUpdate(nextProps, nextState) {
    return (
      nextState !== this.state ||
      Object.keys(nextProps).some(name => {
        if (name === "data" || name === "xsHeaderRowData") {
          return !UU5.Common.Tools.deepEqual(nextProps[name], this.props[name]);
        }
        return nextProps[name] !== this.props[name];
      })
    );
  },

  componentWillUnmount() {
    if (this._initFromLazyRaf) cancelAnimationFrame(this._initFromLazyRaf);
    delete this._initFromLazyRaf;
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  _manageLazyRichtextColWidths() {
    let { onSetTableColWidth, dynamicColWidth, availableColDynamicWidth } = this.props;
    if (dynamicColWidth && typeof onSetTableColWidth === "function" && this._usedLazyRichtexts.length > 0) {
      this._usedLazyRichtexts.forEach(({ index }) => {
        let cellWidth = availableColDynamicWidth;
        if (cellWidth) onSetTableColWidth(cellWidth, index);
      });
    }
  },

  _getCorrectHeaders(isBigSize, index) {
    const tableHeaders = this.props.tableHeaders || [];
    let correct = [];
    if (index || index === 0) {
      if (tableHeaders[index] && Tools.assertType(tableHeaders[index], Array)) {
        if (isBigSize) correct.push(tableHeaders[index][0]);
        else correct.push(tableHeaders[index][1]);
      } else {
        correct.push(tableHeaders[index]);
      }
    } else {
      for (let param of tableHeaders) {
        if (Tools.assertType(param, Array)) {
          if (isBigSize) correct.push(param[0]);
          else correct.push(param[1]);
          continue;
        }
        correct.push(param);
      }
    }
    return correct;
  },

  _getContent(index) {
    let result;
    const colTemplate = this.props.colTemplate;
    if (colTemplate && colTemplate[index + 1]) {
      const template = colTemplate[index + 1];
      if (template.input) return this._getCustom;
      const name = template.name || colTemplate[index + 1];

      result = {
        code: this._getCode,
        static: this._getStatic,
        list: this._getList,
        short: this._getShort,
        number: this._getNumber,
        custom: this._getCustom,
        text: this._getText,
        plainText: this._getPlainText
      }[name];
    }
    if (!result) result = this._getText;
    if (result === this._getText && this.props.allowLazyRichtext && !this.state.hadEverFocus) {
      let cellData = this.props.data[index];
      if (typeof cellData === "string") result = this._getTextWithLazyRichtext;
    }
    return result;

    // const colTemplate = this.props.colTemplate;
    // if (!colTemplate || !colTemplate[index + 1] || !this[`_get${this._capitalizeFirstLetter(colTemplate[index + 1])}`]) return this["_getText"];
    // return this[`_get${this._capitalizeFirstLetter(colTemplate[index + 1])}`];
  },

  _getColWidthInput(cell, name, index) {
    return (
      <Input
        name={name}
        data={cell}
        type="number"
        table
        hideButton
        onChangeField={this.props.onColWidthChange}
        modalRef={this.props.modalRef}
      />
    );
  },

  _getColWidthRow(row, maxCol) {
    let tableRow = [];
    const className = `${this.getClassName("colWidth")} ${this.getClassName("changeWidthBorder")}`;
    for (let i = 0; i < maxCol; i++) {
      let inputName, content, onContextMenu;
      inputName = `${this.getDefault("tablePlaceholder")}-${i}`;
      content = this._getColWidthInput(row && row[i], inputName);
      onContextMenu = { onContextMenu: evt => this.props.onColWidthContextMenu(evt) };
      const style = this.props.preparedColWidths ? this.props.preparedColWidths[i] : null;
      tableRow.push(
        <UU5.Bricks.Table.Td
          key={inputName}
          content={content}
          mainAttrs={onContextMenu}
          className={className}
          style={style}
        />
      );
    }
    return tableRow;
  },

  _getNumber(cell, name, index) {
    const tableColWidth = this.props.dynamicColWidth ? this.props.onSetTableColWidth : null;
    let focus,
      pureRender = true;
    if (this.props.focus && name.indexOf(this.props.focus) !== -1) {
      focus = true;
      pureRender = false;
    }

    const template = this.props.colTemplate && this.props.colTemplate[index + 1];

    return (
      <Input
        type="number"
        name={name}
        data={cell}
        table
        hideButton
        onChangeField={this.props.onChangeTableElement}
        onSetColWidth={tableColWidth}
        pureRender={pureRender}
        autofocus={focus}
        template={template}
        modalRef={this.props.modalRef}
      />
    );
  },

  _getCustom(cell, name, index) {
    let focus,
      pureRender = true;
    if (this.props.focus && name.indexOf(this.props.focus) !== -1) {
      focus = true;
      pureRender = false;
    }

    const template = this.props.colTemplate[index + 1];

    return (
      <Input
        name={name}
        type={template.name}
        data={cell}
        template={template}
        table
        hideButton
        onChangeField={this.props.onChangeTableElement}
        pureRender={pureRender}
        autofocus={focus}
        linkModal={this.props.modalRef.current}
        modalRef={this.props.modalRef}
      />
    );
  },

  _getText(cell, name, index, hideButton = false) {
    const tableColWidth = this.props.dynamicColWidth ? this.props.onSetTableColWidth : null;
    let focus,
      pureRender = true;
    if (this.props.focus && name.indexOf(this.props.focus) !== -1) {
      focus = true;
      pureRender = false;
    }

    const template = this.props.colTemplate && this.props.colTemplate[index + 1];

    return (
      <Input
        name={name}
        data={cell}
        table
        hideButton={hideButton}
        onChangeField={this.props.onChangeTableElement}
        onSetColWidth={tableColWidth}
        pureRender={pureRender}
        autofocus={focus}
        template={template}
        modalRef={this.props.modalRef}
      />
    );
  },

  _getTextWithLazyRichtext(cell, name, index) {
    this._usedLazyRichtexts.push({ name, index });
    return (
      <UU5.Bricks.Div
        className={this.getClassName("textWithLazyRichtext")}
        content={cell}
        mainAttrs={{
          onMouseDownCapture: e => {
            e.persist();
            let tdEl = e.nativeEvent.target;
            while (tdEl && tdEl.tagName !== "TD") tdEl = tdEl.parentNode;
            let tdElRect = tdEl ? tdEl.getBoundingClientRect() : null;

            // re-render with real Richtext editor and set caret position into text
            this.setState({ hadEverFocus: true }, () => {
              if (tdEl) this._clickIntoRichtext(tdEl, tdElRect, e);
            });
          }
        }}
      />
    );
  },

  _clickIntoRichtext(tdEl, tdElRect, e) {
    this._initFromLazyRaf = requestAnimationFrame(() => {
      delete this._initFromLazyRaf;

      // adjust click position in case that TD element got moved during richtext render (scroll / slight jump due to styling / column width change, etc.)
      let currentTdElRect = tdEl.getBoundingClientRect();
      let clickPos = {
        x: e.clientX + (currentTdElRect.left - tdElRect.left),
        y: e.clientY + (currentTdElRect.top - tdElRect.top)
      };

      // try to focus the exact DOM range where user clicked
      let range = Tools.caretRangeFromPoint(clickPos.x, clickPos.y);
      if (range && tdEl.contains(range.startContainer)) {
        getSelection().removeAllRanges();
        getSelection().addRange(range);
      } else {
        // fallback to just clicking the DOM element where user clicked (or click middle of the table cell)
        let focusableEl = document.elementFromPoint(clickPos.x, clickPos.y);
        if (!focusableEl) {
          focusableEl = document.elementFromPoint(
            currentTdElRect.left + currentTdElRect.width / 2,
            currentTdElRect.top + currentTdElRect.height / 2
          );
        }
        if (focusableEl && tdEl.contains(focusableEl)) {
          let event = document.createEvent("MouseEvents");
          // prettier-ignore
          event.initMouseEvent("click", true, true, window, 0, 0, 0, clickPos.x, clickPos.y, false, false, false, false, 0, null);
          focusableEl.dispatchEvent(event);
        }
      }
    });
  },

  _getPlainText(cell, name, index) {
    const tableColWidth = this.props.dynamicColWidth ? this.props.onSetTableColWidth : null;
    let focus,
      pureRender = true;
    if (this.props.focus && name.indexOf(this.props.focus) !== -1) {
      focus = true;
      pureRender = false;
    }

    const template = this.props.colTemplate && this.props.colTemplate[index + 1];

    return (
      <Input
        type="plainText"
        name={name}
        data={cell}
        table
        hideButton
        onChangeField={this.props.onChangeTableElement}
        onSetColWidth={tableColWidth}
        pureRender={pureRender}
        autofocus={focus}
        template={template}
        modalRef={this.props.modalRef}
      />
    );
  },

  _getCode(cell, name, index) {
    return this._getPlainText(cell, name, index);
  },

  _getStatic(cell, name, index) {
    return <UU5.Bricks.Span content={cell} />;
  },

  _getInput(props) {
    return <Input modalRef={this.props.modalRef} {...props} />;
  },

  _getList(cell, name, index) {
    const template = this.props.colTemplate[index + 1];
    if (template.listEditable)
      return template.listEditable(
        cell,
        name,
        this.props.onChangeTableElement,
        this.props.tableEditableApi,
        this._getInput,
        template
      );
    if (!Tools.assertType(cell, Array)) return this._getText(cell, name);

    let list = [];
    for (let i = 0; i < cell.length; i++) {
      list.push(
        <UU5.Bricks.Li
          key={`${name}-${i}`}
          content={
            <Input
              name={`${name}-${i}`}
              template={template} //onGetContextMenuItems={this._getListContextMenuItems}
              onChangeField={this.props.onChangeTableElement}
              data={cell[i]}
              table
              tableEditable={this.props.tableEditableApi}
              modalRef={this.props.modalRef}
            />
          }
        />
      );
    }
    return <UU5.Bricks.Ul content={list} />;
  },

  _getShort(cell, name, index) {
    return this._getText(cell, name, true);
  },

  _getOnContextMenu(row, col) {
    if (this.props.modifyRow || this.props.modifyCol) {
      return { onContextMenu: evt => this.props.onContextMenu(row, evt, col) };
    } else return {};
  },

  _getDefaultRow(row, maxCol, rowIndex) {
    let tableRow = [];
    let className = (this.props.changeWidth && this.getClassName("changeWidthBorder")) || "";
    for (let i = 0; i < maxCol; i++) {
      let inputName, content, onContextMenu;

      inputName = `${this.getDefault("tablePlaceholder")}-${rowIndex}-${i}`;
      content = this._getContent(i)(row[i], inputName, i);
      onContextMenu = { ...this._getOnContextMenu(rowIndex, i), ...this._getOnKeyDown(rowIndex, i) };
      const style = this.props.preparedColWidths ? this.props.preparedColWidths[i] : null;
      tableRow.push(
        <UU5.Bricks.Table.Td
          key={inputName}
          content={content}
          mainAttrs={onContextMenu}
          className={className}
          style={style}
        />
      );
    }
    return tableRow;
  },

  /**
   * @param {number} row working row index
   * @param {number} col working col index
   * shortcuts
   * f11 add col before, ctrl+f11 add col after, alt+f11 remove col
   * f12 add row before, ctrl+f12 add row after, alt+f12 remove row
   */
  _getOnKeyDown(row, col) {
    return {
      onKeyDown: e => {
        let defaultPrevented = true;
        switch (e.keyCode) {
          case 122:
            if (this.props.modifyCol) {
              if (e.ctrlKey) {
                let focus = `-${row}-${col + 1}`;
                this.props.onAddOrRemoveCol(2, row, col, focus); //add col after
              } else if (e.altKey) {
                let focus = `-${row}-${col}`;
                this.props.onAddOrRemoveCol(3, row, col, focus); //remove col
              } else {
                let focus = `-${row}-${col}`;
                this.props.onAddOrRemoveCol(1, row, col, focus); //add col before
              }
            } else {
              defaultPrevented = false;
            }
            break;
          case 123:
            if (this.props.modifyRow) {
              if (e.ctrlKey) {
                let focus = `-${row + 1}-${col}`;
                this.props.onAddOrRemoveRow(2, row, col, focus); //add row after
              } else if (e.altKey) {
                let focus = `-${row}-${col}`;
                this.props.onAddOrRemoveRow(3, row, col, focus); //remove row
              } else {
                let focus = `-${row}-${col}`;
                this.props.onAddOrRemoveRow(1, row, col, focus); //add row before
              }
            } else {
              defaultPrevented = false;
            }
            break;
          default:
            defaultPrevented = false;
        }
        return defaultPrevented ? e.preventDefault() : e;
      }
    };
  },

  _getRowHeader(row, maxCol, rowIndex) {
    let tableRow = [];
    const className = (this.props.changeWidth && this.getClassName("changeWidthBorder")) || "";

    for (let i = 0; i < maxCol; i++) {
      let content, onContextMenu;
      if (rowIndex === undefined) {
        content = (row && row[i]) || "";
      } else {
        const inputName = `${this.getDefault("tablePlaceholder")}-${rowIndex}-${i}`;
        content = this._getContent(i)(row[i], inputName, i);
        onContextMenu = { ...this._getOnContextMenu(rowIndex, i), ...this._getOnKeyDown(rowIndex, i) };
      }
      const style = this.props.preparedColWidths ? this.props.preparedColWidths[i] : null;

      tableRow.push(
        <UU5.Bricks.Table.Th
          key={`${row}+${i}`}
          content={content}
          mainAttrs={onContextMenu}
          className={className}
          style={style}
        />
      );
    }
    return tableRow;
  },

  _getColHeader(row, maxCol, rowIndex) {
    let tableRow = [];
    const className = (this.props.changeWidth && this.getClassName("changeWidthBorder")) || "";

    if (this.props.tableHeaders && !this.props.rowHeader) {
      const style = this.props.preparedColWidths ? this.props.preparedColWidths[0] : null;
      tableRow.push(
        <UU5.Bricks.Table.Th
          key="header"
          content={this._getCorrectHeaders(true, rowIndex)}
          style={style}
          className={className}
        />
      );
    }

    for (let i = 0; i < maxCol; i++) {
      let index = this.props.colHeaderTable ? rowIndex : i;
      const inputName = `${this.getDefault("tablePlaceholder")}-${rowIndex}-${i}`;
      const onContextMenu = { ...this._getOnContextMenu(rowIndex, i), ...this._getOnKeyDown(rowIndex, i) };
      const style = this.props.preparedColWidths ? this.props.preparedColWidths[i] : null;

      if (i === 0 && tableRow.length === 0) {
        tableRow.push(
          <UU5.Bricks.Table.Th
            key={inputName}
            content={this._getContent(index)(row[i], inputName, index)} //rowIndex
            mainAttrs={onContextMenu}
            style={style}
            className={className}
          />
        );
      } else {
        tableRow.push(
          <UU5.Bricks.Table.Td
            key={inputName}
            content={this._getContent(index)(row[i], inputName, index)} //rowIndex
            mainAttrs={onContextMenu}
            style={style}
            className={className}
          />
        );
      }
    }
    return tableRow;
  },

  _getXsRowRow() {
    let { data, xsHeaderRowData } = this.props;
    let i = this.props.index;
    let j = this.props.xsColIndex;
    const inputName = `${this.getDefault("tablePlaceholder")}-${i}-${j}`;
    const inputHeaderName = `${this.getDefault("tablePlaceholder")}-0-${j}`;
    const onContextMenu = this._getOnContextMenu(i, j);

    let cell;
    if (this.props.colHeader && j === 0) {
      cell = (
        <UU5.Bricks.Table.Th
          key={inputName + "-2"}
          mainAttrs={onContextMenu}
          content={this._getContent(j)(data[j], inputName, j)}
        />
      );
    } else {
      cell = (
        <UU5.Bricks.Table.Td
          key={inputName + "-2"}
          mainAttrs={onContextMenu}
          content={this._getContent(j)(data[j], inputName, j)}
        />
      );
    }
    return [
      <UU5.Bricks.Table.Th
        key={inputName + "-1"}
        mainAttrs={onContextMenu}
        content={
          this.props.tableHeaders
            ? this._getCorrectHeaders(false, j)
            : this._getContent(j)(xsHeaderRowData[j], inputHeaderName, j)
        }
      />,
      cell
    ];
  },

  _getXsColRow() {
    let { data, tableHeaders } = this.props;
    let j = this.props.index;
    let i = this.props.xsColIndex;
    const inputName = `${this.getDefault("tablePlaceholder")}-${j}-${i}`;
    const inputHeaderName = `${this.getDefault("tablePlaceholder")}-${j}-${0}`;
    const onContextMenu = this._getOnContextMenu(j, i);

    return [
      <UU5.Bricks.Table.Th
        key={inputName + "-1"}
        mainAttrs={onContextMenu}
        content={tableHeaders ? this._getCorrectHeaders(false, j) : this._getContent(j)(data[0], inputHeaderName, j)}
      />,
      <UU5.Bricks.Table.Td
        key={inputName + "-2"}
        mainAttrs={onContextMenu}
        content={this._getContent(j)(data[i], inputName, j)}
      />
    ];
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let { data, rowHeader, colHeader, tableHeaders, maxCol, index, colWidth, xsColIndex, xsType } = this.props;
    let content = "";
    this._usedLazyRichtexts = [];
    if (index === Row.INDEX_HEADER) {
      content = this._getRowHeader(this._getCorrectHeaders(true), maxCol, undefined);
    } else if (index === Row.INDEX_CHANGE_WIDTH) {
      content = this._getColWidthRow(colWidth, maxCol);
    } else if (xsColIndex !== undefined) {
      content = xsType === "row" ? this._getXsRowRow() : this._getXsColRow();
    } else if (data.length !== 0) {
      if ((tableHeaders && !colHeader) || (!rowHeader && !colHeader) || (rowHeader && !colHeader && index > 0)) {
        content = this._getDefaultRow(data, maxCol, index);
      } else if (!tableHeaders && rowHeader && index === 0) {
        content = this._getRowHeader(data, maxCol, index);
      } else if (
        (colHeader && rowHeader && index > 0) ||
        (colHeader && !rowHeader) ||
        (colHeader && rowHeader && tableHeaders)
      ) {
        content = this._getColHeader(data, maxCol, index);
      }
    }
    return <UU5.Bricks.Table.Tr content={content} parent={this.props.parent} />;
  }
  //@@viewOff:render
});
Row.INDEX_HEADER = -1;
Row.INDEX_CHANGE_WIDTH = -2;

export default Row;
