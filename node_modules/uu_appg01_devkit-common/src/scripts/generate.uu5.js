const fs = require("fs-extra");
const path = require("path");

const Package = require("../tools/package.js");
const StringUtil = require("../tools/string-util.js");

const srcDir = "src"; // TODO paths
const testDir = "test";

module.exports = class Generate {
  constructor(config) {
    this.config = config;
  }

  async process() {
    // let pack = Package.getSingletonSync("package.json");
    // let { type } = pack.templateInfo;
    let config = this.config.getAll();
    let { entityType } = config;

    let name = this.config.commandLineConfig._[0];
    let pkgName = this.config.commandLineConfig._[1];
    if (entityType === "package") await Generate.generatePackage(name);
    else if (entityType === "component" || entityType === "visualComponent") {
      await Generate.generateComponent(name, pkgName, config, entityType === "visualComponent");
    } else {
      console.log(`Examples:
  npm run generate component Bricks.Loader
  npm run generate component Loader
  npm run generate visualComponent Bricks.Calculator
  npm run generate visualComponent Calculator
  npm run generate package bricks
  npm run generate package Bricks   # same as "bricks"`);
    }
  }

  static async generatePackage(fullPackageName, pack = Package.getSingletonSync("package.json")) {
    let templateType = pack.templateInfo.type;
    let templateDir = path.resolve(__dirname + "/../templates-generator/__uu5/package");

    // generate package / nested packages directories
    let filePromises = [];
    let packageInfo = await [srcDir, ...fullPackageName.split(/[/.]/)]
      .filter(Boolean)
      .reduce(async (packInfoPromise, packageName, i, arr) => {
        let packageNameCamelCase = i ? StringUtil.camelCase(packageName) : packageName;
        let packageNameDashCase = i ? StringUtil.dashCase(packageNameCamelCase) : packageName;
        let {
          packageDir: parentPackageDir,
          packageConfigDirPrefix: parentPackageConfigDirPrefix,
          packageNamespace: parentPackageNamespace
        } = (await packInfoPromise) || {};
        let packageNamespace = i ? parentPackageNamespace + "." + packageNameCamelCase : pack.get().namespace;
        let packageDir = i ? parentPackageDir + "/" + packageNameDashCase : packageNameDashCase;
        await fs.mkdirp(packageDir);

        // generate config/* files inside current (sub)package
        // NOTE Only 1st level is nested into config/ folder, others are directly in (sub)package.
        let packageConfigDirName = /*i ? "" :*/ "config";
        let packageConfigDirPrefix = /*i ? "" :*/ packageConfigDirName + "/";
        let packConfigDir = /*i ? packageDir :*/ packageDir + "/" + packageConfigDirName;
        if (packageDir !== packConfigDir) await fs.mkdirp(packConfigDir);
        let context = {
          name: pack.name,
          namespace: pack.get().namespace,
          parentPackageConfigRelPath:
            "../" + (packageConfigDirName ? "../" : "") + (parentPackageConfigDirPrefix || ""),
          packageNameCamelCase,
          packageNameDashCase,
          packageNamespace
        };
        filePromises.push(
          generateFile(templateDir + (i ? "/config.sub.js" : "/config.js"), packConfigDir + "/config.js", context)
        );

        // generate main file with exports of the package
        let packageFile;
        if (templateType === "uu5-lib") {
          let mainFileName = i ? packageNameDashCase + ".js" : "index.js";
          let mainTplFileName = i ? "index.sub.js" : "index.js";
          packageFile = packageDir + "/" + mainFileName;
          filePromises.push(
            await generateFile(
              templateDir + "/" + mainTplFileName,
              packageFile,
              content => {
                // add exports of the nested package
                if (i < arr.length - 1) {
                  let subPackageNameCamelCase = StringUtil.camelCase(arr[i + 1]);
                  let subPackageNameDashCase = StringUtil.dashCase(subPackageNameCamelCase);
                  let toInsert = [];
                  let insertPos = { min: 0, max: content.length };
                  let importStr = `import * as ${subPackageNameCamelCase} from "./${subPackageNameDashCase}/${subPackageNameDashCase}.js";`;
                  if (!content.includes(importStr)) toInsert.push(importStr);
                  else insertPos.min = Math.max(insertPos.min, content.indexOf(importStr) + importStr.length);
                  let exportStr = `export { ${subPackageNameCamelCase} };`;
                  if (!content.includes(exportStr)) toInsert.push(exportStr);
                  else insertPos.max = Math.min(insertPos.max, content.indexOf(exportStr) + exportStr.length);

                  // add it to default export if we're in library root package
                  if (i === 0) {
                    let addedTo = addToDefaultExport(content, subPackageNameCamelCase);
                    content = addedTo.content;
                    insertPos.max = Math.min(insertPos.max, addedTo.position);
                  }

                  // add it after last import/export
                  if (toInsert.length > 0) {
                    let insertAtPos = getLastImportExportPos(content, insertPos.min, insertPos.max);
                    content = insertLines(content, insertAtPos, ...toInsert);
                  }
                }
                return content;
              },
              context
            )
          );
        }
        return {
          packageDir,
          packageConfigDirPrefix,
          packageFile,
          packageNamespace
        };
      }, null);
    await Promise.all(filePromises);
    return packageInfo;
  }

  static async generateComponent(name, packageName, config, isVisual, pack = Package.getSingletonSync("package.json")) {
    if (!name) throw new Error("Component name must be given.");
    let NAME_REGEXP = /^[a-zA-Z0-9\-_/.]*$/;
    if (!name.match(NAME_REGEXP)) throw new Error("Component name must match: " + NAME_REGEXP.source);
    let pkgParts = name.split(/[./]/);
    let usedName = pkgParts.pop();
    let usedPkgName = [packageName, ...pkgParts].filter(Boolean).join(".");
    let { packageDir, packageConfigDirPrefix, packageFile, packageNamespace } = await this.generatePackage(usedPkgName);

    let componentNameCamelCase = StringUtil.camelCase(usedName);
    let componentNameDashCase = StringUtil.dashCase(componentNameCamelCase);

    // generate component & demo & test file
    let templateType = pack.templateInfo.type;
    let templateDir = path.resolve(__dirname + "/../templates-generator/__uu5");
    let namespace = pack.get().namespace;
    let libIsSubmodule = namespace.includes(".");
    let libRootNamespace = libIsSubmodule ? namespace.split(".")[0] : null;
    let libRootNamespaceLibName;
    if (libRootNamespace) {
      let externals = config.externals || (pack.get().uuBuildSettings || {}).externals || {};
      libRootNamespaceLibName = Object.keys(externals).find(
        libName => externals[libName] === libRootNamespace || externals[libName].globalVariable === libRootNamespace
      );
    }
    let context = {
      name: pack.name,
      tagName: packageNamespace + "." + componentNameCamelCase,
      componentNameCamelCase,
      componentNameDashCase,
      packageConfigDirPrefix: packageConfigDirPrefix,
      libRootNamespace,
      libRootNamespaceLibName
    };
    await generateFile(templateDir + (isVisual ? "/visual-component.js" : "/component.js"), packageDir + "/" + componentNameDashCase + ".js", context);
    if (templateType === "uu5-lib") {
      await generateFile(
        templateDir + "/component-demo.html",
        packageDir + "/demo/" + componentNameDashCase + ".html",
        context
      );
    }
    let compTestDir = testDir + packageDir.replace(/^[^/\\]*/, "");
    await generateFile(
      templateDir + "/component-test.js",
      compTestDir + "/" + componentNameDashCase + ".test.js",
      context
    );

    // insert export of component into <package>.js (exists only in uu5-lib)
    if (packageFile) {
      await generateFile(null, packageFile, content => {
        if (content == null) content = "";
        let isRootPackage = !packageDir.includes("/");

        let toInsert = [];
        let insertPos = { min: 0, max: content.length };
        if (isRootPackage) {
          let importStr = `import { ${componentNameCamelCase} } from "./${componentNameDashCase}.js";`;
          if (!content.includes(importStr)) toInsert.push(importStr);
          else insertPos.min = Math.max(insertPos.min, content.indexOf(importStr) + importStr.length);
        }
        let exportStr = `export * from "./${componentNameDashCase}.js";`;
        if (!content.includes(exportStr)) toInsert.push(exportStr);
        else insertPos.max = Math.min(insertPos.max, content.indexOf(exportStr) + exportStr.length);

        // add the component to default export if we're in library root package
        if (isRootPackage) {
          let addedTo = addToDefaultExport(content, componentNameCamelCase);
          content = addedTo.content;
          insertPos.max = Math.min(insertPos.max, addedTo.position);
        }

        if (toInsert.length > 0) {
          let insertAtPos = getLastImportExportPos(content, insertPos.min, insertPos.max);
          content = insertLines(content, insertAtPos, ...toInsert);
        }

        // for libraries that extend existing ones (e.g. uu5tilesg01 extends UU5 by UU5.Tiles.* components)
        // also inject the components into the namespace of the existing library:
        //
        //   let exports = ... // from our default export
        //   import ExistingLib from "ExistingLibName"; // "ExistingLib" is e.g. UU5, "ExistingLibName" is uu5g04
        //   if (!ExistingLib["Namespace"]) ExistingLib["Namespace"] = {}; // "Namespace" is e.g. "Tiles"
        //   for (let k in exports) ExistingLib["Namespace"][k] = exports[k];
        if (isRootPackage && libIsSubmodule && libRootNamespace && libRootNamespaceLibName) {
          content = content.replace(/\nlet exports (\s|\S)*?\[k\] = exports\[k\];\n?/, "");

          let subNamespaces = namespace
            .split(".")
            .slice(1)
            .map(it => "[" + JSON.stringify(it) + "]")
            .join("");
          let importMatch = content.match(new RegExp("import\\s+(\\*\\s+as\\s+)?" + libRootNamespace + "\\s"));
          let needsImport = !importMatch || importMatch[1]; // variable from asterix import is not usable
          let rootName = importMatch && importMatch[1] ? libRootNamespace + "DefaultExport" : libRootNamespace;
          let exportDefaultMatch = content.match(/export default\s+(\{[^}]*\})/);
          toInsert = [
            ``,
            `let exports = ${exportDefaultMatch ? exportDefaultMatch[1] : {}};`,
            needsImport ? `import ${rootName} from ${JSON.stringify(libRootNamespaceLibName)};` : null,
            `if (!${rootName}${subNamespaces}) ${rootName}${subNamespaces} = {};`,
            `for (let k in exports) ${rootName}${subNamespaces}[k] = exports[k];`
          ].filter(line => line != null);
          let insertAtPos = getLastImportExportPos(content);
          content = insertLines(content, insertAtPos, ...toInsert);
        }

        return content;
      });
    }
  }
};

/**
 * Reads "destFile" if it exists (if it doesn't, reads "srcFile" & evaluates expressions against "context") and
 * performs string transformation using transformFn function and writes result back to destFile. Examples:
 *
 * @example generateFile("file.tpl", "dest/file.js", { param: "abc" });
 * @example generateFile("file.tpl", "dest/file.js", content => content.toUpperCase(), { param: "abc" });    // "content" contains data from dest/file.js (if it existed) or evaluated file.tpl (if it didn't)
 * @example generateFile(null, "dest/file.js", content => content.toUpperCase());
 */
async function generateFile(srcFile, destFile /*transformFn?, srcFileExprContext, overwrite=false*/) {
  let args = Array.prototype.slice.call(arguments, 2);
  let transformFn = typeof args[0] === "function" ? args.shift() : null;
  let srcFileExprContext = args.shift();
  let overwrite = args.shift();

  let exists = await fs.pathExists(destFile);
  let content, oldContent;
  if ((!exists && srcFile) || (exists && overwrite)) {
    let srcContent = await fs.readFile(srcFile, "utf-8");
    content = StringUtil.evalExpressions(srcContent, srcFileExprContext, srcFile);
  } else if (exists && transformFn) {
    content = await fs.readFile(destFile, "utf-8");
    oldContent = content;
  }
  if (transformFn) content = transformFn(content, srcFile, destFile);
  if (content != null && content !== oldContent) {
    console.log(
      `  ${destFile}... ` + (exists && overwrite ? ` overwriting` : !exists && srcFile ? `creating` : `updating`)
    );
    await fs.mkdirp(path.dirname(destFile));
    await fs.writeFile(destFile, content, "utf-8");
  }
}

// position after newline of last import/export statement
function getLastImportExportPos(content, minPos = 0, maxPos = content.length) {
  let usableContent = content.substr(minPos, Math.max(0, maxPos - minPos));
  let lastExport = usableContent.lastIndexOf("export ");
  let lastImport = usableContent.lastIndexOf("import ");
  let statementPos = Math.max(lastExport, lastImport);
  let result = minPos;
  if (statementPos !== -1) {
    let fromStatement = usableContent.substr(statementPos);
    let idx = fromStatement.search(/\n/);
    if (idx === -1) result += fromStatement.length + statementPos;
    else result += idx + 1 + statementPos;
  }
  return result;
}

function insertLines(content, pos, ...lines) {
  if (lines.length === 0) return content;
  let list = [];
  if (pos > 0) list.push(content.substr(0, pos));
  list.push(lines.join("\n") + "\n");
  if (pos < content.length) list.push(content.substr(pos));
  return list.join("");
}

function addToDefaultExport(content, exportName) {
  let resultContent, position;
  let defExportPos = content.lastIndexOf("export default ");
  if (defExportPos === -1) {
    let exportStr = `export default { ${exportName} };`;
    position = getLastImportExportPos(content);
    resultContent = insertLines(content, position, exportStr);
  } else {
    resultContent = content.replace(/(export default\s+)\{([^}]*)\}/, (m, g0, strList, idx) => {
      let isAlreadyExported = strList
        .split(",")
        .map(it => it.trim())
        .some(it => it === exportName);
      if (isAlreadyExported) return m;
      let spaceDelim = strList.match(/^\s*/)[0].replace(/^\s*\n/, "\n") || " ";
      position = idx;
      return g0 + "{" + strList.replace(/\s+$/, "") + "," + spaceDelim + exportName + strList.match(/\s*$/)[0] + "}";
    });
  }
  return {
    position,
    content: resultContent
  };
}
