#! /usr/bin/env node
const fs = require("fs");
const path = require("path");
const os = require("os");

const RAW_LOG_EXT = "_raw.json";
const ACCESS_LOG_EXT = "_access.txt";
const TRACE_LOG_EXT = "_trace.txt";
const OTHER_LOG_EXT = "_other.txt";

const LOG_ATTRIBUTES = [
  "time",
  "logLevel",
  "recordType",
  "message",
  "appVersion",
  "hostName",
  "nodeImageName",
  "nodeName",
  "traceId",
  "runtimeStackCode"
];
const LOG_SKIP_ATTRIBUTES = ["stackTrace", "correlationId", "correlatedRecords", "correlationOrder"];

function saveAndFormatLogs(logs, argv) {
  const logPath = _saveLogs(logs, argv);
  _saveFormattedLogs(logPath, logs);
}

function _saveLogs(logs, argv) {
  let logDirPath = argv.logDirPath ? path.resolve(argv.logDirPath) : "./target";
  fs.mkdir(logDirPath, function(e) {});
  //Naming the logs according to whether they're called from npm or npx
  if (argv._=="logstore-export" || argv._=="logstoreExport") {var logEnv = argv.appDeploymentUri
    .toLowerCase()
    .replace(/\[[a-zA-Z0-9]*\]/g, "")
    .replace(/\-|\_|\:/g, ".");
  }else {var logEnv = argv.env;}
  const logPath = path.join(
    logDirPath,
    "logs_"+ logEnv + "_" + `${_formatDate(argv.from)}_${_formatDate(argv.to)}`+ RAW_LOG_EXT
  );

  fs.writeFileSync(logPath, JSON.stringify(logs, null, 2), "utf-8");

  console.log("> Logs saved to: " + path.resolve(logPath));
  return logPath;
}

function _formatDate(date) {
  date = new Date(date);
  let mnth = date.getMonth() + 1;
  let day = date.getDate();
  let hrs = date.getHours();
  let mins = date.getMinutes();
  let secs = date.getSeconds();
  return `${date.getFullYear()}${mnth < 9 ? "0" + mnth : mnth}${day < 9 ? "0" + day : day}${hrs < 9 ? "0" + hrs : hrs}${
    mins < 9 ? "0" + mins : mins
  }${secs < 9 ? "0" + secs : secs}`;
}

function _saveFormattedLogs(rawLogPath, logs) {
  const accessLogPath = rawLogPath.replace(RAW_LOG_EXT, ACCESS_LOG_EXT);
  const traceLogPath = rawLogPath.replace(RAW_LOG_EXT, TRACE_LOG_EXT);
  const otherLogPath = rawLogPath.replace(RAW_LOG_EXT, OTHER_LOG_EXT);

  const entries = [];
  const correlatedEntries = new Map();
  logs.pageEntries.forEach(rec => {
    if (rec.correlationId) {
      const ids = rec.correlationId.split("-");
      rec.correlationId = ids[0];
      rec.correlationOrder = parseInt(ids[1]);
      const corRec = correlatedEntries.get(rec.correlationId);
      if (corRec) {
        corRec.correlatedRecords[rec.correlationOrder] = rec;
      } else {
        const multiRecEntry = Object.assign({}, rec);
        multiRecEntry.message = null;
        multiRecEntry.correlatedRecords = [];
        multiRecEntry.correlatedRecords[rec.correlationOrder] = rec;
        correlatedEntries.set(rec.correlationId, multiRecEntry);
        entries.push(multiRecEntry);
      }
    } else {
      entries.push(rec);
    }
  });

  entries.sort((a, b) => {
    if (new Date(a.time) > new Date(b.time)) {
      return -1;
    } else if (new Date(a.time) < new Date(b.time)) {
      return 1;
    } else {
      return a.id > b.id ? -1 : 1;
    }
  });

  const traceLogStream = fs.createWriteStream(traceLogPath);
  const accessLogStream = fs.createWriteStream(accessLogPath);
  const otherLogStream = fs.createWriteStream(otherLogPath);

  try {
    entries.forEach(e => {
      switch (e.recordType) {
        case "ACCESS_LOG":
          accessLogStream.write(_formatLog(e));
          break;
        case "TRACE_LOG":
          traceLogStream.write(_formatLog(e));
          break;
        default:
          otherLogStream.write(_formatLog(e));
          break;
      }
    });
  } finally {
    traceLogStream.end();
    accessLogStream.end();
    otherLogStream.end();
  }
  console.log("> Trace logs saved to: " + path.resolve(traceLogPath));
  console.log("> Access logs saved to: " + path.resolve(accessLogPath));
  console.log("> Other logs saved to: " + path.resolve(otherLogPath));
}

function _formatLog(log) {
  let result = "";

  // message is not parsed if more than one correlated records -> parse message and merge attrs
  let message;
  if (log.correlatedRecords != null && log.correlatedRecords.length > 0) {
    // eslint-disable-next-line no-unused-vars
    const message = log.correlatedRecords.reduce((msg, rec) => {
      return msg + rec.message;
    }, "");
  } else {
    // message may contain unparsed json even if no correlated records exist
    message = log.message;
  }

  try {
    const completeLog = JSON.parse(message);
    _mergeAttributes(log, completeLog);
  } catch (e) {
    if (!log.message) {
      log.message = message;
    }
  }

  LOG_ATTRIBUTES.forEach(a => {
    if (log[a] != null) {
      result += log[a] + " ";
    }
  });

  for (let [key, value] of Object.entries(log)) {
    if (!LOG_ATTRIBUTES.includes(key) && !LOG_SKIP_ATTRIBUTES.includes(key)) {
      result += value + " ";
    }
  }

  if (log.stackTrace) {
    result += os.EOL + log.stackTrace;
  }

  result += os.EOL;
  return result;
}

function _mergeAttributes(log, completeLog) {
  log.traceId = completeLog.traceId;
  log.message = completeLog.message;
  log.stackTrace = completeLog.stackTrace;

  for (let [key, value] of Object.entries(completeLog)) {
    if (!LOG_ATTRIBUTES.includes(key) && !LOG_SKIP_ATTRIBUTES.includes(key)) {
      log[key] = value;
    }
  }
}
module.exports = saveAndFormatLogs;
