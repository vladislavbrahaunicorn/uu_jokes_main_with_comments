const path = require("path");
const fs = require("fs");

const Package = require("../../src/tools/package.js");

let globalInstance;

module.exports = class ProjectConfig {
  constructor({ mode, commandLineConfig, packageJsonSource, appJsonSource } = {}) {
    this.mode = mode;
    this.commandLineConfig = commandLineConfig;
    this.packageJsonSource = packageJsonSource || new PackageJsonSource();
    this.appJsonSource = appJsonSource || new AppJsonSource();
    this.buildTimestamp = process.env.BUILD_TIMESTAMP || (new Date()).toISOString().replace(/[\-:T]/g, "").split(".")[0];
    process.env.BUILD_TIMESTAMP = this.buildTimestamp;
    this.overrides = {};
    this._merged = null;
  }
  setMode(mode) {
    if (this === globalInstance) process.env.NODE_ENV = mode;
    if (this.mode === mode) return;
    this.mode = mode;
    this._merged = null;
  }
  getMode() {
    return this.mode;
  }
  getUsedMode() {
    return this.mode || process.env.NODE_ENV || "development";
  }
  getBuildTimestamp() {
    return this.buildTimestamp;
  }
  setCommandLineConfig(config) {
    let { environment, mode, ...rest } = config || {};
    this.commandLineConfig = rest;
    if (environment || mode) this.setMode(environment || mode);
    this._merged = null;
  }
  set(/* a) key, value;  b) set */) {
    if (arguments.length === 2) {
      this.overrides[arguments[0]] = arguments[1];
      if (arguments[1] == null) this._merged = null;
      // setting null means "fallback to other source"
      else if (this._merged) this._merged[arguments[0]] = arguments[1];
    } else if (arguments.length === 1 && arguments[0] && typeof arguments[0] === "object") {
      Object.assign(this.overrides, arguments[0]);
      if (hasNulls(arguments[0])) this._merged = null;
      else if (this._merged) Object.assign(this._merged, arguments[0]);
    }
  }
  get(key) {
    this._ensureLoaded();
    return this._merged[key];
  }
  getAll() {
    this._ensureLoaded();
    return this._merged;
  }
  toCommandLineArgs() {
    // TODO Pass from other sources / overrides also (but not from package.json / uuapp.json / mode file / defaults).
    let args = [];
    if (this.commandLineConfig) {
      args = args.concat(this.commandLineConfig._commandLineArgs);
      // args = args.concat(
      //   Object.keys(this.commandLineConfig).map(key => {
      //     let value = this.commandLineConfig[key];
      //     let dashKey = key.replace(/[A-Z]/g, m => "-" + m.toLowerCase());
      //     if (value == null) return "--" + dashKey;
      //     if (typeof value === "boolean") return (value ? "--" : "--no-") + dashKey;
      //     else if (typeof value === "number" || typeof value === "string") return "--" + dashKey + "=" + value;
      //     else console.warn(`Cannot convert value to command line arg - ignoring; key=${key}, value:`, value);
      //   })
      // ); // TODO Append remaining args (non-options).
    }
    return args;
  }

  _ensureLoaded() {
    if (!this._merged) {
      let mode = this.getUsedMode();
      let sources = []; // last wins
      sources.push(this.packageJsonSource);
      sources.push(this.appJsonSource);
      sources.push(ModeSource.forMode(mode));
      sources.push(this.commandLineConfig);
      sources.push(this.overrides);

      this._merged = sources.filter(Boolean).reduce((map, source) => {
        let obj;
        if (typeof source.getConfig === "function") obj = source.getConfig();
        else obj = source;
        obj = removeNulls(obj);
        return Object.assign(map, obj);
      }, {});
    }
  }

  static get instance() {
    if (!globalInstance) globalInstance = new ProjectConfig();
    return globalInstance;
  }
};

class AppJsonSource {
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let appJsonPath = path.join("..", "uuapp.json");
    if (!fs.existsSync(appJsonPath)) return null;
    let appJson = JSON.parse(fs.readFileSync(appJsonPath, "utf-8"));
    let curDirName = path.basename(process.cwd());
    let { [curDirName]: specificCfg, ...result } = appJson;
    if (specificCfg) Object.assign(result, specificCfg);
    return result;
  }
}

class PackageJsonSource {
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let values = Package.getSingletonSync("package.json").get();
    let { name, version, namespace, babel, jest } = values;
    return { name, version, namespace, babel, jest };
  }
}

class ModeSource {
  constructor(mode) {
    this.mode = mode;
  }
  static forMode(mode) {
    let result = ModeSource.modes[mode];
    if (!result) result = ModeSource.modes[mode] = new ModeSource(mode);
    return result;
  }
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let result = null;
    let filePath = path.join("env", this.mode + ".json");
    if (fs.existsSync(filePath)) result = JSON.parse(fs.readFileSync(filePath, "utf-8"));
    return result;
  }
}
ModeSource.modes = {};

function removeNulls(obj) {
  let result = obj;
  if (obj && typeof obj === "object") {
    result = Object.keys(obj)
      .filter(it => obj[it] != null)
      .reduce((r, it) => ((r[it] = obj[it]), r), {});
  }
  return result;
}

function hasNulls(obj) {
  let result = false;
  if (obj && typeof obj === "object") {
    result = Object.keys(obj).some(it => obj[it] == null);
  }
  return result;
}
