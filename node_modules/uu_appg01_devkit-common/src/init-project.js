const path = require("path");
const util = require("util");

const fs = require("fs-extra");
const klaw = require("klaw");

const Package = require("./tools/package.js");
const StringUtil = require("./tools/string-util.js");
const { processFile } = require("./tools/template-helpers");
const crypto = require("crypto");

const PRETTIER_DEFAULTS = {
  printWidth: 120
};

let fs_copyFile = util.promisify(fs.copyFile);
let fs_readFile = util.promisify(fs.readFile);
let fs_writeFile = util.promisify(fs.writeFile);

const VALUE_PLACEHOLDER = "----- VALUE REQUIRED -----";

const APP_SERVER_README_TITLE = "uuApp Server Project (NodeJs)";

const APP_SERVER_README_LINK = "https://uuos9.plus4u.net/uu-bookkitg01-main/78462435-2590bf997d264d959b9d6a88ee1d0ff5/book/page?code=uuAppStyleGuide_00";

const APP_CLIENT_README_TITLE = "uuApp Client Project (UU5)";

const APP_CLIENT_README_LINK = "https://uuos9.plus4u.net/uu-bookkitg01-main/78462435-e884539c8511447a977c7ff070e7f2cf/book/page?code=89628511";

const LIB_UU5_README_TITLE = "UU5 Library Project";

const LIB_UU5_README_LINK = "https://uuos9.plus4u.net/uu-bookkitg01-main/78462435-e884539c8511447a977c7ff070e7f2cf/book/page?code=86405422";

const LIB_ISO_README_TITLE = null;

const LIB_ISO_README_LINK = null;

const LIB_NODE_README_TITLE = null;

const LIB_NODE_README_LINK = null;

module.exports = async function(opts) {
  let { stack, name, namespace, content, hasServer, hasClient, skipInstall } = opts || {};

  let targetDir = name;
  if (fs.existsSync(targetDir)) {
    console.log(`\nWARNING: Project ${targetDir} already exists, skipping.\n`);
    return;
  }
  console.log(`\nCreating project ${targetDir}:`);

  // create directory
  console.log("  Creating project structure...");
  fs.mkdirSync(targetDir);
  process.chdir(targetDir);

  // read existing uuapp.json (to use version, license and description for new projects)
  let uuappJson = {};
  if (await pathExists("../uuapp.json")) uuappJson = JSON.parse(await fs_readFile("../uuapp.json", "utf-8"));
  let version = uuappJson.version || "0.1.0";
  let license = "License Commercial";
  if (uuappJson[name] && uuappJson[name].license) {
    license = uuappJson[name].license;
  } else if (uuappJson.license) {
    license = uuappJson.license;
  }
  let description = "";
  if (uuappJson[name] && uuappJson[name].description) {
    description = typeof uuappJson[name].description === "object" ? uuappJson[name].description.en : uuappJson[name].description;
  } else if (uuappJson.description) {
    description = typeof uuappJson.description === "object" ? uuappJson.description.en : uuappJson.description;
  }

  try {
    // create package.json
    let toolsVersion = require("../package.json").version; // we're assuming that our version is same as _devkit one
    let type = stack;
    let pack = new Package("package.json");
    let packageJson = {
      name,
      version: version,
      license: license,
      description: description,
      spec: `${stack}; uu_appg01`,
      engines: {
        node: ">=" + require("./config/preconditions").NODEJS_VERSION // this is just a plain-text hint, by default it is not enforced by node/npm
      },
      dependencies: {},
      devDependencies: {
        uu_appg01_devkit: `^${toolsVersion}`
      }
    };
    pack.set(packageJson);

    let namespaceApp = [pack.vendor, pack.nameNoVendor.replace(/[-_].*/, "").replace(/g\d{2}$/, "")]
      .map(it => it.replace(/^./, m => m.toUpperCase()))
      .join(""); // uu_demoappg01_main-client => UuDemoapp
    let namespaceAppSnakeCase = [pack.vendor, pack.nameNoVendor.replace(/[-_].*/, "").replace(/g\d{2}$/, "")].join("-"); // uu_demoappg01_main-client => uu-demoapp
    let namespaceAllParts = [
      pack.vendor,
      ...pack.nameNoVendor
        .replace(/-.*/, "")
        .replace(/g\d{2}($|_)/, "$1")
        .split("_")
    ]; // uu_demoappg01_main-client => [uu, demoapp, main]
    let context = {
      ...opts,
      vendor: pack.vendor,
      nameNoVendor: pack.nameNoVendor,
      nameWithVendor: pack.nameWithVendor,
      namespaceApp,
      namespaceAppSnakeCase,
      namespaceAllParts,
      app: pack.nameNoVendor.replace(/[-_].*/, ""),
      subApp: pack.nameNoVendor.replace(/-.*/, "").split("_")[1] || "",
      projectClassName: namespaceAllParts.slice(1).map((item) => {return (item.charAt(0).toUpperCase() + item.substr(1))}).join(""),
      projectClassFile: namespaceAllParts.slice(1).map((item) => {return item.toLowerCase()}).join("-"),
      creationYear: (new Date()).getFullYear(),
      appCode: name.split(/[-_]/).slice(0, -1).join(".").toUpperCase(),
      appName: name.split(/[-_]/).slice(0, -1).join("_").replace(/(_\w)/g, function (match) {
        return match[1].toUpperCase();
      }),
      appVersion: version,
      appLicense: license,
      appDescription: description,
      valuePlaceholder: VALUE_PLACEHOLDER,
      insomniaContextPath: name.replace(/_/g,"-").split("-server")[0],
      errorCode: namespaceAllParts.join("-"),
    };

    let templatesDir = path.join(__dirname, "templates");
    let typeDir = path.join(templatesDir, "__" + (type === "nodejs-app" && !hasClient ? "nodejs-service" : type));
    let packageJsonByTemplatePath = path.resolve(typeDir, "package-partial.json"); // NOTE Must not be named package.json because "npm pack" would omit it from packing.
    let packageJsonByTemplateExpr = await fs_readFile(packageJsonByTemplatePath, "utf-8");
    let packageJsonByTemplate = JSON.parse(
      StringUtil.evalExpressions(packageJsonByTemplateExpr, context, packageJsonByTemplatePath)
    );
    Object.assign(packageJsonByTemplate, {
      name,
      prettier: PRETTIER_DEFAULTS
    });
    if (type !== "nodejs-app" && type !== "nodejs-service") packageJsonByTemplate["namespace"] = namespace;
    Object.keys(packageJsonByTemplate)
      .filter(k => packageJsonByTemplate[k] != null)
      .forEach(k => mergeDeep(packageJson, k, packageJsonByTemplate[k]));
    packageJson.spec = `${type}; uu_appg01@${toolsVersion}`;
    packageJson = Package.sort(packageJson);
    pack.set(packageJson);
    await pack.save();

    console.log("  Generating project content...");
    // prepare list of files to copy (merge templates/*, templates/__<type>/* and templates/__<type>/__<content>/*)
    let genericFiles = listFiles(templatesDir);
    let typeFiles = fs.existsSync(typeDir) ? listFiles(typeDir) : []; // project-type specific
    let contentDir = path.join(typeDir, "__" + content);
    let contentFiles = fs.existsSync(contentDir) ? listFiles(contentDir) : [];

    // use both specific + generic files
    genericFiles = await genericFiles;
    let genericItems = genericFiles.map(fullPath => ({ relFile: path.relative(templatesDir, fullPath), fullPath }));
    typeFiles = await typeFiles;
    let specificItems = typeFiles.map(fullPath => ({ relFile: path.relative(typeDir, fullPath), fullPath }));
    contentFiles = await contentFiles;
    let contentItems = contentFiles.map(fullPath => ({ relFile: path.relative(contentDir, fullPath), fullPath }));

    let fileFilter = getFileFilter(type);
    let usedSet = new Set();
    let usedItems = [...contentItems, ...specificItems, ...genericItems]
      .filter(it => {
        let isNew = !usedSet.has(it.relFile);
        if (isNew) usedSet.add(it.relFile);
        return isNew;
      })
      .filter(it => fileFilter(it.relFile));

    let projectClassPrefix = namespaceAllParts.slice(1).map((item) => {return item.toLowerCase()}).join("-");
    const RENAME_MAP = {
      // NOTE The templates/ folder contains gitignore (no dot), because npm registry
      // automatically renames all .gitignore to .npmignore during publishing / downloading
      // https://github.com/npm/npm/issues/1862
      gitignore: ".gitignore",
      gitattributes: ".gitattributes",
      [path.join("app", "api", "controllers", "project-controller.js")]: path.join("app", "api", "controllers", `${projectClassPrefix}-controller.js`),
      [path.join("app", "dao", "project-mongo.js")]: path.join("app", "dao", `${projectClassPrefix}-mongo.js`),
      [path.join("app", "api", "errors", "project-use-case-error.js")]: path.join("app", "api", "errors", `${projectClassPrefix}-use-case-error.js`),
      [path.join("app", "api", "errors", "project-error.js")]: path.join("app", "api", "errors", `${projectClassPrefix}-error.js`),
      [path.join("app", "abl", "project-abl.js")]: path.join("app", "abl", `${projectClassPrefix}-abl.js`),
      [path.join("app", "api", "validation_types", "project-types.js")]: path.join("app", "api", "validation_types", `${projectClassPrefix}-types.js`),
      [path.join("bin", "project.js")]: path.join("bin", `${name}.js`)
    };
    let preferParentDir = true; // hasServer || (await pathExists("../.git"));
    if (preferParentDir) {
      [".editorconfig", "README.md", "gitignore", "gitattributes"].forEach(item => {
        if (!fs.existsSync(path.join("..", item))) RENAME_MAP[item] = path.join("..", RENAME_MAP[item] || item);
        else usedItems = usedItems.filter(it => it.relFile !== item);
      });
    }

    usedItems.forEach(it => (it.relDestFile = RENAME_MAP[it.relFile] || it.relFile));
    usedItems.sort((a, b) => (a.relDestFile < b.relDestFile ? -1 : 1));

    // copy files asynchronously in batches (there's a limit for the number of opened files on some systems)
    // console.log("Copying files.");
    let dirs = new Set();
    let copyFileFns = usedItems.map(({ relFile, fullPath, relDestFile }) => async () => {
      let isFile = path.basename(fullPath) !== "."; // directories use form of "<dir>/."
      let destFile = path.resolve(relDestFile);
      // console.log("  " + relDestFile);
      let targetFileDir = isFile ? path.dirname(destFile) : destFile;
      if (!dirs.has(targetFileDir)) {
        await fs.ensureDir(targetFileDir);
        dirs.add(targetFileDir);
      }
      if (isFile) await processFile(fullPath, destFile, context);
    });
    let copyPromise = batchExecute(20, copyFileFns);

    // enable beta versions if requested
    if (process.env.UUAPP_DEV_ENABLED) {
      fs.copyFileSync(path.resolve(templatesDir, "__npmrc-dev"), ".npmrc");
    } else if (process.env.UUAPP_BETA_ENABLED) {
      fs.copyFileSync(path.resolve(templatesDir, "__npmrc"), ".npmrc");
    }

    // generate/update uuapp.json while files are being copied
    console.log("  Registering project in uuapp.json...");
    let isLib = type.endsWith("lib");
    let deploysViaCloud = type.match(/nodejs-(app|service)/) || type === "uu5-lib" || type === "lib";
    let parsedProduct = Package.parseProduct(name);
    // TODO Throw if already exists with different values?
    if (uuappJson.product === undefined) uuappJson.product = parsedProduct.product;
    if (!uuappJson.version) uuappJson.version = pack.get().version;
    if (uuappJson.license === undefined) uuappJson.license = "License Commercial";
    if (uuappJson.description === undefined) uuappJson.description = { en: "", cs: "" };
    let specificCfg = uuappJson[parsedProduct.name];
    if (!specificCfg) specificCfg = uuappJson[parsedProduct.name] = {};
    if (isLib || parsedProduct.specifier === 'client') {
      specificCfg.namespace = namespace;
    }
    if (isLib) {
      if (specificCfg.sourceUri === undefined) {
        specificCfg.sourceUri = `https://cdn.plus4u.net/${parsedProduct.vendor}-${pack.nameNoVendor.replace(/_/g, "-")}/%s/${name}.min.js`;
      }
      if (specificCfg.docUri === undefined) specificCfg.docUri = "";
      if (specificCfg.imageUri === undefined) specificCfg.imageUri = "";
    }
    if (deploysViaCloud) {
      specificCfg.devkit = {};
      specificCfg.devkit.development = {appBoxLocationUri: VALUE_PLACEHOLDER, appDeploymentUri: null};
    }
    uuappJson = Package.sort(uuappJson, [
      "product",
      "namespace",
      "version",
      "license",
      "description",
      "sourceUri",
      "imageUri",
      "docUri"
    ]);
    await fs_writeFile("../uuapp.json", JSON.stringify(uuappJson, null, 2), "utf-8");

    // wait for copying to end
    await copyPromise;
    if (type === "nodejs-app" || type === "nodejs-service") {
      // Rename test subfolder
      fs.renameSync(path.join(".", "test", "project"), path.join(".", "test", projectClassPrefix));
    }

    // Update readme
    let readmeTitle = null;
    let readmeLink = null;
    if (type === "nodejs-app" || type === "nodejs-service") {
      readmeTitle = APP_SERVER_README_TITLE;
      readmeLink = APP_SERVER_README_LINK;
    } else if (type === "uu5-app") {
      readmeTitle = APP_CLIENT_README_TITLE;
      readmeLink = APP_CLIENT_README_LINK;
    } else if (type === "uu5-lib") {
      readmeTitle = LIB_UU5_README_TITLE;
      readmeLink = LIB_UU5_README_LINK;
    } else if (type === "lib") {
      readmeTitle = LIB_ISO_README_TITLE;
      readmeLink = LIB_ISO_README_LINK;
    } else if (type === "nodejs-lib") {
      readmeTitle = LIB_NODE_README_TITLE;
      readmeLink = LIB_NODE_README_LINK;
    }
    updateReadme(readmeTitle, readmeLink);
    updateInsomniaTemplate();

    // install dependencies
    if (!skipInstall) {
      console.log(`  Installing packages (this may take a while)...`);
      const PackageManager = require("./tools/package-manager.js");
      await PackageManager.install();
    }

    console.log("  ...finished.\n");
  } finally {
    process.chdir("..");
  }
};

function mergeDeep(target, name, newValue, overwrite = false) {
  if (newValue == null) return;
  if (overwrite || target[name] == null) target[name] = newValue;
  else if (typeof newValue === "object") {
    Object.keys(newValue).forEach(it => mergeDeep(target[name], it, newValue[it], overwrite));
  }
}

function listFiles(dir) {
  return new Promise((resolve, reject) => {
    let dirAbsPath = path.resolve(dir);
    let klawOpts = {
      filter: fileName => fileName.substr(dirAbsPath.length).indexOf(path.sep + "__") === -1 // omit files/dirs starting with "__"
    };
    let files = [];
    klaw(dirAbsPath, klawOpts)
      .on("error", e => reject(e))
      .on("data", item => {
        if (item.stats.isFile()) files.push(item.path);
        else if (item.stats.isDirectory()) files.push(item.path + path.sep + ".");
      })
      .on("end", () => resolve(files));
  });
}

async function batchExecute(maxBatchSize, jobFns) {
  // runs all jobFns; at most maxBatchSize run in parallel at any time
  // NOTE Rejects on 1st error encountered (jobs that are in-flight at the time
  // of the error are not cancelled, i.e. they will finish later than the rejection).
  let { result } = await jobFns.reduce(
    async (partialResult, jobFn, i, arr) => {
      let { result, inFlightSet } = await partialResult;
      if (inFlightSet.size >= maxBatchSize) await Promise.race(inFlightSet);
      let jobPromise = Promise.resolve().then(jobFn);
      let jobPromiseWithRemoval = jobPromise.then(() => inFlightSet.delete(jobPromiseWithRemoval));
      inFlightSet.add(jobPromiseWithRemoval);
      result.push(jobPromise);
      return { result, inFlightSet };
    },
    { result: [], inFlightSet: new Set() }
  );
  return Promise.all(result);
}

function getFileFilter(type) {
  let excludedFiles;
  if (type === "nodejs-app") excludedFiles = ["config/config.js", "config/uu5libraryregistry-descriptor.json"];
  else if (type === "nodejs-lib" || type === "uu5-app") {
    excludedFiles = [
      "config/uu5libraryregistry-descriptor.json",
      "config/uucloud-config.json",
      "config/uucloud-descriptor.json"
    ];
  } else excludedFiles = [];
  excludedFiles.push("package-partial.json");
  excludedFiles = new Set(excludedFiles.map(item => item.replace(/\//g, () => path.sep))); // normalize path separator
  return f => !excludedFiles.has(f);
}

async function pathExists(path) {
  return new Promise(resolve => {
    fs.access(path, err => {
      resolve(!err);
    });
  });
}

function updateInsomniaTemplate() {
  let templatePath = path.resolve(".", "test", "insomnia", "insomnia-workspace.json");
  if (!fs.existsSync(templatePath)) {
    return;
  }
  let template = fs.readFileSync(templatePath).toString();

  const timestamp = Math.floor(Date.now() / 1000);
  const newTemplate = template.replace(/(wrk|env|fld|jar|pair|req)_[^"]+/g, (match) => {
    return `${match}_${timestamp}`;
  });

  fs.writeFileSync(templatePath, newTemplate);
}

function updateReadme(readmeTitle, readmeLink) {
  let readmePath = path.resolve("..", "README.md");
  if (!fs.existsSync(readmePath)) {
    return;
  }
  let readme = fs.readFileSync(readmePath).toString();
  if (!readmeTitle || readme.match(new RegExp(readmeTitle.replace(/\(/g, "\\(").replace(/\)/g, "\\)")))) {
    return;
  }
  let endsWithNewline = readme.endsWith("\n");
  readme = readme.concat(`${endsWithNewline ? "" : "\n"}- [${readmeTitle}](${readmeLink})${endsWithNewline ? "\n" : ""}`);
  fs.writeFileSync(readmePath, readme);
}
