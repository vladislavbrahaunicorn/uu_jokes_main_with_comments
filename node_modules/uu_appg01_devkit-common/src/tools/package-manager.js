const child_process = require("child_process");

class Npm {
  constructor(config) {
    this.config = config || {};
  }
  async install({ packages, save, saveDev, saveExact, logLevel, cwd, exitOnFailure }) {
    let { executable = "npm", genericArgs = [] } = this.config;

    let args = genericArgs.concat(["install"]);
    if (typeof save === "boolean") args.push(save ? "--save" : "--no-save");
    if (typeof saveDev === "boolean") args.push(saveDev ? "--save-dev" : "--no-save-dev");
    if (typeof saveExact === "boolean") args.push(saveExact ? "--save-exact" : "--no-save-exact");
    if (logLevel) args.push("--loglevel=" + logLevel);
    if (Array.isArray(packages)) args.push(...packages);

    var result = child_process.spawnSync(executable, args, {
      shell: true,
      cwd: cwd,
      stdio: "inherit"
    });
    if (result.status && exitOnFailure) process.exit(1);
    return result;
  }
  isForced() {
    return this.config.forced;
  }
}

class Pnpm extends Npm {
  constructor(config = {}) {
    super({
      executable: "pnpm",
      ...config
    });
  }
}

function initInstance() {
  // TODO There's a bug in pnpm which prevents us from detecting that pnpm is being used.
  // https://github.com/zkochan/which-pm-runs/issues/25
  // => always try to use pnpm by default, with fallback to npm
  //
  // let userAgent = process.env.npm_config_user_agent || "";
  // let pmSpec = userAgent.trim().split(/\s/)[0];
  // let name = pmSpec.split("/")[0];
  let forcedName = process.env.UU_APPG01_DEVKIT_PM;
  let name = forcedName;
  if (!name) {
    try {
      let pnpmResult = child_process.spawnSync("pnpm -v", { shell: true, cwd: process.cwd(), stdio: "pipe" });
      if (pnpmResult.status === 0 && pnpmResult.stdout.toString().trim() > "0") name = "pnpm";
    } catch (e) {
      // ignore and fallback to using npm
    }
  }
  let allowedValues = new Set(["npm", "pnpm"]);
  let packageManager = allowedValues.has(name) ? name : allowedValues.values().next().value || "npm";

  let result;
  switch (packageManager) {
    case "pnpm":
      result = new Pnpm({ forced: packageManager === forcedName });
      break;
    case "npm":
      result = new Npm({ forced: packageManager === forcedName });
      break;
    default:
      throw new Error(`Using package manager '${packageManager}' is not supported.`);
  }
  return result;
}

let instance;
class PackageManager {
  static getInstance() {
    if (!instance) instance = initInstance();
    return instance;
  }
  static async install({
    packages,
    save,
    saveDev,
    saveExact,
    logLevel = "error",
    cwd = process.cwd(),
    exitOnFailure = true
  } = {}) {
    return PackageManager.getInstance().install({ packages, save, saveDev, saveExact, logLevel, cwd, exitOnFailure });
  }
}
PackageManager.Npm = Npm;
PackageManager.Pnpm = Pnpm;

module.exports = PackageManager;
