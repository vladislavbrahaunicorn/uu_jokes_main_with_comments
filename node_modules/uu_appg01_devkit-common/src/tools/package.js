const fs = require("fs");
const path = require("path");
const util = require("util");

let fs_readFile = util.promisify(fs.readFile);
let fs_writeFile = util.promisify(fs.writeFile);

let instances = new Map();
let instancesSync = new Map();

const ORDERED_KEYS = [
  "name",
  "version",
  "description",
  "license",
  "namespace",
  "spec",
  "dependencies",
  "uuBuildSettings",
  "devDependencies",
  "engines",
  "scripts",
  "main",
  "jsnext:main",
  "module",
  "files",
  "prettier"
];

module.exports = class Package {
  constructor(path) {
    this._path = path;
  }

  // returns same instance of Package, if it was called with same path
  // (optimizes access to package.json from various components)
  static async getSingleton(filePath = "package.json") {
    let normPath = path.resolve(filePath);
    let instance = instances.get(normPath);
    if (!instance) {
      instance = new Package(normPath).load();
      instances.set(normPath, instance);
    }
    let result = await instance;
    // solve situation if someone called get & getSync, i.e. getSync is already done
    // (we want to always use only a single instance of Package class per file path)
    // => prefer sync instance if present
    if (!instancesSync.has(normPath)) instancesSync.set(normPath, result);
    else result = instancesSync.get(normPath);
    return result;
  }

  // returns same instance of Package, if it was called with same path
  /**
   *
   * @param {*} filePath
   * @return {Package}
   */
  static getSingletonSync(filePath = "package.json") {
    let normPath = path.resolve(filePath);
    let instance = instancesSync.get(normPath);
    if (!instance) {
      instance = new Package(normPath).loadSync();
      instancesSync.set(normPath, instance);
    }
    return instance;
  }

  /**
   * @param {*} json Object whose keys are to be sorted.
   */
  static sort(json, orderedKeys = ORDERED_KEYS) {
    let max = orderedKeys.length;
    let keys = Object.keys(json);
    keys.sort((a, b) => {
      let orderA = orderedKeys.indexOf(a);
      let orderB = orderedKeys.indexOf(b);
      if (orderA === -1) orderA = max;
      if (orderB === -1) orderB = max;
      return orderA - orderB || (a < b ? -1 : a > b ? 1 : 0); // unknown keys at the end alphabetically
    });
    let result = {};
    for (let key of keys) result[key] = json[key];
    return result;
  }

  static parseProduct(name) {
    let normName = name.match(/^uu5/) ? "uu_" + name : name;
    let [product, ...dashPartsRest] = normName.split("-");
    let specifier = dashPartsRest.join("-");
    let [vendor, app, subApp, ...sppParts] = product.split("_");
    let spp = sppParts.join("_");
    return { vendor, app, subApp, spp, specifier, product, name: normName.replace(/^uu_uu5/, "uu5") };
  }

  get() {
    return this._json;
  }
  set(json) {
    if (this._json && json && this._json.spec !== json.spec) delete this._templateInfo;
    this._json = json;
  }
  merge(json) {
    if (this._json && json && this._json.spec !== json.spec) delete this._templateInfo;
    Object.assign(this._json, json);
  }
  async load() {
    this.set(JSON.parse(await fs_readFile(this._path, "utf-8")));
    return this;
  }
  loadSync() {
    this.set(JSON.parse(fs.readFileSync(this._path, "utf-8")));
    return this;
  }
  async save() {
    if (!this._json) throw new Error("Unable to save package.json - JSON is empty. Save path is " + this._path);
    let json = Package.sort(this._json);
    await fs_writeFile(this._path, JSON.stringify(json, null, 2), "utf-8");
  }
  saveSync() {
    if (!this._json) throw new Error("Unable to save package.json - JSON is empty. Save path is " + this._path);
    let json = Package.sort(this._json);
    fs.writeFileSync(this._path, JSON.stringify(json, null, 2), "utf-8");
  }

  get name() {
    return this.get()["name"];
  }
  get vendor() {
    return this._getNameParts().vendor;
  }
  get nameNoVendor() {
    return this._getNameParts().nameNoVendor;
  }
  get nameWithVendor() {
    let { vendor, nameNoVendor } = this._getNameParts();
    return vendor + "_" + nameNoVendor;
  }

  get templateInfo() {
    if (!this._templateInfo) {
      let spec = this.get()["spec"];
      if (!spec)
        throw new Error(
          "This project is not properly initialized (missing 'spec' field in package.json). Project conversion is not supported. Run 'npx create-uuapp -h' or 'npx create-uulib -h' for help on creating new project."
        );
      let specParts = spec.split(/\s*;\s*/); // e.g. "nodejs-lib; uu_appg01@0.1.0"
      specParts[0] = specParts[0].replace(/^node-/, "nodejs-"); // TODO Remove.
      let [specName, specVersion] = (specParts[1] || "").split(/@/);
      if (specName !== "uu_appg01")
        throw new Error(
          "This project is not properly initialized or it was initialized using different generation of devkit (value in 'spec' field in package.json is not valid for uu_appg01_devkit)."
        );
      this._templateInfo = { type: specParts[0], specName, specVersion };
    }
    return this._templateInfo;
  }

  _getNameParts() {
    let vendor, nameNoVendor;
    let nameParts = this.name.split("_");
    if (nameParts.length === 1) [vendor, nameNoVendor] = ["uu", nameParts[0]];
    else [vendor, nameNoVendor] = [nameParts[0], nameParts.slice(1).join("_")];
    return { vendor, nameNoVendor };
  }
};
